//Helbreath Cursed Map Server
#include "../Header/Game.h"
#include "../Header/Rank.h"
#include "..\\Header\\deathmatch.h"
#include "..\\Header\\QuestList.h"
#include "..\\Trades.h"
#include <map>

#include <tchar.h>  
#include <stdio.h> 
#include <chrono>
#include <thread>
#include <algorithm>

extern class cResolution * c_reso;
class CDeathmatch * c_dm;
class CRank * c_rank;
class Trades * c_trades;
class QuestList * c_questlist;
extern void PutLogList(char * cMsg);
extern void CharacterLogList(char * cMsg); // Listo
extern void ChatLogs(char * cMsg); // Listo
extern void Borrado();
extern void ConfigList(char * cMsg);
extern void UpdateConfigList(char* cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];
extern void PutLogHacksFileList(char * cStr); // Listo
extern void PutLogOnlinesFileList(char * cStr);
extern void PutLogDrops(char * cStr); //lalov9 drops 

extern void PutGMLogData(char * cStr);
extern void PutEkAndPkLogFileList(char * cStr);
extern void PutLogItemsList(char * cStr);

extern void PutLogTradeFileList(char * cStr);
extern void PutLogCoinsFileList(char * cStr);

using namespace std;

bool bHappyHour = false;
bool bHappyDay = false;
bool enable_log_cl = true;

extern FILE * pLogFile;
extern HWND	G_hWnd;

char _tmp_cCorpseX[] = { 0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0 };
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0 };

std::mutex mtx;

// Variables de tiempo para el ping
int _tmp_1024_iMoveLocX[9][58]= 
{
	//0 
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//1
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
	30, 31, 32, -1, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//2
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
	30, 31, 32, 32, 32, 32, 32, 32, 32, 32,
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
	32, 32, 32, 32, 32, 32, 32, -1 },

	//3 
	{ 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
	32, 32, 32, 32, 32, -1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//4 
	{ 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
	32, 32, 32, 32, 32, 31, 30, 29, 28, 27,
	26, 25, 24, 23, 22, 21, 20, 19, 18, 17,
	16, 15, 14, 13, 12, 11, 10, 9, 8, 7,
	6, 5, 4, 3, 2, 1, 0, -1 },

	//5 
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
	30, 31, 32, -1, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//6 
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 1, 2, 3, 4, 5,
	6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
	26, 27, 28, 29, 30, 31, 32, -1 },

	//7 
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, -1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//8 
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 1, 2, 3, 4, 5,
	6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
	26, 27, 28, 29, 30, 31, 32, -1 }
};

int _tmp_1024_iMoveLocY[9][58] = {
	//0
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//1
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, -1, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//2
	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
	8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
	18, 19, 20, 21, 22, 23, 24, -1 },

	//3
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, -1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//4
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, -1 },


	//5
	{ 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, -1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	//6
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	24, 24, 24, 24, 24, 24, 24, -1 },

	//7
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
	20, 21, 22, 23, 24, -1, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0 },

	// 8
	{ 24, 23, 22, 21, 20, 19, 18, 17, 16, 15,
	14, 13, 12, 11, 10, 9, 8, 7, 6, 5,
	4, 3, 2, 1, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, -1 },
};

// Resolution 800x600
int _tmp_cMoveLocX[9][47] = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1 },{ 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1 },{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1 } };
int _tmp_cMoveLocY[9][47] = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, -1 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, -1 },{ 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, -1 },{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },{ 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1 } };

// Resolution 640x480
int _tmp_iMoveLocX[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	 // 1
	 {0,1,2,3,4,5,6,7,8,9,
	  10,11,12,13,14,15,16,17,18,19,
	  20,-1,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0},
	  //2
	  {0,1,2,3,4,5,6,7,8,9,
	   10,11,12,13,14,15,16,17,18,19,
	   20,20,20,20,20,20,20,20,20,20,
	   20,20,20,20,20,20,-1},
	   //3
	   {20,20,20,20,20,20,20,20,20,20,
		20,20,20,20,20,20,-1,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0},
		//4
		{20,20,20,20,20,20,20,20,20,20,
		 20,20,20,20,20,20,19,18,17,16,
		 15,14,13,12,11,10,9,8,7,6,
		 5,4,3,2,1,0,-1},
		 //5
		 {0,1,2,3,4,5,6,7,8,9,
		  10,11,12,13,14,15,16,17,18,19,
		  20,-1,0,0,0,0,0,0,0,0,
		  0,0,0,0,0,0,0},
		  //6
		  {0,0,0,0,0,0,0,0,0,0,
		   0,0,0,0,0,0,1,2,3,4,
		   5,6,7,8,9,10,11,12,13,14,
		   15,16,17,18,19,20,-1},
		   //7
		   {0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,-1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0},
			//8
			{0,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,0,1,2,3,4,
			 5,6,7,8,9,10,11,12,13,14,
			 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	 //1
	 {0,0,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0,0,0,0,
	  0,-1,0,0,0,0,0,0,0,0,
	  0,0,0,0,0,0,0},
	  //2
	  {0,0,0,0,0,0,0,0,0,0,
	   0,0,0,0,0,0,0,0,0,0,
	   0,1,2,3,4,5,6,7,8,9,
	   10,11,12,13,14,15,-1},
	   //3
	   {0,1,2,3,4,5,6,7,8,9,
		10,11,12,13,14,15,-1,0,0,0,
		0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0},
		//4
		{0,1,2,3,4,5,6,7,8,9,
		 10,11,12,13,14,15,15,15,15,15,
		 15,15,15,15,15,15,15,15,15,15,
		 15,15,15,15,15,15,-1},
		 //5
		 {15,15,15,15,15,15,15,15,15,15,
		  15,15,15,15,15,15,15,15,15,15,
		  15,-1,0,0,0,0,0,0,0,0,
		  0,0,0,0,0,0,0},
		  //6
		  {0,1,2,3,4,5,6,7,8,9,
		   10,11,12,13,14,15,15,15,15,15,
		   15,15,15,15,15,15,15,15,15,15,
		   15,15,15,15,15,15,-1},
		   //7
		   {0,1,2,3,4,5,6,7,8,9,
			10,11,12,13,14,15,-1,0,0,0,
			0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0},
			// 8
			{15,14,13,12,11,10,9,8,7,6,
			 5,4,3,2,1,0,0,0,0,0,
			 0,0,0,0,0,0,0,0,0,0,
			 0,0,0,0,0,0,-1}
};

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
extern void ThreadProc(void *ch);

CMapServer::CMapServer(HWND hWnd)
{
	int i, x;

	//rank system hbarg
	c_rank = new CRank;

	c_dm = new CDeathmatch;
	c_questlist = new QuestList;
	c_trades = new Trades;
	m_bShinning = false;
	m_bExitServer = false;
	vObjects.clear();
	m_bShutDownServer = false;
	m_bIsGameStarted = FALSE;
	m_hWnd = hWnd;
	m_pMainLogSock = NULL;
	m_bIsLogSockAvailable = FALSE;
	m_bIsWLServerAvailable = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;
	m_sForceRecallTime = 30;

	for (i = 0; i < DEF_MAXCLIENTS; i++) m_pClientList[i] = NULL;
	for (i = 0; i < DEF_MAXPARTYNUM; i++) m_pPartyManager[i] = NULL;
	for (i = 0; i < DEF_MAXMAPS; i++) m_pMapList[i] = NULL;
	for (i = 0; i < DEF_MAXITEMTYPES; i++) m_pItemConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCTYPES; i++) m_pNpcConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCS; i++) m_pNpcList[i] = NULL;
	for (i = 0; i < DEF_MSGQUENESIZE; i++) m_pMsgQuene[i] = NULL;
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++) m_pQuestConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) m_pDynamicObjectList[i] = NULL;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) m_pDelayEventList[i] = NULL;
	for (i = 0; i < DEF_MAXFISHS; i++) m_pFish[i] = NULL;
	for (i = 0; i < DEF_MAXMINERALS; i++) m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		m_pPortionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL;// Crafting
	}

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = NULL;
	for (i = 0; i < DEF_MAXDUPITEMID; i++) m_pDupItemIDList[i] = NULL;

	m_bAnunciosActivo = TRUE;
	EventAuto = TRUE;
	m_iQueneHead = m_iQueneTail = m_iTotalClients = m_iMaxClients = m_iTotalMaps = 0;

	m_iTotalGameServerClients = m_iTotalGameServerMaxClients = 0;
	m_MaxUserSysTime.wHour = m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = m_iElvineOccupyTiles = 0;

	for (i = 1; i < 3; i++)	m_stCityStatus[i].iCrimes = m_stCityStatus[i].iFunds = m_stCityStatus[i].iWins = 0;

	m_iAutoRebootingCount = m_iCurMsgs = m_iMaxMsgs = 0;;
	m_pGold = NULL;
	m_iAddUser = m_iAFKUsers = m_iExtHGServerPort = m_iWorldLogServerPort = m_iWorldMaxUser = m_dwExitProcessTime = m_bAFKLimbo = 0;

	dw_CrusadeTime = dw_TowerTime = dw_CaptureTime = dw_RushTime = dw_DmTime = 0;

	//ZerEoyPnk - News Addons
	for (i = 0; i < DEF_MAXPORTALS; i++) {
		dest_dx_portal[i] = ini_dx_portal[i] = dest_dy_portal[i] = ini_dy_portal[i] = 0;
		LevelLimit_portal[i] = MaxPlayer_portal[i] = PortalPlayers[i] = 0;
		dw_TimeOpenPortal[i] = dw_TimePortal[i] = NULL;
		PortalAbility[i] = FALSE;
	}
	LastPortal = 0;

	// Capture The Flag
	//50Cent - Capture The Flag
	m_bIsCTFMode = m_bIsElvineFlagCaptured = m_bIsAresdenFlagCaptured = false;
	m_sAresdenFlagCount = m_sElvineFlagCount = 0;
	m_iFlagCarrierIndex = -1;

	m_iTowerDefenceElvine = m_iTowerDefenceAresden = GolesElvine = GolesAresden = 0;
	m_bIsRushNetMode = Soccer = AllVsAllPortals = AllVsAll = TowerDefense = FlagElvine = FlagAresden = FALSE;
	//RespawnON = FALSE;

	TotalCompetidores = TotalPrice = 0;

	m_bReceivedItemList = false;
	Actualizar = AbaddonEvent = ActiveEvent = CityVsCity = PriceEvent = HellOfDeath = PriceHODEvent = WorldWar = WWPriceEvent = WWIIPriceEvent = WorldWarII = AllEks = AllDkEks = FALSE;
	EventTime = cvcEventTime = PriceTime = ReliquiaAresden = ReliquiaElvine = WorldWarTime = WWPriceTime = WWIIPriceTime = WorldWarTimeII = AllEksTime = AllDkEksTime = 0;
	dw_abaddon_nospawn = -1;
	AddUser = DeletedUser = VipMap = Masacre = FinalFight = DKEvent = TowerHell = WorldWar = WorldWarII = FALSE;
	Questx2 = Questx3 = AllEks = AllDkEks = FALSE;
	TotalAdded = TotalDeleted = TotalAnnoucement = 0;

	for (i = 0; i < 10; i++) {
		EventCount[i].AresdenWin = -1;
		EventCount[i].ElvineWin = -1;
		EventCount[i].Draw = -1;
		EventCount[i].LastWin = -1;

		SummonBalls[i].dwOpenSummonMap = -1;
		SummonBalls[i].ActiveSummon = false;
		ZeroMemory(SummonBalls[i].GuildName, sizeof(SummonBalls[i].GuildName));
	}

	for (short j = 0; j < 6; j++) {
		for (i = 0; i < 15; i++) {
			Top[j][i].Points = 0;
			ZeroMemory(Top[j][i].Name, sizeof(Top[j][i].Name));
			Top[j][i].Side = Neutral;
		}
	}

	RunSummonEvent = RunSummonEvent2 = RunSummonEvent3 = SummonLaunched = FALSE;
	AssasainRound = AresdenRound = ElvineRound = MSTotal = 0;

	enable_log_cl = true;
}

CMapServer::~CMapServer()
{

}

BOOL CMapServer::bAccept(class XSocket * pXSock)
{
	
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		class XSocket * pTmpSock;
		int x;
		short sTotalConnection;
		sTotalConnection = 0;

		pTmpSock = new class XSocket(m_hWnd, DEF_CLIENTSOCKETBLOCKLIMIT);

		if ((m_bIsLogSockAvailable == FALSE) || (m_bOnExitProcess == TRUE) || (m_bIsGameStarted == FALSE)) goto CLOSE_ANYWAY;

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] == NULL) {
				m_pClientList[i] = new class CClient(m_hWnd, i);
				bAddClientShortCut(i);
				mtx.lock();
				bCheckClient[i] = TRUE;
				mtx.unlock();

				//Auto Save ZeroEoyPnk
				m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime =
					m_pClientList[i]->m_dwHPTime = m_pClientList[i]->Save =
					m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime =
					m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->LastTime =
					m_pClientList[i]->m_dwAutoSaveTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();

				pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i);
				ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
				m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);
				if ((memcmp(m_pClientList[i]->m_cIPaddress, "218.212.16", 10) == 0) ||
					(memcmp(m_pClientList[i]->m_cIPaddress, "67.228.85", 9) == 0) ||
					(memcmp(m_pClientList[i]->m_cIPaddress, "218.111.12", 10) == 0) ||
					(memcmp(m_pClientList[i]->m_cIPaddress, "69.84.41", 8) == 0)) {
					mtx.lock();
					bCheckClient[i] = FALSE;
					delete m_pClientList[i];
					m_pClientList[i] = NULL;
					RemoveClientShortCut(i);
					mtx.unlock();
					//DeleteClient(i, FALSE, FALSE);
					
					goto CLOSE_ANYWAY;
					return FALSE;
				}

				for (x = 0; x < 100; x++) {
					if (strlen(BannedIP[x]) > 0) {
						if (strcmp(m_pClientList[i]->m_cIPaddress, BannedIP[x]) == 0) {
							mtx.lock();
							bCheckClient[i] = FALSE;
							delete m_pClientList[i];
							m_pClientList[i] = NULL;
							RemoveClientShortCut(i);
							mtx.unlock();
							//DeleteClient(i, FALSE, FALSE);

							goto CLOSE_ANYWAY;
							return FALSE;
						}
					}
					else x = 100;
				}

				m_iTotalClients++;
				//if(i > MaxClientID) MaxClientID = i;

				for (x = 0; x < DEF_MAXCLIENTS; x++) {
					if (m_pClientList[x] != NULL) {
						if ((strlen(m_pClientList[x]->m_cIPaddress) == 0) || (strlen(m_pClientList[i]->m_cIPaddress) == 0)) {
							mtx.lock();
							bCheckClient[i] = FALSE;
							delete m_pClientList[i];
							m_pClientList[i] = NULL;
							RemoveClientShortCut(i);
							m_iTotalClients--;
							mtx.unlock();
							//DeleteClient(i, FALSE, FALSE);

							goto CLOSE_ANYWAY;
							return FALSE;
						}
						if (memcmp(m_pClientList[x]->m_cIPaddress, m_pClientList[i]->m_cIPaddress, 15) == 0) {
							if (m_pClientList[x]->NoClear == FALSE) {
								sTotalConnection++;
								if (sTotalConnection >= 15) { //15 cambio lalo
									mtx.lock();
									bCheckClient[i] = FALSE;
									delete m_pClientList[i];
									m_pClientList[i] = NULL;
									RemoveClientShortCut(i);
									m_iTotalClients--;
									mtx.unlock();
									//DeleteClient(i, FALSE, FALSE);

									goto CLOSE_ANYWAY;
									return FALSE;
								}
							}
						}
						if ((memcmp(m_pClientList[x]->m_cCharName, m_pClientList[i]->m_cCharName, 15) == 0) && (x != i)) {
							if (m_pClientList[x]->NoDelete == TRUE) m_pClientList[x]->NoDelete = FALSE;
							if (m_pClientList[x]->NoClear == TRUE) m_pClientList[x]->NoClear = FALSE;

							m_pClientList[x]->m_bForceDisconnect = true;

							DeleteClient(x, TRUE, TRUE);
						}
					}
				}

				if (m_iTotalClients > m_iMaxClients) {
					m_iMaxClients = m_iTotalClients;
					GetLocalTime(&m_MaxUserSysTime);
				}
				return TRUE;
			}

	CLOSE_ANYWAY:;

		pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		pXSock->bAccept(pTmpSock, NULL);
		delete pTmpSock;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bAccept");
	}
#endif

	return FALSE;
}

void CMapServer::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{

#ifdef DEF_DEBUG
	try {
#endif
		SYSTEMTIME SysTime;

		UINT iTmp;
		register int iClientH, iRet;
		DWORD dwTime = timeGetTime();

		iTmp = WM_ONCLIENTSOCKETEVENT;
		iClientH = message - iTmp;

		//Crash aca Lalo ver

		if (iClientH <= 0 || iClientH >= DEF_MAXCLIENTS) return;

		//LaloRamos Array NUll?? aviso.
		if (m_pClientList == NULL) {
			PutLogHacksFileList("Crash evitado ClientList = NULL");
			return;
		}

		if (m_pClientList[iClientH] == NULL) return;
		if (bCheckClient[iClientH] == NULL) return;
		if (!iClientH || !bCheckClient[iClientH]) return;

		iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

			switch (iRet) {
				case DEF_XSOCKEVENT_READCOMPLETE:
					OnClientRead(iClientH);
					m_pClientList[iClientH]->m_dwTime = timeGetTime();
					break;

				case DEF_XSOCKEVENT_BLOCK:
					PutLogList("Socket BLOCKED!");
					break;

				case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
					wsprintf(G_cTxt, "<%d> Confirmcode notmatch!", iClientH);
					CharacterLogList(G_cTxt);
					DeleteClient(iClientH, FALSE, TRUE);
					break;

				case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
				case DEF_XSOCKEVENT_SOCKETERROR://lalo Socket
				case DEF_XSOCKEVENT_SOCKETCLOSED:

					// Si vuelve a crashear habilitar esto (sacar el // anterior al default)
					//default: // veamos si calza por estos lares ... 1.-
					if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == FALSE) {// When client TPs, is not a real deco hack
						DeleteClient(iClientH, TRUE, TRUE);
					}
					else {
						DeleteClient(iClientH, TRUE, TRUE);
					}
					return;
					break;
			//}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: OnClientSocketEvent");
	}
#endif
}

BOOL CMapServer::bInit()
{
	char * cp, cTxt[120];
	DWORD * dwp;
	WORD * wp;
	int  i;
	SYSTEMTIME SysTime;
	DWORD dwTime = timeGetTime();
	PutLogList("INITIALIZING GAME SERVER...");

	for (i = 0; i < DEF_MAXCLIENTS + 1; i++) m_iClientShortCut[i] = 0;

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	mtx.lock();
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) delete m_pClientList[i];
		bCheckClient[i] = FALSE;
	}
	mtx.unlock();


	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];	// Crafting
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;

	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}

	m_iNpcConstructionPoint[1] = 100; // MS
	m_iNpcConstructionPoint[2] = 100; // MS
	m_iNpcConstructionPoint[3] = 100; // MS
	m_iNpcConstructionPoint[4] = 100; // MS
	m_iNpcConstructionPoint[5] = 100; // MS
	m_iNpcConstructionPoint[6] = 100; // MS

	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG

	m_iNpcConstructionPoint[51] = 1500; // Catapult
	m_bIsGameStarted = FALSE;

	m_pMainLogSock = NULL;
	m_bIsLogSockAvailable = FALSE;
	m_bIsWLServerAvailable = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	for (i = 0; i < DEF_MAXCLIENTS; i++) m_pClientList[i] = NULL;
	for (i = 0; i < DEF_MAXMAPS; i++) m_pMapList[i] = NULL;
	for (i = 0; i < DEF_MAXITEMTYPES; i++) m_pItemConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCTYPES; i++) m_pNpcConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXNPCS; i++) m_pNpcList[i] = NULL;
	for (i = 0; i < DEF_MSGQUENESIZE; i++) m_pMsgQuene[i] = NULL;
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pMagicConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) m_pSkillConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++) m_pQuestConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) m_pDynamicObjectList[i] = NULL;
	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) m_pDelayEventList[i] = NULL;
	for (i = 0; i < DEF_MAXFISHS; i++) m_pFish[i] = NULL;
	for (i = 0; i < DEF_MAXMINERALS; i++) m_pMineral[i] = NULL;
	for (i = 0; i < DEF_MAXBUILDITEMS; i++) m_pBuildItemList[i] = NULL;
	for (i = 0; i < DEF_MAXTELEPORTLIST; i++) m_pTeleportConfigList[i] = NULL;
	for (i = 0; i < DEF_MAXGUILDS; i++) m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		m_pPortionConfigList[i] = NULL;
		m_pCraftingConfigList[i] = NULL;	// Crafting
	}
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX = NULL;
		m_stCrusadeStructures[i].dY = NULL;
	}

	for (i = 0; i < MAX_RUSHSTRUCTURES; i++) {
		ZeroMemory(m_stRushStructures[i].cMapName, sizeof(m_stRushStructures[i].cMapName));
		m_stRushStructures[i].cType = NULL;
		m_stRushStructures[i].dX = NULL;
		m_stRushStructures[i].dY = NULL;
	}

	for (i = 0; i < MAX_DEFENCESTRUCTURES; i++) {
		ZeroMemory(m_stDefenceStructures[i].cMapName, sizeof(m_stDefenceStructures[i].cMapName));
		m_stDefenceStructures[i].cType = NULL;
		m_stDefenceStructures[i].dX = NULL;
		m_stDefenceStructures[i].dY = NULL;
	}

	for (i = 0; i < MAX_DEFENCESTRUCTURES; i++) {
		ZeroMemory(m_stDefenceStructuresx[i].cMapName, sizeof(m_stDefenceStructuresx[i].cMapName));
		m_stDefenceStructuresx[i].cType = NULL;
		m_stDefenceStructuresx[i].dX = NULL;
		m_stDefenceStructuresx[i].dY = NULL;
	}

	for (i = 0; i < MAX_CVCSTRUCTURES; i++) {
		ZeroMemory(m_stCVCStructures[i].cMapName, sizeof(m_stCVCStructures[i].cMapName));
		m_stCVCStructures[i].cType = NULL;
		m_stCVCStructures[i].dX = NULL;
		m_stCVCStructures[i].dY = NULL;
	}

	for (i = 0; i < MAX_DEFENCESTRUCTURESA; i++) {
		ZeroMemory(m_stSummonStructures[i].cMapName, sizeof(m_stSummonStructures[i].cMapName));
		m_stSummonStructures[i].cType = NULL;
		m_stSummonStructures[i].dX = NULL;
		m_stSummonStructures[i].dY = NULL;
	}

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		SummonRound[i].Cant = 0;
		ZeroMemory(SummonRound[i].cNpcName, sizeof(SummonRound[i].cNpcName));
	}

	for (i = 0; i < MAX_DEFENCESTRUCTURES; i++) {
		ZeroMemory(m_stHellOfDeathStructures[i].cMapName, sizeof(m_stHellOfDeathStructures[i].cMapName));
		m_stHellOfDeathStructures[i].cType = NULL;
		m_stHellOfDeathStructures[i].dX = NULL;
		m_stHellOfDeathStructures[i].dY = NULL;
	}

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;

	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients = 0;  //acaa
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex = -1;
	m_iElvineMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;
	m_iSubLogSockInitIndex = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;
	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana = 0;
	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 = m_dwFakeTime = m_dwCheckProcess = m_dwNewTime =
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = m_dwAnuncios = m_dwAutoSaveTime = m_dwGameTime8 = m_dwGameTime9 = m_dwMinute = dwTime;

	m_bIsSpecialEventTime = FALSE;

	GetLocalTime(&SysTime);
	m_dwCanFightzoneReserveTime = dwTime - ((SysTime.wHour % 2) * 60 * 60 + SysTime.wMinute * 60) * 1000;

	for (i = 0; i < DEF_MAXFIGHTZONE; i++)
		m_iFightZoneReserve[i] = 0;

	m_iFightzoneNoForceRecall = 0;

	for (i = 1; i < 300; i++) m_iLevelExpTable[i] = iGetLevelExp(i);

	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT + 1]; // ü���� ������ 20�����̻��� ����ġ�� ���� �� ����.  �ӽ÷� ���� 60����
	m_iLevelExp20 = m_iLevelExpTable[20];

	if (bReadProgramConfigFile("UltimateServer.cfg") == FALSE) {
		ErrorList(" ");
		ErrorList("(!!!) CRITICAL ERROR! Cannot execute server! config file contents error!");
		return FALSE;
	}

	if (bDecodeTeleportList("Configs\\Teleport.cfg") == FALSE) {
		ErrorList(" ");
		ErrorList("(!!!) ERROR: El Teleport.cfg esta mal configurado");
		return FALSE;
	}

	if (ReadProcessAndDllBlockedFile("Configs\\CheckProcess.cfg", 1) == FALSE) {
		ErrorList(" ");
		ErrorList("(!!!) ERROR: El CheckProcess.cfg esta mal configurado");
		return FALSE;
	}

	if (ReadProcessAndDllBlockedFile("Configs\\CheckDlls.cfg", 0) == FALSE) {
		ErrorList(" ");
		ErrorList("(!!!) ERROR: El CheckDlls.cfg esta mal configurado");
		return FALSE;
	}

	// New Configs
	_bDecodeNoticementFileContents("Configs\\noticement.txt");
	if (!_bDecodeItemConfigFileContents("Configs\\Item.cfg")) ErrorList("(!!!) STOPPED! Item configuration error.");
	if (!_bDecodeItemConfigFileContents("Configs\\Item2.cfg")) ErrorList("(!!!) STOPPED! Item2 configuration error.");
	if (!_bDecodeItemConfigFileContents("Configs\\Item3.cfg")) ErrorList("(!!!) STOPPED! Item3 configuration error.");
	if (!_bDecodeMagicConfigFileContents("Configs\\Magic.cfg")) ErrorList("(!!!) STOPPED! MAGIC configuration error.");
	if (!_bDecodePortionConfigFileContents("Configs\\potion.cfg")) ErrorList("(!!!) STOPPED! POTION configuration error.");
	if (!_bDecodeBuildItemConfigFileContents("Configs\\builditem.cfg")) ErrorList("(!!!) STOPPED! Build-Item configuration error.");
	if (!_bDecodeSkillConfigFileContents("Configs\\Skill.cfg")) ErrorList("(!!!) STOPPED! SKILL configuration error.");
	if (!_bDecodeQuestConfigFileContents("Configs\\Quest.cfg")) ErrorList("(!!!) STOPPED! QUEST configuration error.");
	if (!_bDecodeNpcConfigFileContents("Configs\\NPC.cfg")) ErrorList("(!!!) STOPPED! Npc configuration error.");

	LoadBannedList(0);

	//WriteTradeLog();

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if (m_pMapList[i] != NULL)
			_bReadMapInfoFiles(i);
	}

	PutLogList("Map info file decodings sucess");

	bReadDupeConfigFile("DupItemIDS.cfg");
	_LinkStrikePointMapIndex();

	//Events Results
	if (!bReadEventResults("Events\\Crusade\\Results.txt", 0)) PutLogList("Error al abrir el Crusade Results");
	if (!bReadEventResults("Events\\CaptureTheFlag\\Results.txt", 1)) PutLogList("Error al abrir el CaptureTheFlag Results");
	if (!bReadEventResults("Events\\Rush\\Results.txt", 2)) PutLogList("Error al abrir el Rush Results");
	if (!bReadEventResults("Events\\TowerDefense\\Results.txt", 3)) PutLogList("Error al abrir el TowerDefense Results");
	if (!bReadEventResults("Events\\CityVsCity\\Results.txt", 4)) PutLogList("Error al abrir el CityVsCity Results");
	if (!bReadEventResults("Events\\HellOfDeath\\Results.txt", 5)) PutLogList("Error al abrir el HellOfDeath Results");
	if (!bReadEventResults("Events\\WorldWar\\Results.txt", 6)) PutLogList("Error al abrir el WorldWar Results");
	if (!bReadEventResults("Events\\WorldWarII\\Results.txt", 7)) PutLogList("Error al abrir el WorldWarII Results");

	//Events Configs
	bReadRushStructureConfigFile("Events\\Rush\\Structures.txt");
	bReadTDStructureConfigFile("Events\\TowerDefense\\Structures.txt");
	bReadCrusadeStructureConfigFile("Events\\Crusade\\Structures.txt");
	bReadCVCStructureConfigFile("Events\\CityVsCity\\Structures.txt");
	bReadSummonStructureConfigFile("Events\\Summon\\Structures.txt");
	bReadHellOfDeathConfigFile("Events\\HellOfDeath\\Structures.txt");
	bReadFinalFightConfigFile("Events\\FinalFight\\EventID.txt");

	_bReadItemsEventCFG("Events\\FinalFight\\Items.txt");

	//Summons
	ReloadSummonEventConfig();
	bReadMessageConfigFile("Configs\\Anuncios.cfg");
	ReadTradeItems("Configs\\TradeContrib.cfg");
	ReadTradeItems("Configs\\TradeEk.cfg");
	ReadTradeItems("Configs\\TradeCoins.cfg");
	ReadQuestItemsCFG("Configs\\ItemQuest.cfg");
	ReadQuestItemsCFG("Configs\\StatedQuest.cfg");

	ReadMapCFGs("Configs\\MapList.cfg");

	srand((unsigned)time(NULL));
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	wsprintf(cTxt, "Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	PutLogList(cTxt);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = FALSE;
	m_bOnExitProcess = FALSE;

	for (i = 0; i <= 100; i++) m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);

	GetLocalTime(&SysTime);
	if ((SysTime.wHour >= 20) || (SysTime.wHour <= 6)) {
		if (SysTime.wMonth == 12) m_cDayOrNight = 3;
		else m_cDayOrNight = 2;
	}
	else m_cDayOrNight = 1;

	m_iCurSubLogSockIndex = 0;
	m_iSubLogSockFailCount = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount = NULL;
	m_bIsCrusadeMode = FALSE;
	m_wServerID_GSS = (WORD)iDice(1, 65535);

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_iCrusadeWinnerSide = NULL;
	m_iWinnerSide = NULL;			//v2.19 2002-11-15 
	m_iNonAttackArea = FALSE;		//v2.19 2002-11-19 
	m_bIsCrusadeWarStarter = FALSE;
	m_iFinalShutdownCount = 0;
	dwCreateGuildGoldCost = 2000;

	MarketEnabled = FALSE;

	return TRUE;
}

void CMapServer::WriteTradeLog()
{

	// Obtener la ruta de la carpeta del programa
	std::string logFilePath = GetProgramDirectory() + "\\log.txt";

	// Abrir el archivo en modo append
	std::ofstream logFile(logFilePath, std::ios::app);
	if (!logFile) {
		std::cerr << "Error al abrir el archivo de log: " << logFilePath << std::endl;
	}

	// Recorrer los elementos y escribir en el archivo
	for (int i = 0; i < DEF_MAXITEMTYPES; i++) {
		if (!m_pItemConfigList[i]) continue;

		logFile << "Item " << i << ": "
			<< "Name: " << m_pItemConfigList[i]->m_cName << ", "
			<< "Sprite: " << m_pItemConfigList[i]->m_sSprite << ", "
			<< "SpriteFrame: " << m_pItemConfigList[i]->m_sSpriteFrame << ", "
			<< "Color: " << static_cast<int>(m_pItemConfigList[i]->m_cItemColor)  // Convertir char a int
			<< std::endl;
	}

	logFile.close();
	std::cout << "Log generado en: " << logFilePath << std::endl;
}

std::string CMapServer::GetProgramDirectory() {
	char buffer[MAX_PATH];
	GetModuleFileNameA(NULL, buffer, MAX_PATH);
	std::string fullPath(buffer);
	size_t lastSlash = fullPath.find_last_of("\\/");
	return fullPath.substr(0, lastSlash);
}

void CMapServer::OnClientRead(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * pData, cKey;
		DWORD  dwMsgSize;

		if (m_pClientList[iClientH] == NULL) return;

		pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointerClient(&dwMsgSize, &cKey); // v1.4

		if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE)
			ErrorList("@@@@@@ CRITICAL ERROR in MsgQuene 1!!! @@@@@@");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: OnClientRead");
	}
#endif
}

void CMapServer::DisplayInfo(HDC hdc)
{
	char cTxt[80];

	SetTextColor(hdc, clGreen);
	wsprintf(cTxt, "SERVER LOGS:");
	TextOut(hdc, 10, 190, cTxt, strlen(cTxt));

	wsprintf(cTxt, "CHARACTER LOGS:");
	TextOut(hdc, 690, 20, cTxt, strlen(cTxt));

	wsprintf(cTxt, "CHAT GAME LOGS:");
	TextOut(hdc, 315, 20, cTxt, strlen(cTxt));

	wsprintf(cTxt, "SERVER CONFIGS:");
	TextOut(hdc, 10, 20, cTxt, strlen(cTxt));

	wsprintf(cTxt, "ERROR LOGS:");
	TextOut(hdc, 690, 290, cTxt, strlen(cTxt));
}


void CMapServer::ClientMotionHandler(int iClientH, char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif

		DWORD * dwp, dwClientTime; // v2.171
		WORD * wp, wCommand, wTargetObjectID;
		short * sp, sX, sY, dX, dY, wType;
		char  * cp, cDir;
		int   iRet, iTemp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		wCommand = *wp;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		sX = *sp;
		cp += 2;

		sp = (short *)cp;
		sY = *sp;
		cp += 2;

		cDir = *cp;
		cp++;

		sp = (short *)cp;
		dX = *sp;
		cp += 2;

		sp = (short *)cp;
		dY = *sp;
		cp += 2;

		sp = (short *)cp;
		wType = *sp;
		cp += 2;

		if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) {
			wp = (WORD *)cp;
			wTargetObjectID = *wp;
			cp += 2;
		}
		else wTargetObjectID = 0;

		dwp = (DWORD *)cp;
		dwClientTime = *dwp;
		cp += 4;

		switch (wCommand) {
		case DEF_OBJECTSTOP:
			iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
			if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
			else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;
		case DEF_OBJECTRUN:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, TRUE);
			if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
			bCheckClientMoveFrequency(iClientH, dwClientTime);
			//agregado Lalov9
			//bCheckClientStatLvl(iClientH);
			if (m_pClientList[iClientH] != NULL) {
				if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
					m_pClientList[iClientH]->ActiveAvA = timeGetTime();
			}
			break;

		case DEF_OBJECTMOVE:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
			if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
			bCheckClientMoveFrequency(iClientH, dwClientTime);
			//bCheckClientStatLvl(iClientH);
			if (m_pClientList[iClientH] != NULL) {
				if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
					m_pClientList[iClientH]->ActiveAvA = timeGetTime();
			}
			break;

		case DEF_OBJECTDAMAGEMOVE:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE, TRUE);
			if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, (short)m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
			if (m_pClientList[iClientH] != NULL) {
				if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
					m_pClientList[iClientH]->ActiveAvA = timeGetTime();
			}
			break;

		case DEF_OBJECTATTACKMOVE:
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
			if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
				SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
				wType = 1;
				iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE); // v1.4
			}
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
			// v2.171
			bCheckClientAttackFrequency(iClientH, dwClientTime);
			if (m_pClientList[iClientH] != NULL) {
				if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
					m_pClientList[iClientH]->ActiveAvA = timeGetTime();
			}
			break;

		case DEF_OBJECTATTACK:
			_CheckAttackType(iClientH, &wType);
			iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
			if (iRet == -1) return;
			if (iRet == 1) {
				if (wType >= 20) {
					if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) m_pClientList[iClientH]->m_iSuperAttackLeft--;
					if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
				}
				SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
			}
			else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			bCheckClientAttackFrequency(iClientH, dwClientTime);
			if (m_pClientList[iClientH] != NULL) {
				if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
					m_pClientList[iClientH]->ActiveAvA = timeGetTime();
			}
			break;

		case DEF_OBJECTGETITEM:
			iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
			if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
			else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;

		case DEF_OBJECTMAGIC:
			iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
			if (iRet == 1) {
				iTemp = 10;
				SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMAGIC, dX, (short)iTemp, NULL);
			}
			else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			//antihack
			bCheckClientMagicFrequency(iClientH, dwClientTime);
			//bCheckClientStatLvl(iClientH);
			if (m_pClientList[iClientH] != NULL) {
				if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
					m_pClientList[iClientH]->ActiveAvA = timeGetTime();
			}
			break;

		default:
			break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClientMotionHandler");
	}
#endif
}


/*

void CMapServer::ClientMotionHandler(int iClientH, char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif

		DWORD * dwp, dwClientTime; // v2.171
		WORD * wp, wCommand, wTargetObjectID;
		short * sp, sX, sY, dX, dY, wType;
		char  * cp, cDir;
		int   iRet, iTemp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		wCommand = *wp;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		sX = *sp;
		cp += 2;

		sp = (short *)cp;
		sY = *sp;
		cp += 2;

		cDir = *cp;
		cp++;

		sp = (short *)cp;
		dX = *sp;
		cp += 2;

		sp = (short *)cp;
		dY = *sp;
		cp += 2;

		sp = (short *)cp;
		wType = *sp;
		cp += 2;

		if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) {
			wp = (WORD *)cp;
			wTargetObjectID = *wp;
			cp += 2;
		}
		else wTargetObjectID = 0;

		dwp = (DWORD *)cp;
		dwClientTime = *dwp;
		cp += 4;

		switch (wCommand) {
			case DEF_OBJECTSTOP:
				iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
				if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
				else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
				break;
			case DEF_OBJECTRUN:
				iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, TRUE);
				if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
				if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
				bCheckClientMoveFrequency(iClientH, (wCommand == DEF_OBJECTRUN));
				//agregado Lalov9
				//bCheckClientStatLvl(iClientH);
				if (m_pClientList[iClientH] != NULL) {
					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						m_pClientList[iClientH]->ActiveAvA = timeGetTime();
				}
				break;

			case DEF_OBJECTMOVE:
				iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
				if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
				bCheckClientMoveFrequency(iClientH, (wCommand == DEF_OBJECTRUN));
				//bCheckClientStatLvl(iClientH);
				if (m_pClientList[iClientH] != NULL) {
					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						m_pClientList[iClientH]->ActiveAvA = timeGetTime();
				}
				break;

			case DEF_OBJECTDAMAGEMOVE:
				iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE, TRUE);
				if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, (short)m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
				if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
				if (m_pClientList[iClientH] != NULL) {
					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						m_pClientList[iClientH]->ActiveAvA = timeGetTime();
				}
				break;

			case DEF_OBJECTATTACKMOVE:
				iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
				if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
					SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
					wType = 1;
					iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE); // v1.4
				}
				if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
				// v2.171
				bCheckClientAttackFrequency(iClientH, dwClientTime);
				if (m_pClientList[iClientH] != NULL) {
					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						m_pClientList[iClientH]->ActiveAvA = timeGetTime();
				}
				break;

			case DEF_OBJECTATTACK:
				_CheckAttackType(iClientH, &wType);
				iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
				if (iRet == -1) return;
				if (iRet == 1) {
					if (wType >= 20) {
						if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) m_pClientList[iClientH]->m_iSuperAttackLeft--;
						if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
					}
					SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
				}
				else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
				bCheckClientAttackFrequency(iClientH, dwClientTime);
				if (m_pClientList[iClientH] != NULL) {
					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						m_pClientList[iClientH]->ActiveAvA = timeGetTime();
				}
				break;

			case DEF_OBJECTGETITEM:
				iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
				if (iRet == 1) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
				else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
				break;

			case DEF_OBJECTMAGIC:
				iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
				if (iRet == 1) {
					iTemp = 10;
					SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMAGIC, dX, (short)iTemp, NULL);
				}
				else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
				//antihack
				bCheckClientMagicFrequency(iClientH, dwClientTime);
				//bCheckClientStatLvl(iClientH);
				if (m_pClientList[iClientH] != NULL) {
					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						m_pClientList[iClientH]->ActiveAvA = timeGetTime();
				}
				break;

			default:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClientMotionHandler");
	}
#endif
}*/

int CMapServer::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, BOOL bIsRun, BOOL BIsDamage)
{

#ifdef DEF_DEBUG
	try {
#endif
		char  * cp, cData[3000], cRemainItemColor;
		class CTile * pTile;
		DWORD * dwp, dwTime;
		WORD  * wp, wObjectID;
		short * sp, dX, dY, sDOtype, sRemainItemSprite, sRemainItemSpriteFrame;
		int   * ip, iRet, iSize, iDamage, iTemp, iTemp2, iEraseReq;
		BOOL  bRet, bLize;
		class CItem * pItem;

		bLize = FALSE;

		if (m_pClientList[iClientH] == NULL) return 0;
		if ((cDir <= 0) || (cDir > 8))       return 0;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
		if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
/*

		if (m_pClientList[client]->m_iAdminUserLevel == 0)
		{

			if (m_pClientList[client]->haste)
			{
				goto _nocheck;
			}

			if (m_pClientList[client]->bDamage)
			{
				m_pClientList[client]->bDamage = false;
				goto _nocheck;
			}

			float distance = 0.0f;
			if (lastMoveTime != 0) {
				distance = sqrtf(static_cast<float>((logx - m_pClientList[client]->m_sX) * (logx - m_pClientList[client]->m_sX) + (logy - m_pClientList[client]->m_sY) * (logy - m_pClientList[client]->m_sY)));
				float timeElapsed = (dwTime - lastMoveTime) / 1000.0f;

				float speed = distance / timeElapsed;

				char logBuffer[256];
				char distanceStr[32], timeElapsedStr[32], speedStr[32];
				_snprintf(distanceStr, sizeof(distanceStr), "%.2f", distance);
				_snprintf(timeElapsedStr, sizeof(timeElapsedStr), "%.2f", timeElapsed);
				_snprintf(speedStr, sizeof(speedStr), "%.2f", speed);

				float maxWalkSpeed = 3.5f;
				float maxRunSpeed = 5.5f;

				if ((bIsRun && speed > maxRunSpeed) || (!bIsRun && speed > maxWalkSpeed)) {
					m_pClientList[client]->speedhackCount++;
					if (m_pClientList[client]->speedhackCount > 5) {
						wsprintf(logBuffer, "Speed Hack Detected: Client %d, Speed: %s units/s, Running: %s",
							client, speedStr, (bIsRun ? "Yes" : "No"));
						PutLogList(logBuffer);
						m_pClientList[client]->m_bForceDisconne
							DeleteClient(client, TRUE, TRUE);
						return 0;
					}

				}
				else {
					m_pClientList[client]->speedhackCount = 0;
				}
			}
		}

	_nocheck:*/

		if (m_pClientList[iClientH]->KilledClientAFK != -1) m_pClientList[iClientH]->KilledClientAFK = -1;

		dwTime = timeGetTime();
		m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

		int iStX, iStY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
			iStX = m_pClientList[iClientH]->m_sX / 20;
			iStY = m_pClientList[iClientH]->m_sY / 20;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
				case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
				case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
			}
		}
		ClearSkillUsingStatus(iClientH);
		dX = m_pClientList[iClientH]->m_sX;
		dY = m_pClientList[iClientH]->m_sY;

		switch (cDir) {
			case 1:	dY--; break;
			case 2:	dX++; dY--;	break;
			case 3:	dX++; break;
			case 4:	dX++; dY++;	break;
			case 5: dY++; break;
			case 6:	dX--; dY++;	break;
			case 7:	dX--; break;
			case 8:	dX--; dY--;	break;
		}

		bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype); // v2.172

		if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0){
			bRet = FALSE;
			bLize = TRUE;
		}

		if (bRet == TRUE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

			m_pClientList[iClientH]->m_sX = dX;
			m_pClientList[iClientH]->m_sY = dY;
			m_pClientList[iClientH]->m_cDir = cDir;

			shinning_update(iClientH);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH, DEF_OWNERTYPE_PLAYER, dX, dY);
			if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
				if ((m_pClientList[iClientH]->m_bIsNeutral != TRUE) && (m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
					iDamage = iDice(2, 4);
					if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
						m_pClientList[iClientH]->m_iHP -= iDamage;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
					}
				}
			}
			if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;

			if (!m_pClientList[iClientH]->NoClear) {
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_OBJECTMOVE_CONFIRM;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
						
				sp = (short *)cp;
				*sp = (short)(dX - m_pClientList[iClientH]->res_sX);
				cp += 2;

				sp = (short *)cp;
				*sp = (short)(dY - m_pClientList[iClientH]->res_sY);
				cp += 2;

				*cp = cDir;
				cp++;

				if (bIsRun == TRUE) {// Staminar ����ġ �Է� 
					if (m_pClientList[iClientH]->m_iSP > 0) {
						*cp = 0; // 1
						if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
							m_pClientList[iClientH]->m_iSP--;
							*cp = 1;
						}
					}
					else {
						*cp = 0; // 1
						if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
							m_pClientList[iClientH]->m_iSP--;
							*cp = 1;
						}
						if (m_pClientList[iClientH]->m_iSP < -10) {
							m_pClientList[iClientH]->m_iSP = 0;
							DeleteClient(iClientH, TRUE, TRUE);
							return 0;
						}
					}
				}
				else *cp = 0;
				cp++;

				pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
				*cp = (char)pTile->m_iOccupyStatus;
				cp++;

				if (BIsDamage == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);

			    iSize = iComposeMoveMapData((short)(dX - m_pClientList[iClientH]->res_sX), (short)(dY - m_pClientList[iClientH]->res_sY), iClientH, cDir, cp);
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 17); // 12 + 1 + 4);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return 0;
				}
			}
			else return 1;
		}
		else {
			if (!m_pClientList[iClientH]->NoClear) {
				m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171 
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				if (bLize)	{ *wp = DEF_OBJECTMOVE_PARALIZE; }
				else { *wp = DEF_OBJECTMOVE_REJECT; }


				wObjectID = (WORD)iClientH;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

				wp = (WORD *)cp;
				*wp = wObjectID;			// ObjectID
				cp += 2;
				sp = (short *)cp;
				sX = m_pClientList[wObjectID]->m_sX;
				*sp = sX;
				cp += 2;
				sp = (short *)cp;
				sY = m_pClientList[wObjectID]->m_sY;
				*sp = sY;
				cp += 2;
				sp = (short *)cp;
				*sp = m_pClientList[wObjectID]->m_sType;
				cp += 2;
				*cp = m_pClientList[wObjectID]->m_cDir;
				cp++;
				memcpy_secure(cp, m_pClientList[wObjectID]->m_cCharName, 10);
				cp += 10;
				sp = (short *)cp;
				*sp = m_pClientList[wObjectID]->m_sAppr1;
				cp += 2;
				sp = (short *)cp;
				*sp = m_pClientList[wObjectID]->m_sAppr2;
				cp += 2;
				sp = (short *)cp;
				*sp = m_pClientList[wObjectID]->m_sAppr3;
				cp += 2;
				sp = (short *)cp;
				*sp = m_pClientList[wObjectID]->m_sAppr4;
				cp += 2;
				ip = (int *)cp; // v1.4
				*ip = m_pClientList[wObjectID]->m_iApprColor;
				cp += 4;
				// New Colors -> ZeroEoyPnk
				ip = (int *)cp;
				*ip = m_pClientList[wObjectID]->m_iApprColor2;
				cp += 4;
				// Status
				ip = (int *)cp;
				iTemp = m_pClientList[wObjectID]->m_iStatus;
				iTemp = 0x0FFFFFFF & iTemp;
				iTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
				iTemp = (iTemp | (iTemp2 << 28));
				*ip = iTemp;
				cp += 4;

				if (m_pClientList[wObjectID]->m_iAdminUserLevel > 0 && m_pClientList[wObjectID]->m_iAdminUserLevel <= 9)
					*cp = (char)m_pClientList[wObjectID]->m_iAdminUserLevel;
				else *cp = 0;
				cp++; // 43

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 47); // v2.23 // v1.4 

				if (!bLize) SendCommand(iClientH, "/freecmd");

				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return 0;
				}
				return 0;
			}
			else return 0;
		}
		RefreshParty(iClientH, 3);

		//heaton prevent lammers quest and exp
		m_pClientList[iClientH]->m_iCheckCount = 0;

		if (getitemname(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY))
		{

			pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			if (pItem != NULL) {

				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {


					//_bItemLog(ITEMLOG_GET, iClientH, (int)-1, pItem);

					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

					SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_ITEMOBTAINED, pItem, NULL);
					if (iEraseReq == 1) delete pItem;
					if (m_pClientList[iClientH] == NULL) return 0;
				}
				else
				{

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);

					SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
					if (m_pClientList[iClientH] == NULL) return 0;
				}
			}
		}

		//HeatoN fast teleport
		int mapindex = -1;
		mapindex = iGetMapIndex(m_pClientList[iClientH]->m_cMapName);

		if (mapindex != -1)
		{
			for (int i = 0; i < DEF_MAXTELEPORTLOC; i++){
				if (BlockedTeleport(iClientH)) continue;
				if ((m_pMapList[mapindex]->m_pTeleportLoc[i] != NULL) && (m_pMapList[mapindex]->m_pTeleportLoc[i]->m_sSrcX == m_pClientList[iClientH]->m_sX) && (m_pMapList[mapindex]->m_pTeleportLoc[i]->m_sSrcY == m_pClientList[iClientH]->m_sY))
				{
					if (m_pClientList[iClientH] != NULL) RequestTeleportHandler(iClientH, "2   ");
					return 1;
				}
			}
		}
		return 1;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iClientMotion_Move_Handler");
	}
#endif
	return 0;
}

void CMapServer::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{

#ifdef DEF_DEBUG
	try {
#endif
		register int i, *ip, secure_login, anti_hackers;
		char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120], cCheckServer, cCheckRecive, cLog[100];
		BOOL bIsObserverMode;
		short resolution;
		resolution = C640x480;
		//resolution = C1024x768;

		cCheckServer = (char)0x49;
		cCheckRecive = (char)cKey;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

		if (cCheckRecive != cCheckServer) {
			wsprintf(cLog, "(X)Cliente Distinto al Original !!! IP(%s)", m_pClientList[iClientH]->m_cIPaddress);
			PutLogHacksFileList(cLog);
			DeleteClient(iClientH, TRUE, TRUE);
			m_iTotalClients--;
			return;
		}

		ZeroMemory(cCharName, sizeof(cCharName));
		ZeroMemory(cAccountName, sizeof(cAccountName));
		ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

		ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
		ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
		ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		ip = (int *)cp;
		secure_login = *ip;
		cp += 4;

		ip = (int *)cp;
		anti_hackers = *ip;
		cp += 4;

		if (secure_login != DEF_SECURITY_LOGIN) {
			DeleteClient(iClientH, FALSE, TRUE);
			return;
		}

		if (anti_hackers != DEF_ANTI_HACKERS) {
			DeleteClient(iClientH, FALSE, TRUE);
			return;
		}

		memcpy_secure(cCharName, cp, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy_secure(cTxt, cCharName, 10);
		m_Misc.bDecode(cKey, cTxt);
		ZeroMemory(cCharName, sizeof(cCharName));
		memcpy_secure(cCharName, cTxt, 10);

		if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

		memcpy_secure(cAccountName, cp, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy_secure(cTxt, cAccountName, 10);
		m_Misc.bDecode(cKey, cTxt);
		ZeroMemory(cAccountName, sizeof(cAccountName));
		memcpy_secure(cAccountName, cTxt, 10);

		memcpy_secure(cAccountPassword, cp, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
		memcpy_secure(cTxt, cAccountPassword, 10);
		m_Misc.bDecode(cKey, cTxt);
		ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
		memcpy_secure(cAccountPassword, cTxt, 10);

		bIsObserverMode = (BOOL)*cp;
		cp++;

		///aca en el medio el cliente le manda 
		
		Pop(cp, resolution);

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
				if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
					wsprintf(G_cTxt, "<%d>Puller1: CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
					CharacterLogList(G_cTxt);
					if (m_pClientList[i]->NoClear == TRUE) m_pClientList[i]->NoClear = FALSE;
					//agregado AntiPullaca
					if (m_pClientList[i]->NoDelete == TRUE) m_pClientList[i]->NoDelete = FALSE;

					m_pClientList[i]->m_bForceDisconnect = true;
					DeleteClient(i, TRUE, TRUE, FALSE);
				}
				else {
					memcpy_secure(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
					memcpy_secure(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
					memcpy_secure(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
					wsprintf(G_cTxt, "Player(%s) (%s)(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cAccountPassword);
					CharacterLogList(G_cTxt);

					m_pClientList[iClientH]->m_bForceDisconnect = true;
					DeleteClient(iClientH, FALSE, FALSE, FALSE);
					return;
				}
			}
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
				if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
					//wsprintf(G_cTxt, "<%d> Posible Puller - Inicia nuevamente : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
					wsprintf(G_cTxt, "<%d>Puller2: CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
					CharacterLogList(G_cTxt);
					if (m_pClientList[i]->NoClear == TRUE) m_pClientList[i]->NoClear = FALSE;
					//agregado AntiPull
					if (m_pClientList[i]->NoDelete == TRUE) m_pClientList[i]->NoDelete = FALSE;
					DeleteClient(i, TRUE, TRUE, FALSE);
				}
				else {
					memcpy_secure(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
					memcpy_secure(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
					memcpy_secure(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
					wsprintf(G_cTxt, "Player(%s) (%s)(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cAccountPassword);
					CharacterLogList(G_cTxt);
					DeleteClient(iClientH, FALSE, FALSE);
					return;
				}
			}
		}

		memcpy_secure(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
		memcpy_secure(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
		memcpy_secure(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

		m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
		m_pClientList[iClientH]->sResolution = resolution; //new addded 
		ApplyResolution(iClientH);
		//CharacterLogList((char*)to_string(resolution).c_str());

		bSendMsgToLS(NUCLEO_REQUEST_PLAYERDATA, iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestInitPlayerHandler");
	}
#endif
}

void CMapServer::RequestInitDataHandler(int iClientH, char * pData, char cKey, BOOL bIsNoNameCheck)
{

//#ifdef DEF_DEBUG
//	try {
//#endif
		char  * cp, cPlayerName[11], cTxt[120];
		int   i, *ip, iMapSide, iTmpMapSide;
		int  iEraseReq, secure_login, anti_hackers;
		class CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;

		if (bHappyHour) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HAPPYHOURSTAR, NULL, NULL, NULL, NULL);
		if (bHappyDay) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HAPPYDAYSTAR, NULL, NULL, NULL, NULL);
		if (DKEvent) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DKEVENT, NULL, NULL, NULL, NULL);
		if (Questx2) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2, NULL, NULL, NULL, NULL);
		if (Questx3) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3, NULL, NULL, NULL, NULL);

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->bPHackWPE == TRUE) {
			wsprintf(cTxt, "(X)Bump/RollBack Nombre del char (%s) ip(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress);
			PutLogHacksFileList(cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		if (bIsNoNameCheck == FALSE) {
			cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

			ip = (int *)cp;
			secure_login = *ip;
			cp += 4;

			ip = (int *)cp;
			anti_hackers = *ip;
			cp += 4;

			if (secure_login != DEF_SECURITY_LOGIN) {
				DeleteClient(iClientH, FALSE, TRUE);
				return;
			}
			if (anti_hackers != DEF_ANTI_HACKERS) {
				DeleteClient(iClientH, FALSE, TRUE);
				return;
			}

			ZeroMemory(cPlayerName, sizeof(cPlayerName));
			memcpy_secure(cPlayerName, cp, 10);

			ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
			memcpy_secure(cTxt, cPlayerName, 10);
			m_Misc.bDecode(cKey, cTxt);
			ZeroMemory(cPlayerName, sizeof(cPlayerName));
			memcpy_secure(cPlayerName, cTxt, 10);

			if ((memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0)) {
				wsprintf(cTxt, "Player(%s) (%s)(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cAccountPassword);
				CharacterLogList(cTxt);
				DeleteClient(iClientH, FALSE, TRUE);
				return;
			}
		}
		m_pClientList[iClientH]->bPHackWPE = TRUE;
		
		if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL && m_pClientList[iClientH]->m_iExp < m_iLevelExpTable[DEF_PLAYERMAXLEVEL])
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[DEF_PLAYERMAXLEVEL];

		iSetSide(iClientH);

		if (m_pClientList[iClientH]->m_iLevel == 1 && m_pClientList[iClientH]->m_iExp == 0 &&
			strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0 && m_pClientList[iClientH]->m_iSuperAttackLeft == 0) {

			m_pClientList[iClientH]->m_iSuperAttackLeft = 5000; //100
		//	m_pClientList[iClientH]->m_iSuperAttackLeft = 0; //100
		}

		//ZeroEoyPnk -> New Send Data player
		SendPlayerData(iClientH);
		SendRestPlayerData(iClientH);
		SendDllsBlocked(iClientH);
		SendProcessBlocked(iClientH);
		ChangeHeroSide(iClientH);

		//FinalFight Item Init
		if (m_pClientList[iClientH] == NULL) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && FinalFight) InitItemsClient(iClientH);
		else LoadPlayerItems(iClientH);
		//LoadPlayerItems(iClientH);

		//Real Crash
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		if (m_pClientList[iClientH] == NULL) return;

		//crash aca lalo ver
		if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == TRUE))
			SetNoHunterMode(iClientH);

		if ((DEF_ARESDEN == m_pClientList[iClientH]->m_cSide) &&
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			SetForceRecallTime(iClientH);
		}

		else if ((DEF_ELVINE == m_pClientList[iClientH]->m_cSide) &&
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

			SetForceRecallTime(iClientH);

		}
		else if ((DEF_NETURAL == m_pClientList[iClientH]->m_cSide) && (!m_pClientList[iClientH]->Assasain) &&
			(m_bIsCrusadeMode == TRUE) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0)
				|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0))
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}

		//Event Dk
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0) {
			RequestDismissPartyHandler(iClientH);
			DkMapUnEquipItems(iClientH);
		}

		//ALL EKS
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) {
			RequestDismissPartyHandler(iClientH);
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = 3;
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 3, iClientH, NULL);

		}

		//ALL DK EKS
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) {
			RequestDismissPartyHandler(iClientH);
			DkMapUnEquipItems(iClientH);
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = 3;
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 3, iClientH, NULL);

		}


		if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
		iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

		if (iMapSide >= 3) iTmpMapSide = iMapSide - 2;
		else iTmpMapSide = iMapSide;

		m_pClientList[iClientH]->m_bIsInBuilding = FALSE;
		if ((m_pClientList[iClientH]->m_cSide != iTmpMapSide) && (iMapSide != 0)) {

			if ((iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)
				&& (m_pClientList[iClientH]->m_cSide != DEF_NETURAL)) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInBuilding = TRUE;
			}
		}
		else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
			else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20 * 5) m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;  // 5��
		}
		else {
			m_pClientList[iClientH]->m_bIsWarLocation = FALSE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		}

		if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_bIsCrusadeMode == FALSE)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_RECALLTIMELEFT, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
			wsprintf(G_cTxt, "Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall / 20);
			PutLogList(G_cTxt);
		}

		_SendQuestContents(iClientH);
		_CheckQuestEnvironment(iClientH);

		if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
			CharacterLogList(G_cTxt);
		}

		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsGateAvailable == TRUE) {
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalDynamicGate; i++) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateX1,
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateY1, 0, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
			}
		}

		SendLasData(iClientH);
		SendEventOpenData(iClientH);

		if ((strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0) && (m_pClientList[iClientH]->m_cSide != EventCount[DEF_HOD].LastWin)){
		//if (((strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0) && (m_pClientList[iClientH]->m_cSide != EventCount[DEF_HOD].LastWin))
		//	|| ((strcmp(m_pClientList[iClientH]->m_cMapName, "areuni") == 0) && (m_pClientList[iClientH]->m_cSide != EventCount[DEF_RUSH].LastWin))) {
			if (m_pClientList[iClientH]->m_cSide == 1) RequestTeleportHandler(iClientH, "2   ", "gshop_1", -1, -1);
			else RequestTeleportHandler(iClientH, "2   ", "gshop_2", -1, -1);
		}
/*#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestInitDataHandler");
	}
#endif*/
}


int CMapServer::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
	int iSize = 0;
#ifdef DEF_DEBUG
	try {
#endif
		register int * ip, ix, iy, iTileExists;
		class CTile * pTileSrc, *pTile;
		unsigned char ucHeader;
		short * sp, *pTotal;
		int   iTemp, iTemp2;
		WORD  * wp;
		char  * cp;
		//DYNAMIC RESOLUTION
		int res_x = 0;
		int rex_y = 0;

		if (m_pClientList[iClientH] == NULL) return 0;

		pTotal = (short *)pData;
		cp = (char *)(pData + 2);

		iSize = 2;
		iTileExists = 0;
		pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX)+(sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
		res_x = m_pClientList[iClientH]->res_tilX;
		rex_y = m_pClientList[iClientH]->res_tilY;

		for (iy = 0; iy < rex_y; iy++) {
			for (ix = 0; ix < res_x; ix++) {

				if (((sX + ix) == 100) && ((sY + iy) == 100))
					sX = sX;

				pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

				if ((pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) ||
					(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL)) {
					iTileExists++;
					sp = (short *)cp;
					*sp = (short)ix;
					cp += 2;
					sp = (short *)cp;
					*sp = (short)iy;
					cp += 2;
					iSize += 4;

					ucHeader = 0;
					if (pTile->m_sOwner != NULL) {
						if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
							else {
								wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
								pTile->m_sOwner = NULL;
							}
						}

						if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
							if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
							else pTile->m_sOwner = NULL;
						}
					}
					if (pTile->m_sDeadOwner != NULL) {
						if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
							else pTile->m_sDeadOwner = NULL;
						}
						if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
							if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
							else pTile->m_sDeadOwner = NULL;
						}
					}
					if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
					if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
					//
					*cp = ucHeader;
					cp++;
					iSize++;

					if ((ucHeader & 0x01) != 0) {
						switch (pTile->m_cOwnerClass) {
							case DEF_OWNERTYPE_PLAYER:
								// Object ID number(Player) : 1~10000 //ver aca lalo bug
								sp = (short *)cp;
								*sp = pTile->m_sOwner;
								cp += 2;
								iSize += 2;
								// object type
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sOwner]->m_sType;
								cp += 2;
								iSize += 2;
								// dir
								*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
								cp++;
								iSize++;
								// Appearance1
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sOwner]->m_sAppr1;
								cp += 2;
								iSize += 2;
								// Appearance2
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;
								// Appearance3
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sOwner]->m_sAppr3;
								cp += 2;
								iSize += 2;
								// Appearance4
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sOwner]->m_sAppr4;
								cp += 2;
								iSize += 2;
								// v1.4 ApprColor
								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
								cp += 4;
								iSize += 4;
								// New Colors -> ZeroEoyPnk
								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor2;
								cp += 4;
								iSize += 4;

								// Status
								ip = (int *)cp;

								iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
								iTemp = 0x0FFFFFFF & iTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
								iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
								iTemp = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;
								// Name
								memcpy_secure(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
								cp += 10;
								iSize += 10;

								if (m_pClientList[pTile->m_sOwner]->m_iAdminUserLevel > 0 && m_pClientList[pTile->m_sOwner]->m_iAdminUserLevel <= 9)
									*cp = (char)m_pClientList[pTile->m_sOwner]->m_iAdminUserLevel;
								else {
									if (m_pClientList[pTile->m_sOwner]->OpenSell == TRUE) *cp = 99;
									else *cp = 0;
								}
								cp++;
								iSize++;
								break;

							case DEF_OWNERTYPE_NPC:
								// Object ID number(NPC) : 10000~
								sp = (short *)cp;
								*sp = pTile->m_sOwner + 10000;
								cp += 2;
								iSize += 2;
								// object type
								sp = (short *)cp;
								*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
								cp += 2;
								iSize += 2;
								// dir
								*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
								cp++;
								iSize++;
								// Appr2
								sp = (short *)cp;
								*sp = m_pNpcList[pTile->m_sOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;
								// Status
								ip = (int *)cp;

								iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
								iTemp = 0x0FFFFFFF & iTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
								iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
								iTemp = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;
								// Name
								memcpy_secure(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
								cp += 5;
								iSize += 5;
								break;
						}
					}

					if ((ucHeader & 0x02) != 0) {
						switch (pTile->m_cDeadOwnerClass) {
							case DEF_OWNERTYPE_PLAYER:
								// Object ID number : 1~10000
								sp = (short *)cp;
								*sp = pTile->m_sDeadOwner;
								cp += 2;
								iSize += 2;
								// object type
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
								cp += 2;
								iSize += 2;
								// dir
								*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
								cp++;
								iSize++;
								// Appearance1
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
								cp += 2;
								iSize += 2;
								// Appearance2
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;
								// Appearance3
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
								cp += 2;
								iSize += 2;
								// Appearance4
								sp = (short *)cp;
								*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
								cp += 2;
								iSize += 2;
								// v1.4 ApprColor
								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
								cp += 4;
								iSize += 4;

								// New Colors -> ZeroEoyPnk
								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor2;
								cp += 4;
								iSize += 4;

								// Status
								ip = (int *)cp;

								iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
								iTemp = 0x0FFFFFFF & iTemp;
								iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
								iTemp = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;
								// Name
								memcpy_secure(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
								cp += 10;
								iSize += 10;
								break;

							case DEF_OWNERTYPE_NPC:
								// Object ID number : 10000	~
								sp = (short *)cp;
								*sp = pTile->m_sDeadOwner + 10000;
								cp += 2;
								iSize += 2;
								// object type
								sp = (short *)cp;
								*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
								cp += 2;
								iSize += 2;
								// dir
								*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
								cp++;
								iSize++;
								// Appr2
								sp = (short *)cp;
								*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;
								// Status
								ip = (int *)cp;

								iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
								iTemp = 0x0FFFFFFF & iTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
								iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
								iTemp = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;
								// Name
								memcpy_secure(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
								cp += 5;
								iSize += 5;
								break;
						}
					}

					if (pTile->m_pItem[0] != NULL) {
						sp = (short *)cp;
						*sp = pTile->m_pItem[0]->m_sSprite;
						cp += 2;
						iSize += 2;

						sp = (short *)cp;
						*sp = pTile->m_pItem[0]->m_sSpriteFrame;
						cp += 2;
						iSize += 2;

						*cp = pTile->m_pItem[0]->m_cItemColor;
						cp++;
						iSize++;
					}

					if (pTile->m_sDynamicObjectType != NULL) {
						wp = (WORD *)cp;
						*wp = pTile->m_wDynamicObjectID;
						cp += 2;
						iSize += 2;

						sp = (short *)cp;
						*sp = pTile->m_sDynamicObjectType;
						cp += 2;
						iSize += 2;
					}
				}
			}
		}
		*pTotal = iTileExists;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iComposeInitMapData");
	}
#endif
	return iSize;
}


void CMapServer::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iExH;
		char * cp, cData[120], cTmpMap[30];
		DWORD * dwp;
		WORD * wp;

//		std::lock_guard<std::mutex> lck(mtx);

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->bPHackWPE == TRUE) m_pClientList[iClientH]->bPHackWPE = FALSE;

		if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0 && FinalFight) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
			RestoreItems(iClientH);
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "towerofh", 8) == 0) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
		}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "masacre", 7) == 0) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
		}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "MapaVip", 7) == 0) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
		}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "abaddon", 7) == 0) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
		}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "NewEvent", 8) == 0) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
		}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "FightMap", 8) == 0) {
			//agregado
			m_pClientList[iClientH]->NoDelete = FALSE;
		}

		//agregadas 1 lineas
		//if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) m_pClientList[iClientH]->NoDelete = FALSE;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE || m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->NoDelete = FALSE;

		//antipull
		if (m_pClientList[iClientH]->NoDelete)
		{
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 1)
			{
			m_pClientList[iClientH]->NoDelete = FALSE;
			}
			else
			{
			m_pClientList[iClientH]->TimeToDelete = timeGetTime() - 100;
			}
			// Activar esta linea para que funcione antipull		
			//m_pClientList[iClientH]->TimeToDelete = timeGetTime() - 100;

			// Desactivar esta linea para que funcione el antipull
			//	m_pClientList[iClientH]->NoDelete = FALSE;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) { // v1.4

			auto player = m_pClientList[iClientH];
			bool isSpecialMap = player->IsLimboMap();

			if (!player->m_bLimbo && !player->m_bForceDisconnect)
			{
				if (isSpecialMap)
				{
					EnableBot(iClientH);
					m_bAFKLimbo++;
				}
			}

			if (player->m_bLimbo && player->m_bForceDisconnect)
			{
				DisableBot(iClientH);
				m_bAFKLimbo--;
			}
			
			if (player->m_bLimbo) return;

			//if ((m_pClientList[iClientH]->NoClear == FALSE) /*&& (m_pClientList[iClientH]->NoDelete == FALSE)*/) {
			if ((m_pClientList[iClientH]->NoClear == FALSE) && (m_pClientList[iClientH]->NoDelete == FALSE)) {
				if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
					wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
					CharacterLogList(G_cTxt);
				}

				shinning_clear(iClientH);

				if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
					iExH = m_pClientList[iClientH]->m_iExchangeH;
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
				}

				if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL))
					m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

				if (bNotify == TRUE)
					SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

				RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

				for (i = 1; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex == iClientH)) {
						m_pClientList[i]->m_iWhisperPlayerIndex = -1;
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
					m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY);
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
			}
		}

		if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {
			if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
				m_pClientList[iClientH]->m_sX = -1;
				m_pClientList[iClientH]->m_sY = -1;

				strcpy_secure(cTmpMap, m_pClientList[iClientH]->m_cMapName);
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));

				if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
					if (!m_pClientList[iClientH]->Assasain) strcpy_secure(m_pClientList[iClientH]->m_cMapName, "default");
					else strcpy_secure(m_pClientList[iClientH]->m_cMapName, "Whouse");
				}
				else {
					if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) {
						if (m_bIsCrusadeMode == TRUE) {
							if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
								ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
								strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
								m_pClientList[iClientH]->m_iLockedMapTime = 15 * 1;
								m_pClientList[iClientH]->m_iDeadPenaltyTime = 15 * 1; // v2.04 10 mins
							}
							else m_pClientList[iClientH]->m_iDeadPenaltyTime = 15 * 1; // v2.04 10 minss
						}
						if (strcmp(cTmpMap, "elvine") == 0) {
							strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
							m_pClientList[iClientH]->m_iLockedMapTime = 15 * 1; // 3 mins
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
						}
						else if (m_pClientList[iClientH]->m_iLevel > 80) memcpy_secure(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
						else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
					}
					else {
						if (m_bIsCrusadeMode == TRUE) {
							if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
								ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
								strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
								m_pClientList[iClientH]->m_iLockedMapTime = 15 * 1;
								m_pClientList[iClientH]->m_iDeadPenaltyTime = 15 * 1; // v2.04 10 mins.30*1
							}
							else m_pClientList[iClientH]->m_iDeadPenaltyTime = 15 * 1; // v2.04 10 mins.
						}

						if (strcmp(cTmpMap, "aresden") == 0) {
							strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
							m_pClientList[iClientH]->m_iLockedMapTime = 15 * 1; // 3 mins
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
						}
						else if (m_pClientList[iClientH]->m_iLevel > 80) memcpy_secure(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
						else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
					}
				}
			}
			else if (bForceCloseConn == TRUE) {
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy_secure(m_pClientList[iClientH]->m_cMapName, "ArGEvent", 8);
				m_pClientList[iClientH]->m_sX = -1;
				m_pClientList[iClientH]->m_sY = -1;

				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "ArGEvent");
				m_pClientList[iClientH]->m_iLockedMapTime = 60 * 60;
			}

			if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				if (m_pClientList[iClientH]->m_cSide == 0) {
					switch (iDice(1, 2)) {
						case 1: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "aresden", 7); break;
						case 2: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvine", 6); break;
					}
				}
				else {
					if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) memcpy_secure(m_pClientList[iClientH]->m_cMapName, "aresden", 10);
					else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvine", 10);
				}
				m_pClientList[iClientH]->m_sX = -1;
				m_pClientList[iClientH]->m_sY = -1;
			}

			if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				if (m_pClientList[iClientH]->m_cSide == 0) {
					switch (iDice(1, 2)) {
						case 1: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "aresden", 7); break;
						case 2: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvine", 6); break;
					}
				}
				else {
					if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN)
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "aresden", 10);
					else
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvine", 10);
				}
				m_pClientList[iClientH]->m_sX = -1;
				m_pClientList[iClientH]->m_sY = -1;
			}

			if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLVSALL, 8) == 0 ||
				memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0 ||
				memcmp(m_pClientList[iClientH]->m_cMapName, "abaddon", 7) == 0 ||
				memcmp(m_pClientList[iClientH]->m_cMapName, "MapaVip", 7) == 0 ||
				memcmp(m_pClientList[iClientH]->m_cMapName, "towerofh", 8) == 0) {
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "aresden", 7); break;
					case 2: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvine", 6); break;
					default: memcpy_secure(m_pClientList[iClientH]->m_cMapName, "Whouse", 6); break;
				}
				m_pClientList[iClientH]->m_sX = -1;
				m_pClientList[iClientH]->m_sY = -1;
			}
			//OLD
			/*if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
				if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDismissPartyHandler(iClientH);
				if (bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
			}
			else bSendMsgToLS(NUCLEO_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {
				if (m_pClientList[iClientH]->m_iPartyID != NULL)  RequestDismissPartyHandler(iClientH);
				bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
			}
			else {
				m_pClientList[iClientH]->NoDelete = FALSE;
				if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDismissPartyHandler(iClientH);
				bSendMsgToLS(NUCLEO_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE);
			}
		}*/

			//NEW
			if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
				if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDismissPartyHandler(iClientH);
				//if (bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
				bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
				LocalSavePlayerData(iClientH);
			}
			else bSendMsgToLS(NUCLEO_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {
				if (m_pClientList[iClientH]->m_iPartyID != NULL)  RequestDismissPartyHandler(iClientH);
				/*	bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);*/
				bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout);
				LocalSavePlayerData(iClientH);
			}
			else {
				m_pClientList[iClientH]->NoDelete = FALSE;
				if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDismissPartyHandler(iClientH);
				bSendMsgToLS(NUCLEO_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE);
			}
		}

		if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDismissPartyHandler(iClientH);

		//50Cent - Capture The Flag
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE && bCheckIfIsFlagCarrier(iClientH)) {
			SetFlagCarrierFlag(iClientH, false);
			SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		};

		//if (m_pClientList[iClientH]->NoClear == FALSE /*&& m_pClientList[iClientH]->NoDelete == FALSE*/) {
		if (m_pClientList[iClientH]->NoClear == FALSE && m_pClientList[iClientH]->NoDelete == FALSE) {
			wsprintf(G_cTxt, "<%d> Disconnect: %s - IP: %s", iClientH, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress);
			CharacterLogList(G_cTxt);

			mtx.lock();
			bCheckClient[iClientH] = FALSE;
			m_iTotalClients--;
			delete m_pClientList[iClientH];
			m_pClientList[iClientH] = NULL;
			RemoveClientShortCut(iClientH);
			mtx.unlock();
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DeleteClient");
	}
#endif
}

int CMapServer::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
	int iSize = 0;
#ifdef DEF_DEBUG
	try {
#endif
		register int * ip, ix, iy, iTileExists, iIndex;
		class CTile * pTileSrc, *pTile;
		unsigned char ucHeader;
		short * sp, *pTotal;
		int   iTemp, iTemp2;
		WORD  * wp;
		char  * cp;

		if (m_pClientList[iClientH] == NULL) return 0;

		pTotal = (short *)pData;
		cp = (char *)(pData + 2);

		iSize = 2;
		iTileExists = 0;
		pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile +
			(sX)+(sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		iIndex = 0;
		while (1) {

			if (m_pClientList[iClientH]->sResolution == C800x600)
			{
				ix = _tmp_cMoveLocX[cDir][iIndex];
				iy = _tmp_cMoveLocY[cDir][iIndex];
			}
			else if (m_pClientList[iClientH]->sResolution == C640x480)
			{
				ix = _tmp_iMoveLocX[cDir][iIndex]; //original
				iy = _tmp_iMoveLocY[cDir][iIndex];
			}
			else if (m_pClientList[iClientH]->sResolution == C1024x768)
			{
				ix = _tmp_1024_iMoveLocX[cDir][iIndex]; //original
				iy = _tmp_1024_iMoveLocY[cDir][iIndex];
			}
			if ((ix == -1) || (iy == -1)) break;
			iIndex++;

			pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

			if ((pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) ||
				(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL)) {
				iTileExists++;

				sp = (short *)cp;
				*sp = ix;
				cp += 2;
				sp = (short *)cp;
				*sp = iy;
				cp += 2;
				iSize += 4;

				ucHeader = 0;
				if (pTile->m_sOwner != NULL) {
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = NULL;
					}
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = NULL;
					}
				}
				if (pTile->m_sDeadOwner != NULL) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = NULL;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = NULL;
					}
				}
				if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
				if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
				//
				*cp = ucHeader;
				cp++;
				iSize++;

				if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
							// Object ID number(Player) : 1~10000
							sp = (short *)cp;
							*sp = pTile->m_sOwner;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;
							// Appearance1
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;
							// Appearance2
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Appearance3
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;
							// Appearance4
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;
							// v1.4 
							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							// New Colors -> ZeroEoyPnk
							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor2;
							cp += 4;
							iSize += 4;

							// Status
							ip = (int *)cp;

							if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide) {
								if (iClientH != pTile->m_sOwner)
									iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
								else iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
							}
							else iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;

							ip = (int *)cp;

							iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp; // ���� 4��Ʈ Ŭ����y
							iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
							iTemp = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;
							// Name
							memcpy_secure(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
							cp += 10;
							iSize += 10;

							if (m_pClientList[pTile->m_sOwner]->m_iAdminUserLevel > 0 && m_pClientList[pTile->m_sOwner]->m_iAdminUserLevel <= 9)
								*cp = (char)m_pClientList[pTile->m_sOwner]->m_iAdminUserLevel;
							else {
								if (m_pClientList[pTile->m_sOwner]->OpenSell == TRUE) *cp = 99;
								else *cp = 0;
							}
							cp++;
							iSize++;
							break;

						case DEF_OWNERTYPE_NPC:
							// Object ID number(NPC) : 10000	~
							sp = (short *)cp;
							*sp = pTile->m_sOwner + 10000;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *)cp;
							*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;
							// Appearance2
							sp = (short *)cp;
							*sp = m_pNpcList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Status
							ip = (int *)cp;

							iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp; // ���� 4��Ʈ Ŭ����
							iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
							iTemp = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;
							// Name
							memcpy_secure(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
							cp += 5;
							iSize += 5;
							break;
					}
				}

				if ((ucHeader & 0x02) != 0) {
					switch (pTile->m_cDeadOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
							// Object ID number(Player) : 1~10000
							sp = (short *)cp;
							*sp = pTile->m_sDeadOwner;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;
							// Appearance1
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;
							// Appearance2
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Appearance3
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;
							// Appearance4
							sp = (short *)cp;
							*sp = m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;
							// v1.4 ApprColor
							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							// New Colors -> ZeroEoyPnk
							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor2;
							cp += 4;
							iSize += 4;

							// Status
							ip = (int *)cp;

							if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide) {
								if (iClientH != pTile->m_sOwner) iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
								else iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							}
							else iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;

							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
							iTemp = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy_secure(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
							cp += 10;
							iSize += 10;
							break;

						case DEF_OWNERTYPE_NPC:
							// Object ID number(NPC) : 10000~
							sp = (short *)cp;
							*sp = pTile->m_sDeadOwner + 10000;
							cp += 2;
							iSize += 2;
							// object type
							sp = (short *)cp;
							*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;
							// dir
							*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;
							// Appearance2
							sp = (short *)cp;
							*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;
							// Status
							ip = (int *)cp;

							iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp; // ���� 4��Ʈ Ŭ����
							iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
							iTemp = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;
							// Name
							memcpy_secure(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
							cp += 5;
							iSize += 5;
							break;
					}
				}

				if (pTile->m_pItem[0]) {
					sp = (short *)cp;
					*sp = pTile->m_pItem[0]->m_sSprite;
					cp += 2;
					iSize += 2;

					sp = (short *)cp;
					*sp = pTile->m_pItem[0]->m_sSpriteFrame;
					cp += 2;
					iSize += 2;

					*cp = pTile->m_pItem[0]->m_cItemColor;
					cp++;
					iSize++;
				}

				if (pTile->m_sDynamicObjectType != NULL) {
					wp = (WORD *)cp;
					*wp = pTile->m_wDynamicObjectID;
					cp += 2;
					iSize += 2;

					sp = (short *)cp;
					*sp = pTile->m_sDynamicObjectType;
					cp += 2;
					iSize += 2;
				}
			}
		}

		*pTotal = iTileExists;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iComposeMoveMapData");
	}
#endif
	return iSize;
}

void CMapServer::OnTimer(char cType)
{
	DWORD dwTime;
	int iRet = 0;

	dwTime = timeGetTime();

	GameProcess();

	if ((dwTime - m_dwFakeTime) > 300) {
		NpcProcess();
		ClientFakeMoveTimmer();
		m_dwFakeTime = dwTime;
	}

	if ((dwTime - m_dwNewTime) > 1) {
		//NpcProcess();
		MobGenerator();
		m_dwNewTime = dwTime;
	}

	if ((dwTime - m_dwGameTime2) > 3000) {
		CheckClientResponseTime();
		InvalidateRect(G_hWnd, NULL, TRUE);
		m_dwGameTime2 = dwTime;
		if (m_bIsRushNetMode) SendHpReliquia();
		if (HellOfDeath) ActualizarStructures();

		if ((m_bIsGameStarted == FALSE) &&
			(m_bIsLogSockAvailable == TRUE) && (m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)) {
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_bIsGameStarted = TRUE;
		}
	}

	if (m_bIsGameStarted)
	{
		if ((dwTime - m_dwGameTime9) > 2 _s) 
		{
			send_objects_data();
			m_dwGameTime9 = dwTime;
		}

		if ((dwTime - m_dwAutoSaveTime) > 30 _s)
		{
			SaveAllCharacters();
			m_dwAutoSaveTime = dwTime;
		}
	}

	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();

	/*	if (Actualizar == TRUE) {
			wsprintf(G_cTxt, "Max Player Connect : %d", m_iMaxClients);
			UpdateConfigList(G_cTxt);

			wsprintf(G_cTxt, "Total Player Connect : %d", m_iTotalClients);
			UpdateConfigList(G_cTxt);

			wsprintf(G_cTxt, "Users Added : %d", m_iAddUser);
			UpdateConfigList(G_cTxt);

			/ *wsprintf(G_cTxt, "Users Afk : %d", m_iAFKUsers); //agregadov11
			UpdateConfigList(G_cTxt);* /

		//	wsprintf(G_cTxt, "Total Visible Users : %d", m_iTotalGameServerClients + m_iAddUser + m_iAFKUsers);			
			wsprintf(G_cTxt, "Total Visible Users : %d", m_iTotalGameServerClients + m_iAddUser);
			UpdateConfigList(G_cTxt);
		}*/

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
				return;
			}
		}
		m_dwGameTime6 = dwTime;
	}

	for (short i = 0; i < 10; i++) {
		if (SummonBalls[i].ActiveSummon) {
			if (dwTime - SummonBalls[i].dwOpenSummonMap > 10800000) {
				SummonBalls[i].dwOpenSummonMap = -1;
				SummonBalls[i].ActiveSummon = false;
				ZeroMemory(SummonBalls[i].GuildName, sizeof(SummonBalls[i].GuildName));
			}
		}
	}

	if (g_ev.Is(EventID::Deathmatch) && c_dm != NULL) {
		if (dwTime - dw_DmTime > 1 _h) g_ev.Deactivate(EventID::Deathmatch);
	}


	//New Command Portal - ZeroEoyPnk
	if (ActiveEvent == TRUE) {
		if ((AllVsAll == TRUE) && (AllVsAllPortals == TRUE)) {
			if (dwTime - dwTimeTP > 300000) {
				PutLogList("Evento Comenzando");
				IniciarAllVsAll();
			}
		}

		if (m_bIsCrusadeMode == TRUE) {
			//if (dwTime - dw_CrusadeTime > 14400000)
			if (dwTime - dw_CrusadeTime > 7200000)
				ManualEndCrusadeMode(0);
		}

		if (TowerDefense == TRUE) {
			//if (dwTime - dw_TowerTime > 14400000)
			if (dwTime - dw_TowerTime > 3600000)
				EndTowerDefenceMode(0);
		}

		if (m_bIsRushNetMode == TRUE) {
		//	if (dwTime - dw_RushTime > 14400000)
			if (dwTime - dw_RushTime > 7200000)
				LocalEndRushNetMode(0);
		}

		if (m_bIsCTFMode == TRUE) {
			//if (dwTime - dw_CaptureTime > 10800000)
			if (dwTime - dw_CaptureTime > 7200000)//2hs
				EndCaptureTheFlag(0);
		}

		if (CityVsCity == TRUE) {
			if (dwTime - cvcEventTime > 3600000)//1800000 = 30min
				EndCityVsCity();
		}

		if (PriceEvent == TRUE) {
			if (dwTime - PriceTime > 1800000) // 900000)
				CloseEventMap();
		}

		//WorldWar - LaloRamos
		if (WorldWar == TRUE) {
			if (dwTime - WorldWarTime > 1800000)
				EndWorldWar();
		}

		if (WWPriceEvent == TRUE) {
			if (dwTime - WWPriceTime > 900000)
				CloseWWEventMap();
		}

		//WorldWar II - LaloRamos
		if (WorldWarII == TRUE) {
			if (dwTime - WorldWarTimeII > 1800000)
				EndWorldWarII();
		}

		if (WWIIPriceEvent == TRUE) {
			if (dwTime - WWIIPriceTime > 900000)
				CloseWWEventMapII();
		}

		if (m_bIsApocalypseMode == TRUE && dw_abaddon_nospawn != -1) {
			if (dwTime - dw_abaddon_nospawn > 9000000) {
				m_bIsApocalypseMode = FALSE;
				dw_abaddon_nospawn = -1;
			}
		}

		if (HellOfDeath == TRUE) {
			//if (dwTime - dw_HODTime > 1800000)
			if (dwTime - dw_HODTime > 3600000)
				EndHellOfDeathMode(0);
		}

		if (PriceHODEvent == TRUE) {
		//	if (dwTime - dw_PriceHODTime > 900000)
			if (dwTime - dw_PriceHODTime > 1800000)
				CloseHODMap();
		}

		if (AllEks == TRUE) {
			if (dwTime - AllEksTime > 3600000)//1800000 = 30min
				EndAllEks();
		}

		if (AllDkEks == TRUE) {
			if (dwTime - AllDkEksTime > 1800000)//1800000 = 30min
				EndAllDkEks();
		}

	}
	else {
		for (int portal = 0; portal <= DEF_MAXPORTALS; portal++) {
			if (PortalAbility[portal] == TRUE) {
				if (dwTime - dw_TimePortal[portal] > dw_TimeOpenPortal[portal])
					ClosePortal(portal);
			}
		}
	}

	if (RunSummonEvent == TRUE) {
		if (AresdenSummon != -1) {
			if ((dwTime - AresdenSummon) > 9500)
				SummonAresden();
		}
	}
	else {
		if (SummonLaunched == TRUE) {
			if ((PortalAbility[5]) && (PortalAbility[6])) {
				if (dwTime - dw_TimePortal[5] > dw_TimeOpenPortal[5])
					ClosePortal(5);
				if (dwTime - dw_TimePortal[6] > dw_TimeOpenPortal[6])
					ClosePortal(6);
			}
		}
	}

	if (RunSummonEvent2 == TRUE) {
		if (ElvineSummon != -1) {
			if ((dwTime - ElvineSummon) > 9500)
				SummonElvine();
		}
	}
	else {
		if (SummonLaunched == TRUE) {
			if ((PortalAbility[7]) && (PortalAbility[8])) {
				if (dwTime - dw_TimePortal[7] > dw_TimeOpenPortal[7])
					ClosePortal(7);
				if (dwTime - dw_TimePortal[8] > dw_TimeOpenPortal[8])
					ClosePortal(8);
			}
		}
	}

	if (RunSummonEvent3 == TRUE) {
		if (AssasainSummon != -1) {
			if ((dwTime - AssasainSummon) > 9500)
				SummonAssasain();
		}
	}
	else {
		if (SummonLaunched == TRUE) {
			if ((PortalAbility[3]) && (PortalAbility[4])) {
				if (dwTime - dw_TimePortal[3] > dw_TimeOpenPortal[3])
					ClosePortal(3);
				if (dwTime - dw_TimePortal[4] > dw_TimeOpenPortal[4])
					ClosePortal(4);
			}
		}
	}

	if (SummonEventTime != -1) {
		if ((dwTime - SummonEventTime) > 3600000)
			EndSummonEvent();
	}

	if ((dwTime - m_dwGameTime3) > 3000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		SpecialEventHandler();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwMinute) > 1000 * 50) {
		CheckDayOrNightMode();
		//EventosAutomaticos();

		if (EventAuto == TRUE)
		{
			EventosAutomaticos();
		}
		SYSTEMTIME SysTime;
		GetLocalTime(&SysTime);
		AutoClearMap();
		m_dwMinute = dwTime;

		if (TotalAnnoucement <= 10 && FinalFight) {
			TotalAnnoucement++;
			for (int z = 1; z < DEF_MAXCLIENTS; z++) {
				if ((m_pClientList[z] != NULL) && (m_pClientList[z]->m_bIsInitComplete) && (memcmp(m_pClientList[z]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0))
					SendNotifyMsg(NULL, z, CLIENT_NOTIFY_ARENAPVPEVENT_INIT, NULL, NULL, NULL, NULL, NULL);
			}
		}
	}

	if ((dwTime - m_dwGameTime4) > 600) {
		//MobGenerator();

		if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
			m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
			m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

			wsprintf(G_cTxt, "Conectando ... (%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
			PutLogList(G_cTxt);

			m_iSubLogSockInitIndex++;
		}
		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwFishTime) > 4000) {
		//FishProcessor();
		//FishGenerator();
		SendCollectedMana();
		ActualizarContador();
		ActualizarWWContador();
		ActualizarWWIIContador();
		m_dwFishTime = dwTime;
	}

	if ((m_bAnunciosActivo == TRUE) && (dwTime >= m_dwAnuncios)) {
		Anuncios();
		m_dwAnuncios = timeGetTime() + 1000 * 10 * 60;
	}

	if ((dwTime - m_dwWhetherTime) > 1000 * 20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;

		int i, iAres = 0, iElv = 0, itra = 0, iAss = 0;
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (!m_pClientList[i]->NoClear)) iAres++;
				else if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (!m_pClientList[i]->NoClear)) iElv++;
				else if ((memcmp(m_pClientList[i]->m_cLocation, "NONE", 4) == 0) && (!m_pClientList[i]->Assasain) && (!m_pClientList[i]->NoClear))  itra++;
				else if (m_pClientList[i]->Assasain) iAss++;
			}
		}
		m_iTotalGameServerClients = iAres + iElv + itra + iAss;

		wsprintf(G_cTxt, "Users Online: %d", m_iTotalGameServerClients + m_iAddUser + m_iAFKUsers);//FakeLalo
		PutLogOnlinesFileList(G_cTxt);
	}

	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		Borrado();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((dwTime - m_dwCheckProcess) > 1000 * 60 * 20) {// 20 mins
		CheckProcessClients();
		for (int a = 0; a < DEF_MAXMAPS; a++) {
			if (m_pMapList[a] != NULL) {
				RemoveOccupyFlags(a);
				m_pMapList[a]->BorrarFlag();
			}
		}
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000 * 2)) {
		if (_iForcePlayerDisconect() == 0) {
			PutLogList("GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogList("(!!!) AUTO-SERVER-REBOOTING!");

				bInit();
				m_iAutoRebootingCount++;
			}
			else if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20; //20
		}
		m_dwExitProcessTime = dwTime;
	}

	if ((dwTime - m_dwMapSectorInfoTime) > 1000 * 10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();
		MineralGenerator();
		ArmarEventTop();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CMapServer::CheckClientResponseTime()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iPlusTime, iMaxSuperAttack, iValue;
		short sTemp, sItemIndex;
		DWORD dwTime;
		int a;



		dwTime = timeGetTime();
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				// AntiPull 
				if ((m_pClientList[i]->NoDelete) && (m_pClientList[i]->TimeToDelete != -1))
				{
					m_pClientList[i]->m_dwTime = dwTime;
					if ((dwTime - m_pClientList[i]->TimeToDelete > 10000) || m_pClientList[i]->m_bIsKilled)
					{
						m_pClientList[i]->NoDelete = FALSE;

						m_pClientList[i]->m_bForceDisconnect = true;
						DeleteClient(i, TRUE, TRUE);
						return;
					}
				}

				if (m_pClientList[i]->NoClear) m_pClientList[i]->m_dwTime = dwTime;

				if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					if (m_pClientList[i]->m_bIsInitComplete != TRUE) {
						if (m_pClientList[i]->NoClear == FALSE) {
							mtx.lock();
							bCheckClient[i] = FALSE;
							wsprintf(G_cTxt, "<%d> Disconnect: %s - IP: %s", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
							CharacterLogList(G_cTxt);

							delete m_pClientList[i];
							m_pClientList[i] = NULL;
							m_iTotalClients--;
							RemoveClientShortCut(i);
							mtx.unlock();
							//DeleteClient(i, FALSE, FALSE);
						}
					}
				}
				else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
					if (m_pClientList[i]->m_bManaMe == TRUE) {
						if (dwTime - m_pClientList[i]->m_dwManaMe > MANA_ME_DURATION * 1000) {
							m_pClientList[i]->m_bManaMe = FALSE;
							m_pClientList[i]->m_dwManaMe = NULL;
							SetSlateFlag(i, CLIENT_NOTIFY_SLATECLEAR, FALSE);
						}
					}

					//heaton prevent lammers quest and exp
					handleCheckTimer(i);

					if (m_pClientList[i]->m_sRebirthEnabled == 1 &&
						m_pClientList[i]->m_sRebirthStatus == 1 &&
						m_pClientList[i]->m_iLevel == m_iPlayerMaxLevel)
					{
						disableRebirthStatus(i);
						disableRebirth(i);

						m_pClientList[i]->m_iLU_Pool = m_pClientList[i]->m_iLU_Pool + 3;
						//SendCommand(i, "/statspoints", m_pClientList[i]->m_iLU_Pool);

						SendAlertMsg(i, "Congratulations Rebirth completed!");
					}

					if (m_pClientList[i]->requestrevive && m_pClientList[i]->IsInMap("dm"))	SendCommand(i, "/revive");

					if (m_pClientList[i]->IsInMap("dm") && !g_ev.Is(EventID::Deathmatch) || m_pClientList[i]->IsInMap("dm") && !c_dm->is_fighter(m_pClientList[i]->m_cCharName))
					{
						if (m_pClientList[i]->IsLocation("aresden"))
						{
							RequestTeleportHandler(i, "2   ", "aresden", -1, -1);													
						}
						else
						{
							RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
						}
					}

					if ((m_pClientList[i]->KilledClientAFK != -1) && (dwTime - m_pClientList[i]->KilledClientAFK > 1000 * 60)) {
						if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresden") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvine") == 0)) {
							if (m_pMapList[m_pClientList[i]->m_cMapIndex]->iGetAttribute(m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 0x00000006) != 0) {
								if (m_pClientList[i]->m_bIsKilled == FALSE)
									ClientKilledHandler(i, NULL, NULL, m_pClientList[i]->m_iHP);
							}
						}
						if (m_pClientList[i] != NULL) m_pClientList[i]->KilledClientAFK = -1;
					}

					if ((m_pClientList[i]->TimeFlagCarrier != -1) && (dwTime - m_pClientList[i]->TimeFlagCarrier > 1000 * 600)) {
						ClientKilledHandler(i, NULL, NULL, m_pClientList[i]->m_iHP);
						if (m_pClientList[i] != NULL) m_pClientList[i]->TimeFlagCarrier = -1;
					}

					if ((m_pClientList[i]->ActiveAvA != -1) && (dwTime - m_pClientList[i]->ActiveAvA > 5000 * 60)) {
						if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0) {
							if (m_pClientList[i]->m_iAdminUserLevel == 0) {
								if (m_pClientList[i]->m_bIsKilled == FALSE)
									//allvsall Lalo fix
									ClientKilledHandler(i, NULL, NULL, m_pClientList[i]->m_iHP);
							if (m_pClientList[i] != NULL) m_pClientList[i]->ActiveAvA = -1;
							}
						else if (m_pClientList[i] != NULL) m_pClientList[i]->ActiveAvA = -1;
						}
					}

					if (m_pClientList[i] == NULL) return;

					m_pClientList[i]->m_iTimeLeft_ShutUp--;
					if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;

					m_pClientList[i]->m_iTimeLeft_Rating--;
					if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;

					if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
						if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 || m_pClientList[i]->NoClear == TRUE)) {}
						else m_pClientList[i]->m_iHungerStatus--;

						if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
						m_pClientList[i]->m_dwHungerTime = dwTime;

						if ((m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30))
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}

					if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0))
						iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus) * 1000;
					else iPlusTime = 0;

					iPlusTime = abs(iPlusTime);

					// HP
					if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
						TimeHitPointsUp(i);
						m_pClientList[i]->m_dwHPTime = dwTime;
					}

					// MP
					if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
						TimeManaPointsUp(i);
						m_pClientList[i]->m_dwMPTime = dwTime;
					}

					// SP
					if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
						TimeStaminarPointsUp(i);
						m_pClientList[i]->m_dwSPTime = dwTime;
					}

					if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
						PoisonEffect(i, NULL);
						m_pClientList[i]->m_dwPoisonTime = dwTime;
					}

					if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
						m_pClientList[i]->m_dwExpStockTime = dwTime;
						CalcExpStock(i);
						CheckUniqueItemEquipment(i);
						CheckItemStatedEquipment(i);
						CheckCrusadeResultCalculation(i);
					}
					//lalonull
					if (m_pClientList[i] == NULL) return;
					if (m_pClientList[i]->TimeCoord != NULL) {
						if ((dwTime - m_pClientList[i]->TimeCoord) > 6000) {
							m_pClientList[i]->RecallCoordX = -1;
							m_pClientList[i]->RecallCoordY = -1;
							m_pClientList[i]->TimeCoord = NULL;
						}
					}

					//No recall por 10 segundos - ZeroEoyPnk
					if (m_pClientList[i]->m_bRecall == FALSE) {
						if (dwTime - m_pClientList[i]->RecallTime > 10000)
							m_pClientList[i]->m_bRecall = TRUE;
					}

					//Auto Save ZeroEoyPnk
					//lalonull
					if (m_pClientList[i] == NULL) return;
				/*	if ((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > DEF_AUTOSAVETIME) {
						if (m_pClientList[i]->b_AutoSaveTime == TRUE) {
							if ((memcmp(m_pClientList[i]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight) 
								//bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, i);
								LocalSavePlayerData(i);
						}

						m_pClientList[i]->b_AutoSaveTime = TRUE;
						m_pClientList[i]->m_dwAutoSaveTime = dwTime;
					}*/

					if ((dwTime - m_pClientList[i]->LastTime) >= 60000) { // 1 minuto 
						m_pClientList[i]->LastTime = dwTime;
						m_pClientList[i]->MinPlaying++;
						if (m_pClientList[i]->MinPlaying > 59) {
							m_pClientList[i]->MinPlaying = 0;
							m_pClientList[i]->HourPlaying++;
						}

						if (HellOfDeath || CityVsCity) {
							if (m_pClientList[i]->RndEventID == RandomEventID)
								m_pClientList[i]->EventMinPlaying++;
						}
					}

					/*if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
						iValue = (m_pClientList[i]->m_iLevel * 20); // More exp afk
						if (iValue <= 0) iValue = 1;
						if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
							if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel + 1]) {
								GetExp(i, iValue);
								CalcExpStock(i);
							}
						}
						m_pClientList[i]->m_iAutoExpAmount = 0;
						m_pClientList[i]->m_dwAutoExpTime = dwTime;
					}*/

		/*			//lalonull
					if (m_pClientList[i] == NULL) return;
					if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
						sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
						if (sItemIndex != -1) {
							//Crash Aca Laloramos
							if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
								if ((m_pClientList[i]->m_iInt + m_pClientList[i]->m_iAngelicInt) > 99 && (m_pClientList[i]->m_iMag + m_pClientList[i]->m_iAngelicMag) > 99) {
									m_pClientList[i]->m_cMagicMastery[94] = FALSE; // TRUE;
									SendNotifyMsg(NULL, i, CLIENT_NOTIFY_STATECHANGE_SUCCESS, 1, NULL, NULL, NULL);
								}
							}
						}
					}*/
					if (m_pClientList[i] == NULL) return;
					m_pClientList[i]->m_iSpecialAbilityTime -= 3;
					if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;

					if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
						if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime) / 1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
							m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
							m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
							sTemp = m_pClientList[i]->m_sAppr4;
							sTemp = sTemp & 0xFF0F;
							m_pClientList[i]->m_sAppr4 = sTemp;
							SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						}
					}

					m_pClientList[i]->m_iLockedMapTime -= 3;
					if (m_pClientList[i]->m_iLockedMapTime < 0) {
						m_pClientList[i]->m_iLockedMapTime = 0;
						ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
						strcpy_secure(m_pClientList[i]->m_cLockedMapName, "NONE");
					}

					m_pClientList[i]->m_iDeadPenaltyTime -= 3;
					if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

					if (m_pClientList[i] == NULL) break;
					if (m_pClientList[i]->m_b5MinutosFinales == TRUE) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

						if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
							m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
							m_pClientList[i]->m_b5MinutosFinales = FALSE;

							if ((memcmp(m_pClientList[i]->m_cMapName, DEF_EVENTMAP_TOWERDEFENSE, 8) == 0) ||
								(memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0)) {

								m_pClientList[i]->m_iTimeLeft_ForceRecall = 60;
								SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
								RequestTeleportHandler(i, "1   ");
							}
						}
					}

					if (m_pClientList[i] == NULL) break;
					if ((m_pClientList[i]->m_bIsWarLocation == TRUE)) {
						if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[i]->m_bIsInBuilding == TRUE))
							m_pClientList[i]->m_iTimeLeft_ForceRecall--;

						if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
							m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
							m_pClientList[i]->m_dwWarBeginTime = dwTime;
							m_pClientList[i]->m_bIsWarLocation = FALSE;
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
							RequestTeleportHandler(i, "0   ");
						}
					}

					if (m_pClientList[i] == NULL) break;
					if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) DeleteClient(i, TRUE, TRUE);
					else m_pClientList[i]->m_iSkillMsgRecvCount = 0;

					if (m_pClientList[i] == NULL) break;
					if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "0   ");
					}

					if (m_pClientList[i] == NULL) break;
					if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
						(m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "0   ");
					}

					if (m_pClientList[i] == NULL) break;
					if ((m_bIsCrusadeMode == FALSE)
						&& (m_pClientList[i]->m_bIsHunter == TRUE)
						&& (((m_iMiddlelandMapIndex == m_pClientList[i]->m_cMapIndex) && (m_iMiddlelandMapIndex != -1))
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresdend1", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvined1", 8) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone3", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone4", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middle", 6) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "0   ");
					}
					//recall en tower hell Laloramos
					if ((TowerHell == FALSE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "towerofh", 8) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}
					//recall en Masacre
					if ((Masacre == FALSE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "masacre", 7) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}
					//Recall en HuntMap
					if ((VipMap == FALSE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "MapaVip", 7) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}

					//Recall en ALL EKS
					if ((AllEks == FALSE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "evento13", 8) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}

					//Recall en ALL EKS
					if ((AllDkEks == FALSE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "evento14", 8) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}

					//Recall en EventGarden
					if ((m_pClientList[i]->m_cSide != EventCount[DEF_RUSH].LastWin) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "areuni", 6) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}
					//Recall en EventPrize
					if (((WWPriceEvent == FALSE) && (PriceEvent == FALSE) && (WWIIPriceEvent == FALSE)) &&
					//if ((PriceEvent == FALSE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "EventMap", 8) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}

					if (((m_pClientList[i]->m_iRebirthLevel > 0) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "ABarracks", 9) == 0)) ||
						((m_pClientList[i]->m_iRebirthLevel > 0) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "EBarracks", 9) == 0)))
					{
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}

					if ((CityVsCity == TRUE) &&
						((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland", 10) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "Extreme", 7) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middled1n", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "TowerMap", 8) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvuni", 6) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "procella", 8) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "toh3", 4) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "dglv4", 5) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "towerofh", 8) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "MapaVip", 7) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "areuni", 6) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone1", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone2", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone3", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "huntzone4", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "toh2", 4) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "toh1", 4) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "dglv2", 5) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "dglv3", 5) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresdend1", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvined1", 8) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middled1x", 9) == 0)
							|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "druncncity", 10) == 0))
						&& (m_pClientList[i]->m_iAdminUserLevel < 1)) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}

					if (m_pClientList[i] == NULL) break;
					//ZeroEoyPnk! - Capture The Flag
					if (m_bIsCTFMode) {
						RequestCheckFlag(i);
						if (bCheckIfIsFlagCarrier(i)) {
							if (m_pClientList[i]->m_iHP >= 1) {
								SetInvisibilityFlag(i, DEF_OWNERTYPE_PLAYER, false);
								SetIceFlag(i, DEF_OWNERTYPE_PLAYER, true);
							}
						}
					}

					a = -1;
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_HELLCLAW, strlen(DEF_SUMMONMAP_HELLCLAW)) == 0) a = 0;
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_TIGERWORM, strlen(DEF_SUMMONMAP_TIGERWORM)) == 0) a = 1;
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_WYVERN, strlen(DEF_SUMMONMAP_WYVERN)) == 0) a = 2;
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_FIRE_WYVERN, strlen(DEF_SUMMONMAP_FIRE_WYVERN)) == 0) a = 3;
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_ABADDON, strlen(DEF_SUMMONMAP_ABADDON)) == 0) a = 4;
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_HELLDEATH, strlen(DEF_SUMMONMAP_HELLDEATH)) == 0) a = 5;
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_LIGHTWORM, strlen(DEF_SUMMONMAP_LIGHTWORM)) == 0) a = 6;
					if (a != -1) {
						if (SummonBalls[a].dwOpenSummonMap == -1) {
							switch (m_pClientList[i]->m_cSide) {
								case 0: RequestTeleportHandler(i, "2   ", "Whouse", -1, -1); break;
								case 1: RequestTeleportHandler(i, "2   ", "aresden", -1, -1); break;
								case 2: RequestTeleportHandler(i, "2   ", "elvine", -1, -1); break;
							}
						}
					}

					//News Portals - ZeroEoyPnk
					if (m_pClientList[i] == NULL) break;
					for (int portal = 0; portal <= DEF_MAXPORTALS; portal++) {
						if (PortalAbility[portal] == TRUE) {
							if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, Portal_Init[portal], 11) == 0) &&
								(m_pClientList[i]->m_iLevel <= LevelLimit_portal[portal]) &&
								((m_pClientList[i]->m_sX > ini_dx_portal[portal] - 10) && (m_pClientList[i]->m_sX < ini_dx_portal[portal] + 10)) &&
								((m_pClientList[i]->m_sY > ini_dy_portal[portal] - 10) && (m_pClientList[i]->m_sY < ini_dy_portal[portal] + 10))) {
								SendNotifyMsg(NULL, i, CLIENT_NOTIFY_APOCGATEOPEN, portal, ini_dx_portal[portal], ini_dy_portal[portal], Portal_Init[portal]);
								if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, Portal_Init[portal], 11) == 0) &&
									(m_pClientList[i]->m_iLevel <= LevelLimit_portal[portal]) &&
									((m_pClientList[i]->m_sX > ini_dx_portal[portal] - 1) && (m_pClientList[i]->m_sX < ini_dx_portal[portal] + 2)) &&
									((m_pClientList[i]->m_sY > ini_dy_portal[portal] - 1) && (m_pClientList[i]->m_sY < ini_dy_portal[portal] + 2))) {

									RequestTeleportHandler(i, "2   ", Portal_MapName[portal], dest_dx_portal[portal], dest_dy_portal[portal]);
									if (MaxPlayer_portal[portal] != -1) {
										PortalPlayers[portal]++;

										if (PortalPlayers[portal] >= MaxPlayer_portal[portal]) ClosePortal(portal);
									}
								}
							}
						}
					}

					if (m_pClientList[i] == NULL) break;
					m_pClientList[i]->m_iSuperAttackCount++;
					if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39�ʸ��� �Ѱ��� ���� �ȴ�.				
						m_pClientList[i]->m_iSuperAttackCount = 0;
						iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
						if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) {
							m_pClientList[i]->m_iSuperAttackLeft++;
							SendCriticals(i);
						}
					}

					m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
					if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;
					if (m_pClientList[i] == NULL) break;
					if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

					if (m_pClientList[i]->m_iConstructionPoint > 0)
						CheckCommanderConstructionPoint(i);
				}
			}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckClientResponseTime");
	}
#endif
}

void CMapServer::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   iRet;

		if (m_pMainLogSock == NULL) return;

		iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

		switch (iRet) {
			case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
				PutLogList("(!!!) Main-log-socket connected!");
				break;

			case DEF_XSOCKEVENT_READCOMPLETE:
				OnMainLogRead();
				break;

			case DEF_XSOCKEVENT_BLOCK:
				PutLogList("(!!!) Main-log-socket BLOCKED!");
				break;

			case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
			case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				delete m_pMainLogSock;
				m_pMainLogSock = NULL;
				PutLogList("(!!!) Main-log-socket connection lost!");
				m_bIsLogSockAvailable = FALSE;
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: OnMainLogSocketEvent");
	}
#endif
}

void CMapServer::OnMainLogRead()
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwMsgSize;
		char * pData, cKey;

		pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);
		if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
			ErrorList("@@@@@@ CRITICAL ERROR in MsgQuene 2!!! @@@@@@");
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: OnMainLogRead");
	}
#endif
}

BOOL CMapServer::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag, char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD * dwp;
		WORD  * wp;
		int     iRet, i, iSize;
		char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], *cp;
		char    cGuildLoc[11], cTemp[120];
		int   * ip, iSendSize = 0;
		char cKey;
		cKey = (char)(rand() % 255) + 1;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		ZeroMemory(cCharName, sizeof(cCharName));
		ZeroMemory(cAccountName, sizeof(cAccountName));
		ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
		ZeroMemory(cAddress, sizeof(cAddress));
		ZeroMemory(cGuildName, sizeof(cGuildName));
		ZeroMemory(cGuildLoc, sizeof(cGuildLoc));
		
		switch (dwMsg) {
			case NUCLEO_REQUEST_SETACCOUNTWAITSTATUS:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = dwMsg;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cp, m_pClientList[iClientH]->m_cAccountName, 10);
				cp += 10;
				ip = (int *)cp;
				*ip = m_pClientList[iClientH]->m_iLevel;
				cp += 4;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
				iSendSize = 16;
				break;

			case NUCLEO_ENTERGAMECONFIRM:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_ENTERGAMECONFIRM;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cp, m_pClientList[iClientH]->m_cAccountName, 10);
				cp += 10;
				memcpy_secure(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
				cp += 10;
				memcpy_secure(cp, m_cServerName, 10);
				cp += 10;
				ZeroMemory(cTxt, sizeof(cTxt));
				m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
				memcpy_secure(cp, cTxt, 16);
				cp += 16;
				ip = (int *)cp;
				*ip = m_pClientList[iClientH]->m_iLevel;
				cp += 4;

				wsprintf(G_cTxt, "<%d> Loggin: %s - IP: %s - In Map: %s - Coord X: %d / Coord Y: %d", iClientH, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress, 
					m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
				CharacterLogList(G_cTxt);

				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
				iSendSize = 56;
				break;

			case NUCLEO_REQUEST_REGISTERGAMESERVER:
				if (m_pMainLogSock == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_REGISTERGAMESERVER;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

				memcpy_secure(cp, m_cServerName, 10);
				cp += 10;

				memcpy_secure(cp, m_cGameServerAddr, 16);
				cp += 16;

				wp = (WORD *)cp;
				*wp = (WORD)m_iGameServerPort;
				cp += 2;

				*cp = m_iTotalMaps;
				cp++;

				for (i = 0; i < m_iTotalMaps; i++) {
					memcpy_secure(cp, m_pMapList[i]->m_cName, 11);
					cp += 11;
				}
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 29 + (11 * m_iTotalMaps) + 3); // 56
				return TRUE;
				break;

			case NUCLEO_REQUEST_PLAYERDATA:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_PLAYERDATA;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) CharacterLogList("(X) CharName NULL!");
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
				memcpy_secure(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountPassword, 10);
				cp += 10;
				ZeroMemory(cTemp, sizeof(cTemp));
				iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
				memcpy_secure((char *)cp, cTemp, 15);
				cp += 15;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
				iSendSize = 52;
				break;

			case NUCLEO_REQUEST_SAVEPLAYERDATA_REPLY:
			case NUCLEO_REQUEST_SAVEPLAYERDATA:
			case NUCLEO_REQUEST_SAVEPLAYERDATALOGOUT:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = dwMsg;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
				memcpy_secure(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountPassword, 10);
				cp += 10;
				*cp = (char)bFlag; // Ä«¿îÆÃ ÇÃ·¡±× 
				cp++;
				iSize = _iComposePlayerDataFileContents(iClientH, cp);
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
				iSendSize = 37 + iSize;
				break;

			case NUCLEO_REQUEST_NOSAVELOGOUT:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_NOSAVELOGOUT;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
				memcpy_secure(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountPassword, 10);
				cp += 10;
				*cp = (char)bFlag; // ī���� �÷��� 
				cp++;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
				iSendSize = 37;
				break;

			case NUCLEO_REQUEST_DELETEACCOUNT:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (pData == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_DELETEACCOUNT;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

				memcpy_secure((char *)cp, pData, 10);
				cp += 10;

				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 16);
				iSendSize = 16;
				break;

			case NUCLEO_REQUEST_CREATENEWGUILD:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_CREATENEWGUILD;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
				memcpy_secure(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
				memcpy_secure(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
				memcpy_secure(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountPassword, 10);
				cp += 10;
				memcpy_secure((char *)cp, cGuildName, 20);
				cp += 20;
				memcpy_secure((char *)cp, cGuildLoc, 10);
				cp += 10;
				ip = (int *)cp;
				*ip = m_pClientList[iClientH]->m_iGuildGUID;
				cp += 4;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
				iSendSize = 75;
				break;

			case NUCLEO_REQUEST_DISBANDGUILD:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_DISBANDGUILD;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
				memcpy_secure(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
				memcpy_secure(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cAccountPassword, 10);
				cp += 10;
				memcpy_secure((char *)cp, cGuildName, 20);
				cp += 20;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
				iSendSize = 56;
				break;

			case NUCLEO_REQUEST_NEWGUILDSMAN:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_NEWGUILDSMAN;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cGuildName, 20);
				cp += 20;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
				iSendSize = 36;
				break;

			case NUCLEO_REQUEST_DELGUILDSMAN:
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				dwp = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
				*dwp = NUCLEO_REQUEST_DELGUILDSMAN;
				wp = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_CONFIRM;
				cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);
				memcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
				memcpy_secure(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
				memcpy_secure((char *)cp, cCharName, 10);
				cp += 10;
				memcpy_secure((char *)cp, cGuildName, 20);
				cp += 20;
				iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
				iSendSize = 36;
				break;
		}

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
				PutLogList(G_cTxt);

				delete m_pSubLogSock[m_iCurSubLogSockIndex];
				m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
				m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
				m_iSubLogSockActiveCount--;

				m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
				m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
				m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
				wsprintf(G_cTxt, "Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
				PutLogList(G_cTxt);
				m_iSubLogSockFailCount++;
				if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
				m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
				return FALSE;
		}
		return TRUE;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSendMsgToLS");
	}
#endif
	return FALSE;
}

void CMapServer::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		WORD * wp;
		DWORD * dwp;
		char * cp, cCharName[11], cTxt[120];
		int  i;

		ZeroMemory(cCharName, sizeof(cCharName));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		memcpy_secure(cCharName, cp, 10);
		cp += 10;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
					wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
					switch (*wp) {
						case DEF_MSGTYPE_CONFIRM:
							InitPlayerData(i, pData, dwSize);
							break;

						case DEF_MSGTYPE_REJECT:
							if (*cp == 1) {
								ZeroMemory(cTxt, sizeof(cTxt));
								dwp = (DWORD *)(cTxt + DEF_INDEX4_MSGID);
								*dwp = CLIENT_RESPONSE_INITPLAYER;
								wp = (WORD *)(cTxt + DEF_INDEX2_MSGTYPE);
								*wp = DEF_MSGTYPE_REJECT;

								m_pClientList[i]->m_pXSock->iSendMsg(cTxt, 6);
							}
							else {
								wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
								PutLogHacksFileList(G_cTxt);
								DeleteClient(i, FALSE, FALSE);
							}
							break;

						default:
							break;
					}

					return;
				}
			}
		}

		wsprintf(cTxt, "Non-existing player data received from Log server: CharName(%s)", cCharName);
		CharacterLogList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ResponsePlayerDataHandler");
	}
#endif
}

void CMapServer::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus;
		DWORD * dwp;
		WORD  * wp;
		int     i, iRet;
		BOOL    bRet;
		char  cPrice = 0;
		//Agregados lalov9
		short cStr, cVit, cDex, cInt, cMag, cChar;
		int iTotalSetting = 0;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

		if (m_bShutDownServer) return;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		ZeroMemory(cName, sizeof(cName));
		memcpy_secure(cName, cp, 10);
		cp += 10;

		cp++;

		cGuildStatus = *cp;
		cp++;

		m_pClientList[iClientH]->m_iHitRatio = m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_cSide = 0;
		m_pClientList[iClientH]->FirstPosition = FALSE;

		bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);

		if (FinalFight) {
			if (m_pClientList[iClientH]->EventID != FinalFight_ID)
				m_pClientList[iClientH]->Event_Killed = m_pClientList[iClientH]->Event_Death = 0;
			else for (i = 0; i < 9; i++) CheckNewNivel(iClientH, TRUE);
		}
		else m_pClientList[iClientH]->Event_Killed = m_pClientList[iClientH]->Event_Death = 0;

		if (bRet == FALSE) {
			wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
			PutLogHacksFileList(G_cTxt);
			DeleteClient(iClientH, FALSE, TRUE); //!!!
			return;
		}

		bRet = _bDecodePlayerDatafileContents2(iClientH, cp, dwSize - 19); //read more character variables added by heaton
		if (bRet == FALSE) {
			wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
			PutLogHacksFileList(G_cTxt);
			DeleteClient(iClientH, FALSE, TRUE); //!!!
			return;
		}

		ReadMarket(iClientH);
		m_pClientList[iClientH]->read_quest_data();

		//___RestorePlayerCharacteristics(iClientH);

		//Agregados lalov9
		//if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {

			/*iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
				m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;*/

			//if (iTotalSetting > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70)) {
			/*if ((iTotalSetting > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70)) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
				wsprintf(G_cTxt, "HACK-STATS-LOGIN - Character(%s)!", m_pClientList[iClientH]->m_cCharName);
				PutLogHacksFileList(G_cTxt);
				DeleteClient(iClientH, FALSE, TRUE);
				return;
			}*/

			//if ((m_pClientList[iClientH]->m_iLevel) > 200){
			if (((m_pClientList[iClientH]->m_iLevel) > m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
				wsprintf(G_cTxt, "HACK-LEVEL-LOGIN - Character(%s)!", m_pClientList[iClientH]->m_cCharName);
				PutLogHacksFileList(G_cTxt);
				DeleteClient(iClientH, FALSE, TRUE);
				return;
			}
		//}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) ___RestorePlayerRating(iClientH);

		if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1))
			GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

		iSetSide(iClientH);
		int iTemp, iTemp2;
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = 0x0FFFFFFF & iTemp;
		iTemp2 = iGetPlayerABSStatus(iClientH, NULL);
		iTemp = iTemp | (iTemp2 << 28);
		m_pClientList[iClientH]->m_iStatus = iTemp;

		if (m_bIsCTFMode) ActualizarCountFlag(iClientH, true);

		if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter))
			SetNoHunterMode(iClientH);

		m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1];

		CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
		iCalcTotalWeight(iClientH);

		if ((m_pClientList[iClientH]->m_iAdminUserLevel >= 1) && (m_pClientList[iClientH]->m_iAdminUserLevel <= 9)) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			m_pClientList[iClientH]->AdminChat = TRUE;
		}

		if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy_secure(m_pClientList[iClientH]->m_cGuildName, "NONE");
			m_pClientList[iClientH]->m_iGuildRank = -1;
			m_pClientList[iClientH]->m_iGuildGUID = -1;

			SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
		}

		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH, 0);
		if (m_pClientList[iClientH]->m_iItemQuest != NULL) _bCheckIsQuestCompleted(iClientH, 1);
		if (m_pClientList[iClientH]->m_iStatedQuest != NULL) _bCheckIsQuestCompleted(iClientH, 2);

		if (m_pClientList[iClientH]->AssasainPoint >= DEF_ASSASAINPOINTS) m_pClientList[iClientH]->Assasain = TRUE;

		if (m_pClientList[iClientH]->m_bIsOnShop) {
			cPrice = 0;
			if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) cPrice = -10;
		}

		if (m_pClientList[iClientH] == NULL) {
			wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
			CharacterLogList(cTxt);
			return;
		}

		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0) {
			m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
		}

		//if ((HellOfDeath || PriceHODEvent || SummonLaunched)) {
		if ((HellOfDeath || SummonLaunched)) {
			if ((strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
				(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
				(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0))// ||
			//	(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0))
				m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
		}

		if (CityVsCity && (strcmp(m_pClientList[iClientH]->m_cMapName, "abaddon") != 0)) {
			m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
		}

		SendEventOpenData(iClientH);
		
		notify_rankexp(iClientH);
		
		send_objects_data();

		ZeroMemory(cData, sizeof(cData));
		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_INITPLAYER;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
				CharacterLogList(cTxt);
				DeleteClient(iClientH, FALSE, TRUE); //!!!!!
				return;
		}

		m_pClientList[iClientH]->m_bIsInitComplete = TRUE;
		if (m_pClientList[iClientH]->CheckProcess) CheckProcess(iClientH);

		if (m_pClientList[iClientH]->Assasain) SearchAssasainPosition(iClientH);
		else {
			for (i = 0; i < 6; i++) HandleRequestMemoryTops(0, i, FALSE);
		}

		if (m_pClientList[iClientH]->m_iPKCount > 9) {
			if (!m_pClientList[iClientH]->Achivements[17].Complete)
				CheckCompleteAchivement(iClientH, 17, TRUE);
		}

		bSendMsgToLS(NUCLEO_ENTERGAMECONFIRM, iClientH);

		iTemp = -1;
		if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_HELLCLAW, 10) == 0) iTemp = 0;
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_TIGERWORM, 10) == 0) iTemp = 1;
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_WYVERN, 10) == 0) iTemp = 2;
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_FIRE_WYVERN, 10) == 0) iTemp = 3;
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_ABADDON, 10) == 0) iTemp = 4;
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_HELLDEATH, 10) == 0) iTemp = 5;
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_SUMMONMAP_LIGHTWORM, 10) == 0) iTemp = 6;

		if (iTemp != -1) {
			if (!SummonBalls[iTemp].ActiveSummon || memcmp(m_pClientList[iClientH]->m_cGuildName, SummonBalls[iTemp].GuildName, 22) != 0
				|| SummonBalls[iTemp].dwOpenSummonMap == -1) {

				switch (m_pClientList[iClientH]->m_cSide) {
					case 0: RequestTeleportHandler(iClientH, "2   ", "WHouse", -1, -1); break;
					case 1: RequestTeleportHandler(iClientH, "2   ", "aresden", -1, -1); break;
					case 2: RequestTeleportHandler(iClientH, "2   ", "elvine", -1, -1); break;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iPartyID != NULL)
			RequestDismissPartyHandler(iClientH);

		if (PriceHODEvent || PriceEvent) {
			if (m_pClientList[iClientH]->RndEventID == RandomEventID) {
				if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0) {
					if (EventTime > m_pClientList[iClientH]->EventMinPlaying) {
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: RequestTeleportHandler(iClientH, "2   ", "WHouse", -1, -1); break;
							case 1: RequestTeleportHandler(iClientH, "2   ", "gshop_1", -1, -1); break;
							case 2: RequestTeleportHandler(iClientH, "2   ", "gshop_2", -1, -1); break;
						}
					}
				}

				if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0) {
					if (EventTime > m_pClientList[iClientH]->EventMinPlaying) {
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: RequestTeleportHandler(iClientH, "2   ", "WHouse", -1, -1); break;
							case 1: RequestTeleportHandler(iClientH, "2   ", "gshop_1", -1, -1); break;
							case 2: RequestTeleportHandler(iClientH, "2   ", "gshop_2", -1, -1); break;
						}
					}
				}
			}
		}

		if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: RequestTeleportHandler(iClientH, "2   ", "WHouse", -1, -1); break;
				case 1: RequestTeleportHandler(iClientH, "2   ", "gshop_1", -1, -1); break;
				case 2: RequestTeleportHandler(iClientH, "2   ", "gshop_2", -1, -1); break;
			}
		}

		m_pClientList[iClientH]->m_iMaxRankExp = c_rank->m_iMaxrankexp[m_pClientList[iClientH]->m_sRankLevel];
		notify_rankexp(iClientH);

		NotifyRankData(iClientH);
		NotifyCInsert(iClientH);
		NotifyCDelete(iClientH);
		notifyShinningStatus(iClientH);
		NotifyFragments(iClientH);
		
		SendCommand(iClientH, "/rebirthlevel", m_pClientList[iClientH]->m_iRebirthLevel);
		SendCommand(iClientH, "/rebirthstatus", m_pClientList[iClientH]->m_sRebirthStatus);
		SendCommand(iClientH, "/rebirthenabled", m_pClientList[iClientH]->m_sRebirthEnabled);
		SendCommand(iClientH, "/handle", m_pClientList[iClientH]->client);
		//m_pClientList[iClientH]->sendInitMessage();

		g_ev.LoginNotify(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitPlayerData");
	}
#endif
}

//heaton 2024
void CMapServer::NotifyFragments(int iClientH)
{
	if (!m_pClientList[iClientH]) return;
	SendCommand(iClientH, "/shards", m_pClientList[iClientH]->shard_light, m_pClientList[iClientH]->shard_strong);
	SendCommand(iClientH, "/fragment_hp", m_pClientList[iClientH]->fragment_hp);
	SendCommand(iClientH, "/fragment_dr", m_pClientList[iClientH]->fragment_dr);
	SendCommand(iClientH, "/fragment_hprec", m_pClientList[iClientH]->fragment_hprec);
	SendCommand(iClientH, "/fragment_sprec", m_pClientList[iClientH]->fragment_sprec);
	SendCommand(iClientH, "/fragment_mprec", m_pClientList[iClientH]->fragment_mprec);
	SendCommand(iClientH, "/fragment_mr", m_pClientList[iClientH]->fragment_mr);
	SendCommand(iClientH, "/fragment_pa", m_pClientList[iClientH]->fragment_pa);
	SendCommand(iClientH, "/fragment_ma", m_pClientList[iClientH]->fragment_ma);
	SendCommand(iClientH, "/fragment_exp", m_pClientList[iClientH]->fragment_exp);
}

void CMapServer::NotifyCInsert(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	char data[500];
	char* cp = data;

	Push(cp, (u32)NOT_CINSERT);
	Push(cp, (u16)0);

	Push(cp, p->m_sCandyInsert);

	m_pClientList[client]->m_pXSock->iSendMsg(data, sizeof(data));

}

void CMapServer::NotifyCDelete(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	char data[500];
	char* cp = data;

	Push(cp, (u32)NOT_CDELETE);
	Push(cp, (u16)0);

	Push(cp, p->m_sCandyDelete);

	m_pClientList[client]->m_pXSock->iSendMsg(data, sizeof(data));
}

void CMapServer::GameProcess()
{
	MsgProcess();
}

BOOL CMapServer::bReadProgramConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadMode, cTxt[120];
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		PutLogList("Adding maps");

		while (token != NULL) {
			if (cReadMode != 0) {
				switch (cReadMode) {
					case 1:
						ZeroMemory(m_cServerName, sizeof(m_cServerName));
						if (strlen(token) > 10) {
							wsprintf(cTxt, "Game server name(%s) must within 10 chars!", token);
							ErrorList(cTxt);
							return FALSE;
						}
						strcpy_secure(m_cServerName, token);
						wsprintf(cTxt, "Game server name : %s", m_cServerName);
						ConfigList(cTxt);
						cReadMode = 0;
						break;

					case 2:
						m_iGameServerPort = atoi(token);
						wsprintf(cTxt, "Game server port : %d", m_iGameServerPort);
						ConfigList(cTxt);
						cReadMode = 0;
						break;

					case 3:
						ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
						if (strlen(token) > 15) {
							wsprintf(cTxt, "Log server address(%s) must within 15 chars!", token);
							ErrorList(cTxt);
							return FALSE;
						}
						strcpy_secure(m_cLogServerAddr, token);
						wsprintf(cTxt, "Log server address : %s", m_cLogServerAddr);
						ConfigList(cTxt);
						cReadMode = 0;
						break;

					case 4:
						m_iLogServerPort = atoi(token);
						wsprintf(cTxt, "Log server port : %d", m_iLogServerPort);
						ConfigList(cTxt);
						cReadMode = 0;
						break;

					case 5:
						if (strlen(token) > 10) {
							wsprintf(cTxt, "CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
							ErrorList(cTxt);
							return FALSE;
						}
						if (_bRegisterMap(token) == FALSE) return FALSE;
						cReadMode = 0;
						break;

					case 6:
					case 7:
						cReadMode = 0;
						break;

					case 8:
						ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
						if (strlen(token) > 15) {
							wsprintf(cTxt, "Game server address(%s) must within 15 chars!", token);
							ErrorList(cTxt);
							return FALSE;
						}
						strcpy_secure(m_cGameServerAddr, token);
						wsprintf(cTxt, "Game server address :  : %s", m_cGameServerAddr);
						ConfigList(cTxt);
						cReadMode = 0;
						break;

					case 9:
						m_iExtHGServerPort = atoi(token);
						wsprintf(cTxt, "External GameServer server port : %d", m_iExtHGServerPort);
						ConfigList(cTxt);
						cReadMode = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 8;
				if (memcmp(token, "external-server-port", 20) == 0)		cReadMode = 9;
			}
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete[]cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CMapServer::bReadMessageConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadMode;
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;
	int i;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	for (i = 0; i < 25; i++) ZeroMemory(m_cMsg[i], sizeof(m_cMsg[i]));
	i = 0;

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadMode != 0) {
				switch (cReadMode) {
					case 1:
						ZeroMemory(m_cMsg[i], sizeof(m_cMsg[i]));
						if (strlen(token) > 100) return FALSE;
						strcpy_secure(m_cMsg[i], token);
						cReadMode = 0;
						i++;
						break;

				}
			}
			else {
				if (memcmp(token, "msg", 3) == 0) cReadMode = 1;
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CMapServer::bReadCrusadeStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading Crusade configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);

								if (m_stCrusadeStructures[iIndex].cType != NULL) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate potion number.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
								memcpy_secure(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCrusadeStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCrusadeStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCrusadeStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CMapServer::_bRegisterMap(char * pName)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		char cTmpName[11], cTxt[120];

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pName);
		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
				wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
				PutLogList(cTxt);
				return FALSE;
			}
		}

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] == NULL) {
				m_pMapList[i] = (class CMap *)new class CMap(this);
				if (m_pMapList[i]->bInit(pName) == FALSE) {
					wsprintf(cTxt, "Data file loading fail! - %s", pName);
					ErrorList(cTxt);
					return FALSE;
				};

				if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0))
					m_iMiddlelandMapIndex = i;

				if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0))
					m_iAresdenMapIndex = i;

				if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0))
					m_iElvineMapIndex = i;

				if ((m_iWhouseMapIndex == -1) && (strcmp("Whouse", pName) == 0))
					m_iWhouseMapIndex = i;

				m_iTotalMaps++;
				return TRUE;
			}
		}
		wsprintf(cTxt, "CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
		ErrorList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bRegisterMap");
	}
#endif
	return FALSE;
}

BOOL CMapServer::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * pContents, *token, *pOriginContents, cTmpName[11], cTxt[120];
		char   seps[] = "= \t\n";
		char   cReadModeA, cReadModeB;
		int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
		class  CStrTok * pStrTok;
		short  sTmpType = 1, sTmpAppr1;
		short itemBagPossX;
		short itemBagPossY;
		short ItemBankPosition;
		short TotalBankPosition = 0;
		short TempPosition = 0;
		BOOL   bRet;
		int    iTemp;
		SYSTEMTIME SysTime;
		__int64 iDateSum1, iDateSum2;
		BOOL   bIsNotUsedItemFound = FALSE, TempItem = FALSE;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		iTotalGold = 0;
		iItemIndex = 0;
		iItemInBankIndex = 0;
		iNotUsedItemPrice = 0;

		cReadModeA = 0;
		cReadModeB = 0;

		pContents = new char[dwSize + 2];
		ZeroMemory(pContents, dwSize + 2);
		memcpy_secure(pContents, pData, dwSize);

		pOriginContents = pContents;

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						strcpy_secure(m_pClientList[iClientH]->m_cMapName, token);

						ZeroMemory(cTmpName, sizeof(cTmpName));
						strcpy_secure(cTmpName, token);
						for (i = 0; i < DEF_MAXMAPS; i++) {
							if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
								m_pClientList[iClientH]->m_cMapIndex = (char)i;
							}
						}

						if (m_pClientList[iClientH]->m_cMapIndex == -1) {
							wsprintf(cTxt, "Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						cReadModeA = 0;
						break;

					case 2:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sX = atoi(token);
						cReadModeA = 0;
						break;

					case 3:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sY = atoi(token);
						cReadModeA = 0;
						break;

					case 4:
						cReadModeA = 0;
						break;

					case 5:
						switch (cReadModeB) {
							case 1:
								// v2.12
								if (iItemIndex >= DEF_MAXITEMS) {
									delete pContents;
									delete pStrTok;
									return FALSE;
								}

								if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
									wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token);
									PutLogList(cTxt);

									HANDLE hFile;
									DWORD  nWrite;
									hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
									WriteFile(hFile, (char *)pContents, dwSize + 2, &nWrite, NULL);
									CloseHandle(hFile);

									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								// m_dwCount
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}

								iTemp = atoi(token);
								if (iTemp < 0) iTemp = 1;
								if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH)) {
									iTemp = 1;
								}

								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
								cReadModeB = 3;

								if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
									iTotalGold += iTemp;
								break;

							case 3:
								// m_sTouchEffectType
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								// m_sTouchEffectValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								// m_sTouchEffectValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								// m_sTouchEffectValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);	
								cReadModeB = 7;
								break;

							case 7:
								// m_cItemColor
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// m_sItemSpecEffectValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// m_sItemSpecEffectValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								// m_sItemSpecEffectValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								// m_wCurLifeSpan
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);

								cReadModeB = 12;
								break;

							case 12:
								// m_dwAttribute
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);

								if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
									if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
										(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
										(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
										wsprintf(cTxt, "Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
											m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
											m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
											m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
											m_pClientList[iClientH]->m_sCharIDnum1,
											m_pClientList[iClientH]->m_sCharIDnum2,
											m_pClientList[iClientH]->m_sCharIDnum3);
										PutLogList(cTxt);
									}
								}

								// ZeroEoyPnk - Fix endurance
								if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 > 0) {
									switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
										case 5:
										case 6:
										case 15:
											m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
											break;
									}
								}

								_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

								if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) &&
									(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
								}

								bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);//dejame ver algo a ver como lo guarda

								CheckHeroData(iClientH, iItemIndex, FALSE);

								if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
									iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
									delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
									m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
									bIsNotUsedItemFound = TRUE;
								}
								cReadModeB = 13;
								break;

							case 13:
								itemBagPossX = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								itemBagPossY = atoi(token);

								m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetBagPosition(itemBagPossX, itemBagPossY);

								cReadModeB = 0;
								cReadModeA = 0;

								iItemIndex++;

								break;
						}
						break;

					case 6:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cSex = atoi(token);
						cReadModeA = 0;
						break;

					case 7:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cSkin = atoi(token);
						cReadModeA = 0;
						break;

					case 8:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cHairStyle = atoi(token);
						cReadModeA = 0;
						break;

					case 9:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cHairColor = atoi(token);
						cReadModeA = 0;
						break;

					case 10:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cUnderwear = atoi(token);
						cReadModeA = 0;
						break;

					case 11:
						for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
							m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

						for (i = 0; i < DEF_MAXITEMS; i++)
							m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if (bIsNotUsedItemFound == FALSE) {
							for (i = 0; i < DEF_MAXITEMS; i++) {
								wsprintf(cTxt, "%d", token[i]);
								if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
									if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)
										m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
									else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
								}
								else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

								if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
									if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
										m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // ���� Ư��ġ �������� ������ �������� �������� �ʾƾ� �Ѵٸ� ���� ���Ѱ��� ǥ�� 
								}
							}
						}

						cReadModeA = 0;
						break;

					case 12:
						ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
						strcpy_secure(m_pClientList[iClientH]->m_cGuildName, token);
						cReadModeA = 0;
						break;

					case 13:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iGuildRank = atoi(token);
						cReadModeA = 0;
						break;

					case 14:
						// HP 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iHP = atoi(token);
						cReadModeA = 0;
						break;

					case 15:
						// DefenseRatio �������� �ʴ´�. ���ǹ��� �� 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						cReadModeA = 0;
						break;

					case 16:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						cReadModeA = 0;
						break;

					case 17:
						// Level  
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iLevel = atoi(token);
						cReadModeA = 0;
						break;

					case 18:
						// Str 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iStr = atoi(token);
						cReadModeA = 0;
						break;

					case 19:
						// Int 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iInt = atoi(token);
						cReadModeA = 0;
						break;

					case 20:
						// Vit 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iVit = atoi(token);
						cReadModeA = 0;
						break;

					case 21:
						// Dex 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iDex = atoi(token);
						cReadModeA = 0;
						break;

					case 22:
						// Mag 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iMag = atoi(token);
						cReadModeA = 0;
						break;

					case 23:
						// Charisma 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iCharisma = atoi(token);
						cReadModeA = 0;
						break;

					case 24:
						// Luck 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iLuck = atoi(token);
						cReadModeA = 0;
						break;

					case 25:
						// Exp 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iExp = atoi(token);
						cReadModeA = 0;
						break;

					case 26:
						// Magic-Mastery
						for (i = 0; i < DEF_MAXMAGICTYPE; i++) m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
						cReadModeA = 0;
						break;

					case 27:
						// Skill-Mastery 
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
						cReadModeB++;

						if (cReadModeB >= DEF_MAXSKILLTYPE) {
							cReadModeA = 0;
							cReadModeB = 0;
						}
						break;

					case 28:
						// Warehouse
						switch (cReadModeB) {
							case 1:
								if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
									wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token);
									PutLogList(cTxt);

									HANDLE hFile;
									DWORD  nWrite;
									hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
									WriteFile(hFile, (char *)pOriginContents, dwSize + 2, &nWrite, NULL);
									CloseHandle(hFile);

									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								// m_dwCount
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}

								iTemp = atoi(token);
								if (iTemp < 0) iTemp = 1;

								if (iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH)) {
									iTemp = 1;
								}

								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
								cReadModeB = 3;

								if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
									iTotalGold += iTemp;
								break;

							case 3:
								// m_sTouchEffectType
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								// m_sTouchEffectValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								// m_sTouchEffectValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								// m_sTouchEffectValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								// m_cItemColor
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// m_sItemSpecEffectValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// m_sItemSpecEffectValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								// m_sItemSpecEffectValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								// m_wCurLifeSpan
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

								cReadModeB = 12;
								break;

							case 12:
								// m_dwAttribute
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);

								// ZeroEoyPnk - Fix endurance
								if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 > 0) {
									switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
										case 5:
										case 6:
										case 15:
											m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
											break;
									}
								}

								_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);
								CheckHeroData(iClientH, iItemInBankIndex, TRUE);

								if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
									m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;

								// v1.433
								if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) &&
									(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
									wsprintf(G_cTxt, "character (%s) have the GemStone of Sacrifice to lifespan 0 !", m_pClientList[iClientH]->m_cCharName);
									CharacterLogList(G_cTxt);
									m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
								}

								if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
									iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
									delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
									m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
								}

								cReadModeB = 13;
								break;

							case 13:
								// Wh Page Index - ZeroEoyPnk
								// Obtengo la pagina donde est� el item			

								//Evita el bug, si hay chars sin WH Pages
								if (memcmp(token, "character-bank-item", 19) == 0) {
									TotalBankPosition++;
									if (TotalBankPosition >= DEF_MAXBANKITEMPAGE) {
										TempPosition++;
										TotalBankPosition = 1;
									}
									// Le asigno la pagina correspondiente
									ItemBankPosition = TempPosition;

									m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->SetBankPosition(ItemBankPosition);

									cReadModeA = 28;
									cReadModeB = 1;
									iItemInBankIndex++;
									m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
								}
								else {
									ItemBankPosition = atoi(token);
									if (ItemBankPosition == NULL) {
										TotalBankPosition++;
										if (TotalBankPosition > DEF_MAXBANKITEMPAGE) {
											TempPosition++;
											TotalBankPosition = 1;
										}
										ItemBankPosition = TempPosition;
									}

									m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->SetBankPosition(ItemBankPosition);

									cReadModeA = 0;
									cReadModeB = 0;
									iItemInBankIndex++;
								}
								break;
						}
						break;

					case 29:
						ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
						strcpy_secure(m_pClientList[iClientH]->m_cLocation, token);
						cReadModeA = 0;
						break;

					case 30:
						// m_iMP
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iMP = atoi(token);
						cReadModeA = 0;
						break;

					case 31:
						// m_iSP
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iSP = atoi(token);
						cReadModeA = 0;
						break;

					case 32:
						// m_cLU_Pool
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
						cReadModeA = 0;
						break;

					case 33:
						// Achivements
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->Achivements[cReadModeB].Contador = atoi(token);
						cReadModeB++;

						if (cReadModeB >= DEF_MAXACHIVEMENTS) {
							cReadModeA = 0;
							cReadModeB = 0;
						}
						break;

					case 34: // Total Mobs Killed
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->TotalMobsKilled = atoi(token);
						cReadModeA = 0;
						break;

					case 35: // Total Death
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->TotalDeath = atoi(token);
						cReadModeA = 0;
						break;

					case 36:// m_iEnemyKillCount
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
						cReadModeA = 0;
						break;

					case 37:// m_iEnemyKillTotalCount
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							ErrorList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iEnemyKillTotalCount = atoi(token);
						cReadModeA = 0;
						break;

					case 38:// m_iPKCount
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iPKCount = atoi(token);
						cReadModeA = 0;
						break;

					case 39:// m_iPKCount
						if (_bGetIsStringIsNumber(token) == FALSE) m_pClientList[iClientH]->m_iCityFriendKilled = 0;
						else m_pClientList[iClientH]->m_iCityFriendKilled = atoi(token);
						cReadModeA = 0;
						break;

					case 40:// Assasain-Count
						if (_bGetIsStringIsNumber(token) == FALSE) m_pClientList[iClientH]->AssasainPoint = 0;
						else m_pClientList[iClientH]->AssasainPoint = atoi(token);
						cReadModeA = 0;
						break;

					case 41:// m_iRewardGold
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iRewardGold = atoi(token);
						cReadModeA = 0;
						break;

					case 42:// Skill-SSN �����Ѵ�.
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
						cReadModeB++;

						if (cReadModeB >= DEF_MAXSKILLTYPE) {
							cReadModeA = 0;
							cReadModeB = 0;
						}
						break;

					case 43:
						if (token != NULL) {
							ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
							strcpy_secure(m_pClientList[iClientH]->m_cProfile, token);
						}
						cReadModeA = 0;
						break;

					case 44: // Hunger-Status �����Ѵ�.
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
						cReadModeA = 0;
						break;

					case 45: // AdminUserLevel
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
						cReadModeA = 0;
						break;

					case 46: // TimeLeft_ShutUp
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
						cReadModeA = 0;
						break;

					case 47: // TimeLeft_Rating
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
						cReadModeA = 0;
						break;

					case 48: // Rating
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iRating = atoi(token);
						cReadModeA = 0;
						break;

					case 49: // Guild GUID: ������ �����Ǿ��� �������� ���� -1�� �� ���� ���̴�.
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
						cReadModeA = 0;
						break;

					case 50: // Down Skill Index
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
						cReadModeA = 0;
						break;

					case 51:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}

						m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].x = atoi(token);
						cReadModeB++;
						if (cReadModeB > 50) {
							cReadModeA = 0;
							cReadModeB = 0;
						}
						break;

					case 52:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].y = atoi(token);
						if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB - 1].y = -10;
						cReadModeB++;
						if (cReadModeB > 50) {
							cReadModeA = 0;
							cReadModeB = 0;
						}
						break;

					case 53:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
						cReadModeA = 0;
						break;

					case 54:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
						cReadModeA = 0;
						break;

					case 55:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
						cReadModeA = 0;
						break;

					case 56:
						switch (cReadModeB) {
							case 1:	// Penalty Block Year
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);
								cReadModeB = 2;
								break;

							case 2:	// Penalty Block Month
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);
								cReadModeB = 3;
								break;

							case 3: // Penalty Block day
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					case 57:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iQuest = atoi(token);
						cReadModeA = 0;
						break;

					case 58:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
						cReadModeA = 0;
						break;

					case 59:
						cReadModeA = 0;
						break;

					case 60:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
						cReadModeA = 0;
						break;

					case 61:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
						cReadModeA = 0;
						break;

					case 62:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iContribution = atoi(token);
						cReadModeA = 0;
						break;

					case 63:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iQuestID = atoi(token);
						cReadModeA = 0;
						break;

					case 65:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
						cReadModeA = 0;
						break;

					case 66:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
						cReadModeA = 0;
						break;

					case 67:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
						cReadModeA = 0;
						break;

					case 68:
						switch (cReadModeB) {
							case 1:
								// FightZone Number
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);
								cReadModeB = 2;
								break;

							case 2:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_iReserveTime = atoi(token);
								cReadModeB = 3;
								break;
							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					case 70:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
						cReadModeA = 0;
						break;

					case 71:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
						cReadModeA = 0;
						break;

					case 72:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iWarContribution = atoi(token);
						cReadModeA = 0;
						break;

					case 73:
						if (strlen(token) > 10) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, token);
						cReadModeA = 0;
						break;

					case 74:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
						cReadModeA = 0;
						break;

					case 75:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
						cReadModeA = 0;
						break;

					case 76:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
						cReadModeA = 0;
						break;

					case 77:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
						cReadModeA = 0;
						break;

					case 78:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
						cReadModeA = 0;
						break;

					case 79: // v2.06 12-4
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iPartyID = NULL;
						if (m_pClientList[iClientH]->m_iPartyID != NULL) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
						cReadModeA = 0;
						break;

					case 80: // v2.15 ���������۾��׷��̵�
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
						cReadModeA = 0;
						break;

					case 81:
						if (strlen(token) > 21) {
							strcpy_secure(token, m_pClientList[iClientH]->m_cIPaddress);
						}
						ZeroMemory(m_pClientList[iClientH]->m_cIP2, sizeof(m_pClientList[iClientH]->m_cIP2));
						strcpy_secure(m_pClientList[iClientH]->m_cIP2, token);
						cReadModeA = 0;
						break;

					case 82:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Coins Player (%s) - Wrong. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iCoins = atoi(token);
						if (m_pClientList[iClientH]->m_iCoins < 0) m_pClientList[iClientH]->m_iCoins = 0;
						if ((m_pClientList[iClientH]->m_iCoins >= 500) && (!m_pClientList[iClientH]->Achivements[12].Complete))
							CheckCompleteAchivement(iClientH, 12, TRUE);
						cReadModeA = 0;
						break;

					case 83:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_dwHeldenianGUID = atoi(token);
						cReadModeA = 0;
						break;

					case 84:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->TotalClientKilled = atoi(token);
						cReadModeA = 0;
						break;

					case 85:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->TotalQuestCompleted = atoi(token);
						cReadModeA = 0;
						break;

					case 86:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->HourPlaying = atoi(token);
						cReadModeA = 0;
						break;

					case 87:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->MinPlaying = atoi(token);
						cReadModeA = 0;
						break;

					case 88:
						if (strcmp(token, "ON") == 0) m_pClientList[iClientH]->CheckProcess = TRUE;
						else m_pClientList[iClientH]->CheckProcess = FALSE;
						cReadModeA = 0;
						break;

					case 89:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->EventID = atoi(token);
						cReadModeA = 0;
						break;
					case 90:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->Event_Killed = atoi(token);
						cReadModeA = 0;
						break;

					case 91:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->Event_Death = atoi(token);
						cReadModeA = 0;
						break;

					case 92: // New Item Quest
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iItemQuest = atoi(token);
						cReadModeA = 0;
						break;

					case 93:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iItemQuestID = atoi(token);
						cReadModeA = 0;
						break;

					case 94:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iItemQuestCount = atoi(token);
						cReadModeA = 0;
						break;

					case 95:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iItemQuestRewardType = atoi(token);
						cReadModeA = 0;
						break;

					case 96: // Item Stated quest
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iStatedQuest = atoi(token);
						cReadModeA = 0;
						break;

					case 97:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iStatedQuestID = atoi(token);
						cReadModeA = 0;
						break;

					case 98:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iStatedQuestCount = atoi(token);
						cReadModeA = 0;
						break;

					case 99:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iStatedQuestRewardType = atoi(token);
						cReadModeA = 0;
						break;

					case 100:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->RndEventID = atoi(token);
						cReadModeA = 0;
						break;

					case 101:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->EventMinPlaying = atoi(token);
						cReadModeA = 0;
						break;

					case 102:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sRankLevel = atoi(token);
						cReadModeA = 0;
						break;

					case 103:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iRankPoints = atoi(token);
						cReadModeA = 0;
						break;

					case 104:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_iRankExp = atoi(token);
						cReadModeA = 0;
						break;

					case 105:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sRankAddStr = atoi(token);
						cReadModeA = 0;
						break;


					case 106:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sRankAddVit = atoi(token);
						cReadModeA = 0;
						break;


					case 107:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sRankAddInt = atoi(token);
						cReadModeA = 0;
						break;

					case 108:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sRankAddDex = atoi(token);
						cReadModeA = 0;
						break;

					case 109:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sRankAddMag = atoi(token);
						cReadModeA = 0;
						break;

					case 110:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sCandyInsert = atoi(token);
						cReadModeA = 0;
						break;

					case 111:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sCandyDelete = atoi(token);
						cReadModeA = 0;
						break;

					case 112:
						if (_bGetIsStringIsNumber(token) == FALSE) {
							wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
							PutLogList(cTxt);
							delete pContents;
							delete pStrTok;
							return FALSE;
						}
						m_pClientList[iClientH]->m_sNoDrop = atoi(token);
						cReadModeA = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
				else if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
				else if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
				else if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
				else if (memcmp(token, "character-item", 14) == 0) {
					cReadModeA = 5;
					cReadModeB = 1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
				}

				else if (memcmp(token, "character-bank-item", 19) == 0) {
					cReadModeA = 28;
					cReadModeB = 1;
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
				}

				else if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
				else if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
				else if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
				else if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
				else if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;

				else if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
				else if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
				else if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
				else if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
				else if (memcmp(token, "character-DefenseRatio", 22) == 0)  cReadModeA = 15;
				else if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
				else if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
				else if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
				else if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
				else if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
				else if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
				else if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
				else if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
				else if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
				else if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
				else if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;

				else if (memcmp(token, "skill-mastery", 13) == 0) {
					cReadModeA = 27;
					cReadModeB = 0;
				}

				else if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;

				else if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
				else if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;

				else if (memcmp(token, "character-LU_Pool", 17) == 0)    cReadModeA = 32;
				else if (memcmp(token, "Achivements", 11) == 0) {
					cReadModeA = 33;
					cReadModeB = 0;
				}
				else if (memcmp(token, "Total-Mobs-Killed", 17) == 0)    cReadModeA = 34;
				else if (memcmp(token, "Total-Death", 11) == 0)    cReadModeA = 35;
				else if (memcmp(token, "character-EK-Count", 18) == 0)    cReadModeA = 36;
				else if (memcmp(token, "character-EK-TotalCount", 23) == 0) cReadModeA = 37;
				else if (memcmp(token, "character-PK-Count", 18) == 0)    cReadModeA = 38;
				else if (memcmp(token, "character-FK-Count", 18) == 0)    cReadModeA = 39;
				else if (memcmp(token, "Assasain-Count", 14) == 0)    cReadModeA = 40;
				else if (memcmp(token, "character-reward-gold", 21) == 0) cReadModeA = 41;
				else if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 42;
				else if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 43;
				else if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 44;
				else if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 45;
				else if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 46;
				else if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 47;
				else if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 48;
				else if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 49;
				else if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 50;
				else if (memcmp(token, "item-position-x", 15) == 0) {
					cReadModeA = 51;
					cReadModeB = 1;
				}
				else if (memcmp(token, "item-position-y", 15) == 0) {
					cReadModeA = 52;
					cReadModeB = 1;
				}
				else if (memcmp(token, "character-IDnum1", 16) == 0)		cReadModeA = 53;
				else if (memcmp(token, "character-IDnum2", 16) == 0)		cReadModeA = 54;
				else if (memcmp(token, "character-IDnum3", 16) == 0)		cReadModeA = 55;
				else if (memcmp(token, "penalty-block-date", 18) == 0) {
					cReadModeA = 56;
					cReadModeB = 1;
				}
				else if (memcmp(token, "character-contribution", 22) == 0)  cReadModeA = 62;
				else if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 65;
				else if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 66;
				else if (memcmp(token, "special-event-id", 16) == 0)		cReadModeA = 67;
				else if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;
				else if (memcmp(token, "reserved-fightzone-id", 21) == 0) {
					cReadModeA = 68;
					cReadModeB = 1;
				}
				else if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71;
				else if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72;

				else if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
				else if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
				else if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
				else if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
				else if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;
				else if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
				else if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79; // v2.06 12-4
				else if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80; // v2.15 ���������۾��׷��̵�
				else if (memcmp(token, "ip-muerte", 9) == 0) cReadModeA = 81;
				else if (memcmp(token, "Coins", 5) == 0) cReadModeA = 82;
				else if (memcmp(token, "heldenian-GUID", 14) == 0)    cReadModeA = 83;
				else if (memcmp(token, "Total-Client-Killed", 19) == 0) cReadModeA = 84;
				else if (memcmp(token, "Total-Quest-Completed", 21) == 0) cReadModeA = 85;
				else if (memcmp(token, "Hour-Play", 9) == 0) cReadModeA = 86;
				else if (memcmp(token, "Min-Play", 8) == 0) cReadModeA = 87;
				else if (memcmp(token, "CheckProcess", 12) == 0) cReadModeA = 88;
				else if (memcmp(token, "EventID", 7) == 0) cReadModeA = 89;
				else if (memcmp(token, "EventKill", 9) == 0) cReadModeA = 90;
				else if (memcmp(token, "EventDeath", 10) == 0) cReadModeA = 91;
				else if (memcmp(token, "Random-Event-ID", 15) == 0) cReadModeA = 100;
				else if (memcmp(token, "Event-Time-Playing", 18) == 0) cReadModeA = 101;
				else if (memcmp(token, "character-quest-number", 22) == 0) cReadModeA = 57;
				else if (memcmp(token, "current-quest-count", 19) == 0)	 cReadModeA = 58;
				else if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 60;
				else if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 61;
				else if (memcmp(token, "character-quest-ID", 18) == 0)        cReadModeA = 63;
				else if (memcmp(token, "item-quest-number", 17) == 0)		cReadModeA = 92;
				else if (memcmp(token, "item-quest-ID", 13) == 0)			cReadModeA = 93;
				else if (memcmp(token, "item-quest-count", 16) == 0)			cReadModeA = 94;
				else if (memcmp(token, "item-reward-type", 16) == 0)		cReadModeA = 95;
				else if (memcmp(token, "stated-quest-number", 19) == 0)		cReadModeA = 96;
				else if (memcmp(token, "stated-quest-ID", 15) == 0)			cReadModeA = 97;
				else if (memcmp(token, "stated-quest-count", 18) == 0)		cReadModeA = 98;
				else if (memcmp(token, "stated-reward-type", 18) == 0)		cReadModeA = 99;
				else if (memcmp(token, "character-rank-level", 20) == 0)		cReadModeA = 102;
				else if (memcmp(token, "character-rank-points", 21) == 0)		cReadModeA = 103;
				else if (memcmp(token, "character-rank-exp", 18) == 0)		cReadModeA = 104;
				else if (memcmp(token, "character-rank-addstr", 21) == 0)		cReadModeA = 105;
				else if (memcmp(token, "character-rank-addvit", 21) == 0)		cReadModeA = 106;
				else if (memcmp(token, "character-rank-addint", 21) == 0)		cReadModeA = 107;
				else if (memcmp(token, "character-rank-adddex", 21) == 0)		cReadModeA = 108;
				else if (memcmp(token, "character-rank-addmag", 21) == 0)		cReadModeA = 109;
				else if (memcmp(token, "character-candy-insert", 22) == 0)		cReadModeA = 110;
				else if (memcmp(token, "character-candy-delete", 22) == 0)		cReadModeA = 111;
				else if (memcmp(token, "character-no-drop", 17) == 0)		cReadModeA = 112;			
				else if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
			}
			token = pStrTok->pGet();
		}

	DPDC_STOP_DECODING:;

		delete pStrTok;
		delete[]pContents;
		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
			PutLogList(cTxt);

			HANDLE hFile2;
			DWORD  nWrite2;
			hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
			WriteFile(hFile2, (char *)pOriginContents, dwSize + 2, &nWrite2, NULL);
			CloseHandle(hFile2);
			return FALSE;
		}

		bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		if (bRet == FALSE) GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

		if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > 9999)) return FALSE;

		if (m_pClientList[iClientH]->m_iStr < 10) return FALSE;
		if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
			m_pClientList[iClientH]->m_iLU_Pool += m_pClientList[iClientH]->m_iStr - DEF_CHARPOINTLIMIT;
			m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
		}

		if (m_pClientList[iClientH]->m_iDex < 10) return FALSE;
		if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
			m_pClientList[iClientH]->m_iLU_Pool += m_pClientList[iClientH]->m_iDex - DEF_CHARPOINTLIMIT;
			m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
		}

		if (m_pClientList[iClientH]->m_iVit < 10) return FALSE;
		if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
			m_pClientList[iClientH]->m_iLU_Pool += m_pClientList[iClientH]->m_iVit - DEF_CHARPOINTLIMIT;
			m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
		}

		if (m_pClientList[iClientH]->m_iInt < 10) return FALSE;
		if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
			m_pClientList[iClientH]->m_iLU_Pool += m_pClientList[iClientH]->m_iInt - DEF_CHARPOINTLIMIT;
			m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
		}

		if (m_pClientList[iClientH]->m_iMag < 10) return FALSE;
		if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
			m_pClientList[iClientH]->m_iLU_Pool += m_pClientList[iClientH]->m_iMag - DEF_CHARPOINTLIMIT;
			m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
		}

		if (m_pClientList[iClientH]->m_iCharisma < 10) return FALSE;
		if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
			m_pClientList[iClientH]->m_iLU_Pool += m_pClientList[iClientH]->m_iCharisma - DEF_CHARPOINTLIMIT;
			m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;
		}

		if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE))
			return FALSE;

		if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
			GetLocalTime(&SysTime);
			iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear * 10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth * 100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
			iDateSum2 = (__int64)(SysTime.wYear * 10000 + SysTime.wMonth * 100 + SysTime.wDay);
			if (iDateSum1 >= iDateSum2) return FALSE;
		}

		if (m_pClientList[iClientH]->m_iReserveTime != 0) {
			GetLocalTime(&SysTime);
			iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
			iDateSum2 = (__int64)(SysTime.wMonth * 10000 + SysTime.wDay * 100 + SysTime.wHour);
			if (iDateSum2 >= iDateSum1) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
				m_pClientList[iClientH]->m_iFightzoneNumber = 0;
				m_pClientList[iClientH]->m_iReserveTime = 0;
				m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
			}
		}

		if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

		if (m_pClientList[iClientH]->m_cSex == 1) sTmpType = 1;
		else if (m_pClientList[iClientH]->m_cSex == 2) sTmpType = 4;

		switch (m_pClientList[iClientH]->m_cSkin) {
			case 1: break;
			case 2: sTmpType += 1; break;
			case 3: sTmpType += 2; break;
		}

		if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10)  sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

		sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

		m_pClientList[iClientH]->m_sType = sTmpType;
		m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

		iCalcTotalWeight(iClientH);
		if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
			int _i, _iTemp1, _iTemp2;
			short _sID1, _sID2, _sID3;

			_iTemp1 = 1;
			_iTemp2 = 1;
			for (_i = 0; _i < 10; _i++) {
				_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
				_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
			}

			_sID1 = (short)timeGetTime();
			_sID2 = (short)_iTemp1;
			_sID3 = (short)_iTemp2;

			m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
			m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
			m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
		}
		m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;

		// Check Old System Quest To Renew position --> no se una pija de ingles :P -> ZeroEoyPnk
		if (m_pClientList[iClientH]->m_iQuest > 200) {
			m_pClientList[iClientH]->m_iStatedQuest = m_pClientList[iClientH]->m_iQuest;
			m_pClientList[iClientH]->m_iStatedQuestID = m_pClientList[iClientH]->m_iQuestID;
			m_pClientList[iClientH]->m_iStatedQuestCount = m_pClientList[iClientH]->m_iCurQuestCount;
			m_pClientList[iClientH]->m_iStatedQuestRewardType = m_pClientList[iClientH]->m_iQuestRewardType;
			m_pClientList[iClientH]->m_iQuest = 0;
			m_pClientList[iClientH]->m_iQuestID = 0;
			m_pClientList[iClientH]->m_iCurQuestCount = 0;
			m_pClientList[iClientH]->m_iQuestRewardType = 0;
			m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		}
		else if (m_pClientList[iClientH]->m_iQuest > 100) {
			m_pClientList[iClientH]->m_iItemQuest = m_pClientList[iClientH]->m_iQuest;
			m_pClientList[iClientH]->m_iItemQuestID = m_pClientList[iClientH]->m_iQuestID;
			m_pClientList[iClientH]->m_iItemQuestCount = m_pClientList[iClientH]->m_iCurQuestCount;
			m_pClientList[iClientH]->m_iItemQuestRewardType = m_pClientList[iClientH]->m_iQuestRewardType;
			m_pClientList[iClientH]->m_iQuest = 0;
			m_pClientList[iClientH]->m_iQuestID = 0;
			m_pClientList[iClientH]->m_iCurQuestCount = 0;
			m_pClientList[iClientH]->m_iQuestRewardType = 0;
			m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		mtx.lock();
		bCheckClient[iClientH] = FALSE;
		m_iTotalClients--;
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = NULL;
		RemoveClientShortCut(iClientH);

		mtx.unlock();
		//DeleteClient(iClientH, FALSE, FALSE);
		ErrorList("Crash Evitado en: _bDecodePlayerDatafileContents");
		return FALSE;
	}
#endif
	return TRUE;
}

int CMapServer::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
	int size = 0;
#ifdef DEF_DEBUG
	try {
#endif
		SYSTEMTIME SysTime;
		char  cTxt[120], cTmp[21];
		POINT TempItemPosList[DEF_MAXITEMS];
		int   i, iPos;

		if (m_pClientList[iClientH] == NULL) return 0;

		GetLocalTime(&SysTime);
		strcat(pData, "[FILE-DATE]\n\n");

		wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "[NAME-ACCOUNT]\n\n");
		strcat(pData, "character-name     = ");
		strcat(pData, m_pClientList[iClientH]->m_cCharName);
		strcat(pData, "\n");
		strcat(pData, "account-name       = ");
		strcat(pData, m_pClientList[iClientH]->m_cAccountName);
		strcat(pData, "\n");
		wsprintf(cTxt, "Hour-Play = %d", m_pClientList[iClientH]->HourPlaying);
		strcat(pData, cTxt);
		strcat(pData, "\n");
		wsprintf(cTxt, "Min-Play = %d", m_pClientList[iClientH]->MinPlaying);
		strcat(pData, cTxt);
		strcat(pData, "\n\n");

		if (m_pClientList[iClientH]->CheckProcess) wsprintf(cTxt, "CheckProcess = ON");
		else wsprintf(cTxt, "CheckProcess = OFF");
		strcat(pData, cTxt);

		strcat(pData, "\n\n[NAME-ACCOUNT]\n\n");
		strcat(pData, "character-profile 	=");
		if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) strcat(pData, "__________");
		else strcat(pData, m_pClientList[iClientH]->m_cProfile);
		strcat(pData, "\n");

		strcat(pData, "character-location   = ");
		strcat(pData, m_pClientList[iClientH]->m_cLocation);
		strcat(pData, "\n");

		strcat(pData, "character-guild-name = ");
		if (m_pClientList[iClientH]->m_iGuildRank != -1) strcat(pData, m_pClientList[iClientH]->m_cGuildName);
		else strcat(pData, "NONE");
		strcat(pData, "\n");

		strcat(pData, "character-guild-GUID = ");
		if (m_pClientList[iClientH]->m_iGuildRank != -1) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
			strcat(pData, cTxt);
		}
		else strcat(pData, "-1");
		strcat(pData, "\n");

		strcat(pData, "character-guild-rank = ");
		itoa(m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "\n\n[MAP-DATA]\n\n");
		strcat(pData, "character-loc-map = ");
		strcat(pData, m_pClientList[iClientH]->m_cMapName);
		strcat(pData, "\n");

		strcat(pData, "character-loc-x   = ");
		itoa(m_pClientList[iClientH]->m_sX, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "character-loc-y   = ");
		itoa(m_pClientList[iClientH]->m_sY, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n\n");

		wsprintf(cTxt, "locked-map-name = %s\n", m_pClientList[iClientH]->m_cLockedMapName);
		strcat(pData, cTxt);

		wsprintf(cTxt, "locked-map-time = %d\n", m_pClientList[iClientH]->m_iLockedMapTime);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[STATS]\n\n");
		wsprintf(cTxt, "character-EXP      = %d\n", m_pClientList[iClientH]->m_iExp);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-LEVEL    = %d\n", m_pClientList[iClientH]->m_iLevel);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-LU_Pool  = %d\n", m_pClientList[iClientH]->m_iLU_Pool);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-STR      = %d\n", m_pClientList[iClientH]->m_iStr);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-INT      = %d\n", m_pClientList[iClientH]->m_iInt);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-VIT      = %d\n", m_pClientList[iClientH]->m_iVit);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-DEX      = %d\n", m_pClientList[iClientH]->m_iDex);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-MAG      = %d\n", m_pClientList[iClientH]->m_iMag);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-CHARISMA = %d\n", m_pClientList[iClientH]->m_iCharisma);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[STATUS]\n\n");
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
		wsprintf(cTxt, "character-HP       = %d\n", m_pClientList[iClientH]->m_iHP);
		strcat(pData, cTxt);

		if (m_pClientList[iClientH]->m_iMP < 0) m_pClientList[iClientH]->m_iMP = 0;
		wsprintf(cTxt, "character-MP       = %d\n", m_pClientList[iClientH]->m_iMP);
		strcat(pData, cTxt);

		if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0;
		wsprintf(cTxt, "character-SP       = %d\n", m_pClientList[iClientH]->m_iSP);
		strcat(pData, cTxt);

		strcat(pData, "sex-status       = ");
		itoa(m_pClientList[iClientH]->m_cSex, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "skin-status      = ");
		itoa(m_pClientList[iClientH]->m_cSkin, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "hairstyle-status = ");
		itoa(m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "haircolor-status = ");
		itoa(m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "underwear-status = ");
		itoa(m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		wsprintf(cTxt, "hunger-status    = %d\n", m_pClientList[iClientH]->m_iHungerStatus);
		strcat(pData, cTxt);

		wsprintf(cTxt, "admin-user-level = %d\n", m_pClientList[iClientH]->m_iAdminUserLevel);
		strcat(pData, cTxt);

		wsprintf(cTxt, "party-id = %d\n", m_pClientList[iClientH]->m_iPartyID);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[TIMMERS]\n\n");
		wsprintf(cTxt, "timeleft-shutup  = %d\n", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
		strcat(pData, cTxt);

		wsprintf(cTxt, "timeleft-rating  = %d\n", m_pClientList[iClientH]->m_iTimeLeft_Rating);
		strcat(pData, cTxt);

		wsprintf(cTxt, "timeleft-force-recall  = %d\n", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
		strcat(pData, cTxt);

		wsprintf(cTxt, "timeleft-firm-staminar = %d\n", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
		strcat(pData, cTxt);

		wsprintf(cTxt, "dead-penalty-time = %d\n", m_pClientList[iClientH]->m_iDeadPenaltyTime);
		strcat(pData, cTxt);

		wsprintf(cTxt, "penalty-block-date = %d %d %d\n", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
		strcat(pData, cTxt);

		wsprintf(cTxt, "special-ability-time = %d\n", m_pClientList[iClientH]->m_iSpecialAbilityTime);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[POINTS]\n\n");
		wsprintf(cTxt, "Assasain-Count = %d\n", m_pClientList[iClientH]->AssasainPoint);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-RATING   = %d\n", m_pClientList[iClientH]->m_iRating);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-EK-Count = %d\n", m_pClientList[iClientH]->m_iEnemyKillCount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-EK-TotalCount = %d\n", m_pClientList[iClientH]->m_iEnemyKillTotalCount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-PK-Count = %d\n", m_pClientList[iClientH]->m_iPKCount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-FK-Count = %d\n", m_pClientList[iClientH]->m_iCityFriendKilled);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-contribution = %d\n", m_pClientList[iClientH]->m_iContribution);
		strcat(pData, cTxt);

		wsprintf(cTxt, "gizon-item-upgade-left = %d\n", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
		strcat(pData, cTxt);

		wsprintf(cTxt, "super-attack-left = %d\n", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
		strcat(pData, cTxt);

		wsprintf(cTxt, "Coins = %d\n", m_pClientList[iClientH]->m_iCoins);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[QUEST]\n\n");
		wsprintf(cTxt, "character-quest-number = %d\n", m_pClientList[iClientH]->m_iQuest);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-quest-ID     = %d\n", m_pClientList[iClientH]->m_iQuestID);
		strcat(pData, cTxt);

		wsprintf(cTxt, "current-quest-count    = %d\n", m_pClientList[iClientH]->m_iCurQuestCount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "quest-reward-type      = %d\n", m_pClientList[iClientH]->m_iQuestRewardType);
		strcat(pData, cTxt);

		wsprintf(cTxt, "quest-reward-amount    = %d\n", m_pClientList[iClientH]->m_iQuestRewardAmount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "item-quest-number	   = %d\n", m_pClientList[iClientH]->m_iItemQuest);
		strcat(pData, cTxt);

		wsprintf(cTxt, "item-quest-ID		   = %d\n", m_pClientList[iClientH]->m_iItemQuestID);
		strcat(pData, cTxt);

		wsprintf(cTxt, "item-quest-count	   = %d\n", m_pClientList[iClientH]->m_iItemQuestCount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "item-reward-type       = %d\n", m_pClientList[iClientH]->m_iItemQuestRewardType);
		strcat(pData, cTxt);

		wsprintf(cTxt, "stated-quest-number    = %d\n", m_pClientList[iClientH]->m_iStatedQuest);
		strcat(pData, cTxt);

		wsprintf(cTxt, "stated-quest-ID        = %d\n", m_pClientList[iClientH]->m_iStatedQuestID);
		strcat(pData, cTxt);

		wsprintf(cTxt, "stated-quest-count     = %d\n", m_pClientList[iClientH]->m_iStatedQuestCount);
		strcat(pData, cTxt);

		wsprintf(cTxt, "stated-reward-type     = %d\n", m_pClientList[iClientH]->m_iStatedQuestRewardType);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[ACHIVEMENTS]\n\n");
		wsprintf(cTxt, "Total-Mobs-Killed = %d\n", m_pClientList[iClientH]->TotalMobsKilled);
		strcat(pData, cTxt);

		wsprintf(cTxt, "Total-Death = %d\n", m_pClientList[iClientH]->TotalDeath);
		strcat(pData, cTxt);

		wsprintf(cTxt, "Total-Client-Killed = %d\n", m_pClientList[iClientH]->TotalClientKilled);
		strcat(pData, cTxt);

		wsprintf(cTxt, "Total-Quest-Completed = %d\n", m_pClientList[iClientH]->TotalQuestCompleted);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[DATA-EVENTS]\n\n");
		wsprintf(cTxt, "crusade-job = %d\n", m_pClientList[iClientH]->m_iCrusadeDuty);
		strcat(pData, cTxt);

		wsprintf(cTxt, "crusade-GUID = %d\n", m_pClientList[iClientH]->m_dwCrusadeGUID);
		strcat(pData, cTxt);

		wsprintf(cTxt, "construct-point = %d\n", m_pClientList[iClientH]->m_iConstructionPoint);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-war-contribution = %d\n", m_pClientList[iClientH]->m_iWarContribution);
		strcat(pData, cTxt);

		wsprintf(cTxt, "EventID = %d\n", FinalFight_ID);
		strcat(pData, cTxt);

		wsprintf(cTxt, "EventKill = %d\n", m_pClientList[iClientH]->Event_Killed);
		strcat(pData, cTxt);

		wsprintf(cTxt, "EventDeath = %d\n", m_pClientList[iClientH]->Event_Death);
		strcat(pData, cTxt);

		wsprintf(cTxt, "Random-Event-ID = %d\n", m_pClientList[iClientH]->RndEventID);
		strcat(pData, cTxt);

		wsprintf(cTxt, "Event-Time-Playing = %d\n", m_pClientList[iClientH]->EventMinPlaying);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[OTHER-DATA]\n\n");
		wsprintf(cTxt, "character-IDnum1 = %d\n", m_pClientList[iClientH]->m_sCharIDnum1);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-IDnum2 = %d\n", m_pClientList[iClientH]->m_sCharIDnum2);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-IDnum3 = %d\n", m_pClientList[iClientH]->m_sCharIDnum3);
		strcat(pData, cTxt);

		wsprintf(cTxt, "reserved-fightzone-id = %d %d %d\n", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime, m_pClientList[iClientH]->m_iFightZoneTicketNumber);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-reward-gold = %d\n", m_pClientList[iClientH]->m_iRewardGold);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-downskillindex = %d\n", m_pClientList[iClientH]->m_iDownSkillIndex);
		strcat(pData, cTxt);

		strcat(pData, "ip-muerte = ");
		strcat(pData, m_pClientList[iClientH]->m_cIP2);
		strcat(pData, "\n");

		strcat(pData, "\n\n");

		strcat(pData, "appr1 = ");
		itoa(m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
		strcat(pData, "appr2 = ");

		itoa(m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
		strcat(pData, "appr3 = ");
		itoa(m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
		strcat(pData, "appr4 = ");
		itoa(m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "appr-color = ");
		itoa(m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");

		// New Colors -> ZeroEoyPnk
		strcat(pData, "appr-color2 = ");
		itoa(m_pClientList[iClientH]->m_iApprColor2, cTxt, 10);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[RANK-SYSTEM]\n\n");//Agregado

		wsprintf(cTxt, "character-rank-level = %d\n", m_pClientList[iClientH]->m_sRankLevel);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rank-points = %d\n", m_pClientList[iClientH]->m_iRankPoints);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rank-exp = %d\n", m_pClientList[iClientH]->m_iRankExp);
		strcat(pData, cTxt);
		strcat(pData, "\n"); //Agregado
		wsprintf(cTxt, "character-rank-addstr = %d\n", m_pClientList[iClientH]->m_sRankAddStr);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rank-addvit = %d\n", m_pClientList[iClientH]->m_sRankAddVit);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rank-addint = %d\n", m_pClientList[iClientH]->m_sRankAddInt);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rank-adddex = %d\n", m_pClientList[iClientH]->m_sRankAddDex);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rank-addmag = %d\n", m_pClientList[iClientH]->m_sRankAddMag);
		strcat(pData, cTxt);

		//HeatoN 2024
		strcat(pData, "\n\n[ENCHANTING]\n\n");

		wsprintf(cTxt, "character-shard-light = %d\n", m_pClientList[iClientH]->shard_light);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-shard-strong = %d\n", m_pClientList[iClientH]->shard_strong);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-hp = %d\n", m_pClientList[iClientH]->fragment_hp);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-dr = %d\n", m_pClientList[iClientH]->fragment_dr);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-hprec = %d\n", m_pClientList[iClientH]->fragment_hprec);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-sprec = %d\n", m_pClientList[iClientH]->fragment_sprec);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-mprec = %d\n", m_pClientList[iClientH]->fragment_mprec);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-mr = %d\n", m_pClientList[iClientH]->fragment_mr);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-pa = %d\n", m_pClientList[iClientH]->fragment_pa);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-ma = %d\n", m_pClientList[iClientH]->fragment_ma);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-fragment-exp = %d\n", m_pClientList[iClientH]->fragment_exp);
		strcat(pData, cTxt);

		strcat(pData, "\n\n[DONNER-SYSTEM]\n\n");//Agregado

		wsprintf(cTxt, "character-candy-insert = %d\n", m_pClientList[iClientH]->m_sCandyInsert);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-candy-delete = %d\n", m_pClientList[iClientH]->m_sCandyDelete);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-no-drop = %d", m_pClientList[iClientH]->m_sNoDrop);
		strcat(pData, cTxt);
		
		//HeatoN 2024
		strcat(pData, "\n\n[REBIRTH]\n\n");

		wsprintf(cTxt, "character-rebirth-level = %d\n", m_pClientList[iClientH]->m_iRebirthLevel);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rebirth-status = %d\n", m_pClientList[iClientH]->m_sRebirthStatus);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-rebirth-enabled = %d\n", m_pClientList[iClientH]->m_sRebirthEnabled);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-rebirth-level = %d\n", m_pClientList[iClientH]->m_iBackRebirthLevel);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-exp = %d\n", m_pClientList[iClientH]->m_iBackExp);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-stats-point = %d\n", m_pClientList[iClientH]->m_iBackStatsPoint);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-str = %d\n", m_pClientList[iClientH]->m_iBackStr);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-vit = %d\n", m_pClientList[iClientH]->m_iBackVit);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-int = %d\n", m_pClientList[iClientH]->m_iBackInt);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-dex = %d\n", m_pClientList[iClientH]->m_iBackDex);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-chr = %d\n", m_pClientList[iClientH]->m_iBackChr);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-mag = %d\n", m_pClientList[iClientH]->m_iBackMag);
		strcat(pData, cTxt);

		wsprintf(cTxt, "character-back-level = %d", m_pClientList[iClientH]->m_iBackLevel);
		strcat(pData, cTxt);

		strcat(pData, "\n\n");

		strcat(pData, "[ITEMLIST]\n\n");

		for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
			TempItemPosList[i].x = 40;
			TempItemPosList[i].y = 30;
		}
		iPos = 0;

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
				TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
				iPos++;

				strcat(pData, "character-item = ");
				memset(cTmp, ' ', 21);
				strcpy_secure(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
				cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
				cTmp[20] = NULL;
				strcat(pData, cTmp);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->GetBagPositionX(), cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemList[i]->GetBagPositionY(), cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, "\n");
			}
		}
		strcat(pData, "\n\n");

		for (i = 0; i < DEF_MAXITEMS; i++) {
			m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x;
			m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
		}

		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
				strcat(pData, "character-bank-item = ");
				memset(cTmp, ' ', 21);
				strcpy_secure(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
				cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
				cTmp[20] = NULL;
				strcat(pData, cTmp);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, " ");
				// ZeroEoyPnk - Wh Page
				itoa(m_pClientList[iClientH]->m_pItemInBankList[i]->GetBankPosition(), cTxt, 10);
				strcat(pData, cTxt);
				strcat(pData, "\n");
			}
		}
		strcat(pData, "\n\n");

		strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

		strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
		strcat(pData, "\n");

		strcat(pData, "magic-mastery     = ");
		for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
			wsprintf(cTxt, "%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
			strcat(pData, cTxt);
		}
		strcat(pData, "\n");

		strcat(pData, "skill-mastery     = ");

		for (i = 0; i < 60; i++) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

			strcat(pData, cTxt); // ��±â°ª ��·�
		}
		strcat(pData, "\n");

		strcat(pData, "skill-SSN     = ");
		for (i = 0; i < 60; i++) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

			strcat(pData, cTxt); // ��±â°ª ��·�
		}
		strcat(pData, "\n\n");

		strcat(pData, "Achivements     = ");
		for (i = 0; i < DEF_MAXACHIVEMENTS; i++) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%d ", m_pClientList[iClientH]->Achivements[i].Contador);

			strcat(pData, cTxt);
		}
		strcat(pData, "\n\n");

		strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
		strcat(pData, "item-equip-status = ");

		ZeroMemory(cTxt, sizeof(cTxt));
		strcpy_secure(cTxt, "00000000000000000000000000000000000000000000000000");

		int iEP = 0;
		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
					cTxt[iEP] = '1';
				}
				iEP++;
			}
		}
		strcat(pData, cTxt);
		strcat(pData, "\n");

		strcat(pData, "item-position-x = ");
		for (i = 0; i < DEF_MAXITEMS; i++) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
			strcat(pData, cTxt);
		}
		strcat(pData, "\n");

		strcat(pData, "item-position-y = ");
		for (i = 0; i < DEF_MAXITEMS; i++) {
			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
			strcat(pData, cTxt);
		}
		strcat(pData, "\n\n");

		strcat(pData, "[EOF]");
		strcat(pData, "\n\n\n\n");

		size = strlen(pData);

#ifdef DEF_DEBUG
	}
	catch (...) {

		ErrorList("Crash Evitado en: _iComposePlayerDataFileContents");
	}
#endif
	return size;
}

BOOL CMapServer::_bDecodeItemConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemConfigListIndex = 0, iTemp;
	class CStrTok * pStrTok;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading ITEM configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								iItemConfigListIndex = atoi(token);

								if (iItemConfigListIndex == 490)
									iItemConfigListIndex = atoi(token);

								if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
									wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
									PutLogList(cTxt);
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex] = new class CItem;
								m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
								cReadModeB = 2;
								break;

							case 2:
								// m_cName 
								ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
								memcpy_secure(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
								if (memcmp(m_pItemConfigList[iItemConfigListIndex]->m_cName, "���̾�Ʈ-�ҵ�", strlen("���̾�Ʈ-�ҵ�")) == 0) {
									int i;
									i = 0;
								}
								cReadModeB = 3;
								break;

							case 3:
								// m_cItemType
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								// m_cEquipPos
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								// m_sItemEffectType
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								// m_sItemEffectValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								// m_sItemEffectValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// m_sItemEffectValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// m_sItemEffectValue4
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								// m_sItemEffectValue5
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								// m_sItemEffectValue6
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
								cReadModeB = 12;
								break;

							case 12:
								// m_wMaxLifeSpan
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								//Fix Endu
								m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (int)atoi(token);
								cReadModeB = 13;
								break;

							case 13:
								// m_sSpecialEffect
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								// m_sSprite
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
								cReadModeB = 15;
								break;

							case 15:
								// m_sSpriteFrame
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
								cReadModeB = 16;
								break;

							case 16:
								// m_wPrice
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								iTemp = atoi(token);
								if (iTemp < 0)
									m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
								else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;

								m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
								cReadModeB = 17;
								break;

							case 17:
								// m_wWeight
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
								cReadModeB = 18;
								break;

							case 18:
								// Appr Value
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
								cReadModeB = 19;
								break;

							case 19:
								// m_cSpeed
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
								cReadModeB = 20;
								break;

							case 20:
								// m_sLevelLimit
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
								cReadModeB = 21;
								break;

							case 21:
								// m_cGederLimit
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
								cReadModeB = 22;
								break;

							case 22:
								// m_sSpecialEffectValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
								cReadModeB = 23;
								break;

							case 23:
								// m_sSpecialEffectValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
								cReadModeB = 24;
								break;

							case 24:
								// m_sRelatedSkill
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
								cReadModeB = 25;
								break;

							case 25:
								// m_cCategory
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
								cReadModeB = 26;
								break;

							case 26:
								// m_cItemColor
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "Item", 4) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}

				if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
					cReadModeA = 0;
					cReadModeB = 0;
					goto DICFC_STOPDECODING;
				}
			}
			token = pStrTok->pGet();
		}

	DICFC_STOPDECODING:;

		delete pStrTok;
		delete[]pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
		PutLogList(cTxt);

		m_bReceivedItemList = true;

		return TRUE;
	}
}

BOOL CMapServer::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		char cTmpName[22];

		ZeroMemory(cTmpName, sizeof(cTmpName));
		memcpy_secure(cTmpName, pItemName, 20);

		for (i = 0; i < DEF_MAXITEMTYPES; i++) {
			if (m_pItemConfigList[i] != NULL) {
				if (strcmp(cTmpName, m_pItemConfigList[i]->m_cName) == 0) {
					ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
					strcpy_secure(pItem->m_cName, m_pItemConfigList[i]->m_cName);
					pItem->m_cItemType = m_pItemConfigList[i]->m_cItemType;
					pItem->m_cEquipPos = m_pItemConfigList[i]->m_cEquipPos;
					pItem->m_sItemEffectType = m_pItemConfigList[i]->m_sItemEffectType;
					pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
					pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
					pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
					pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
					pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
					pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
					pItem->m_wMaxLifeSpan = m_pItemConfigList[i]->m_wMaxLifeSpan;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					pItem->m_sSpecialEffect = m_pItemConfigList[i]->m_sSpecialEffect;

					pItem->m_sSprite = m_pItemConfigList[i]->m_sSprite;
					pItem->m_sSpriteFrame = m_pItemConfigList[i]->m_sSpriteFrame;
					pItem->m_wPrice = m_pItemConfigList[i]->m_wPrice;
					pItem->m_wWeight = m_pItemConfigList[i]->m_wWeight;
					pItem->m_cApprValue = m_pItemConfigList[i]->m_cApprValue;
					pItem->m_cSpeed = m_pItemConfigList[i]->m_cSpeed;
					pItem->m_sLevelLimit = m_pItemConfigList[i]->m_sLevelLimit;
					pItem->m_cGenderLimit = m_pItemConfigList[i]->m_cGenderLimit;

					pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
					pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

					pItem->m_sRelatedSkill = m_pItemConfigList[i]->m_sRelatedSkill;
					pItem->m_cCategory = m_pItemConfigList[i]->m_cCategory;
					pItem->m_sIDnum = m_pItemConfigList[i]->m_sIDnum;

					pItem->m_bIsForSale = m_pItemConfigList[i]->m_bIsForSale;
					pItem->m_cItemColor = m_pItemConfigList[i]->m_cItemColor;
					return TRUE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bInitItemAttr");
	}
#endif
	return FALSE;
}

BOOL CMapServer::_bInitItemAttr(class CItem * pItem, int iItemID)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		char cTmpName[21];

		ZeroMemory(cTmpName, sizeof(cTmpName));

		for (i = 0; i < DEF_MAXITEMTYPES; i++) {
			if (m_pItemConfigList[i] != NULL) {
				if (iItemID == m_pItemConfigList[i]->m_sIDnum) {
					ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
					strcpy_secure(pItem->m_cName, m_pItemConfigList[i]->m_cName);
					pItem->m_cItemType = m_pItemConfigList[i]->m_cItemType;
					pItem->m_cEquipPos = m_pItemConfigList[i]->m_cEquipPos;
					pItem->m_sItemEffectType = m_pItemConfigList[i]->m_sItemEffectType;
					pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
					pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
					pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
					pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
					pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
					pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
					pItem->m_wMaxLifeSpan = m_pItemConfigList[i]->m_wMaxLifeSpan;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					pItem->m_sSpecialEffect = m_pItemConfigList[i]->m_sSpecialEffect;

					pItem->m_sSprite = m_pItemConfigList[i]->m_sSprite;
					pItem->m_sSpriteFrame = m_pItemConfigList[i]->m_sSpriteFrame;
					pItem->m_wPrice = m_pItemConfigList[i]->m_wPrice;
					pItem->m_wWeight = m_pItemConfigList[i]->m_wWeight;
					pItem->m_cApprValue = m_pItemConfigList[i]->m_cApprValue;
					pItem->m_cSpeed = m_pItemConfigList[i]->m_cSpeed;
					pItem->m_sLevelLimit = m_pItemConfigList[i]->m_sLevelLimit;
					pItem->m_cGenderLimit = m_pItemConfigList[i]->m_cGenderLimit;

					pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
					pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

					pItem->m_sRelatedSkill = m_pItemConfigList[i]->m_sRelatedSkill;
					pItem->m_cCategory = m_pItemConfigList[i]->m_cCategory;
					pItem->m_sIDnum = m_pItemConfigList[i]->m_sIDnum;

					pItem->m_bIsForSale = m_pItemConfigList[i]->m_bIsForSale;
					pItem->m_cItemColor = m_pItemConfigList[i]->m_cItemColor;
					return TRUE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bInitItemAttr");
	}
#endif
	return FALSE;
}

BOOL CMapServer::_bGetIsStringIsNumber(char * pStr)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		for (i = 0; i < (int)strlen(pStr); i++)
			if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;

		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bGetIsStringIsNumber");

	}
#endif
	return FALSE;
}

BOOL CMapServer::_bReadMapInfoFiles(int iMapIndex)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (__bReadMapInfo(iMapIndex) == FALSE) return FALSE;
		return TRUE;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bGetIsStringIsNumber");

	}
#endif
	return FALSE;
}

BOOL CMapServer::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iIndex, iMapIndex, iFollowIndex;
		char cTmpName[11], cFollowSide;

		ZeroMemory(cTmpName, sizeof(cTmpName));
		iMapIndex = -1;
		iFollowIndex = -1;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0)) {
				iIndex = i;
				iMapIndex = m_pNpcList[i]->m_cMapIndex;
				goto NEXT_STEP_SNFM1;
			}
		}

	NEXT_STEP_SNFM1:;

		switch (cFollowOwnerType) {
			case DEF_OWNERTYPE_NPC:
				for (i = 1; i < DEF_MAXNPCS; i++)
					if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0)) {
						if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
						iFollowIndex = i;
						cFollowSide = m_pNpcList[i]->m_cSide;
						goto NEXT_STEP_SNFM2;
					}
				break;

			case DEF_OWNERTYPE_PLAYER:
				for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0)) {
						if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
						iFollowIndex = i;
						if (m_pClientList[i]->Assasain)
							cFollowSide = 11;
						else
							cFollowSide = m_pClientList[i]->m_cSide;
						goto NEXT_STEP_SNFM2;
					}
				break;
		}

	NEXT_STEP_SNFM2:;

		if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

		m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
		m_pNpcList[iIndex]->m_cFollowOwnerType = cFollowOwnerType;
		m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
		m_pNpcList[iIndex]->m_cSide = cFollowSide;

		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetNpcFollowMode");
	}
#endif
	return FALSE;
}

BOOL CMapServer::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, t, j, k, iMapIndex;
		char  cTmpName[11], cTxt[120];
		short sX, sY, sRange;
		BOOL  bFlag;
		SYSTEMTIME SysTime;

		if (strlen(pName) == 0)   return FALSE;
		if (strlen(pNpcName) == 0) return FALSE;

		GetLocalTime(&SysTime);

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pMapName);
		iMapIndex = -1;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)
					iMapIndex = i;
			}
		}
		//lalo Abaddon
		if ((m_bIsApocalypseMode == TRUE) && (memcmp(cTmpName, "abaddon", 7) == 0) && (memcmp(pNpcName, "Abaddon", 7) != 0)) return FALSE;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)
					iMapIndex = i;
			}
		}

		if (iMapIndex == -1) return FALSE;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] == NULL) {
				m_pNpcList[i] = new class CNpc(pName);

				if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
					wsprintf(cTxt, "Not existing NPC creation request! (%s) Ignored.", pNpcName);
					PutLogList(cTxt);

					delete m_pNpcList[i];
					m_pNpcList[i] = NULL;
					return FALSE;
				}

				m_pNpcList[i]->m_iMaxHP = m_pNpcList[i]->m_iHP;

				if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
					if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek) {
						delete m_pNpcList[i];
						m_pNpcList[i] = NULL;
						return FALSE;
					}
				}

				ZeroMemory(m_pNpcList[i]->m_cMapName, sizeof(m_pNpcList[i]->m_cMapName));
				strcpy(m_pNpcList[i]->m_cMapName, pMapName);

				switch (cMoveType) {
					case DEF_MOVETYPE_GUARD:
					case DEF_MOVETYPE_RANDOM:
						if ((poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL)) {
							sX = *poX;
							sY = *poY;
						}
						else {
							for (j = 0; j <= 30; j++) {
								sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
								sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

								bFlag = TRUE;
								for (k = 0; k < DEF_MAXMGAR; k++) {
									if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
										if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
											(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
											(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
											(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
											bFlag = FALSE;
										}
									}
								}
								if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;
							}
							delete m_pNpcList[i];
							m_pNpcList[i] = NULL;
							return FALSE;

						GET_VALIDLOC_SUCCESS:;
						}
						break;

					case DEF_MOVETYPE_RANDOMAREA:
						sRange = (short)(pArea->right - pArea->left);
						sX = (short)((rand() % sRange) + pArea->left);
						sRange = (short)(pArea->bottom - pArea->top);
						sY = (short)((rand() % sRange) + pArea->top);
						break;

					case DEF_MOVETYPE_RANDOMWAYPOINT:
						sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1, 10) - 1]].x;
						sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1, 10) - 1]].y;
						break;

					default:
						if ((poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL)) {
							sX = *poX;
							sY = *poY;
						}
						else {
							sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
							sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
						}
						break;
				}

				if (m_pNpcList[i]->m_sAreaSize == 0) {
					if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {
						delete m_pNpcList[i];
						m_pNpcList[i] = NULL;
						return FALSE;
					}
				}
				else {
					if (bGetNpcMovementArea(i, sX, sY, iMapIndex, m_pNpcList[i]->m_sAreaSize) == FALSE) {
						delete m_pNpcList[i];
						m_pNpcList[i] = NULL;
						return FALSE;
					}
				}

				if ((bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0)) {
					delete m_pNpcList[i];
					m_pNpcList[i] = NULL;
					return FALSE;
				}

				if ((poX != NULL) && (poY != NULL)) {
					*poX = sX;
					*poY = sY;
				}

				m_pNpcList[i]->m_sX = sX;
				m_pNpcList[i]->m_sY = sY;

				m_pNpcList[i]->m_vX = sX;
				m_pNpcList[i]->m_vY = sY;

				for (t = 0; t < 10; t++)
					m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

				m_pNpcList[i]->m_cTotalWaypoint = 0;
				for (t = 0; t < 10; t++)
					if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

				if (pArea != NULL) {
					// RANDOMAREA Copy
					SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
				}

				switch (cMoveType) {
					case DEF_MOVETYPE_GUARD:
						m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
						m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
						break;

					case DEF_MOVETYPE_SEQWAYPOINT:
						m_pNpcList[i]->m_cCurWaypoint = 1;

						m_pNpcList[i]->m_dX = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].x;
						m_pNpcList[i]->m_dY = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].y;
						break;

					case DEF_MOVETYPE_RANDOMWAYPOINT:
						m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;

						m_pNpcList[i]->m_dX = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].x;
						m_pNpcList[i]->m_dY = (short)m_pMapList[iMapIndex]->m_WaypointList[m_pNpcList[i]->m_iWayPointIndex[m_pNpcList[i]->m_cCurWaypoint]].y;
						break;

					case DEF_MOVETYPE_RANDOMAREA:
						m_pNpcList[i]->m_cCurWaypoint = 0;

						sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
						m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
						sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
						m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
						break;

					case DEF_MOVETYPE_RANDOM:
						m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
						m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
						break;
				}

				m_pNpcList[i]->m_tmp_iError = 0;
				m_pNpcList[i]->m_cMoveType = cMoveType;

				switch (m_pNpcList[i]->m_cActionLimit) {
					case 2:
					case 3:
					case 5:
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;

						switch (m_pNpcList[i]->m_sType) {
							case 15: // ShopKeeper-W
							case 19: // Gandlf
							case 20: // Howard
							case 24: // Tom
							case 25: // William
							case 26: // Kennedy
								m_pNpcList[i]->m_cDir = 4 + iDice(1, 3) - 1;
								break;
							case 91:
								m_pNpcList[i]->m_cDir = 3;
								break;
							case 111:
								m_pNpcList[i]->m_cDir = 0;
								break;
							default:
								m_pNpcList[i]->m_cDir = iDice(1, 8);
								break;
						}
						break;

					default:
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
						m_pNpcList[i]->m_cDir = 5;
						break;
				}
				m_pNpcList[i]->m_iFollowOwnerIndex = NULL;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTurn = (rand() % 2);

				switch (m_pNpcList[i]->m_sType) {
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						m_pNpcList[i]->m_sAppr2 = (short)0xF000;
						m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // ����
						m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // ���� 
						break;

					case 36:
					case 37:
						m_pNpcList[i]->m_sAppr2 = 3;
						break;

					case 38: // MS-Aresden/MS-Elvine
					case 39: // DT-Aresden/DT-Elvine
						if ((m_bIsRushNetMode == TRUE) || (RunSummonEvent) || (RunSummonEvent2) || (RunSummonEvent3))
							m_pNpcList[i]->m_sAppr2 = 0;
						else
							m_pNpcList[i]->m_sAppr2 = 3;
						break;

					case 66:
					case 73:
					case 114:
					//case 128:
					//case 120:
						m_pNpcList[i]->m_sAreaSize = 3;
						break;

					case 81:
						// ZeroEoyPnk 
						m_pNpcList[i]->m_sAreaSize = 3;
						if (PriceEvent == TRUE)
							m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIA;
						break;

					case 92:
						// ZeroEoyPnk 
						if (m_bIsRushNetMode)
							m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIA; //DEF_MAXHPRELIQUIAHOD
						break;
						if (HellOfDeath)
							m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIAHOD; //DEF_MAXHPRELIQUIAHOD
						break;

					case 120:
						// ZeroEoyPnk 
						m_pNpcList[i]->m_sAreaSize = 3;
						if (WWPriceEvent == TRUE)
							m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIA;
						break;

					case 128:
						// ZeroEoyPnk 
						m_pNpcList[i]->m_sAreaSize = 3;
						if (WWIIPriceEvent == TRUE)
							m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIAWWII;
						break;

					default:
						m_pNpcList[i]->m_sAppr2 = 0;
						break;
				}

				m_pNpcList[i]->m_cMapIndex = (char)iMapIndex;
				m_pNpcList[i]->m_dwTime = timeGetTime() + (rand() % 10000);
				m_pNpcList[i]->m_dwActionTime += (rand() % 300);
				m_pNpcList[i]->m_dwMPupTime = timeGetTime();
				m_pNpcList[i]->m_dwHPupTime = m_pNpcList[i]->m_dwMPupTime;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_bIsSummoned = bIsSummoned;
				m_pNpcList[i]->m_bIsMaster = bIsMaster;
				if (bIsSummoned == TRUE)
					m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

				if (bFirmBerserk == TRUE) {
					m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
					m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20; // 100000
					m_pNpcList[i]->m_iExp *= 2;
				}

				if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

				m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
				m_pNpcList[i]->m_iSpotMobIndex = iSpotMobIndex;
				m_pNpcList[i]->m_iGuildGUID = iGuildGUID;

				if (iGuildGUID != 0) {
					wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
					PutLogList(G_cTxt);
				}

				if (m_pNpcList[i]->m_sAreaSize == 0)
					m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
				else m_pMapList[iMapIndex]->SetBigOwner(i, DEF_OWNERTYPE_NPC, sX, sY, m_pNpcList[i]->m_sAreaSize);

				m_pMapList[iMapIndex]->m_iTotalActiveObject++;
				m_pMapList[iMapIndex]->m_iTotalAliveObject++;

				switch (m_pNpcList[i]->m_sType) {
					case 36:
					case 37:
					case 38:
					case 39:
					case 42:
						m_pMapList[iMapIndex]->bAddCrusadeStructureInfo((char)m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
						break;
					case 64:	//v2.19 2002-12-16 ���� ��ų ����
						m_pMapList[iMapIndex]->bAddCropsTotalSum();
						return i; // ���� �� �������� �־ ���۹��� ���쿡�� ���⼭ ���� �Ѵ�.
						break;
				}

				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
				return i;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCreateNewNpc");
	}
#endif
	return FALSE;
}

void CMapServer::NpcProcess()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iMaxHP;
		DWORD dwTime, dwActionTime;

		dwTime = timeGetTime();

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
					switch (iDice(1, 7)) { //7
						case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
						case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
						case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
						case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
						case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
						case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
						case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
					}
					if (dwActionTime < 600) dwActionTime = 600;
				}
				else dwActionTime = m_pNpcList[i]->m_dwActionTime;

				if (m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] != 0)
					dwActionTime += (dwActionTime / 2);
			}

			if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
				m_pNpcList[i]->m_dwTime = dwTime;
				if ((m_bIsRushNetMode == TRUE) && ((m_pNpcList[i]->m_sType == 92) || (m_pNpcList[i]->m_sType == 39) ||
					(m_pNpcList[i]->m_sType == 87) || (m_pNpcList[i]->m_sType == 89))) {
					if (m_pNpcList[i]->m_sType == 92)
						if (m_pNpcList[i]->m_iHP > DEF_MAXHPRELIQUIA) m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIA;
					if (m_pNpcList[i]->m_sType == 39)
						if (m_pNpcList[i]->m_iHP > 50000) m_pNpcList[i]->m_iHP = 50000;
					if ((m_pNpcList[i]->m_sType == 87) || (m_pNpcList[i]->m_sType == 89))
						if (m_pNpcList[i]->m_iHP > 50000) m_pNpcList[i]->m_iHP = 50000;
				}
				else if ((HellOfDeath == TRUE) && (m_pNpcList[i]->m_sType == 92)) {
					if (m_pNpcList[i]->m_iHP > DEF_MAXHPRELIQUIAHOD)
						m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIAHOD;
				}
				else if ((PriceEvent == TRUE) && (m_pNpcList[i]->m_sType == 81)) {
					if (m_pNpcList[i]->m_iHP > DEF_MAXHPRELIQUIA)
						m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIA;
				}
				else if ((WWPriceEvent == TRUE) && (m_pNpcList[i]->m_sType == 120)) {
					if (m_pNpcList[i]->m_iHP > DEF_MAXHPRELIQUIA)
						m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIA;
				}
				else if ((WWIIPriceEvent == TRUE) && (m_pNpcList[i]->m_sType == 128)) {
					if (m_pNpcList[i]->m_iHP > DEF_MAXHPRELIQUIAWWII)
						m_pNpcList[i]->m_iHP = DEF_MAXHPRELIQUIAWWII;
				}
				else {
					if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
						if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
							m_pNpcList[i]->m_dwMPupTime = dwTime;
							m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana / 5));

							if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
								m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
						}
					}
					if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
						m_pNpcList[i]->m_dwHPupTime = dwTime;
						iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
						if (m_pNpcList[i]->m_iHP < iMaxHP) {

							if (m_pNpcList[i]->m_bIsSummoned == FALSE)
								m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit Point

							if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
							if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
						}
					}
				}
				switch (m_pNpcList[i]->m_cBehavior) {
					case DEF_BEHAVIOR_DEAD:
						NpcBehavior_Dead(i);
						break;
					case DEF_BEHAVIOR_STOP:
						NpcBehavior_Stop(i);
						break;
					case DEF_BEHAVIOR_MOVE:
						NpcBehavior_Move(i);
						break;
					case DEF_BEHAVIOR_ATTACK:
						NpcBehavior_Attack(i);
						break;
					case DEF_BEHAVIOR_FLEE:
						NpcBehavior_Flee(i);
						break;
				}
				if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
					switch (m_pNpcList[i]->m_sType) {
						case 29: if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000 * 90) NpcKilledHandler(NULL, NULL, i, 0); 	break;
						case 64: if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_PLANTTIME) DeleteNpc(i); 	break;
						default: if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) NpcKilledHandler(NULL, NULL, i, 0); break;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcProcess");
	}
#endif
}

void CMapServer::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iRet;
		WORD * wp;
		int  * ip;
		char * cp, *cp2;
		char   cBuffer[256], cTemp[256], cSendMode = NULL, cTxt[256];
		char notice[256];

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (dwMsgSize > 83 + 30) return;

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
		if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
		if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

		int iStX, iStY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
			iStX = m_pClientList[iClientH]->m_sX / 20;
			iStY = m_pClientList[iClientH]->m_sY / 20;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
				case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
				case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
			}
		}
		cp = (char *)(pData + 21);

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
			char cTemp[200];
			ZeroMemory(cTemp, sizeof(cTemp));
			pData[dwMsgSize - 1] = NULL;
			wsprintf(cTemp, "GM Chat(%s):\"%s\"", m_pClientList[iClientH]->m_cCharName, cp);
			PutGMLogData(cTemp);
		}
		//lalochat
	//	if (m_Misc.bCheckMSGString(cp) == FALSE) return;

		switch (*cp) {
			case '$':
				if (m_pClientList[iClientH] == NULL) return;
				if (m_Misc.bCheckMSGString(cp) == FALSE) return; //lalochat
				*cp = 32;

				if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3)) {
					if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
						m_pClientList[iClientH]->m_iSP -= 3;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
					}
					cSendMode = 4;
				}
				else cSendMode = NULL;

				if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
				break;

			case '@':
				if (m_pClientList[iClientH] == NULL) return;
				*cp = 32;

				if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) &&
					(m_pClientList[iClientH]->m_iSP >= 3)) {
					if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
						m_pClientList[iClientH]->m_iSP -= 3;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
					}
					cSendMode = 1;
				}
				else cSendMode = NULL;

				if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
				break;

			case '!':
				if (m_pClientList[iClientH] == NULL) return;
				if (m_Misc.bCheckMSGString(cp) == FALSE) return; //lalochat
				*cp = 32;

				//ANTI SPAM Zerito Lalo
				if ((m_pClientList[iClientH]->m_iAdminUserLevel == 0) && (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10)
					&& (m_pClientList[iClientH]->m_iHP > 100)) {
						m_pClientList[iClientH]->m_iHP -= 100;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
					cSendMode = 2;
				}
				else cSendMode = NULL;

				if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
				if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;

				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->AdminChat == TRUE)) cSendMode = 10;
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->AdminChat == FALSE)) cSendMode = 2; //35
				break;

			case '^':
				if (m_pClientList[iClientH] == NULL) return;
				*cp = 32;

				if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) &&
					(m_pClientList[iClientH]->m_iSP >= 5) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
					if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
						m_pClientList[iClientH]->m_iSP -= 3;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
					}
					cSendMode = 1;	// �޽��� â�� ������.
				}
				else cSendMode = NULL;

				if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
				if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
				break;


			case '~':
				if (m_pClientList[iClientH] == NULL) return;
				if (m_Misc.bCheckMSGString(cp) == FALSE) return; //lalochat
				*cp = 32;

				if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) &&
					(m_pClientList[iClientH]->m_iSP >= 3)) {
					if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
						m_pClientList[iClientH]->m_iSP -= 3;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
					}
					cSendMode = 3;
				}
				else cSendMode = NULL;

				if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
				if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
				break;

			case '/':
				// Nuevo chequeo
				if (m_pClientList[iClientH] == NULL) return;
				if (m_Misc.bCheckMSGString(cp) == FALSE) return; //lalochat
				if (strlen(cp) < 0) return;
				ZeroMemory(cBuffer, sizeof(cBuffer));

				memcpy_secure(cBuffer, cp, dwMsgSize - 21);
				cp = (char *)(cBuffer);

				/* ZeroEoyPnk - new structure for commands */
				/* Normal Users Start */
				if (m_pClientList[iClientH]->m_iAdminUserLevel >= 0) {
					if (memcmp(cp, "/who", 4) == 0) {
						wsprintf(notice, "Use Ctrl + W to see how many people online");
						ShowClientMsg(iClientH, notice);
						return;
					}
					if (CMD("/tradeek"))
					{
						c_trades->send_trade_data(iClientH, DEF_TRADEEK);
						return;
					}
					if (CMD("/reqping"))
					{
						SendCommand(iClientH, "/responseping");
						return;
					}

					if (CMD("/tradecontrib"))
					{
						c_trades->send_trade_data(iClientH, DEF_TRADECONTRIB);
						return;
					}
					if (CMD("/trademajs"))
					{
						c_trades->send_trade_data(iClientH, DEF_TRADEMAJS);
						return;
					}

					if (CMD("/tradecoin"))
					{
						c_trades->send_trade_data(iClientH, DEF_TRADECOIN);
						return;
					}
					if (CMD("/getcrits"))
					{
						getCriticals(iClientH);
						return;
					}
					if (CMD("/getquests"))
					{
						c_questlist->send_quest_data(iClientH);
						return;
					}

					if (CMD("/getcharquests"))
					{
						m_pClientList[iClientH]->send_charquest_data();
						return;
					}

					/*if (CMD("/resetrank")) {
						CharacterRankingReset(iClientH);
						return;
					}*/
					if (CMD("/event")) {
						if (m_pClientList[iClientH]->m_iAdminUserLevel <= 5) return;
						AdminCommand_Event(iClientH, cp, dwMsgSize - 21);
						return;
					}
					if (CMD("/reqtopdm"))
					{
						c_dm->getranking(iClientH);
						return;
					}
					if (CMD("/reviveyes"))
					{
						if (m_pClientList[iClientH]->IsInMap("dm"))
						{
							if (!m_pClientList[iClientH]->requestrevive) return;
							c_dm->revive(iClientH);
							return;
						}
						return;
					}

					if (CMD("/reviveno"))
					{
						if (m_pClientList[iClientH]->IsInMap("dm"))
						{
							if (!m_pClientList[iClientH]->requestrevive) return;
							c_dm->not_revive(iClientH);
							return;
						}
						return;
					}

					if (CMD("/tpdm")) {
						c_dm->join_event(iClientH);
						return;
					}

					if (CMD("/reqrebirth"))
					{
						if (!m_pClientList[iClientH]->m_bIsInitComplete) return;
						requestRebirth(iClientH);
						return;
					}

					if (CMD("/reqswitch"))
					{
						if (!m_pClientList[iClientH]->m_bIsInitComplete) return;
						switchRebirth(iClientH);
						return;
					}

					if (memcmp(cp, "/showframes", 11) == 0) {
						wsprintf(notice, "Use Ctrl + N to see how many Frames per Second");
						ShowClientMsg(iClientH, notice);
						return;
					}

					if (memcmp(cp, "/to", 3) == 0) {
						ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/setpf ", 10) == 0) {
						SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/pf ", 4) == 0) {
						GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/admins", 7) == 0) {
						PlayerCommandCheckAdmins(iClientH);
						return;
					}

					if (memcmp(cp, "/rep+ ", 6) == 0) {
						//SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/rep- ", 6) == 0) {
						//SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/hold", 5) == 0) {
						SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/tgt ", 5) == 0) {
						SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
						return;
					}

					if (memcmp(cp, "/free", 5) == 0) {
						SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/showversion", 12) == 0) {
						ShowVersion(iClientH);
						return;
					}

					if (memcmp(cp, "/createparty", 12) == 0) {
						RequestCreatePartyHandler(iClientH);
						return;
					}

					if (memcmp(cp, "/joinparty ", 11) == 0) {
						RequestJoinPartyHandler(iClientH, cp, dwMsgSize - 21);
						return;
					}

					if (memcmp(cp, "/dismissparty", 13) == 0) {
						RequestDismissPartyHandler(iClientH);
						return;
					}

					if (memcmp(cp, "/deleteparty", 12) == 0) {
						RequestDismissPartyHandler(iClientH);
						return;
					}

					if (memcmp(cp, "/zerkme", 7) == 0) {
						ZerkMe(iClientH);
						return;
					}

					if (memcmp(cp, "/maname", 7) == 0) {
						ManaMe(iClientH);
						return;
					}

					if (memcmp(cp, "/changecity", 11) == 0) {
					//	PlayerOrder_ChangeCity(iClientH);
						ShowClientMsg(iClientH, "Change City solo desde el panel TRADE MP!");
						return;
					}

					/*if (memcmp(cp, "/EslobAkear", 11) == 0) {
						PlayerOrder_ChangeCity(iClientH);
						return;
					}*/

					if (memcmp(cp, "/summonguild", 12) == 0) {						
				//		ShowClientMsg(iClientH, "Summon Guild disabled");
				//		return;
				//	}
						if (AllVsAll == TRUE) {
						ShowClientMsg(iClientH, "Durante este evento, no podras hacer summonguild");
						return;
						}
						if (FinalFight == TRUE) {
						ShowClientMsg(iClientH, "Durante este evento, no podras hacer summonguild");
						return;
						}
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_MARKETPLACE, 6) == 0) {
							ShowClientMsg(iClientH, "En este mapa, no podras hacer summonguild");
							return;
						}
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK, 8) == 0) {
							ShowClientMsg(iClientH, "En este mapa, no podras hacer summonguild");
							return;
						}
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK, 8) == 0) {
							ShowClientMsg(iClientH, "En este mapa, no podras hacer summonguild");
							return;
						}
						if ((PriceEvent || PriceHODEvent) && ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Abaddon", 7) == 0) ||
							(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_HELLOFDEAT, 8) == 0) ||
							(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_PRICE_EVENT_CITYVSCITY, 8) == 0))) {
							ShowClientMsg(iClientH, "Durante este evento, no podras hacer summonguild");
							return;
						}
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT, 7) == 0) {
							ShowClientMsg(iClientH, "En este mapa, no podras hacer summonguild");
							return;
						}
						if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "MBarracks", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ABarracks", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "EBarracks", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "EventMap", 8) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "market", 6) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "NewEvent", 8) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Counter", 7) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "VipMap1", 7) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden", 7) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine", 6) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland", 10) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni", 6) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvuni", 6) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "WorldMap", 8) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Extreme", 7) == 0) ||
						(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "FightMap", 8) == 0))	{
						ShowClientMsg(iClientH, "En este mapa, no podras hacer summonguild");
						return;
						}
						if ((!m_bIsCrusadeMode) || (m_pClientList[iClientH]->m_iGuildRank == 0)) {
							if ((m_pClientList[iClientH]->m_iGuildRank == 0) && (m_pClientList[iClientH]->m_bIsKilled == FALSE)) {
								if (dwGetItemCount(iClientH, "Gold") >= 50000) {
									if ((timeGetTime() - m_pClientList[iClientH]->dw_LastSG) < 120000) {
										wsprintf(notice, "Debes esperar %d segundos, para usar summonguild", (120 - ((timeGetTime() - m_pClientList[iClientH]->dw_LastSG) /1000)));
										ShowClientMsg(iClientH, notice);
										return;
									}
									if (m_pClientList[iClientH]->m_iHP <= 0) return;
									SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - 50000);
									AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);
									m_pClientList[iClientH]->dw_LastSG = timeGetTime();
									return;
								}
							}
						}
					}

					if (memcmp(cp, "/monstercount", 13) == 0) {
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "abaddon", 6) != 0
							&& m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
						AdminOrder_MonsterCount(iClientH, cp, dwMsgSize - 21);
						return;
					}

					/*
					if (memcmp(cp, "/HaberNoReal971", 15) == 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FAKE, NULL, NULL, NULL, NULL, NULL);
						return;
						}*/

					if (memcmp(cp, "/ban", 4) == 0) { // Ver Con Lalo
						UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
						return;
					}
				}
				/* End users */

				/* Admins */
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					if (memcmp(cp, "/qwepo", 6) == 0) {
						m_pClientList[iClientH]->m_bActivarComandos = TRUE;
						ZeroMemory(notice, sizeof(notice));
						wsprintf(notice, "Admin command ON !");
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, notice);
						return;
					}

					/* Activated commands TRUE */
					if (m_pClientList[iClientH]->m_bActivarComandos == TRUE) {
						/* Admins Lvl 1 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 1) {

							if ((memcmp(cp, "/teleport ", 10) == 0) || (memcmp(cp, "/tp ", 4) == 0)) {
								AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/setinvi ", 9) == 0) {
								AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
								return;
							}
						}
						/* End Admin Lvl 1 */

						/* Admin Lvl 2 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 2) {
							if (memcmp(cp, "/sharap ", 8) == 0) {
								ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/status", 7) == 0) {
								AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/summonplayer ", 14) == 0) {
								AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/kill ", 6) == 0) {
								AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/revive ", 8) == 0) {
								AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/ci ", 4) == 0) {
								AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/closeass ", 10) == 0) {
								AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
								return;
							}													

							if (memcmp(cp, "/goto ", 6) == 0) {
								AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
								return;
							}
						}
						/* End Admin Lvl 2 */

						/* Admin Lvl 3 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 3) {
							if (memcmp(cp, "/startcrusade ", 13) == 0) {
								LocalStartCrusadeMode(timeGetTime());
								return;
							}

							if (memcmp(cp, "/endcrusade ", 11) == 0) {
								ManualEndCrusadeMode(0);
								return;
							}

							if (memcmp(cp, "/startctf", 9) == 0) {
								StartCaptureTheFlag();
								return;
							}

							if (memcmp(cp, "/endctf", 7) == 0) {
								EndCaptureTheFlag(0);
								return;
							}

							if (memcmp(cp, "/user+", 6) == 0) {
								if (m_pClientList[iClientH]->m_iAdminUserLevel == 7)
								{
									m_iAddUser += 3;
									if (m_iAddUser > DEF_LIMIT_MAX_FAKE_USERS) m_iAddUser = DEF_LIMIT_MAX_FAKE_USERS;
								}								
								return;
							}

							if (memcmp(cp, "/user-", 6) == 0) {
								if (m_pClientList[iClientH]->m_iAdminUserLevel == 7)
								{
									m_iAddUser -= 3;
									if (m_iAddUser < 0) m_iAddUser = 0;
								}
								return;
							}

							if (memcmp(cp, "/dc", 3) == 0) {
								DeleteCliente(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/realonlines", 12) == 0) {
								int i, iAres = 0, iElv = 0, itra = 0, iAss = 0;
								for (i = 0; i < DEF_MAXCLIENTS; i++) {
									if (m_pClientList[i] != NULL) {
										//if (m_pClientList[i]->m_bLimbo) continue;
										if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (!m_pClientList[i]->NoClear) && (!m_pClientList[i]->m_bLimbo)) iAres++;
										else if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (!m_pClientList[i]->NoClear) && (!m_pClientList[i]->m_bLimbo)) iElv++;
										else if ((memcmp(m_pClientList[i]->m_cLocation, "NONE", 4) == 0) && (!m_pClientList[i]->Assasain) && (!m_pClientList[i]->NoClear) && (!m_pClientList[i]->m_bLimbo))  itra++;
										else if (m_pClientList[i]->Assasain) iAss++;
									}
								}
								wsprintf(notice, "Ares: %d - Elvin: %d - Travel: %d - Assa: %d", iAres, iElv, itra, iAss);
								ShowClientMsg(iClientH, notice);

							//	wsprintf(notice, "Real: %d - AFK Users: %d - Users+: %d - Limbo: %d - Total Users: %d", iAres + iElv + itra + iAss, m_iAFKUsers, m_iAddUser, m_bAFKLimbo, m_iTotalGameServerClients + m_iAddUser + m_iAFKUsers);
								wsprintf(notice, "Real: %d - Users+: %d - AFK: %d - Total: %d", iAres + iElv + itra + iAss, m_iAddUser, m_bAFKLimbo, m_iTotalGameServerClients + m_iAddUser);
								ShowClientMsg(iClientH, notice);
							}

							if (memcmp(cp, "/unlimbo ", 9) == 0) {
								AdminOrder_UnLimbo(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/sacar", 6) == 0) {
								DkMapUnEquipItems(iClientH);
								return;
							}

							if (memcmp(cp, "/openrush", 10) == 0) {
								LocalStartRushNetMode();
								return;
							}

							if (memcmp(cp, "/closerush", 10) == 0) {
								LocalEndRushNetMode(0);
								return;
							}

							if (memcmp(cp, "/cvc", 4) == 0) {									
								StartCityVsCity();
								return;
							}

							if (memcmp(cp, "/endcvc", 7) == 0) {
								EndCityVsCity();
								return;
							}

							if (memcmp(cp, "/summon ", 8) == 0) {
								AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/addcrit", 8) == 0) {
								AdminOrder_SetPoints(iClientH, cp, dwMsgSize - 21, 5);
								return;
							}

							if (memcmp(cp, "/allvsall", 9) == 0) {
								InitAllVsAll();
								return;
							}

							if (memcmp(cp, "/endallvsall", 12) == 0) {
								EndAllVsAll(iClientH);
								return;
							}

							if (memcmp(cp, "/soccer", 7) == 0) {
								if (Soccer == FALSE) {
									Soccer = TRUE;
									CreateEnergy();
								}
								return;
							}

							if (memcmp(cp, "/terminar", 9) == 0) {
								if (Soccer == TRUE) {
									Soccer = FALSE;
									GolesElvine = 0;
									GolesAresden = 0;
									DeleteEnergy();
								}
								return;
							}

							if (memcmp(cp, "/startdkevent", 13) == 0) {
								StartDkEvent(iClientH);
								return;
							}

							if (memcmp(cp, "/enddkevent", 11) == 0) {
								EndDkEvent(iClientH);
								return;
							}
						}
						
						/* End Admin Lvl 3 */
						/* Admin Lvl 4 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) {											

							if (memcmp(cp, "/finalfight", 11) == 0) {
								InitArenaEvent();
								return;
							}

							if (memcmp(cp, "/closefinalfight", 16) == 0) {
								CloseArenaEvent();
								return;
							}
							//WorldWar LaloRamos
							if (memcmp(cp, "/startworldwar", 14) == 0) {
								StartWorldWar();
								return;
							}

							if (memcmp(cp, "/endworldwar", 12) == 0) {
								EndWorldWar();
								return;
							}		

							//WorldWarII LaloRamos
							if (memcmp(cp, "/startworld2", 12) == 0) {
								StartWorldWarII();
								return;
							}

							if (memcmp(cp, "/endworld2", 10) == 0) {
								EndWorldWarII();
								return;
							}

							if (strcmp(cp, "/shinning") == 0) {

								m_bShinning = !m_bShinning;
								showShinningStatus();
								return;
							}
							
							if (memcmp(cp, "/starttd", 8) == 0) {
								InitTowerDefence();
								return;
							}

							if (memcmp(cp, "/addmaj", 7) == 0) {
								AdminOrder_SetPoints(iClientH, cp, dwMsgSize - 21, 4);
								return;
							}

							if (memcmp(cp, "/endtd", 6) == 0) {
								EndTowerDefenceMode(0);
								return;
							}

							if (memcmp(cp, "/starthod", 9) == 0) {
								InitHellOfDeath();
								return;
							}

							if (memcmp(cp, "/endhod", 7) == 0) {
								EndHellOfDeathMode(0);
								return;
							}
						}/* End Admin Lvl 4 */

						/* Admin Lvl 5 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 5) {				

							if (memcmp(cp, "/asigek", 7) == 0) {
								AdminOrder_SetPoints(iClientH, cp, dwMsgSize - 21, 0);
								return;
							}

							if (memcmp(cp, "/setobservermode ", 17) == 0) {
								AdminOrder_SetObserverMode(iClientH); // Ver Con lalo
								return;
							}

							if (memcmp(cp, "/jailban ", 9) == 0) {
								AdminOrder_banjail(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/checkuserip ", 13) == 0) {
								CheckUsersIP(iClientH, cp, dwMsgSize - 21);
								return;
							}
						}/* End Admin Lvl 5 */


						/* Admin Lvl 6 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 6) {
							if (memcmp(cp, "/summonall ", 11) == 0) {
								AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/checkip ", 9) == 0) {
								AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/playerban ", 11) == 0) {
								AdminOrder_ban(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/clearmap", 9) == 0) {
								AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
								return;
							}
							if (memcmp(cp, "/checkrep", 9) == 0) {
								AdminOrder_CheckRep(iClientH, cp, dwMsgSize - 21);
								return;
							}
							
							if (memcmp(cp, "/clearnpc", 9) == 0) {
								AdminOrder_ClearNpc(iClientH);
								return;
							}

							if (memcmp(cp, "/fi ", 4) == 0) { // Ver Con Lalo
								CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
								return;
							}							

							if (memcmp(cp, "/updateranksettings", 19) == 0) {
								c_rank->update();
								return;
							}

							if (memcmp(cp, "/reservefightzone", 17) == 0) {
								AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/attack ", 8) == 0) {
								AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/createfish ", 12) == 0) {
								AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/summondemon ", 13) == 0) {
								AdminOrder_SummonDemon(iClientH);
								return;
							}

							if (memcmp(cp, "/unsummonall ", 13) == 0) {
								AdminOrder_UnsummonAll(iClientH);
								return;
							}

							if (memcmp(cp, "/unsummonboss ", 14) == 0) {
								AdminOrder_UnsummonBoss(iClientH);
								return;
							}							

							if (memcmp(cp, "/polymorph ", 11) == 0) {
								AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/gns ", 4) == 0) {
								AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
								AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/disconnectall ", 15) == 0) {
								AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
								return;
							}
							
							if (memcmp(cp, "/city ", 6) == 0) {
								AdminOrder_ChangeCity(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/monstercount", 13) == 0) {
								AdminOrder_MonsterCount(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/setzerk ", 9) == 0) {
								AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/desbug ", 8) == 0) {
								Desbug(iClientH, cp, dwMsgSize - 21);
								return;
							}
							if (memcmp(cp, "/setmsg ", 8) == 0) {
								SetAccountMsg(iClientH, cp, dwMsgSize - 21);
								return;
							}							

							if (memcmp(cp, "/weather", 8) == 0) {
								AdminOrder_Weather(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/send ", 6) == 0) {
								AdminOrder_Pushplayer(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/time ", 6) == 0) {
								AdminOrder_Time(iClientH, cp, dwMsgSize - 21);
								return;
							}
						}
						/* End Admin Lvl 6 */

						/* Admin Lvl 7 */
						if (m_pClientList[iClientH]->m_iAdminUserLevel >= 7)
						{


							
							if (memcmp(cp, "/addrep", 7) == 0) {
								AdminOrder_SetPoints(iClientH, cp, dwMsgSize - 21, 1);
								return;
							}

							if (memcmp(cp, "/addpk", 6) == 0) {
								AdminOrder_SetPoints(iClientH, cp, dwMsgSize - 21, 2);
								return;
							}

							if (memcmp(cp, "/addcoins", 9) == 0) {
								AdminOrder_SetPoints(iClientH, cp, dwMsgSize - 21, 3);
								return;
							}

							if (memcmp(cp, "/getticket ", 11) == 0) {
								AdminOrder_GetFightzoneTicket(iClientH);
								return;
							}

							if (memcmp(cp, "/deslogpull", 11) == 0) {
								AdminOrder_deslogpull(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/portal ", 8) == 0) {
								AdminOrder_Portal(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/closeportal1", 13) == 0) {
								ClosePortal(1);
								return;
							}

							if (memcmp(cp, "/closeportal2", 13) == 0) {
								ClosePortal(2);
								return;
							}

							if (memcmp(cp, "/closeallportal", 15) == 0) {
								AllClosePortals();
								return;
							}

							if (memcmp(cp, "/activarchat", 12) == 0) {
								if (m_pClientList[iClientH]->AdminChat == TRUE)
									m_pClientList[iClientH]->AdminChat = FALSE;
								else m_pClientList[iClientH]->AdminChat = TRUE;
								return;
							}							

							if (memcmp(cp, "/startabaddon", 13) == 0) {
								InitAbaddonEvent();
								return;
							}

							if (memcmp(cp, "/endabaddon", 11) == 0) {
								CloseAbaddonEvent();
								return;
							}

							/*if (memcmp(cp, "/respawn", 8) == 0) {
								if (RespawnON == FALSE) {
									RespawnON = TRUE;
									wsprintf(notice, "Respawn ON");
									ShowClientMsg(iClientH, notice);
								}
							return;
							}
							if (memcmp(cp, "/norespawn", 10) == 0) {
								if (RespawnON == TRUE) {
									RespawnON = FALSE;
									wsprintf(notice, "Respawn OFF");
									ShowClientMsg(iClientH, notice);
								}
								return;
							}*/

							if (memcmp(cp, "/closeportals", 13) == 0) {
								IniciarAllVsAll();
								return;
							}

							if (memcmp(cp, "/happyhour ", 11) == 0) {
								ManualStartHappyHour(iClientH, cp, dwMsgSize - 21);
								return;
							}
							//Nuevo Happy Day LaloRamos
							if (memcmp(cp, "/happyday ", 10) == 0) {
								ManualStartHappyDay(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/setattackmode ", 15) == 0) {
								AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
								return;
							}							

							if (memcmp(cp, "/summonevent", 12) == 0) {
								LaunchSummonEvent();
								return;
							}

							if (memcmp(cp, "/endsummonevent", 15) == 0) {
								EndSummonEvent();
								return;
							}

							if (memcmp(cp, "/reloadsummon", 13) == 0) {
								ReloadSummonEventConfig();
								return;
							}
							
							if (memcmp(cp, "/portales", 9) == 0) {
								AbrirPortales(5);
								return;
							}
							///borrrar dsp 
					
							if (memcmp(cp, "/contarnpcs", 11) == 0)
							{	
								int counter = 0;
								for (i = 0; i < DEF_MAXNPCS; i++) {
									if (m_pNpcList[i] != NULL) {
										counter++;
									}
								}

								wsprintf(notice, "Cantidad de mobs: %d", counter);
								ShowClientMsg(iClientH, notice);
							}

							if (memcmp(cp, "/createassasain", 15) == 0) {
								AdminOrder_Assasain(iClientH, cp, dwMsgSize - 21);
								return;
							}
							
							//Agregado Actives
							if (memcmp(cp, "/actives", 8) == 0) {
								int i, iAres = 0, iElv = 0, itra = 0, iAss = 0, TotalActives = 0;
								for (i = 0; i < DEF_MAXCLIENTS; i++) {
									if (m_pClientList[i] != NULL) {
										if ((m_pClientList[i]->m_iStatus & 0x00000008) == 0) {
											if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (!m_pClientList[i]->NoClear)) {
												iAres++;
											}
											else if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (!m_pClientList[i]->NoClear)) {
												iElv++;
											}
											else if ((memcmp(m_pClientList[i]->m_cLocation, "NONE", 4) == 0) && (!m_pClientList[i]->Assasain) && (!m_pClientList[i]->NoClear)) {
												itra++;
											}
											else if (m_pClientList[i]->Assasain) {
												iAss++;
											}
											TotalActives++;
										}
									}
								}
								wsprintf(notice, "Ares Active: %d - Elv Active: %d - Trav Active: %d - Assa Active: %d", iAres, iElv, itra, iAss);
								ShowClientMsg(iClientH, notice);

								//int PercentActive = ((100 * TotalActives) / (m_iTotalGameServerClients + m_iAddUser + m_iAFKUsers));
								int PercentActive = ((100 * TotalActives) / (m_iTotalGameServerClients));// + m_iAddUser + m_iAFKUsers));
								int AresActive = (100 * iAres) / TotalActives;
								int ElvActive = (100 * iElv) / TotalActives;
								wsprintf(notice, "Total Active: %d - %% Active: %d - Citys: Ares: %d%% - Elv: %d%%", TotalActives, PercentActive, AresActive, ElvActive);
								ShowClientMsg(iClientH, notice);
							}

							if (memcmp(cp, "/openvip", 8) == 0) {
								if (VipMap != TRUE) {
									VipMap = TRUE;
									ShowClientMsg(iClientH, "Hunt Map Abierto - Teleports en CityHall");
								}
								return;
							}
							if (memcmp(cp, "/closevip", 9) == 0) {
								if (VipMap != FALSE) {
									VipMap = FALSE;
									ShowClientMsg(iClientH, "Hunt Map Cerrado - Teleports Cerrados");
								}
								return;
							}

							if (memcmp(cp, "/openmasacre", 12) == 0) {
								if (Masacre != TRUE) {
									Masacre = TRUE;
									ShowClientMsg(iClientH, "Masacre Abierto - Teleports en CityHall");
								}
								return;
							}
							if (memcmp(cp, "/closemasacre", 13) == 0) {
								if (Masacre != FALSE) {
									Masacre = FALSE;
									ShowClientMsg(iClientH, "Masacre Map Cerrado - Teleports Cerrados");
								}
								return;
							}

							if (memcmp(cp, "/opentower", 10) == 0) {
								if (TowerHell != TRUE) {
									TowerHell = TRUE;
									ShowClientMsg(iClientH, "TowerOfHell Map Open - Teleports Abiertos");
								}
								return;
							}

							if (memcmp(cp, "/closedtower", 12) == 0) {
								if (TowerHell != FALSE) {
									TowerHell = FALSE;
									ShowClientMsg(iClientH, "TowerOfHell Map Close - Teleports Cerrados");
								}
								return;
							}

							if (memcmp(cp, "/OnQuestx2", 10) == 0) {
								if (Questx2 != TRUE) {
									Questx2 = TRUE;
									ShowClientMsg(iClientH, "Quest x 2 ON!");
									PutLogList("Quest x 2 ON");
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2, 10, NULL, NULL, NULL, NULL);
								}
								return;
							}

							if (memcmp(cp, "/OffQuestx2", 11) == 0) {
								if (Questx2 != FALSE) {
									Questx2 = FALSE;
									ShowClientMsg(iClientH, "Quest x 2 OFF!");
									PutLogList("Quest x 2 OFF");
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2OFF, 10, NULL, NULL, NULL, NULL);
								}
								return;
							}

							if (memcmp(cp, "/OnQuestx3", 10) == 0) {
								if (Questx3 != TRUE) {
									Questx3 = TRUE;
									ShowClientMsg(iClientH, "Quest x 3 ON!");
									PutLogList("Quest x 3 ON");
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3, 10, NULL, NULL, NULL, NULL);
								}
								return;
							}

							if (memcmp(cp, "/OffQuestx3", 11) == 0) {
								if (Questx3 != FALSE) {
									Questx3 = FALSE;
									ShowClientMsg(iClientH, "Quest x 3 OFF!");
									PutLogList("Quest x 3 OFF");
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3OFF, 10, NULL, NULL, NULL, NULL);
								}
								return;
							}

							if (memcmp(cp, "/EventosOFF", 11) == 0) {
								if (EventAuto != FALSE) {
									EventAuto = FALSE;
									ShowClientMsg(iClientH, "Eventos Automaticos OFF");
									PutLogList("Eventos Automaticos OFF");
								}
								return;
							}

							if (memcmp(cp, "/EventosON", 10) == 0) {
								if (EventAuto != TRUE) {
									EventAuto = TRUE;
									ShowClientMsg(iClientH, "Eventos Automaticos ON");
									PutLogList("Eventos Automaticos ON");
								}
								return;
							}

							if (memcmp(cp, "/checkprocess", 13) == 0) {
								CheckHability(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/reloadantihack", 15) == 0) {
								ReadProcessAndDllBlockedFile("Configs\\CheckProcess", 1);
								ReadProcessAndDllBlockedFile("Configs\\CheckDlls.cfg", 0);
								UpdateProcessClient();
								return;
							}	

							if (memcmp(cp, "/ipban ", 7) == 0) {
								AdminOrder_BanIP(iClientH, cp, dwMsgSize - 21);
								return;
							}

							if (memcmp(cp, "/reloadbanlist ", 14) == 0) {
								LoadBannedList(0);
								return;
							}

							/*if (memcmp(cp, "/ping ", 5) == 0) {
							//	ReqPing(iClientH);
								ReqPing(iClientH, dwMsgSize);
								return;
							}*/

							if (memcmp(cp, "/openalleks", 11) == 0) {
								StartAllEks();
								return;
							}
							if (memcmp(cp, "/closealleks", 12) == 0) {
								EndAllEks();
								return;
							}

							if (memcmp(cp, "/openalldkeks", 13) == 0) {
								StartAllDkEks();
								return;
							}
							if (memcmp(cp, "/closealldkeks", 14) == 0) {
								EndAllDkEks();
								return;
							}

							if (memcmp(cp, "/openmarket", 11) == 0) {
								if (!MarketEnabled) {
									MarketEnabled = TRUE;
									ShowClientMsg(iClientH, "Market Open!");
								}
								return;
							}

							if (memcmp(cp, "/shutdownserver", 15) == 0) {
								if (!m_bShutDownServer)
								{
									m_bShutDownServer = true;

									ShowClientMsg(iClientH, "Server shutdown!");

									for (i = 1; i < DEF_MAXCLIENTS; i++) {
										if (m_pClientList[i] != NULL) {
											m_pClientList[i]->m_bForceDisconnect = true;
											DeleteClient(iClientH, TRUE, TRUE);
										}
									}

									std::thread timerThread([this]() {
										std::this_thread::sleep_for(std::chrono::seconds(5));
										exit(1);
									});
									timerThread.detach();

								}
								return;
							}


							if (memcmp(cp, "/closemarket", 14) == 0) {
								if (MarketEnabled) {
									for (i = 1; i < DEF_MAXCLIENTS; i++) {
										if (m_pClientList[i] != NULL) {
											if (m_pClientList[i]->SellType != -1) {
												for (short x = 0; x < DEF_MAXSELLITEMS; x++) {
													if (m_pClientList[i]->MarketItem[x].sIndex != -1) {
														m_pClientList[i]->MarketItem[x].sIndex = -1;
														m_pClientList[i]->MarketItem[x].m_wPrice = -1;
													}
												}
											}
											m_pClientList[i]->SellType = -1;
											m_pClientList[i]->BuyTo = -1;
											m_pClientList[i]->OpenSell = FALSE;
											SendNotifyMsg(NULL, i, CLIENT_RESPONSE_MARKET, 0, NULL, NULL, NULL);
										}
									}
									MarketEnabled = FALSE;
									ShowClientMsg(iClientH, "Market Closed!");
								}
								return;
							}

						}
						/* End Admin Lvl 7 */
					}
					/* End Activated commands */
				}
				/* End Admins Commands */
				return;
		}

		pData[dwMsgSize - 1] = NULL;

		// Confuse lenguaje in all vs all
		if (((m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] == 1) && (iDice(1, 3) != 2))
			|| ((m_pClientList[iClientH]->m_iAdminUserLevel == 0) && (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLVSALL) == 0))
			|| (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0)
			|| (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0)) {
			cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);

			while (*cp != NULL) {
				if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
					switch (iDice(1, 36)) {
						case 1:		memcpy_secure(cp, "a", 1); break;
						case 2:		memcpy_secure(cp, "b", 1); break;
						case 3:		memcpy_secure(cp, "c", 1); break;
						case 4:		memcpy_secure(cp, "d", 1); break;
						case 5:		memcpy_secure(cp, "e", 1); break;
						case 6:		memcpy_secure(cp, "f", 1); break;
						case 7:		memcpy_secure(cp, "g", 1); break;
						case 8:		memcpy_secure(cp, "h", 1); break;
						case 9:		memcpy_secure(cp, "i", 1); break;
						case 10:	memcpy_secure(cp, "j", 1); break;
						case 11:	memcpy_secure(cp, "k", 1); break;
						case 12:	memcpy_secure(cp, "l", 1); break;
						case 13:	memcpy_secure(cp, "m", 1); break;
						case 14:	memcpy_secure(cp, "n", 1); break;
						case 15:	memcpy_secure(cp, "o", 1); break;
						case 16:	memcpy_secure(cp, "p", 1); break;
						case 17:	memcpy_secure(cp, "q", 1); break;
						case 18:	memcpy_secure(cp, "r", 1); break;
						case 19:	memcpy_secure(cp, "s", 1); break;
						case 20:	memcpy_secure(cp, "t", 1); break;
						case 21:	memcpy_secure(cp, "u", 1); break;
						case 22:	memcpy_secure(cp, "v", 1); break;
						case 23:	memcpy_secure(cp, "w", 1); break;
						case 24:	memcpy_secure(cp, "x", 1); break;
						case 25:	memcpy_secure(cp, "y", 1); break;
						case 26:	memcpy_secure(cp, "z", 1); break;
						case 27:	memcpy_secure(cp, "1", 1); break;
						case 28:	memcpy_secure(cp, "2", 1); break;
						case 29:	memcpy_secure(cp, "3", 1); break;
						case 30:	memcpy_secure(cp, "4", 1); break;
						case 31:	memcpy_secure(cp, "5", 1); break;
						case 32:	memcpy_secure(cp, "6", 1); break;
						case 33:	memcpy_secure(cp, "7", 1); break;
						case 34:	memcpy_secure(cp, "8", 1); break;
						case 35:	memcpy_secure(cp, "9", 1); break;
						case 36:	memcpy_secure(cp, "0", 1); break;
					}
					cp++;
				}
				else cp++;
			}
		}

		if (m_pClientList[iClientH] == NULL) return;
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
		if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
			cSendMode = 20;
			if (*cp == '#') cSendMode = NULL;
			if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		}
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)iClientH;
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
		*cp = cSendMode;

		if (cSendMode != 20) {
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {
					switch (cSendMode) {
						case NULL:
							if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
							
								if ((m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
									(m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
									(m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
									(m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
									(m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7)) {
									if (m_bIsCrusadeMode == TRUE) {
										if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
											(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
										}
										else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
									}
									else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
								}
								break;

						case 1:
							if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
							if ((memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
								(memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0)) {
								if (m_bIsCrusadeMode == TRUE) {
									if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
										(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
									}
									else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
								}
								else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							}
							break;

						case 2:
						case 10: // Global
						case 35:
							if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case 3:
							if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
							if ((m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide))
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case 4:
							if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
							if ((m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID))
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;
					}
				}
			}
		}
		else {
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);

			if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex] != NULL) {
				if (strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_cCharName) == 0) {
					iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);
					if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
						char cTxt[200];
						ZeroMemory(cTxt, sizeof(cTxt));
						wsprintf(cTxt, "PC Chat(%s):\"%s\"\tto GM(%s)", m_pClientList[iClientH]->m_cCharName, pData + 21, m_pClientList[iClientH]->m_cWhisperPlayerName);
						//bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTxt);
						PutGMLogData(cTxt);
					}
				}
			}

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);//Agregado Lalo882
					break;
			}
		}

		switch (cSendMode) {
			case NULL:
				//ZeroEoyPnk - ChatLogs
				wsprintf(cTxt, "%s: %s", m_pClientList[iClientH]->m_cCharName, pData + 21);
				break;

			case 1:
				//ZeroEoyPnk - ChatLogs
				wsprintf(cTxt, "%s: ^ %s", m_pClientList[iClientH]->m_cCharName, pData + 21);
				break;

			case 2:
			case 10:
			case 35:
				//ZeroEoyPnk - ChatLogs
				wsprintf(cTxt, "%s: ! %s", m_pClientList[iClientH]->m_cCharName, pData + 21);
				break;

			case 3:
				//ZeroEoyPnk - ChatLogs
				wsprintf(cTxt, "%s: ~ %s", m_pClientList[iClientH]->m_cCharName, pData + 21);
				break;

			case 4:
				//ZeroEoyPnk - ChatLogs
				wsprintf(cTxt, "%s: $ %s", m_pClientList[iClientH]->m_cCharName, pData + 21);
				break;

			case 20:
				//ZeroEoyPnk - ChatLogs
				wsprintf(cTxt, "%s: (to %s) - %s", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cWhisperPlayerName, pData + 21);
				break;

			default:
				break;
		}
		ChatLogs(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChatMsgHandler");
	}
#endif
}

int CMapServer::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cData[100];
		DWORD * dwp, dwTime;
		WORD  * wp;
		int     iRet, iExp, tdX = 0, tdY = 0, uX, uY, vX1, vX2, vY1, vY2;
		short   sOwner, sAbsX, sAbsY, sItemIndex;
		char    cOwnerType;
		BOOL    bNearAttack = FALSE, bFarAttack = FALSE;
		BOOL	 ArrowConsumed = FALSE;

		if (m_pClientList[iClientH] == NULL) return 0;
		if ((cDir <= 0) || (cDir > 8))       return 0;
		if ((dX == 0) || (dY == 0)) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

		if (m_pClientList[iClientH]->KilledClientAFK != -1) m_pClientList[iClientH]->KilledClientAFK = -1;

		dwTime = timeGetTime();
		m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

		if ((wTargetObjectID != NULL) && (wType != 2)) {
			tdX = 0;
			tdY = 0;

			if (wTargetObjectID < DEF_MAXCLIENTS) {
				if (m_pClientList[wTargetObjectID] != NULL) {
					tdX = m_pClientList[wTargetObjectID]->m_sX;
					tdY = m_pClientList[wTargetObjectID]->m_sY;
				}
			}
			else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS))) {
				if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
					tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
					tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
				}
			}

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

			if (sOwner == (wTargetObjectID - 10000)) {
				if (m_pNpcList != NULL) {
					tdX = m_pNpcList[sOwner]->m_sX;
					dX = tdX;
					tdY = m_pNpcList[sOwner]->m_sY;
					dY = tdY;
				}
				bNearAttack = FALSE;
				bFarAttack = TRUE;
			}
			if (bFarAttack != TRUE) {
				if ((tdX == dX) && (tdY == dY)) bNearAttack = FALSE;
				else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
					dX = tdX;
					dY = tdY;
					bNearAttack = TRUE;
				}
			}
		}

		if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
			(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;

		if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

		int iStX, iStY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
			iStX = m_pClientList[iClientH]->m_sX / 20;
			iStY = m_pClientList[iClientH]->m_sY / 20;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
				case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
				case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
			}
		}

		sAbsX = abs(sX - dX);
		sAbsY = abs(sY - dY);
		if ((wType != 2) && (wType < 20)) {
			if (bFarAttack == FALSE) {
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 4957) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 4958)) { // Storm Bringer
						if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
					}
					else if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
				else if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
			else {
				cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
				if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)) != FALSE)
					wType = 0;
			}
		}

		ClearSkillUsingStatus(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
		m_pClientList[iClientH]->m_cDir = cDir;

		iExp = 0;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

		if (sOwner != NULL) {
			if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {
				if (iCheckLugar(iClientH) != 1) {

					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874) { // Directional bow
							uY = dY - sY;
							uX = dX - sX;

							while ((uX) || (uY)) {
								if (abs(uX) >= abs(uY / 2)) {
									if (uX > 0) uX--;
									else if (uX < 0) uX++;
								}
								if (abs(uY) >= abs(uX / 2)) {
									if (uY > 0) uY--;
									else if (uY < 0) uY++;
								}
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, (dX - uX), (dY - uY));
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, (dX - uX), (dY - uY), wType, bNearAttack, bIsDash, ArrowConsumed); // 1
								if (!ArrowConsumed) ArrowConsumed = TRUE;
							}
						}
						else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 560) { // battle axe
							if (((abs(tdX - dX) >= 1) && (abs(tdY - dY) >= 1)) || ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1))) { // Coords
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE);
							}
							vX1 = vX2 = dX;
							vY1 = vY2 = dY;
							if ((dX - sX) && (dY - sY)) {
								switch (cDir) {
									case 2: vX1--; vY2++; break;
									case 4: vX1--; vY2--; break;
									case 6: vX1++; vY2--; break;
									case 8: vX1++; vY2++; break;
								}
							}
							else if ((!(dX - sX)) && (dY - sY)) {
								vX1++;
								vX2--;
							}
							else if ((dX - sX) && !(dY - sY)) {
								vY1++;
								vY2--;
							}
							if (iDice(1, 2) == 1) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, vX1, vY1);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, vX1, vY1, wType, bNearAttack, bIsDash, TRUE);
							}
							if (iDice(1, 2) == 1) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, vX2, vY2);
								iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, vX2, vY2, wType, bNearAttack, bIsDash, TRUE);
							}
						}
						else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873) { // Fire-Bow
							if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
								iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1, 7) + 3) * 1000, 8);
								iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
							}
						}
						else iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
					}
					else iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
				}
				else iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
				if (m_pClientList[iClientH] == NULL) return 0;
				m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
			}
		}
		else _CheckMiningAction(iClientH, dX, dY);

		if (iExp != 0) GetExp(iClientH, iExp, TRUE);

		if (bResponse == TRUE) {
			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_OBJECTMOTION_ATTACK_CONFIRM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
			}
		}
		return 1;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iClientMotion_Attack_Handler");
	}
#endif
	return 0;
}

char CMapServer::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError, char cArea, short sOwnerH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register char  cDir, cTmpDir;
		register int   aX, aY, dX, dY;
		register int   i, iResX, iResY;

		if ((sX == dstX) && (sY == dstY)) return 0;

		dX = sX;
		dY = sY;

		if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
			iResX = dstX;
			iResY = dstY;
		}
		else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

		cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

		if (cTurn == 0) {
			for (i = cDir; i <= cDir + 7; i++) {
				cTmpDir = i;
				if (cTmpDir > 8) cTmpDir -= 8;
				aX = _tmp_cTmpDirX[cTmpDir];
				aY = _tmp_cTmpDirY[cTmpDir];
				if (cArea > 0) {
					if (m_pMapList[cMapIndex]->bGetBigMoveable(sOwnerH, dX + aX, dY + aY, cArea) == TRUE) return cTmpDir;
				}
				else {
					if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
				}
			}
		}

		if (cTurn == 1) {
			for (i = cDir; i >= cDir - 7; i--) {
				cTmpDir = i;
				if (cTmpDir < 1) cTmpDir += 8;
				aX = _tmp_cTmpDirX[cTmpDir];
				aY = _tmp_cTmpDirY[cTmpDir];
				if (cArea > 0) {
					if (m_pMapList[cMapIndex]->bGetBigMoveable(sOwnerH, dX + aX, dY + aY, cArea) == TRUE) return cTmpDir;
				}
				else {
					if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: cGetNextMoveDir");
	}
#endif
	return 0;
}

char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

BOOL CMapServer::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		short sX, sY;

		for (i = 0; i < 100; i++) {
			if ((m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
				(m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE)) {
				sX = *pX + _tmp_cEmptyPosX[i];
				sY = *pY + _tmp_cEmptyPosY[i];
				*pX = sX;
				*pY = sY;
				return TRUE;
			}
		}

		GetMapInitialPoint(cMapIndex, &sX, &sY);
		*pX = sX;
		*pY = sY;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bGetEmptyPosition");
	}
#endif
	return FALSE;
}

void CMapServer::NpcBehavior_Move(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif

		char  cDir;
		short sX, sY, dX = 0, dY = 0, absX, absY;
		short sTarget, sDistance;
		char  cTargetType;

		if (m_pNpcList[iNpcH] == NULL) return;
		if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
		if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) && (m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
		if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) return;

		switch (m_pNpcList[iNpcH]->m_cActionLimit) {
			case 2:
			case 3:
			case 4: //sacado v13
			case 5:
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_STOP;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				return;
		}

		int iStX, iStY;
		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
			iStX = m_pNpcList[iNpcH]->m_sX / 20;
			iStY = m_pNpcList[iNpcH]->m_sY / 20;
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;
		}

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;

			absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
			absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);

			if ((absX <= 2) && (absY <= 2))
				CalcNextWayPointDestination(iNpcH);

			m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
			m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
		}

		TargetSearch(iNpcH, &sTarget, &cTargetType);
		if (sTarget != NULL) {
			if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
				if (iDice(1, 3) == 3) {
					m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
					m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
					return;
				}
			}
			else {
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
				return;
			}
		}

		if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1, 3) == 2)) return;

		if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
			sX = m_pNpcList[iNpcH]->m_sX;
			sY = m_pNpcList[iNpcH]->m_sY;
			switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
						m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
						return;
					}

					dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
					dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
						m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
						m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
						return;
					}

					dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
					dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
					break;
			}

			if (abs(sX - dX) >= abs(sY - dY))
				sDistance = abs(sX - dX);
			else sDistance = abs(sY - dY);

			if (sDistance >= 3) {
				if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
					cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
				}
				else cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize, iNpcH);

				if (cDir != 0) {
					dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
					dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
					if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
					}
					else {
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
					}
					m_pNpcList[iNpcH]->m_sX = dX;
					m_pNpcList[iNpcH]->m_sY = dY;
					m_pNpcList[iNpcH]->m_cDir = cDir;
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
					///updateEntitySync(iNpcH, DEF_OWNERTYPE_NPC, ACTION_OBJECTMOVE);
				}
			}
		}
		else {
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0)
				cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			else cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize, iNpcH);

			if (cDir == 0) {
				if (iDice(1, 10) == 3) CalcNextWayPointDestination(iNpcH);
			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];

				if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				}
				else {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
				}
				m_pNpcList[iNpcH]->m_sX = dX;
				m_pNpcList[iNpcH]->m_sY = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				//updateEntitySync(iNpcH, DEF_OWNERTYPE_NPC, ACTION_OBJECTMOVE);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcBehavior_Move");
	}
#endif
}

void CMapServer::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int ix, iy, iPKCount;
		register short sX, sY, rX, rY, dX = 0, dY = 0;
		short sOwner, sTargetOwner, sDistance, sTempDistance, TempOwner;
		char  cOwnerType, cTargetType, cTargetSide = 0;
		int   iInv = 0, iSearchType;
		BOOL ASS;

		sTargetOwner = NULL;
		cTargetType = NULL;
		sDistance = 100;

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
		rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;

		iSearchType = NULL;

		for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange * 2 + 1; ix++) {
			for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange * 2 + 1; iy++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
				if (sOwner != NULL) {

					if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break;
					TempOwner = NULL;
					iPKCount = 0;

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwner] == NULL) {
								m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
							}
							else {
								if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;
								if ((m_pClientList[sOwner]->m_cSide == DEF_NETURAL) && (!m_pClientList[sOwner]->Assasain)) goto SKIP_SEARCH;

								switch (iSearchType) {
									case 1: goto SKIP_SEARCH; break;
									case NULL: break;
								}

								dX = m_pClientList[sOwner]->m_sX;
								dY = m_pClientList[sOwner]->m_sY;
								cTargetSide = m_pClientList[sOwner]->m_cSide;
								iPKCount = m_pClientList[sOwner]->m_iPKCount;
								iInv = m_pClientList[sOwner]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY];
								TempOwner = sOwner;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwner] == NULL) {
								m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
							}
							else {
								if (RunSummonEvent || RunSummonEvent2 || RunSummonEvent3) {
									if ((memcmp(m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->m_cName, "ESAresden", 9) == 0) ||
										(memcmp(m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->m_cName, "ESElvine", 8) == 0) ||
										(memcmp(m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->m_cName, "ESAssasain", 10) == 0))
										goto SKIP_SEARCH;
								}
								switch (iSearchType) {
									case 1:
										switch (m_pNpcList[sOwner]->m_sType) {
											case 36:
											case 37:
											case 38:
											case 39:
											case 40:
											case 41:
												break;

											default:
												goto SKIP_SEARCH;
												break;
										}
										break;
									case NULL:
										break;
								}

								dX = m_pNpcList[sOwner]->m_sX;
								dY = m_pNpcList[sOwner]->m_sY;
								cTargetSide = m_pNpcList[sOwner]->m_cSide;
								iPKCount = 0;
								iInv = m_pNpcList[sOwner]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY];

								if (m_pNpcList[iNpcH]->m_sType == 21) {
									if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
										sOwner = NULL;
										cOwnerType = NULL;
									}
								}
							}
							break;
					}

					if (TempOwner != NULL) ASS = m_pClientList[TempOwner]->Assasain;
					else ASS = FALSE;

					if (m_pNpcList[iNpcH]->m_cSide < 10) {
						if (cTargetSide == 0) {
							if (iPKCount == 0 && ASS == FALSE) goto SKIP_SEARCH;
						}
						else {
							if ((iPKCount == 0 && ASS == FALSE) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
							if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
						}
					}
					else {
						if (m_pNpcList[iNpcH]->m_cSide == 11) {
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (cTargetSide == 0 && ASS == TRUE)) goto SKIP_SEARCH;
							if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
						}
						else {
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (cTargetSide == 0 && ASS == FALSE)) goto SKIP_SEARCH;
							if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
						}

						if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
					}

					if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

					if (abs(sX - dX) >= abs(sY - dY)) sTempDistance = abs(sX - dX);
					else sTempDistance = abs(sY - dY);

					if (sTempDistance < sDistance) {
						sDistance = sTempDistance;
						sTargetOwner = sOwner;
						cTargetType = cOwnerType;
					}
				SKIP_SEARCH:;
				}
			}
		}

		*pTarget = sTargetOwner;
		*pTargetType = cTargetType;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: TargetSearch");
	}
#endif
}

void CMapServer::NpcBehavior_Attack(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   iMagicType;
		short sX, sY, dX, dY;
		char  cDir;
		DWORD dwTime = timeGetTime();
		BOOL bFly = FALSE;

		if (m_pNpcList[iNpcH] == NULL) return;
		if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) return;
		if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

		switch (m_pNpcList[iNpcH]->m_cActionLimit) {
			case 1:
			case 2:
			case 3:
			case 4:
				return;
		}

		int iStX, iStY;
		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
			iStX = m_pNpcList[iNpcH]->m_sX / 20;
			iStY = m_pNpcList[iNpcH]->m_sY / 20;
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;
		}

		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0)
			m_pNpcList[iNpcH]->m_iAttackCount = 0;

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;

			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
				m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;

			return;
		}

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		switch (m_pNpcList[iNpcH]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					return;
				}
				dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
				dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					return;
				}
				dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
				dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
				break;
		}

		if ((iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) &&
			(m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
			(m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
			return;
		}

		if ((m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1, m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
			(m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
			(m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
			return;
		}

		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
			if (cDir == 0) return;
			m_pNpcList[iNpcH]->m_cDir = cDir;

			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				//Para evitar que ataquen las torres de la sade, cuando no fueron construidas - ZeroEoyPnk
				if (m_pNpcList[iNpcH]->m_sAppr2 == 0) {
					switch (m_pNpcList[iNpcH]->m_sType) {
						case 36: // Crossbow Guard Tower: 
						case 87:
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2);
							iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE);
							break;

						case 37: // Cannon Guard Tower: 
						case 89:
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
							m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
							NpcMagicHandler(iNpcH, dX, dY, 61);
							break;
					}
				}
			}

			else {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į���� ���������� �����ϴ� �ǹ� 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1); // ���ݿ� ���� ȿ���� �����Ѵ�. 
				switch (m_pNpcList[iNpcH]->m_sType) {
					case 65: // Ice Golem
					case 98: // Ice Lizzard
						if (m_pNpcList[iNpcH]->m_cTargetType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) {
								if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
									bool bFrozenFlag = true;
									int FrozenTime = 5000; // 5 Segundos de freeze como default
									int NecklaceIndex = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->GetWearedItemIndex((int)DEF_EQUIPPOS_NECK);

									if (NecklaceIndex > -1) {
										if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex] != NULL) {
											if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 643) // Ice Elemental Necklace	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3228) // FullPowerNeck	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3235) // NeckMasterDef	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3248) // NeckMasterDef2	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3249) // NeckMasterDef3	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3250) // NeckMasterDef4	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3251) // NeckMasterDef5	
												bFrozenFlag = false;
											else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 642) // Ice Pro Necklace									
												FrozenTime = 1250; // 25% * 5000									
										}
									}

									if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != NULL)
										if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
											FrozenTime = 1250; // 25% * 5000
										else if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5)
											bFrozenFlag = false;

									if (bFrozenFlag == true) {
										m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);

										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE,
											dwTime + FrozenTime,
											m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER,
											NULL, NULL, NULL, 1, NULL, NULL);//	NULL, NULL, NULL, 1, NULL, NULL);

										SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex,
											CLIENT_NOTIFY_MAGICEFFECTON,
											DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
							}
						}
						break;
				}
			}
			m_pNpcList[iNpcH]->m_iAttackCount++;

			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
					case DEF_ATTACKAI_EXCHANGEATTACK:
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
						break;

					case DEF_ATTACKAI_TWOBYONEATTACK:
						if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
							m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
						}
						break;
				}
			}
		}
		else {
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			m_pNpcList[iNpcH]->m_cDir = cDir;

			if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1, 2) == 1) &&
				(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
				iMagicType = -1;
				switch (m_pNpcList[iNpcH]->m_cMagicLevel) { // �� ��Ŭ���� ���� ������ �������� �Ǵ��� ó��. 
					case 1:
						if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 0;
						break;

					case 2:
						if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 10;
						else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 0;
						break;

					case 3: // Orc Mage
						if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 20; // Fire-Ball
						else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 10; // Energy-Bolt
						break;

					case 4: // ????
						if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 30; // Fire-Strike
						else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 37; // Lightning-Arrow
						else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 20; // Fire-Ball
						else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 10; // Energy-Bolt
						break;

					case 5: // Hellbound, Cyclops, Cannibal-Plant, Rudolph
						if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 43; // Lightning
						else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 30; // Fire-Strike
						else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 37; // Lightning-Arrow
						else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 20; // Fire-Ball
						else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 10; // Energy-Bolt
						break;

					case 6: // Liche, Tentocle
						if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 51; // Lightning-Bolt
						else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 43; // Lightning
						else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 30; // Fire-Strike
						else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 37; // Lightning-Arrow
						else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 20; // Fire-Ball
						else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 10; // Energy-Bolt
						break;

					case 7: // Demon, Gagoyle, Hellclaw, Barlog, Fire-Wyvern, MasterMage-Orc, LWB-Aresden, LWB-Elvine, GHK, GHKABS, TK, BG
						if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 5) == 3)) iMagicType = 70; // Bloody-Shock-Wave
						else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 61; // Mass-Fire-Strike
						else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 60; // Energy-Strike
						else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 51; // Lightning-Bolt
						else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 43; // Lightning
						break;

					case 8: // Unicorn, Centaurus, Giant-Lizard, 
						if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 35; // Paralyze
						else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 60; // Energy-Strike
						else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 51; // Lightning-Bolt
						else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 43; // Lightning
						break;

					case 9: // Tiger-Worm
						if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 74; // Lightning-Strike
						break;

					case 10: // Frost, Nizie
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 57; // Ice-Strike
						break;

					case 12: // 09/05/06 22:51 Wyvern
						if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 91; // Blizzard
						else if (m_pMagicConfigList[63]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 63; // Mass-Child-Wind
						break;

					case 13: // Abaddon
						if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 96; // Earth Shock Wave
						else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 81; // Meteor Strike
						break;

					case 14: // LightWorm
						if ((m_pMagicConfigList[97]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 97; // StormOfDeath
						else if (m_pMagicConfigList[56]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 56; // Meteor Strike
						break;

					case 15: // Death Wyvern
						if ((m_pMagicConfigList[76]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 76; // cancel
						else if (m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 96; // esw
						else if (m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 35; // Lize
						break;

					case 16: // Hell Liche
						if ((m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 81; // meteor
						else if (m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 74; // LightingStrike
						else if (m_pMagicConfigList[83]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 83; // inibition
						break;

					case 17: // Hell Abaddon
						if ((m_pMagicConfigList[76]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 76; // cancel
						else if (m_pMagicConfigList[97]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 97; // StormOfDeath
						else if (m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 96; // esw
						else if (m_pMagicConfigList[83]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 83; // inibition
						break;
					case 18: // Hell hound
						if ((m_pMagicConfigList[85]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 85; // Fury
						else if (m_pMagicConfigList[65]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 65; // AMP
						break;
					case 19: // GhostAba
						if ((m_pMagicConfigList[76]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 5) == 1)) iMagicType = 76; // cancel
						else if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 5) == 2)) iMagicType = 35; // Lize
						else if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 5) == 3)) iMagicType = 96; // esw
						break;
					case 20: // BlackWyvern
						if ((m_pMagicConfigList[76]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 1)) iMagicType = 76; // cancel
						else if ((m_pMagicConfigList[92]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 2)) iMagicType = 92; // Lize
						else if ((m_pMagicConfigList[98]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1, 3) == 3)) iMagicType = 98; // esw
						break;
				}

				if (iMagicType != -1) {
					if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
						switch (m_pNpcList[iNpcH]->m_cTargetType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) {
									if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
										m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
										m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
										return;
									}
									else goto NBA_CHASE;
								}
								if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)) goto NBA_CHASE;
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) {
									if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
										m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
										m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
										return;
									}
									else goto NBA_CHASE;
								}
								if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)) goto NBA_CHASE;
								break;
						}
					}

					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į���� ���������� �����ϴ� �ǹ� 
					NpcMagicHandler(iNpcH, dX, dY, iMagicType);
					m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000;
					return;
				}
			}

			if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1, 2) == 1) &&
				(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
				iMagicType = -1;
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 43;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 37;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) iMagicType = 0;

				if (iMagicType != -1) {
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Į���� ���������� �����ϴ� �ǹ� 
					NpcMagicHandler(iNpcH, dX, dY, iMagicType);
					m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000;
					return;
				}
			}

			if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) &&
				(abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {

				cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
				if (cDir == 0) return;
				m_pNpcList[iNpcH]->m_cDir = cDir;

				if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
					//Para evitar que ataquen las torres de la sade, cuando no fueron construidas - ZeroEoyPnk
					if (m_pNpcList[iNpcH]->m_sAppr2 == 0) {
						switch (m_pNpcList[iNpcH]->m_sType) {
							case 36: // Crossbow Guard Tower
							case 87: // Cross Torret
								SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2);
								iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
								break;

							case 37: // Cannon Guard Tower
							case 89: // Ancient Gran Canion
								SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
								m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
								NpcMagicHandler(iNpcH, dX, dY, 61);
								break;
						}
					}
				}
				else {
					switch (m_pNpcList[iNpcH]->m_sType) {
						case 51: // v2.05 Catapult: �Ž� ���̾� ��Ʈ����ũ ���� 
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1);
							m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
							NpcMagicHandler(iNpcH, dX, dY, 61);
							break;

						case 54: // Dark Elf: Ȱ ������ �Ѵ�.
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2: Ȱ���� 
							iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
							break;

						case 63: //Frost
						case 53: //Beholder
						case 79: //Nizie
							switch (m_pNpcList[iNpcH]->m_cTargetType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
									if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) &&
										(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
										if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5 * 1000),
												m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
											SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
									if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) &&
										(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
										if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5 * 1000),
												m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						NBA_BREAK1:;
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: �ʻ���
							iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
							break;

						default:
							SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: �ʻ��� 
							iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
							break;
					}
				}
				m_pNpcList[iNpcH]->m_iAttackCount++;

				if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
					switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
						case DEF_ATTACKAI_EXCHANGEATTACK:
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
							m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
							break;

						case DEF_ATTACKAI_TWOBYONEATTACK:
							if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_FLEE;
							}
							break;
					}
				}
				return;
			}

		NBA_CHASE:;

			if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;
			m_pNpcList[iNpcH]->m_iAttackCount = 0;

			if (m_pNpcList[iNpcH]->m_sAreaSize == 0)
				cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			else cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize, iNpcH);

			if (cDir == 0) return;
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			}
			else {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
			}
			m_pNpcList[iNpcH]->m_sX = dX;
			m_pNpcList[iNpcH]->m_sY = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcBehavior_Attack");
	}
#endif
}

void CMapServer::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		DWORD dwTime = timeGetTime();

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				// Crusade 
				if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
					(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

					if (m_pNpcList[i]->m_cActionLimit == 0) {
						m_pNpcList[i]->m_bIsSummoned = TRUE;
						m_pNpcList[i]->m_dwSummonedTime = dwTime;
					}
				}

				if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) &&
					(m_pNpcList[i]->m_cTargetType == cTargetType)) {

					switch (iCode) {
						case DEF_MAGICTYPE_INVISIBILITY:
							if (m_pNpcList[i]->m_cSpecialAbility != 1) {
								m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
								m_pNpcList[i]->m_iTargetIndex = NULL;
								m_pNpcList[i]->m_cTargetType = NULL;
							}
							break;

						default:
							m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
							m_pNpcList[i]->m_iTargetIndex = NULL;
							m_pNpcList[i]->m_cTargetType = NULL;
							break;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveFromTarget");
	}
#endif
}

int CMapServer::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack, BOOL bIsDash, BOOL bArrowDirection)
{
	int    iAP_SM, iAP_L, iAttackerHitRatio = 0, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
	char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect;
	short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
	DWORD  dwTime = timeGetTime();
	WORD   wWeaponType;
	double dTmp1, dTmp2, dTmp3;
	BOOL   bKilled = FALSE;
	BOOL   bNormalMissileAttack = FALSE;
	BOOL   bIsAttackerBerserk, bIsAttackerBerserk2 = FALSE;
	int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
	int    iAttackerHP, iMoveDamage, iRepDamage;
	char   cAttackerSA;
	int    iAttackerSAvalue, iHitPoint = 0;
	char   cDamageMoveDir;
	int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
	int	iSkillLV, iCropLimit;


#ifdef DEF_DEBUG
	try {
#endif
		iExp = 0;
		iPartyID = 0;

		ZeroMemory(cAttackerName, sizeof(cAttackerName));
		cAttackerSA = NULL;
		iAttackerSAvalue = NULL;
		wWeaponType = NULL;

		switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH] == NULL) return 0;
				if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0 && m_pClientList[sAttackerH]->m_iAdminUserLevel < 5) return 0;
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return 0;
				if (m_bIsCrusadeMode == FALSE && (m_pClientList[sAttackerH]->m_bIsHunter == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;

				if ((m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0) {
					SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);

					bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
				}

				if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

				iAP_SM = 0;
				iAP_L = 0;

				wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

				if (wWeaponType == 0) {
					iAP_SM = iAP_L = iDice(1, (m_pClientList[sAttackerH]->m_iStr / 12));
					if (iAP_SM <= 0) iAP_SM = 1;
					if (iAP_L <= 0) iAP_L = 1;
					iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
					m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5;
				}
				else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
					iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
					iAP_L = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

					iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
					iAP_L += m_pClientList[sAttackerH]->m_cAttackBonus_L;

					iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

					// Str
					dTmp1 = (double)iAP_SM;
					if (m_pClientList[sAttackerH]->m_iStr <= 0)
						dTmp2 = 1.0f;
					else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;

					dTmp2 = dTmp2 / 5.0f;
					dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
					iAP_SM = (int)(dTmp3 + 0.5f);

					dTmp1 = (double)iAP_L;
					if (m_pClientList[sAttackerH]->m_iStr <= 0)
						dTmp2 = 1.0f;
					else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;

					dTmp2 = dTmp2 / 5.0f;
					dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
					iAP_L = (int)(dTmp3 + 0.5f);
				}
				else if (wWeaponType >= 40) {
					iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
					iAP_L = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

					iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
					iAP_L += m_pClientList[sAttackerH]->m_cAttackBonus_L;

					iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
					bNormalMissileAttack = TRUE;

					// Str
					iAP_SM += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
					iAP_L += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
				}

				iAttackerHitRatio += 50;
				if (iAP_SM <= 0) iAP_SM = 1;
				if (iAP_L <= 0) iAP_L = 1;

				//Custom-Made
				if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
					if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM))
						iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
					if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L))
						iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
					if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM))
						iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
					if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L))
						iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
				}
				// v3.8 Damage Bonus
				if ((strcmp(m_pClientList[sAttackerH]->m_cMapName, "middleland") == 0) ||
					(strcmp(m_pClientList[sAttackerH]->m_cMapName, "2ndmiddle") == 0) ||
					(strcmp(m_pClientList[sAttackerH]->m_cMapName, "icebound") == 0)) {
					iAP_SM += iAP_SM / 5;
					iAP_L += iAP_SM / 5;
				}
				//WorldWar - LaloRamos - DMG Bonus
				if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "FightMap") == 0) {
					iAP_SM += iAP_SM*1.4;
					iAP_L += iAP_L*1.4;
				}

				//WorldWarII - LaloRamos - DMG Bonus
				if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "WorldMap") == 0) {
					iAP_SM += iAP_SM * 2;
					iAP_L += iAP_L * 2;
				}

				//All Eks - LaloRamos - DMG Bonus
				if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "evento13") == 0) {
					iAP_SM += iAP_SM * 1.5;
					iAP_L += iAP_L * 1.5;
				}

				//All DK Eks - LaloRamos - DMG Bonus
				if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "evento14") == 0) {
					iAP_SM += iAP_SM * 1.5;
					iAP_L += iAP_L * 1.5;
				}

				//EventDk - LaloRamos - DMG Bonus
				if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "EventDk") == 0) {
					iAP_SM += iAP_SM * 1.5;
					iAP_L += iAP_L * 1.5;
				}

				//Bonus Armas Assasain 
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sWeaponIndex == -1) || (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] == NULL))
					sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];

				if ((sWeaponIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL)) {
					if (m_pClientList[sAttackerH]->Assasain == TRUE) {
						if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4975) || //Assasain Barbarian
							(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4976) || //Assasain Blade
							(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4977)) { //Assasain Axe

							if (m_pClientList[sAttackerH]->m_iRating < 0) {
								iRepDamage = abs(m_pClientList[sAttackerH]->m_iRating) / 100;
								iAP_SM += iRepDamage; // /2
								iAP_L += iRepDamage;
								if (cTargetType == DEF_OWNERTYPE_PLAYER) {
									if (m_pClientList[sTargetH] != NULL) {
										if (m_pClientList[sTargetH]->m_iRating > 0) {
											iRepDamage = m_pClientList[sTargetH]->m_iRating / 100;
											iAP_SM += iRepDamage / 4; // 2
											iAP_L += iRepDamage / 4;
										}
										if (m_pClientList[sTargetH]->m_iRating < 0) {
											iRepDamage = m_pClientList[sTargetH]->m_iRating / 100;
											iAP_SM += iRepDamage / 4;
											iAP_L += iRepDamage / 4;
										}
									}
								}
							}
						}
					}

					//Bonus de la DarkExecutor durante la noche 
					if ((sWeaponIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL)) {
						if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 847) && // Dark Executor
							(m_cDayOrNight == 2)) { // Noche
							iAP_SM += 25;
							iAP_L += 25;
						}
					}
					//Bonus de la LightingBlade durante el dia 
					if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 848) && // Lighting Blade
						(m_cDayOrNight == 1)) { // Dia
						iAP_SM += 45;
						iAP_L += 45;
					}
					// AresdenStormBringer
					if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4957) && (m_pClientList[sAttackerH]->m_cSide == 1)) {
						if (cTargetType == DEF_OWNERTYPE_PLAYER) {
							if ((m_pClientList[sTargetH] != NULL) && (m_pClientList[sTargetH]->m_cSide != 1 ||
								((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)))) {
								iAP_SM += 60;
								iAP_L += 60;
							}
						}
					}
					// ElvineStormBringer	
					if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4958) && (m_pClientList[sAttackerH]->m_cSide == 2)) {
						if (cTargetType == DEF_OWNERTYPE_PLAYER) {
							if ((m_pClientList[sTargetH] != NULL) && (m_pClientList[sTargetH]->m_cSide != 2 ||
								((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)))) {
								iAP_SM += 60;
								iAP_L += 60;
							}
						}
					}

					//KlonnessEsterk 851	Lalo Ramos
					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 851) { // KlonessEsterk
						if (m_pClientList[sAttackerH]->m_iRating > 0) {
							iRepDamage = m_pClientList[sAttackerH]->m_iRating / 500;
							iAP_SM += iRepDamage + 1;
							iAP_L += iRepDamage + 1;
						}
					}

					// Aca Lalin
					//Bonus de las armas Kloness
					if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 4908) || // BlackAxe
						(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 849) || // KlonessBlade
						(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum == 850)) { // KlonessAxe

						if (m_pClientList[sAttackerH]->m_iRating > 0) {
							iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
							iAP_SM += iRepDamage;
							iAP_L += iRepDamage;
							if (cTargetType == DEF_OWNERTYPE_PLAYER) {
								if (m_pClientList[sTargetH] != NULL) {
									if (m_pClientList[sTargetH]->m_iRating < 0) {
										iRepDamage = abs(m_pClientList[sTargetH]->m_iRating) / 100;
										iAP_SM += iRepDamage / 2;
										iAP_L += iRepDamage / 2;
									}
									if (m_pClientList[sTargetH]->m_iRating > 0) {
										iRepDamage = m_pClientList[sTargetH]->m_iRating / 100; //100
										iAP_SM -= iRepDamage / 12;
										iAP_L -= iRepDamage / 12;
									}
									if ((m_pClientList[sTargetH]->Assasain) && (m_pClientList[sTargetH]->m_iRating > 0)) {
										iRepDamage = abs(m_pClientList[sTargetH]->m_iRating) / 100;
										iAP_SM += iRepDamage / 2;
										iAP_L += iRepDamage / 2; //4
									}
								}
							}
						}
					}
				}

				cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
				strcpy_secure(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);

				if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) {
					if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 2) bIsAttackerBerserk = TRUE;
					else bIsAttackerBerserk2 = TRUE;
				}
				else bIsAttackerBerserk = FALSE;

				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {

					dTmp1 = (double)iAP_SM;
					dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
					dTmp3 = dTmp2 / 100.0f;
					dTmp2 = dTmp1 * dTmp3;
					iTemp = (int)(dTmp2 + 0.5f);
					iAP_SM += iTemp;

					dTmp1 = (double)iAP_L;
					dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
					dTmp3 = dTmp2 / 100.0f;
					dTmp2 = dTmp1 * dTmp3;
					iTemp = (int)(dTmp2 + 0.5f);
					iAP_L += iTemp;

					switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
						case 6:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 30; break;	// Ȱ ���� +10%
						case 7:  iAP_SM *= 2; iAP_L *= 2; break; // �ܰ� ���� +200%
						case 8:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 30; break;	// ��Į ���� +10%
						case 10:  iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5);                           break;   // ���� ���� +20%
						case 14:  iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); iAttackerHitRatio += 20; break;   // �ظ� ���� +20%
						case 21:  iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); iAttackerHitRatio += 50; break;   // ������ ���� +20%
						default: break;		// ��Ÿ ����
					}
					iAttackerHitRatio += 100;
					iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
				}

				if (bIsDash == TRUE) {
					iAttackerHitRatio += 20;
					switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
						case 8:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); break;	// ��Į ���� +10%
						case 10: iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); break;    // ���� ���� +20%
						case 14: iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); break;    // �ظ� ���� +20%
						default: break;		// ��Ÿ ����
					}
				}

				iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
				iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

				sAtkX = m_pClientList[sAttackerH]->m_sX;
				sAtkY = m_pClientList[sAttackerH]->m_sY;

				iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH] == NULL) return 0;
				if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return 0;

				if ((m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0) {
					SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);

					bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
					m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
				}

				cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
				iAP_SM = iAP_L = 0;

				if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0)
					iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);

				iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;

				cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
				memcpy_secure(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);

				if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) bIsAttackerBerserk = TRUE;
				else bIsAttackerBerserk = FALSE;

				iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;
				cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

				sAtkX = m_pNpcList[sAttackerH]->m_sX;
				sAtkY = m_pNpcList[sAttackerH]->m_sY;

				break;
		}

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return 0;
				if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return 0;
				if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return 0;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
					if (memcmp(m_pClientList[sTargetH]->m_cMapName, "VipMap1", 7) == 0) return 0;
					//Safe en Event Garden
					if (memcmp(m_pClientList[sTargetH]->m_cMapName, "areuni", 6) == 0) return 0;
				}

				if ((m_bIsCrusadeMode == FALSE) &&
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_bIsHunter == TRUE) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER)) return 0;

				if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE)
					&& (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return 0;

				if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;
				if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
				if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

				cTargetDir = m_pClientList[sTargetH]->m_cDir;
				iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE)) {
					iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
					if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {}
					else {
						if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
							if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
						}
						else return 0;
					}
				}

				iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;

				sTgtX = m_pClientList[sTargetH]->m_sX;
				sTgtY = m_pClientList[sTargetH]->m_sY;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sTargetH] == NULL) return 0;
				if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;
				if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;
				switch (m_pNpcList[sTargetH]->m_sType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26:
					case 67:
					case 68:
					case 69:
					case 90:
					case 111:
						return 0;
						break;
				}

				cTargetDir = m_pNpcList[sTargetH]->m_cDir;
				iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

				if (RunSummonEvent == TRUE || RunSummonEvent2 == TRUE || RunSummonEvent3 == TRUE) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 38:
						case 39:
							return 0;
							break;
					}
				}
				if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 36:
						case 37:
						case 38:
						case 39:
							if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide))
								if (wWeaponType != 25)
									return 0;
							break;

						case 40:
						case 41:
						case 87:
						case 89:
							if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
							break;
						case 64:
							if (m_bIsCrusadeMode == TRUE) return 0;
							break;

						case 92:
							if ((m_bIsRushNetMode) || (HellOfDeath)) {
								//Reliquia elvine
								if ((!HellOfDeath) && (!AttackElvine) && (m_pNpcList[sTargetH]->m_cSide == 2)) return 0;
								else if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;

								//Reliquia Aresden
								if ((!HellOfDeath) && (!AttackAresden) && (m_pNpcList[sTargetH]->m_cSide == 1)) return 0;
								else if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
							}
							break;
					}

					if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
						if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;

						switch (m_pNpcList[sTargetH]->m_sType) {
							case 36:
							case 37:
							case 38:
							case 39:
								if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 4)
									m_pNpcList[sTargetH]->m_iBuildCount = 1;

								switch (m_pNpcList[sTargetH]->m_iBuildCount) {
									case 1: // �ϼ��Ǿ���.
										m_pNpcList[sTargetH]->m_sAppr2 = 0;
										SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

										switch (m_pNpcList[sTargetH]->m_sType) {
											case 36: iConstructionPoint = 700; iWarContribution = 700; break;	// �ַο� ���� Ÿ�� 
											case 37: iConstructionPoint = 700; iWarContribution = 700; break;	// ĳ�� ���� Ÿ��
											case 38: iConstructionPoint = 500; iWarContribution = 500; break;	// ���� �ݷ���
											case 39: iConstructionPoint = 500; iWarContribution = 500; break;	// ������
										}

										m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
										if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
											m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

										wsprintf(G_cTxt, "Construction Complete! WarContribution: +%d", iWarContribution);
										PutLogList(G_cTxt);

										SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
										break;

									case 5: // �ι�° ���׷��̵� 
										m_pNpcList[sTargetH]->m_sAppr2 = 1;
										SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
										break;
									case 10: // ó�� ���׷��̵�
										m_pNpcList[sTargetH]->m_sAppr2 = 2;
										SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
										break;
								}
								break;
						}

						m_pNpcList[sTargetH]->m_iBuildCount--;
						if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) m_pNpcList[sTargetH]->m_iBuildCount = 0;
						return 0;
					}

					if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_iNpcCrops != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {

						iSkillLV = m_pClientList[sAttackerH]->m_cSkillMastery[2];
						iCropLimit = m_pNpcList[sTargetH]->m_iCropsSkillLV;

						if (20 > iSkillLV) return 0;  //v2.19 2002-12-16 ��ų���� 20���� ����..
						if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0; //v2.20 2002-12-20 ���� ��ų ���� 20���� ����

						switch (m_pNpcList[sTargetH]->m_sType) {
							case 64:
								switch (m_pNpcList[sTargetH]->m_iBuildCount) {
									case 1: // ��������.

										m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 3;
										if (iSkillLV <= iCropLimit + 10) SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

										if (bProbabilityTable(iSkillLV, iCropLimit, 2) > 0) bCropsItemDrop(sAttackerH, sTargetH, TRUE);
										DeleteNpc(sTargetH);

										break;
									case 8: // �ι�° ���׷��̵�
										m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 3;
										if (iSkillLV <= iCropLimit + 10) SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

										if (bProbabilityTable(iSkillLV, iCropLimit, 2) > 0)
											if (iSkillLV <= iCropLimit + 10) bCropsItemDrop(sAttackerH, sTargetH);
										break;

									case 18: // ù��° ���׷��̵� 
										m_pNpcList[sTargetH]->m_sAppr2 = m_pNpcList[sTargetH]->m_iNpcCrops << 8 | 2;
										if (iSkillLV <= iCropLimit + 10) SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

										if (bProbabilityTable(iSkillLV, iCropLimit, 2) > 0)
											if (iSkillLV <= iCropLimit + 10) bCropsItemDrop(sAttackerH, sTargetH);
										break;
								}
								break;
						}

						if (m_pNpcList[sTargetH] == NULL) return 0;

						if (bProbabilityTable(iSkillLV, iCropLimit, 1) > 0
							|| m_pNpcList[sTargetH]->m_iBuildCount == 1
							|| m_pNpcList[sTargetH]->m_iBuildCount == 8
							|| m_pNpcList[sTargetH]->m_iBuildCount == 18) {

							iTemp = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];

							if ((iTemp != -1) || (m_pClientList[sAttackerH]->m_pItemList[iTemp] != NULL)) {
								if (m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
									m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan--;

								if (m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
									SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
									ReleaseItemHandler(sAttackerH, iTemp, TRUE);  // <- �� �Լ��� ���������� ȿ���� ó�� 
								}
							}
							m_pNpcList[sTargetH]->m_iBuildCount--;
						}
						if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) m_pNpcList[sTargetH]->m_iBuildCount = 0;
						return 0;
					}
				}
				sTgtX = m_pNpcList[sTargetH]->m_sX;
				sTgtY = m_pNpcList[sTargetH]->m_sY;
				break;
		}

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER)) {

			sX = m_pClientList[sAttackerH]->m_sX;
			sY = m_pClientList[sAttackerH]->m_sY;

			dX = m_pClientList[sTargetH]->m_sX;
			dY = m_pClientList[sTargetH]->m_sY;

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
		}

		// Dex
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_sRankAddDex + m_pClientList[sAttackerH]->m_iAngelicDex) > 50) {
				iAttackerHitRatio += (m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_sRankAddDex + m_pClientList[sAttackerH]->m_iAngelicDex - 50);
			}
		}

		if (wWeaponType >= 40) {
			switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
				case 0:	break;
				case 1:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 20); break;
				case 2:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 10); break;
				case 3:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 4);  break;
			}
		}
		if (iAttackerHitRatio < 0) iAttackerHitRatio = 0;

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
				break;

			case DEF_OWNERTYPE_NPC:
				cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
				break;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
				if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] == NULL) {
					m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
					DeleteClient(sAttackerH, TRUE, TRUE);
					return 0;
				}

				if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
					if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) return 0;
					else {
						if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == NULL) return 0;

						if (bArrowDirection == FALSE) {
							m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
							if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount <= 0) {

								ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE);
								m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
							}
							else {
								SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount, (char)FALSE, NULL);
								iCalcTotalWeight(sAttackerH);
							}
						}
					}
					if (cProtect == 1) return 0;
				}
			}
		}
		else {
			switch (m_pNpcList[sAttackerH]->m_sType) {
				case 65: // Ice Golem
				case 98: // Ice Lizard
					if (m_pNpcList[sAttackerH]->m_cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_iHP > 0) {
							int NecklaceIndex = m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->GetWearedItemIndex((int)DEF_EQUIPPOS_NECK);
							if (NecklaceIndex > -1) {
								if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex] != NULL) {
									if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 643) {
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3228) {//NeckPowerFull
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3235) {//NeckMasterDef
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3248) {//NeckMasterDef2
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3249) {//NeckMasterDef3
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3250) {//NeckMasterDef4
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 3251) {//NeckMasterDef5
										iAP_SM = 0;
										iAP_L = 0;
									}
									else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_pItemList[NecklaceIndex]->m_sIDnum == 642) {
										iAP_SM = iAP_SM / 2;
										iAP_L = iAP_SM / 2;
									}
								}
							}
							if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != NULL) {
								if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) {
									iAP_SM = iAP_SM / 2;
									iAP_L = iAP_SM / 2;
								}
								else if (m_pClientList[m_pNpcList[sAttackerH]->m_iTargetIndex]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) {
									iAP_SM = 0;
									iAP_L = 0;
								}
							}
						}
					}
					break;
			}
			// NPC
			switch (cProtect) {
				case 1:
					switch (m_pNpcList[sAttackerH]->m_sType) {
						case 54:
							if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0;
							break;
					}
					break;
				case 3: iTargetDefenseRatio += 40;  break; //  Magic Shield
				case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
			}
			if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
		}

		if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
		if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

		dTmp1 = (double)(iAttackerHitRatio);
		dTmp2 = (double)(iTargetDefenseRatio);

		dTmp3 = (dTmp1 / dTmp2) * 50.0f;
		iDestHitRatio = (int)(dTmp3);

		if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
		if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

		// Berserk
		if ((bIsAttackerBerserk == TRUE) && (iAttackMode < 20)) {
			iAP_SM = iAP_SM * 2;
			iAP_L = iAP_L * 2;
		}
		if ((bIsAttackerBerserk2 == TRUE) && (iAttackMode < 20)) {
			if (cTargetType == DEF_OWNERTYPE_NPC) {
				switch (m_pNpcList[sTargetH]->m_sType) {
					case 36:
					case 37:
					case 38:
					case 39:
					case 40:
					case 41:
					case 64:
					case 87:
					case 89:
					case 91:
					case 92:
						break;
					default:
						dTmp1 = (double)iAP_SM;
						dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
						dTmp3 = dTmp2 / 52;
						dTmp2 = dTmp1 * dTmp3;
						iTemp = (int)(dTmp2 + 0.5f);
						iAP_SM += iTemp;

						dTmp1 = (double)iAP_L;
						dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
						dTmp3 = dTmp2 / 52;
						dTmp2 = dTmp1 * dTmp3;
						iTemp = (int)(dTmp2 + 0.5f);
						iAP_L += iTemp;
						break;
				}
			}
			else {
				dTmp1 = (double)iAP_SM;
				dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
				dTmp3 = dTmp2 / 52;
				dTmp2 = dTmp1 * dTmp3;
				iTemp = (int)(dTmp2 + 0.5f);
				iAP_SM += iTemp;

				dTmp1 = (double)iAP_L;
				dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
				dTmp3 = dTmp2 / 52;
				dTmp2 = dTmp1 * dTmp3;
				iTemp = (int)(dTmp2 + 0.5f);
				iAP_L += iTemp;
			}
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
			iAP_L += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		}

		if (bNearAttack == TRUE) {
			iAP_SM = iAP_SM / 2;
			iAP_L = iAP_L / 2;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
			iAP_L -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
		}

		//Crusade
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (iAP_SM <= 1) iAP_SM = 1;
			if (iAP_L <= 1) iAP_L = 1;
		}
		else {
			if (iAP_SM <= 0) iAP_SM = 0;
			if (iAP_L <= 0) iAP_L = 0;
		}

		iResult = iDice(1, 100);

		if (iResult <= iDestHitRatio) {
			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
				if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) &&
					(iDice(1, 10) == 5)) return FALSE;

				m_pClientList[sAttackerH]->m_iComboAttackCount++;
				if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
				if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;

				iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
				iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

				if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
					iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

				iAP_SM += iComboBonus;
				iAP_L += iComboBonus;

				switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {	// ���� ������ ȿ�� ����: 0-None 1-�ʻ����������߰� 2-�ߵ�ȿ�� 3-������ 4-������
					case 0: break;
					case 1: // �ʻ���~
						if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
							iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
							iAP_L += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
						}
						break;

					case 2: // �ߵ���~
						cAttackerSA = 61; // cAttackerSA�� 61�̸� �ߵ� ������ ������ ���� �ǹ� 
						iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue * 5;
						break;

					case 3: // ������~
						cAttackerSA = 62;
						break;
				}

				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
					iAP_SM += iAP_SM / 3;
					iAP_L += iAP_L / 3;
				}

				// Crusade
				if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
					if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
						iAP_SM += iAP_SM;
						iAP_L += iAP_L;
					}
					else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
						iAP_SM += (iAP_SM * 7) / 10;
						iAP_L += (iAP_L * 7) / 10;
					}
					else {
						iAP_SM += iAP_SM / 3; ;
						iAP_L += iAP_L / 3;
					}
				}
			}

			switch (cTargetType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sTargetH] == NULL) return 0;
					ClearSkillUsingStatus(sTargetH);
					if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return 0;
					else {
						switch (cAttackerSA) {
							case 62: // ������~
								if (m_pClientList[sTargetH]->m_iRating < 0) {
									iTemp = abs(m_pClientList[sTargetH]->m_iRating) / 10;
									if (iTemp > 10) iTemp = 10;
									iAP_SM += iTemp;
								}
								break;
						}

						iAP_Abs_Armor = 0;
						iAP_Abs_Shield = 0;

						iTemp = iDice(1, 10000);
						if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1; // 50%�� ���뿡 ����
						else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2; // 25%�� �ٸ������� ����
						else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3; // 15%�� �Ⱥ����� ����
						else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4; // 10%�� �Ӹ������� ���� 

						switch (iHitPoint) {
							case 1:
								if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
									if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
										dTmp1 = 80.0f;
									else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
									dTmp2 = (double)iAP_SM;
									dTmp3 = (dTmp1 / 100.0f) * dTmp2;

									iAP_Abs_Armor = (int)dTmp3;
								}
								break;

							case 2:
								if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
									m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
									if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
										m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
										dTmp1 = 80.0f;
									else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
									dTmp2 = (double)iAP_SM;
									dTmp3 = (dTmp1 / 100.0f) * dTmp2;

									iAP_Abs_Armor = (int)dTmp3;
								}
								break;

							case 3:
								if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
									if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
										dTmp1 = 80.0f;
									else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
									dTmp2 = (double)iAP_SM;
									dTmp3 = (dTmp1 / 100.0f) * dTmp2;

									iAP_Abs_Armor = (int)dTmp3;
								}
								break;

							case 4:
								if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
									if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
										dTmp1 = 80.0f;
									else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
									dTmp2 = (double)iAP_SM;
									dTmp3 = (dTmp1 / 100.0f) * dTmp2;

									iAP_Abs_Armor = (int)dTmp3;
								}
								break;
						}
						//Lalo Ramos PaSet Balance /2  ((int)dTmp3)/2;
						if (m_pClientList[sTargetH]->m_iAddAbsPD != 0) {

							dTmp1 = (double)iAP_SM;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsPD;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iAP_SM = iAP_SM - ((int)dTmp3);
						//	iAP_SM = iAP_SM - ((int)dTmp3)/2;
						//	iAP_SM = iAP_SM - ((int)dTmp3) / 1.25;

							dTmp1 = (double)iAP_L;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsPD;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iAP_L = iAP_L - ((int)dTmp3);
						//	iAP_L = iAP_L - ((int)dTmp3)/2;
						//	iAP_L = iAP_L - ((int)dTmp3) / 1.25;
						}

						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
							if (iDice(1, 100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {

								if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80)
									dTmp1 = 80.0f;
								else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
								dTmp2 = (double)iAP_SM;
								dTmp3 = (dTmp1 / 100.0f) * dTmp2;

								iAP_Abs_Shield = (int)dTmp3;

								iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
								if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {

									if (((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) || (m_pClientList[sTargetH]->Assasain))
										&& (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))
										m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;

									if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
										SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
										ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- �� �Լ��� ���������� ȿ���� ó�� 
									}
								}
							}
						}
						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
							iAP_SM = iAP_SM - ((iAP_Abs_Armor / 2) + iAP_Abs_Shield);
							if (iAP_SM <= 0) iAP_SM = 1;
						}
						else if (cAttackerType == DEF_OWNERTYPE_NPC) {
							iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
							if ((iAP_SM <= 0) && (m_pNpcList[sAttackerH]->m_sType != 65) && (m_pNpcList[sAttackerH]->m_sType != 98))
								iAP_SM = 1;
						}

						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) {
							switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
								case 0: break;
								case 1: // HP 50%�� �������� ������. ���� 50%�� �������� ���� ���������� ���ٸ� �������� �״����̴�.
									iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
									if (iTemp > iAP_SM) iAP_SM = iTemp;
									if (iAP_SM <= 0) iAP_SM = 1;
									break;

								case 2: // 10�ʰ� �õ� ȿ�� 
									if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
										m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (30 * 1000),
											sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

										SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
									break;

								case 3:
									if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 0) {
										m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = 2;
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (10 * 1000),
											sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 10, NULL, NULL);

										SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, NULL, NULL);
									}
									break;

								case 4:
									iAP_SM = (m_pClientList[sTargetH]->m_iHP);
									break;

								case 5:
									m_pClientList[sAttackerH]->m_iHP += iAP_SM;
									if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
									SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
									break;
							}
						}

						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
							switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
								case 50:
									if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
										sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
									else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
									if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
									break;

								case 51:
									if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
										iAP_SM = 0;
									break;

								case 52:
									iAP_SM = 0;
									break;

								case 70:
									m_pClientList[sAttackerH]->m_iHP -= iAP_SM;
									SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
									SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, -1, NULL);
									if (m_pClientList[sAttackerH]->m_iHP <= 0)
										ClientKilledHandler(sAttackerH, NULL, NULL, iAP_SM);
									iAP_SM = 0;
									break;
							}
						}

						if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) &&
							(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
							iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
						}

						// Hammer Stripping
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) HammerStrip(sAttackerH, cAttackerType, sTargetH, iHitPoint);

						if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
							SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT], NULL, NULL);
							switch (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
								case 1:
									SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
									break;
								case 2:
								case 5:
									SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
									break;
								case 3:
								case 4:
									SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
									break;
							}
							m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
						}

						if ((m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && ((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61))) {
							if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) {
								m_pClientList[sTargetH]->m_bIsPoisoned = TRUE;
								if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
								else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
								else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue; // cAttackerSA�� 61�̸� �ߵ� ������ ������ ���� �ǹ� 

								m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
								SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
								SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE); // v2.23
							}
						}

						if (cAttackerType == DEF_OWNERTYPE_NPC) {
							if (m_pNpcList[sAttackerH]->m_sType == 65 || m_pNpcList[sAttackerH]->m_sType == 98) {
								if (cTargetType == DEF_OWNERTYPE_PLAYER)
									if (iAP_SM <= 0) iAP_SM = 1;
							}
						}

						m_pClientList[sTargetH]->m_iHP -= iAP_SM;

						if (m_pClientList[sTargetH]->m_iHP <= 0) {
							if (cAttackerType == DEF_OWNERTYPE_PLAYER)
								bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);

							ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);
							bKilled = TRUE;
							if (m_pClientList[sTargetH] != NULL) iKilledDice = m_pClientList[sTargetH]->m_iLevel;
						}
						else {
							if (iAP_SM > 0) {
								if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
									dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
									dTmp2 = (double)iAP_SM;
									dTmp3 = (dTmp1 / 100.0f)*dTmp2;

									iTemp = (2 * (m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_sRankAddMag + m_pClientList[sTargetH]->m_iAngelicMag)) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt + m_pClientList[sTargetH]->m_sRankAddInt + m_pClientList[sTargetH]->m_iAngelicInt) / 2);
									m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
									if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
								}

								if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
									if (iDice(1, 50) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) { //aumentado el tiempo de recharge
										iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
										if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
										SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
									}
								}

								//No recall por 10 segundos - ZeroEoyPnk
								m_pClientList[sTargetH]->m_bRecall = FALSE;
								m_pClientList[sTargetH]->RecallTime = dwTime;
								SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (cAttackerType == DEF_OWNERTYPE_PLAYER) sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
								else sAttackerWeapon = 1;

								if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE))
									iMoveDamage = 60;
								else iMoveDamage = 40;

								if (iAP_SM >= iMoveDamage) {
									if (sTgtX == sAtkX) {
										if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
										else if (sTgtY > sAtkY) cDamageMoveDir = 5;
										else if (sTgtY < sAtkY) cDamageMoveDir = 1;
									}
									else if (sTgtX > sAtkX) {
										if (sTgtY == sAtkY)     cDamageMoveDir = 3;
										else if (sTgtY > sAtkY) cDamageMoveDir = 4;
										else if (sTgtY < sAtkY) cDamageMoveDir = 2;
									}
									else if (sTgtX < sAtkX) {
										if (sTgtY == sAtkY)     cDamageMoveDir = 7;
										else if (sTgtY > sAtkY) cDamageMoveDir = 6;
										else if (sTgtY < sAtkY) cDamageMoveDir = 8;
									}

									m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;
									SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
								}
								else {
								CAE_SKIPDAMAGEMOVE:;
									int iProb;
									if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
										switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
											case 6: iProb = 3500; break;		// Ȱ����
											case 8: iProb = 1000; break;		// ��Į ���� 
											case 9: iProb = 2900; break;       // ���� ����
											case 10: iProb = 2500; break;		// ���� ����
											case 14: iProb = 2000; break;		// �ظ� ����
											case 21: iProb = 2000; break;		// ������ ����
											default: iProb = 1; break;			// ��Ÿ ����
										}
									}
									else iProb = 1;

									if (iDice(1, 10000) >= iProb)
										SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);
								}

								if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1) {
									SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

									m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
									bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}

								m_pClientList[sTargetH]->m_iSuperAttackCount++;
								if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) {

									m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
									iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 5);
									if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;

									SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
								}
							}
						}
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
					if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;

					if (m_bIsCrusadeMode == TRUE) {
						if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
							switch (m_pNpcList[sTargetH]->m_sType) {
								case 40:
								case 41:
								case 43:
								case 44:
								case 45:
								case 46:
								case 47:
								case 51:
									return 0;

								default: break;
							}
						}
						else {
							switch (m_pNpcList[sTargetH]->m_sType) {
								case 41:
									if (cAttackerSide != 0) {
										m_pNpcList[sTargetH]->m_iV1 += iAP_L;
										if (m_pNpcList[sTargetH]->m_iV1 > 500) {
											m_pNpcList[sTargetH]->m_iV1 = 0;
											m_pNpcList[sTargetH]->m_iManaStock--;
											if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
											wsprintf(G_cTxt, "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
											PutLogList(G_cTxt);
										}
									}
									break;
							}
						}
					}

					switch (m_pNpcList[sTargetH]->m_cActionLimit) {
						case 1:
						case 2:
						case 6: //v2.20 2002-12-20 ���� NPC ���� �ʵǰ� 
							return 0;
					}

					if (m_pNpcList[sTargetH]->m_cSize == 0)	 iDamage = iAP_SM;
					else iDamage = iAP_L;

					if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
						dTmp1 = (double)iDamage;
						dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage)) / 100.0f;
						dTmp3 = dTmp1 * dTmp2;
						dTmp2 = dTmp1 - dTmp3;
						iDamage = (int)dTmp2;
						if (iDamage < 0) iDamage = 1;
					}

					if ((31 == m_pNpcList[sTargetH]->m_sType) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)
						&& (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7)) iDamage = iDamage + iDice(3, 2);

					if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);
					}

					switch (m_pNpcList[sTargetH]->m_cActionLimit) {
						case 0: // �Ϲ�
						case 3: // ���̷�
						case 5: // ���๰ 
							m_pNpcList[sTargetH]->m_iHP -= iDamage;

							if (cAttackerType == DEF_OWNERTYPE_PLAYER && cTargetType == DEF_OWNERTYPE_NPC)
							{
								if (m_pClientList[sAttackerH] != NULL && m_pNpcList[sTargetH] != NULL)
								{
									if (m_pNpcList[sTargetH]->m_iHP > m_pNpcList[sTargetH]->m_iMaxHP) m_pNpcList[sTargetH]->m_iMaxHP = m_pNpcList[sTargetH]->m_iHP;
									notifyNpcHealth(sAttackerH, sTargetH);
								}
							}
							break;
					}

					if (m_pNpcList[sTargetH]->m_iHP <= 0) {
						NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
						bKilled = TRUE;
						iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
					}
					else {
						if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
							&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

						if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
						if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
						if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
						if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;

						if (iDice(1, 3) == 2) {
							if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
								tX = tY = 0;
								switch (m_pNpcList[sTargetH]->m_cTargetType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
											tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
											tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
											tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
											tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
										}
										break;
								}

								iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

								tX = tY = 0;
								switch (cAttackerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sAttackerH] != NULL) {
											tX = m_pClientList[sAttackerH]->m_sX;
											tY = m_pClientList[sAttackerH]->m_sY;
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sAttackerH] != NULL) {
											tX = m_pNpcList[sAttackerH]->m_sX;
											tY = m_pNpcList[sAttackerH]->m_sY;
										}
										break;
								}

								iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

								if (iDst2 <= iDst1) {
									m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
									m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
									m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
									m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;
								}
							}
							else {
								m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
								m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
								m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;
							}
						}

					CAE_SKIPCOUNTERATTACK:;

						if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
							m_pNpcList[sTargetH]->m_dwTime = dwTime;

						if (cAttackerType == DEF_OWNERTYPE_PLAYER)
							sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
						else sAttackerWeapon = 1;

						if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;
							}

							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
								cDamageMoveDir = iDice(1, 8);
								dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
								dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

								if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
							}

							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
							m_pNpcList[sTargetH]->m_sX = dX;
							m_pNpcList[sTargetH]->m_sY = dY;
							m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

							SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
								cDamageMoveDir = iDice(1, 8);
								dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
								dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

								if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
							}

							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
							m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
							m_pNpcList[sTargetH]->m_sX = dX;
							m_pNpcList[sTargetH]->m_sY = dY;
							m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

							SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

							if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
								if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
									if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

									if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
										dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
										dTmp2 = (double)iExp;
										dTmp3 = (dTmp1 / 100.0f)*dTmp2;
										iExp += (int)dTmp3;
									}

									// Crusade
									if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

									GetExp(sAttackerH, iExp);
									DeleteNpc(sTargetH);
									return FALSE;
								}
							}

						CAE_SKIPDAMAGEMOVE2:;
						}
						else SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);

						if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1) {
							m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
						}
						else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 2) {
							if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
								m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
								bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
							}
						}

						if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) &&
							(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
								iExp = iDamage;
								m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
							}
							else {
								iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
								m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
							}

							if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1 / 100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							if (m_bIsCrusadeMode == TRUE) iExp = iExp / 3;

							if (m_pClientList[sAttackerH]->m_iLevel > 100) {
								switch (m_pNpcList[sTargetH]->m_sType) {
									case 55:
									case 56:
										iExp = 0;
										break;
									default: break;
								}
							}

						}
					}
					break;
			}

			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {


				if (m_pClientList[sAttackerH] != NULL)
				{
					if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
						sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];

					if (sWeaponIndex != -1) {
						if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) &&
							(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231)) {
							if (bKilled == FALSE)
								CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
							else {
								if (m_pClientList[sAttackerH]->m_iHP <= 3) // ü���� ���� �����ٸ� 2�� ���ʽ� 
									CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice) * 2);
								else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
							}
						}

						if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) &&
							(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0)) {
							iWepLifeOff = 1;
							if ((wWeaponType >= 1) && (wWeaponType < 40)) {
								switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
								case 0:	break;
								case 1:	if (iDice(1, 3) == 1) iWepLifeOff++; break;
								case 2:	if (iDice(1, 2) == 1) iWepLifeOff += iDice(1, 2); break;
								case 3:	if (iDice(1, 2) == 1) iWepLifeOff += iDice(1, 3); break;
								}
							}

							if (m_pClientList[sAttackerH]->m_cSide != 0 || m_pClientList[sAttackerH]->Assasain == TRUE) {
								if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff)
									m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
								else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
							}

							if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
								ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);
							}
						}
					}
				}
				
			}
		}
		else if (cAttackerType == DEF_OWNERTYPE_PLAYER) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
#ifdef DEF_DEBUG
	}
	catch (...) {
		iExp = 0;
		ErrorList("Crash Evitado en: iCalculateAttackEffect");
	}
#endif
	return iExp;
}

void CMapServer::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage, BOOL bHeld)
{
#ifdef DEF_DEBUG
	try {
#endif
		short  sAttackerWeapon;
		int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iWarContribution;
		double dTmp1, dTmp2, dTmp3;
		char   * cp, cData[120];
		unsigned int cQuestRemain;
		int Structures;
		int pX, pY, iNamingValue, z;
		char cName_Internal[31], cWaypoint[31];

		if (m_pNpcList[iNpcH] == NULL) return;
		if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

		if (m_pClientList[sAttackerH] != NULL)
		{
			if (cAttackerType == DEF_OWNERTYPE_PLAYER)
			{
				auto player = m_pClientList[sAttackerH];
				auto npc = m_pNpcList[iNpcH];

				int tmpindex = -1;
				for (int b = 0; b < m_pClientList[sAttackerH]->vec_charquest.size(); b++)
				{
					if (m_pClientList[sAttackerH]->vec_charquest[b].m_sStatus == 1 && tmpindex == -1)
					{						
						if (strcmp(m_pClientList[sAttackerH]->vec_charquest[b].m_cNpcName, m_pNpcList[iNpcH]->m_cNpcName) == 0 && strcmp(m_pClientList[sAttackerH]->vec_charquest[b].m_cMapName, m_pNpcList[iNpcH]->m_cMapName) == 0)
						{
							tmpindex = b;
						}
					}
				}

				if (tmpindex != -1)
				{
				

					if (Questx2) m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_iKills += 2;
					else m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_iKills++;
					//}

					if (m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_iKills >= m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_iMaxKills)
					{
						m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_sCompleted = 1;
						m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_iKills = m_pClientList[sAttackerH]->vec_charquest[tmpindex].m_iMaxKills;
						m_pClientList[sAttackerH]->send_charquest_data_byindex(tmpindex);
					}
					else
					{
						m_pClientList[sAttackerH]->send_charquest_data_byindex(tmpindex);
					}

				}
			}
		}

		m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
		m_pNpcList[iNpcH]->m_iHP = 0;
		m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

		// Summon  Event
		if (RunSummonEvent == TRUE || RunSummonEvent2 == TRUE || RunSummonEvent3 == TRUE) {
			if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "ESAresden", 9) == 0) {
				if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject <= MSTotal) {
					AresdenSummon = timeGetTime() - 500;
					NextRound(1, 1, 10);
				}
				else NextRound(1, 2, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject - MSTotal);
			}
			else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "ESElvine", 8) == 0) {
				if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject <= MSTotal) {
					ElvineSummon = timeGetTime() - 500;
					NextRound(2, 1, 10);
				}
				else NextRound(2, 2, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject - MSTotal);
			}
			else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "ESAssasain", 10) == 0) {
				if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject <= MSTotal) {
					AssasainSummon = timeGetTime() - 500;
					NextRound(0, 1, 10);
				}
				else NextRound(0, 2, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject - MSTotal);
			}
		}

		if ((PriceHODEvent) && (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_HELLOFDEAT, 8) == 0))
			if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject <= 0) dw_PriceHODTime = timeGetTime() - 3300000;

		//ZeroEoyPnk - Apocalypse Abbadon Create
		if ((m_bIsApocalypseMode == TRUE) && (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "abaddon", 7) == 0)) {
			if (m_pNpcList[iNpcH]->m_sType != 81) {
				if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) {
					ZeroMemory(cWaypoint, sizeof(cWaypoint));

					for (z = 0; z < DEF_MAXMAPS; z++) {
						if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "abaddon") == 0)) {
							iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
							if (iNamingValue != -1) {

								ZeroMemory(cName_Internal, sizeof(cName_Internal));
								wsprintf(cName_Internal, "XX%d", iNamingValue);
								cName_Internal[0] = '_';
								cName_Internal[1] = z + 65;
								pX = 94;
								pY = 102;

								if ((bCreateNewNpc("Abaddon", cName_Internal, m_pMapList[z]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
									m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
								}
							}
						}
					}
				}
			}
		}

		Structures = -1;
		if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_HELLCLAW, strlen(DEF_SUMMONMAP_HELLCLAW)) == 0) Structures = 0;
		else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_TIGERWORM, strlen(DEF_SUMMONMAP_TIGERWORM)) == 0) Structures = 1;
		else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_WYVERN, strlen(DEF_SUMMONMAP_WYVERN)) == 0) Structures = 2;
		else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_FIRE_WYVERN, strlen(DEF_SUMMONMAP_FIRE_WYVERN)) == 0) Structures = 3;
		else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_ABADDON, strlen(DEF_SUMMONMAP_ABADDON)) == 0) Structures = 4;
		else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_HELLDEATH, strlen(DEF_SUMMONMAP_HELLDEATH)) == 0) Structures = 5;
		else if (memcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, DEF_SUMMONMAP_LIGHTWORM, strlen(DEF_SUMMONMAP_LIGHTWORM)) == 0) Structures = 6;

		if (Structures != -1) SummonBalls[Structures].dwOpenSummonMap = timeGetTime() - 9000000;

		RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);
		ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);

		m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
		m_pNpcList[iNpcH]->m_cTargetType = NULL;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH] == NULL) return;
			sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
			// Achivements - Hb Argentina v4.0
			m_pClientList[sAttackerH]->TotalMobsKilled++;
			if (!m_pClientList[sAttackerH]->Achivements[0].Complete)
				CheckCompleteAchivement(sAttackerH, 0, TRUE);
			else if (!m_pClientList[sAttackerH]->Achivements[9].Complete)
				CheckCompleteAchivement(sAttackerH, 9, TRUE);
			else if (!m_pClientList[sAttackerH]->Achivements[25].Complete)
				CheckCompleteAchivement(sAttackerH, 25, TRUE);

			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
				if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW)
					CheckCompleteAchivement(sAttackerH, 3, TRUE);
			}

			if ((m_bIsCrusadeMode) || (m_bIsRushNetMode) || (TowerDefense)) {
				switch (m_pNpcList[iNpcH]->m_sType) {
					case 36:
					case 37:
					case 38:
					case 39:
					case 40:
					case 87:
					case 89:
					case 92:
						m_pClientList[sAttackerH]->TotalStructuresKilled++;
						if (!m_pClientList[sAttackerH]->Achivements[10].Complete) CheckCompleteAchivement(sAttackerH, 10, TRUE);
						break;
				}
			}

			switch (m_pNpcList[iNpcH]->m_sType) {
				case 49:
				case 50:
				case 66:
				case 73:
				case 108:
				case 109:
					if (!m_pClientList[sAttackerH]->Achivements[11].Complete) CheckCompleteAchivement(sAttackerH, 11, TRUE);
					break;

				case 81:
					if (!m_pClientList[sAttackerH]->Achivements[11].Complete) CheckCompleteAchivement(sAttackerH, 11, TRUE);
					if (!m_pClientList[sAttackerH]->Achivements[26].Complete) CheckCompleteAchivement(sAttackerH, 26, TRUE);
					break;
			}
		}
		else sAttackerWeapon = 1;

		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
		if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		}
		else m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);

		m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
		if (bHeld == TRUE) NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);
		if ((m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
			iExp = (m_pNpcList[iNpcH]->m_iExp / 3);
			if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
				iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

			if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
				dTmp2 = (double)iExp;
				dTmp3 = (dTmp1 / 100.0f)*dTmp2;
				iExp += (int)dTmp3;
			}
			if (m_pNpcList[iNpcH]->m_sType == 81) {
				for (i = 1; i < DEF_MAXCLIENTS; i++) {
					if (m_pClientList[i] != NULL)
						SendNotifyMsg(sAttackerH, i, CLIENT_NOTIFY_ABADDONKILLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
				}

				if (AbaddonEvent) CloseAbaddonEvent();

				if (PriceEvent == TRUE) {
					PriceTime = timeGetTime() - (25 * 60 * 1000);
					for (z = 0; z < DEF_MAXMAPS; z++) { // No atack luego de matar al abby
						if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) m_pMapList[z]->m_bIsAttackEnabled = FALSE;
						else if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "abaddon") == 0)) m_pMapList[z]->m_bIsAttackEnabled = FALSE;
					}
				}

				if (WWPriceEvent == TRUE) {
					WWPriceTime = timeGetTime() - (25 * 60 * 1000);
					for (z = 0; z < DEF_MAXMAPS; z++) { // No atack luego de matar al abby
						if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) m_pMapList[z]->m_bIsAttackEnabled = FALSE;
						else if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "HellAbaddon") == 0)) m_pMapList[z]->m_bIsAttackEnabled = FALSE;
					}
				}

				if (WWIIPriceEvent == TRUE) {
					WWIIPriceTime = timeGetTime() - (25 * 60 * 1000);
					for (z = 0; z < DEF_MAXMAPS; z++) { // No atack luego de matar al abby
						if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) m_pMapList[z]->m_bIsAttackEnabled = FALSE;
						else if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "BlackWyvern") == 0)) m_pMapList[z]->m_bIsAttackEnabled = FALSE;
					}
				}
			}

			if (m_bIsCrusadeMode == TRUE && (strcmp(m_pClientList[sAttackerH]->m_cMapName, "default") != 0))
				if (iExp > 10) iExp = iExp / 4;

			GetExp(sAttackerH, iExp);

			for (i = 0; i < 3; i++) {
				switch (i) {
					case 0: iQuestIndex = m_pClientList[sAttackerH]->m_iQuest; break;
					case 1: iQuestIndex = m_pClientList[sAttackerH]->m_iItemQuest; break;
					case 2: iQuestIndex = m_pClientList[sAttackerH]->m_iStatedQuest; break;
				}

				if (iQuestIndex != NULL) {
					////heaton prevent lammers quest and exp
					if (m_pQuestConfigList[iQuestIndex] != NULL && !m_pClientList[sAttackerH]->m_bIsQuestCompleted[i] && m_pClientList[sAttackerH]->m_iCheckCount < 40) {
						switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
							case DEF_QUESTTYPE_MONSTERHUNT_CONTRIB:
							case DEF_QUESTTYPE_MONSTERHUNT_RARE:
							case DEF_QUESTTYPE_MONSTERHUNT_STATED:
								if ((memcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, m_pQuestConfigList[iQuestIndex]->m_cTargetName, 10) == 0)
									&& (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType)) {
									switch (i) {
										case 0:
											//EventoQuest x2 y x3
											if (Questx2 == TRUE)
											{
												((m_pClientList[sAttackerH]->m_iCurQuestCount++) + (m_pClientList[sAttackerH]->m_iCurQuestCount++));
											}
											else if (Questx3 == TRUE)
											{
												((m_pClientList[sAttackerH]->m_iCurQuestCount++) + (m_pClientList[sAttackerH]->m_iCurQuestCount++) + (m_pClientList[sAttackerH]->m_iCurQuestCount++));
											}
											else
											{
												m_pClientList[sAttackerH]->m_iCurQuestCount++;
											}
											//m_pClientList[sAttackerH]->m_iCurQuestCount++;
											cQuestRemain = (m_pQuestConfigList[iQuestIndex]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
											if (cQuestRemain <= 0) {
												cQuestRemain = 0;
												m_pClientList[sAttackerH]->m_iCurQuestCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
												m_pClientList[sAttackerH]->m_bIsQuestCompleted[0] = TRUE;
											}
											break;
										case 1:
											//EventoQuest x2 y x3
											if (Questx2 == TRUE) 
											{
												((m_pClientList[sAttackerH]->m_iItemQuestCount++) + (m_pClientList[sAttackerH]->m_iItemQuestCount++));
											}
											else if (Questx3 == TRUE)
											{
												((m_pClientList[sAttackerH]->m_iItemQuestCount++) + (m_pClientList[sAttackerH]->m_iItemQuestCount++) + (m_pClientList[sAttackerH]->m_iItemQuestCount++));
											}
											else 
											{
												m_pClientList[sAttackerH]->m_iItemQuestCount++;
											}
											//m_pClientList[sAttackerH]->m_iItemQuestCount++;
											cQuestRemain = (m_pQuestConfigList[iQuestIndex]->m_iMaxCount - m_pClientList[sAttackerH]->m_iItemQuestCount);
											if (cQuestRemain <= 0) {
												cQuestRemain = 0;
												m_pClientList[sAttackerH]->m_iItemQuestCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
												m_pClientList[sAttackerH]->m_bIsQuestCompleted[1] = TRUE;
											}
											break;
										case 2:
											//EventoQuest x2 y x3
											if (Questx2 == TRUE)
											{
												((m_pClientList[sAttackerH]->m_iStatedQuestCount++) + (m_pClientList[sAttackerH]->m_iStatedQuestCount++));
											}
											else if (Questx3 == TRUE)
											{
												((m_pClientList[sAttackerH]->m_iStatedQuestCount++) + (m_pClientList[sAttackerH]->m_iStatedQuestCount++) + (m_pClientList[sAttackerH]->m_iStatedQuestCount++));
											}
											else
											{
												m_pClientList[sAttackerH]->m_iStatedQuestCount++;
											}
											//m_pClientList[sAttackerH]->m_iStatedQuestCount++;
											cQuestRemain = (m_pQuestConfigList[iQuestIndex]->m_iMaxCount - m_pClientList[sAttackerH]->m_iStatedQuestCount);
											if (cQuestRemain <= 0) {
												cQuestRemain = 0;
												m_pClientList[sAttackerH]->m_iStatedQuestCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
												m_pClientList[sAttackerH]->m_bIsQuestCompleted[2] = TRUE;
											}
											break;
									}
									SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_QUESTCOUNTER, i, cQuestRemain, NULL, NULL);
									_bCheckIsQuestCompleted(sAttackerH, i);
								}
								break;
						}
					}
				}
			}
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[iNpcH]->m_sType) {
				case 32:
					// Si matan a un unicorn le resta 5 puntos de rep al character
					if (!m_pClientList[sAttackerH]->Assasain) {
						m_pClientList[sAttackerH]->m_iRating -= 5;
						if (m_pClientList[sAttackerH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[sAttackerH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						if (m_pClientList[sAttackerH]->m_iRating > (DEF_LIMIT_REP * 1000)) m_pClientList[sAttackerH]->m_iRating = (DEF_LIMIT_REP * 1000);
						SendNotifyMsg(NULL, sAttackerH, CLIENT_REPONSE_PLAYERREP, m_pClientList[sAttackerH]->m_iRating, NULL, NULL, NULL);
					}
					break;
			}
		}

		// Crusade
		iConstructionPoint = 0;
		switch (m_pNpcList[iNpcH]->m_sType) {
			case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
			case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
			case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
			case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
			case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
			case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	// �Ӽ��ʸ�
			case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	// �ַο� ���� Ÿ�� 
			case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	// ĳ�� ���� Ÿ��
			case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	// ���� �ݷ���
			case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	// ������
			case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	// ������ �ǵ� ���׷�����
			case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;	// �׷��� ���� ���׷�����
			case 43: iConstructionPoint = 500; iWarContribution = 1000; break;	// ����Ʈ �� ��Ʋ
			case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	// ���� �ڵ� ����Ʈ
			case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	// ���� �ڵ� �⺴
			case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	// ���� ����Ʈ
			case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	// ��Ʋ ����
			case 51: iConstructionPoint = 800; iWarContribution = 1500; break;	// ĳ����Ʈ
			case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;
		}

		if (iConstructionPoint != NULL) {
			switch (cAttackerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
						m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

						if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
							m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

					//	wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
					//	PutLogList(G_cTxt);
						SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
					}
					else {
						m_pClientList[sAttackerH]->m_iWarContribution = 0;
						SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
						if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
							for (i = 1; i < DEF_MAXCLIENTS; i++) {
								if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
									(m_pClientList[i]->m_iCrusadeDuty == 3)) {

									m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
									if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
										m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

								//	wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
									//PutLogList(G_cTxt);
									SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
									goto NKH_GOTOPOINT1;
								}
							}
						}
					}
					break;
			}
		}

	NKH_GOTOPOINT1:;
		if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
			m_pNpcList[iNpcH]->m_iMana = 100;
			m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
			NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30);
		}
		else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
			m_pNpcList[iNpcH]->m_iMana = 100;
			m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
			NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61);
		}

		int iMapIndex;
		if (m_pNpcList[iNpcH]->m_bIsBossMob == TRUE) {
			iMapIndex = NULL;
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (iMapIndex >= 0) && (iMapIndex < DEF_MAXMAPS) && (m_pMapList[iMapIndex] != NULL) && (m_pMapList[iMapIndex]->m_bIsRecallImpossible == TRUE)) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 200;
				m_pClientList[i]->m_bIsImpossibleZone = TRUE;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_RECALLTIMELEFT, m_pClientList[i]->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
			}
		}

		if (m_bIsRushNetMode == TRUE) {
			if (m_pNpcList[iNpcH]->m_sType == 92) {
				if (m_pNpcList[iNpcH]->m_cSide == 1) LocalEndRushNetMode(1);
				else if (m_pNpcList[iNpcH]->m_cSide == 2) LocalEndRushNetMode(2);
			}
			Structures = 0;
			if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89) || (m_pNpcList[iNpcH]->m_sType == 38) || (m_pNpcList[iNpcH]->m_sType == 39)) {
				if (m_pNpcList[iNpcH]->m_cSide == 1) {
					m_iTowerAresden--;
					if (m_iTowerAresden == 0) Structures = 1;
				}
				else if (m_pNpcList[iNpcH]->m_cSide == 2) {
					m_iTowerElvine--;
					if (m_iTowerElvine == 0) Structures = 2;
				}
				UpdateRushNet(Structures, true);
			}
		}

		if (TowerDefense == TRUE) {
			Structures = 0;
			if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89)) {
				if (m_pNpcList[iNpcH]->m_cSide == 1) {
					m_iTowerDefenceAresden -= 1;
					if (m_iTowerDefenceAresden <= 0) {
						Structures = 3;
						FlagElvine = TRUE;
					}
				}
				else if (m_pNpcList[iNpcH]->m_cSide == 2) {
					m_iTowerDefenceElvine -= 1;
					if (m_iTowerDefenceElvine <= 0) {
						Structures = 4;
						FlagAresden = TRUE;
					}
				}
				wsprintf(G_cTxt, "(%d - Aresden) / (%d - Elvine)", m_iTowerDefenceAresden, m_iTowerDefenceElvine);
				PutLogList(G_cTxt);
				UpdateTowerDefence(Structures);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcKilledHandler");
	}
#endif
}

void CMapServer::NpcBehavior_Dead(int iNpcH, BOOL Drop)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTime;

		if (m_pNpcList[iNpcH] == NULL) return;

		dwTime = timeGetTime();
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		}
		if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
			DeleteNpc(iNpcH, TRUE, Drop);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcBehavior_Dead");
	}
#endif
}

int CMapServer::iGetDangerValue(int iNpcH, short dX, short dY)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int ix, iy, iDangerValue;
		short sOwner, sDOType;
		char  cOwnerType;
		DWORD dwRegisterTime;

		if (m_pNpcList[iNpcH] == NULL) return FALSE;

		iDangerValue = 0;

		for (ix = dX - 2; ix <= dX + 2; ix++) {
			for (iy = dY - 2; iy <= dY + 2; iy++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sDOType, &dwRegisterTime);

				if (sDOType == 1) iDangerValue++;

				switch (cOwnerType) {
					case NULL:
						break;
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwner] == NULL) break;
						if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) iDangerValue++;
						else iDangerValue--;
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwner] == NULL) break;
						if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) iDangerValue++;
						else iDangerValue--;
						break;
				}
			}
		}
		return iDangerValue;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetDangerValue");
		return 0;
	}
#endif
}

void CMapServer::NpcBehavior_Flee(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cDir;
		short sX, sY, dX = 0, dY = 0;
		short sTarget;
		char  cTargetType;

		if (m_pNpcList[iNpcH] == NULL) return;
		if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

		switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK: // ���� -> ���� -> ... 
			case DEF_ATTACKAI_TWOBYONEATTACK: // ���� -> ���� -> ���� -> ...
				if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
					m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					return;
				}
				break;

			default:
				if (iDice(1, 2) == 1) NpcRequestAssistance(iNpcH);
				break;
		}

		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[iNpcH]->m_tmp_iError = 0;
			if (m_pNpcList[iNpcH]->m_iHP <= 3) {
				m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice);
				if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
			}
			return;
		}

		TargetSearch(iNpcH, &sTarget, &cTargetType);
		if (sTarget != NULL) {
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
		}

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
				dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
				break;
			case DEF_OWNERTYPE_NPC:
				dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
				dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
				break;
		}
		dX = sX - (dX - sX);
		dY = sY - (dY - sY);

		if (m_pNpcList[iNpcH]->m_sAreaSize == 0)
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
		else cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError, m_pNpcList[iNpcH]->m_sAreaSize, iNpcH);

		if (cDir != 0) {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			if (m_pNpcList[iNpcH]->m_sAreaSize == 0) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			}
			else {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearBigOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, m_pNpcList[iNpcH]->m_sAreaSize);
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetBigOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY, m_pNpcList[iNpcH]->m_sAreaSize);
			}
			m_pNpcList[iNpcH]->m_sX = dX;
			m_pNpcList[iNpcH]->m_sY = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcBehavior_Flee");
	}
#endif
}

void CMapServer::MsgProcess()
{
#ifdef DEF_DEBUG
	try {
#endif
		char   * pData, cFrom, cKey;
		DWORD    dwMsgSize, *dwpMsgID;
		WORD   * wpMsgType, *wp;
		int      i, iClientH;
		char   m_msgBuff[1000];
		int iAres = 0, iElv = 0;

		if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
			m_cShutDownCode = 2;
			m_bOnExitProcess = TRUE;
			m_dwExitProcessTime = timeGetTime();
			PutLogList("GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
			return;
		}

		ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE + 1);
		pData = (char *)m_pMsgBuffer;

		m_iCurMsgs = 0;
		while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {
			m_iCurMsgs++;
			if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

			switch (cFrom) {
				case DEF_MSGFROM_CLIENT:
					dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
					switch (*dwpMsgID) {
					case START_QUEST:
						c_questlist->get_quest_data(iClientH, pData + 4 + 2);
						break;
					case REQ_TRADE:
						c_trades->req_trade(iClientH, pData + 4 + 2);
						break;
					case REQ_TRADE_BALL:
						c_trades->req_tradeball(iClientH, pData + 4 + 2);
						break;
					case NOTIFY_PING:
						response_ping(iClientH);
						break;
					case DISMISS_QUEST:
						m_pClientList[iClientH]->req_dismiss_quest(pData + 4 + 2);
						break;
					case PAUSE_QUEST:
						m_pClientList[iClientH]->req_pause_quest(pData + 4 + 2);
						break;

					case REWARD_QUEST:
						m_pClientList[iClientH]->req_reward_quest(pData + 4 + 2);
						break;

					case ACTIVE_QUEST:
						m_pClientList[iClientH]->req_active_quest(pData + 4 + 2);
						break;
					case REQUEST_GETMARKETITEM:
						RequestGetMarketItem(iClientH, pData);
						break;

					case REQUEST_SETMARKETITEM:
						RequestSetMarketItem(iClientH, pData);
						break;

					case REQUEST_MARKETNAMES:
						RequestMarketNames(iClientH);
						break;

					case REQUEST_MARKETITEMS:
						RequestMarketItems(iClientH, pData);
						break;

					case ENHANCEMENT_EXTRACT:
						handleEnchantingExtract(iClientH, pData + 4 + 2);
						break;

					case ENHANCEMENT_FUSION:
						handleEnchantingUpgrade(iClientH, pData + 4 + 2);
						break;

						case NOT_ITEMDATA:
							r_flooritem(iClientH, pData + 4 + 2);
							break;

						case NOT_OBJECTID:
							get_object(iClientH, pData + 4 + 2);
							break;

						case NOT_CHANGERANKSTATS:
							setrankstats(iClientH, pData + 4 + 2);
							break;

						case CLIENT_REQUEST_RESURRECTPLAYER_YES:
							RequestResurrectPlayer(iClientH, TRUE);
							break;

						case CLIENT_REQUEST_RESURRECTPLAYER_NO:
							RequestResurrectPlayer(iClientH, FALSE);
							break;

						case CLIENT_REQUEST_ANGEL:
							GetAngelHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_STATUS_AFK:
							SetAfkFlag(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_SELLITEMLIST:
							RequestSellItemListHandler(iClientH, pData);
							break;

						case CLIENT_NOTIFY_CHANGECITY:
							PlayerOrder_ChangeCity(iClientH);
							break;

						case CLIENT_REQUEST_RESTART:
							RequestRestartHandler(iClientH);
							break;

						//case CLIENT_REQUEST_LOGOUT:
						case CLIENT_REQUEST_NOWLOGOUT:
							RequestLogOutHandler(iClientH);
							break;

						case CLIENT_REQUEST_CANCELLOGOUT:
							RequestCancelLogOutHandler(iClientH);
							break;

						case CLIENT_REQUEST_ONLINE_USERS:
							SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_TOTALUSERS, NULL, NULL, NULL, NULL);
							break;

						case CLIENT_REQUEST_PANNING:
							iRequestPanningMapDataRequest(iClientH, pData);
							break;

						case CLIENT_REQUEST_NOTICEMENT:
							RequestNoticementHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_COMMAND_SHUTUP:
							_BWM_Command_Shutup(pData);
							break;

						case CLIENT_REQUEST_SETITEMPOS:
							_SetItemPos(iClientH, pData);
							break;

						case CLIENT_REQUEST_FULLOBJECTDATA:
							RequestFullObjectData(iClientH, pData);
							break;

						case CLIENT_REQUEST_RETRIEVEITEM:
							RequestRetrieveItemHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_CIVILRIGHT:
							RequestCivilRightHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_TELEPORT:
							RequestTeleportHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_INITPLAYER:
							RequestInitPlayerHandler(iClientH, pData, cKey);
							break;

						case CLIENT_REQUEST_INITDATA:
							RequestInitDataHandler(iClientH, pData, cKey);
							break; //revisar

						case CLIENT_REQUEST_COMMAND_COMMON:
							ClientCommonHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_COMMAND_MOTION:
							ClientMotionHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_COMMAND_CHECKCONNECTION:
							CheckConnectionHandler(iClientH, pData);
							break;

						case CLIENT_REQUEST_COMMAND_CHATMSG:
							ChatMsgHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_CREATENEWGUILD:
							RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_DISBANDGUILD:
							RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_FIGHTZONE_RESERVE:
							FightzoneReserveHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_LEVELUPSETTINGS:
							LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_STATECHANGEPOINT:
							StateChangeHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_TELEPORT_LIST:
							RequestTeleportListHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_CHARGED_TELEPORT:
							RequestChargedTeleportHandler(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_TOPMEMORY:
							for (i = 0; i < 6; i++) HandleRequestMemoryTops(iClientH, i);
							break;

						case CLIENT_REQUEST_FULLDATACHAR:
							SendF5DataCharacter(iClientH);
							break;

						//case CLIENT_REQUEST_HACKDETECTED:
						case CLIENT_REQUEST_PACKSARPAD:
							char * cp;
							cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
							ZeroMemory(m_msgBuff, sizeof(m_msgBuff));
							strcpy_secure(m_msgBuff, cp);
							cp += 30;

							if (m_pClientList[iClientH] != NULL) {
								wsprintf(G_cTxt, "Character: %s - Using Hack: %s", m_pClientList[iClientH]->m_cCharName, m_msgBuff);
								PutLogHacksFileList(G_cTxt);
							//	PutLogList(G_cTxt);
								SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_DELETEHACK, NULL, NULL, NULL, NULL);
							}
							break;

						case CLIENT_REQUEST_DCHACK:
							if (m_pClientList[iClientH] != NULL) 
							{
								wsprintf(G_cTxt, "Character: %s DC HACK", m_pClientList[iClientH]->m_cCharName);// , m_msgBuff);
								PutLogHacksFileList(G_cTxt);
							}
							break;

						case CLIENT_REQUEST_PROCESSANDDLL:
							DataProcessReceived(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_ITEMTOSELLLIST:
							bSetItemToSellList(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_MARKET_ITEMLIST:
							RequestItemsList(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_TIPESELLLIST:
							RequestDefineSellList(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_PURCHASE:
							RequestBuyItem(iClientH, pData, dwMsgSize);
							break;

						case CLIENT_REQUEST_BUY_ASSAPOINTS:
							RequestBuyAssasainPoints(iClientH, pData, dwMsgSize);
							break;

						default:
							/*mtx.lock();*/
							if (enable_log_cl) {
								wsprintf(m_msgBuff, "From Cli: 0x%.8X", *dwpMsgID);
								PutLogList(m_msgBuff);
							}

							bCheckClient[iClientH] = FALSE;

							DeleteClient(iClientH, true, true);
							
							/*delete m_pClientList[iClientH];
							m_pClientList[iClientH] = NULL;
							m_iTotalClients--;
							RemoveClientShortCut(iClientH);
							mtx.unlock();							
							DeleteClient(iClientH, FALSE, FALSE);*/		
							break;
					}
					break;

				case DEF_MSGFROM_LOGSERVER:
					dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
					wpMsgType = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
					switch (*dwpMsgID) {

						case NUCLEO_REQUEST_FORCEDISCONECTACCOUNT:
							wpMsgType = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
							ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
							break;

						case NUCLEO_RESPONSE_SAVEPLAYERDATA_REPLY:
							ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
							break;

						case NUCLEO_RESPONSE_DISBANDGUILD:
							ResponseDisbandGuildHandler(pData, dwMsgSize);
							break;

						case NUCLEO_RESPONSE_CREATENEWGUILD:
							ResponseCreateNewGuildHandler(pData, dwMsgSize);
							break;

						case NUCLEO_RESPONSE_REGISTERGAMESERVER:
							switch (*wpMsgType) {
								case DEF_MSGTYPE_CONFIRM:
									m_bIsLogSockAvailable = true;
									break;

								case DEF_MSGTYPE_REJECT:
									break;
							}
							break;

						case NUCLEO_RESPONSE_PLAYERDATA:
							ResponsePlayerDataHandler(pData, dwMsgSize);
							break;

						default:
							wsprintf(G_cTxt, "From Log: 0x%.8X", dwpMsgID);
							PutLogList(G_cTxt);
							break;
					}
					break;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MsgProcess");
	}
#endif
}


BOOL CMapServer::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;
		m_pMsgQuene[m_iQueneTail] = new class CMsg;
		if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

		if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

		m_iQueneTail++;
		if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;
		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bPutMsgQuene");
		return FALSE;
	}
#endif
}

BOOL CMapServer::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

		m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

		delete m_pMsgQuene[m_iQueneHead];
		m_pMsgQuene[m_iQueneHead] = NULL;

		m_iQueneHead++;
		if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bGetMsgQuene");
		return FALSE;
	}
#endif
}

void CMapServer::ClientCommonHandler(int iClientH, char * pData)
{
	WORD * wp, wCommand;
	short * sp, sX, sY;
	int   * ip, iV1, iV2, iV3, iV4;
	char  * cp, cDir, *pString;

#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		wCommand = *wp;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		sX = *sp;
		cp += 2;

		sp = (short *)cp;
		sY = *sp;
		cp += 2;

		cDir = *cp;
		cp++;

		ip = (int *)cp;
		iV1 = *ip;
		cp += 4;

		ip = (int *)cp;
		iV2 = *ip;
		cp += 4;

		ip = (int *)cp;
		iV3 = *ip;
		cp += 4;

		pString = cp;
		cp += 30;

		ip = (int *)cp;
		iV4 = *ip;
		cp += 4;

		switch (wCommand) {
			/*case CLIENT_REQUEST_PING:
				ReqPing(iClientH, iV1);
				break;*/

			case CLIENT_REQUEST_HUNTMODE:
				RequestHuntmode(iClientH);
				break;

			case CLIENT_REQUEST_GUILDNAME:
				RequestGuildNameHandler(iClientH, iV1, iV2);
				break;

			case CLIENT_REQUEST_UPGRADEITEM:
				RequestItemUpgradeHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_ACCEPTJOINPARTY:
				RequestAcceptJoinPartyHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_CREATESLATE:
				ReqCreateSlateHandler(iClientH, pData);
				break;

			case CLIENT_REQUEST_SETGUILDTELEPORTLOC:
				RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
				break;

			case CLIENT_REQUEST_SETGUILDCONSTRUCTLOC:
				RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
				break;

			case CLIENT_REQUEST_GUILDTELEPORT:
				RequestGuildTeleportHandler(iClientH);
				break;

			case CLIENT_REQUEST_SUMMONWARUNIT:
				RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
				break;

			case CLIENT_REQUEST_MAPSTATUS:
				MapStatusHandler(iClientH, iV1, pString);
				break;

			case CLIENT_REQUEST_SELECTCRUSADEDUTY:
				SelectCrusadeDutyHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_CANCELQUEST:
				CancelQuestHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_ACTIVATESPECABLTY:
				ActivateSpecialAbilityHandler(iClientH);
				break;

			case CLIENT_REQUEST_JOINPARTY:
				JoinPartyHandler(iClientH, iV1, pString);
				break;

			case CLIENT_REQUEST_GETMAGICABILITY:
				GetMagicAbilityHandler(iClientH);
				break;

			case CLIENT_REQUEST_BUILDITEM:
				BuildItemHandler(iClientH, pData);
				break;

			case CLIENT_REQUEST_QUESTACCEPTED:
				QuestAcceptedHandler(iClientH);
				break;

			case CLIENT_REQUEST_CANCELEXCHANGEITEM:
				CancelExchangeItem(iClientH);
				break;

			case CLIENT_REQUEST_CONFIRMEXCHANGEITEM:
				ConfirmExchangeItem(iClientH);
				break;

			case CLIENT_REQUEST_SETEXCHANGEITEM:
				SetExchangeItem(iClientH, iV1, iV2);
				break;

				//NetPanel -Trade EK
			case CLIENT_REQUEST_MAJESTICS_ITEMS:
				GetMajesticsItemsHandler(iClientH, iV1, pString);
				break;

			case CLIENT_REQUEST_GETHEROMANTLE:
				GetHeroMantleHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_ITEMSDK:
				GetDkHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_SETDOWNSKILLINDEX:
				SetDownSkillIndexHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_TALKTONPC:
				NpcTalkHandler(iClientH, iV1, iV2);
				break;

			case CLIENT_REQUEST_CREATEPOTION:
				ReqCreatePortionHandler(iClientH, pData);
				break;

			case CLIENT_REQUEST_GETFISHTHISTIME:
				ReqGetFishThisTimeHandler(iClientH);
				break;

			case CLIENT_REQUEST_REPAIRITEMCONFIRM:
				ReqRepairItemCofirmHandler(iClientH, iV1, pString);
				break;

			case CLIENT_REQUEST_REPAIRITEM:
				ReqRepairItemHandler(iClientH, iV1, iV2, pString);
				break;

			case CLIENT_REQUEST_SELLITEMCONFIRM:
				ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
				break;

			case CLIENT_REQUEST_SELLITEM:
				ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
				break;

			case CLIENT_REQUEST_USESKILL:
				UseSkillHandler(iClientH, iV1, iV2, iV3);
				break;

			case CLIENT_REQUEST_USEITEM:
			case CLIENT_REQUEST_TOMOEAT:
				UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
				break;

			case CLIENT_REQUEST_GETREWARDMONEY:
				GetRewardMoneyHandler(iClientH);
				break;

			case CLIENT_COMMON_ITEMDROP:
				DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
				break;

			case CLIENT_REQUEST_EQUIPITEM:
				bEquipItemHandler(iClientH, iV1);
				break;

			case CLIENT_REQUEST_PURCHASEITEM:
				RequestPurchaseItemHandler(iClientH, pString, iV1);
				break;

			case CLIENT_REQUEST_STUDYMAGIC:
				RequestStudyMagicHandler(iClientH, pString);
				break;

			case CLIENT_REQUEST_GIVEITEMTOCHAR:
				GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
				break;

			case CLIENT_REQUEST_EXCHANGEITEMTOCHAR:
				ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
				break;

			case CLIENT_COMMON_JOINGUILDAPPROVE:
				JoinGuildApproveHandler(iClientH, pString);
				break;

			case CLIENT_COMMON_JOINGUILDREJECT:
				JoinGuildRejectHandler(iClientH, pString);
				break;

			case CLIENT_COMMON_DISMISSGUILDAPPROVE:
				DismissGuildApproveHandler(iClientH, pString);
				break;

			case CLIENT_COMMON_DISMISSGUILDREJECT:
				DismissGuildRejectHandler(iClientH, pString);
				break;

			case CLIENT_REQUEST_RELEASEITEM:
				ReleaseItemHandler(iClientH, iV1, TRUE);
				break;

			case CLIENT_REQUEST_TOGGLECOMBATMODE:
				ToggleCombatModeHandler(iClientH);
				break;

			case CLIENT_COMMON_MAGIC:
				PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
				break;

			case CLIENT_REQUEST_TOGGLESAFEATTACKMODE:
				ToggleSafeAttackModeHandler(iClientH);
				break;

			case CLIENT_REQUEST_GETOCCUPYFIGHTZONETICKET:
				GetFightzoneTicketHandler(iClientH);
				break;

			case CLIENT_REQUEST_CRAFTITEM:
				ReqCreateCraftingHandler(iClientH, pData);
				break;

			case CLIENT_REQUEST_REPAIR_ALL:
				int i;
				for (i = 0; i < 50; i++)
					ReqRepairItemCofirmHandler(iClientH, i, NULL);
				break;

			case CLIENT_REQUEST_RECALL_COORDS:
				PlayerReceivedCoords(iClientH, iV1, iV2);
				break;

			case CLIENT_REQUEST_BANKPAGE:
				DefineWHPage(iClientH, iV1);
				break;

				//Lalov9fake
			case CLIENT_REQUEST_NODISCONNECT:
				// Fakes with Movement -> ZeroEoyPnk papa ;)
				m_iAFKUsers++;
				m_pClientList[iClientH]->NoClear = TRUE;
				{
					wsprintf(G_cTxt, "AfkUser: %s", m_pClientList[iClientH]->m_cCharName);
					PutLogHacksFileList(G_cTxt);
				}
				m_pClientList[iClientH]->TimerMove = timeGetTime() + (iDice(1, 120) * 60000);
				return;
			//	DeleteClient(iClientH, FALSE, FALSE, FALSE, TRUE);
				break;

			case CLIENT_REQUEST_GETASSASAINHERO:
				GetAssasainHero(iClientH, iV1);
				break;

			case CLIENT_REQUEST_RESETASSASAIN:
				ResetAssasain(iClientH, iV1);
				break;

			case CLIENT_REQUEST_CHANGEPKEK:
				ChangePkToEk(iClientH, iV1);
				break;

			case CLIENT_REQUEST_BANME:
				RemoveFromGuild(iClientH);
				break;

			case CLIENT_RESQUEST_TRADEITEM:
				RequestTradeItemHandler(iClientH, pString, iV1, iV2);
				break;

			case CLIENT_REQUEST_REMOVEITEMEXCHANGE:
				RequestRemoveItemExchange(iClientH, iV1);
				break;

			case CLIENT_REQUEST_LISTCOMPLETE:
				CompleteAchivementList(iClientH);
				break;

			case CLIENT_REQUEST_STATUSFRIEND:
				SearchStatusFriend(iClientH, iV1, pString);
				break;

			case CLIENT_REQUEST_GUILDMEMBER:
				RequestGuildMembers(iClientH);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClientCommonHandler");
	}
#endif
}

void CMapServer::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;  //DEBUG
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
		if ((iAmount != -1) && (iAmount < 0)) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		if (FinalFight && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0) return;
		if (DKEvent && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_EVENTDK ) == 0 && m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0) return;
		//NADA CON ID
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			ShowClientMsg(iClientH, "Item con ID no puedes tirarlo!");
			return;
		}


		if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) && (iAmount == -1))
			iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;

		if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

		if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
			(((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0)) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
				delete pItem;
				return;
			}
			else {
				if (iAmount <= 0) {
					delete pItem;
					return;
				}
				pItem->m_dwCount = (DWORD)iAmount;
			}

			if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
				delete pItem;
				return;
			}

			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
			SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

			if (m_pClientList[iClientH] == NULL) return;
			pItem->m_dwTimeDrop = timeGetTime();

			if (bByPlayer == TRUE) _bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);
			else _bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem, TRUE);

			SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			ReleaseItemHandler(iClientH, sItemIndex, TRUE);

			if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) &&
				(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
				m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwTimeDrop = timeGetTime();

				if (bByPlayer == TRUE) _bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				else _bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex], TRUE);

				if (m_pClientList[iClientH] == NULL) return;
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
			}

			if (m_pClientList[iClientH] == NULL) return;
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
			m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
		}
		iCalcTotalWeight(iClientH);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DropItemHandler");
	}
#endif
}

int CMapServer::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
	char  cRemainItemColor, cData[100];
	int   iRet, iEraseReq;
	class CItem * pItem;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return 0;
		if ((cDir <= 0) || (cDir > 8))       return 0;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

		if (m_pClientList[iClientH]->KilledClientAFK != -1) m_pClientList[iClientH]->KilledClientAFK = -1;

		if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

		int iStX, iStY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
			iStX = m_pClientList[iClientH]->m_sX / 20;
			iStY = m_pClientList[iClientH]->m_sY / 20;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
				case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
				case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
			}
		}

		ClearSkillUsingStatus(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

		pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
		if (pItem != NULL) {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				pItem->m_dwTimeDrop = -1;

				_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_ITEMOBTAINED;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

				*cp = 1;
				cp++;

				memcpy_secure(cp, pItem->m_cName, 20);
				cp += 20;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
				cp++;

				sp = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;

				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor; // v1.4
				cp++;

				//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				//cp++;
				//cambio lalomanu
				sp = (short *)cp;
				*sp = pItem->m_sItemSpecEffectValue2;
				cp += 2;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;

				if (iEraseReq == 1) delete pItem;

				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

				//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				//cambio lalomanu
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return 0;
				}
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
				pItem->m_dwTimeDrop = timeGetTime();

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return 0;
				}
			}
		}

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOTION_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
		return 1;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iClientMotion_GetItem_Handler");
	}
#endif
	return 0;
}

BOOL CMapServer::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pItem == NULL) return FALSE;

		if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH))
				return FALSE;
		}
		else {
			if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH))
				return FALSE;
		}

		if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			for (i = 0; i < DEF_MAXITEMS; i++) {
				if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) &&
					(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0)) {
					m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
					*pDelReq = 1;
					iCalcTotalWeight(iClientH);
					return TRUE;
				}
			}
		}

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {

				m_pClientList[iClientH]->m_pItemList[i] = pItem;
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
				m_pClientList[iClientH]->m_pItemList[i]->SetBagPosition(40, 30);

				*pDelReq = 0;

				if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

				iCalcTotalWeight(iClientH);
				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bAddClientItemList");
	}
#endif
	return FALSE;
}

BOOL CMapServer::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{
	char  cEquipPos, cHeroChecker;
	short sTemp, sSpeed;
	int   iTemp;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;

		if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
			switch (m_pClientList[iClientH]->m_sType) {
				case 1:
				case 2:
				case 3:
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
					break;
				case 4:
				case 5:
				case 6:
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
					break;
			}
		}

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3111 && m_pClientList[iClientH]->m_iLevel > 150) || 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3111 && m_pClientList[iClientH]->m_iRebirthLevel > 0))
		{
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, sItemIndex, TRUE);
			ShowClientMsg(iClientH, "Your level is too high to use this item");
			return FALSE;
		}

		if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) * 100) return FALSE;

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) || (cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
				case 10: // Str ���� 
					if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
						return FALSE;
					}
					break;
				case 11: // Dex
					if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
						return FALSE;
					}
					break;
				case 12: // Vit
					if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
						return FALSE;
					}
					break;
				case 13: // Int
					if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
						return FALSE;
					}
					break;
				case 14: // Mag
					if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
						return FALSE;
					}
					break;
				case 15: // Chr
					if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
						return FALSE;
					}
					break;
			}
		}

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum) {
			case 845: // Storm Bringer
				if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 65) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex, TRUE);
					return FALSE;
				}
				break;
			case 865: // Resur Wand Ms 10
			case 866: // Resur Wand Ms 29
				if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt)) > 99 &&
					((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) > 99 && m_pClientList[iClientH]->m_iSpecialAbilityTime < 1) {
					m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
				}
				break;
			case 890: // power hero sword
				if (((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < 200) ||
					((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex, TRUE);
					ShowClientMsg(iClientH, "You need 200 Str and 200 Dex");
					return FALSE;
				}
				break;
			case 2090: // power hero wand
				if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 200) ||
					((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) < 200)) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex, TRUE);
					ShowClientMsg(iClientH, "You need 200 Int and 200 Mag");
					return FALSE;
				}
				break;
			case 4957: // Ares Storm Bringer
			case 4958: // Elv Storm Bringer|
				if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 65) ||
					((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex, TRUE);
					ShowClientMsg(iClientH, "You need 65 Int and 200 Dex");
					return FALSE;
				}
				break;
			case 4969: // Ice Strip Hammer
				if (((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < 200) ||
					((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex, TRUE);
					ShowClientMsg(iClientH, "You need 200 Str and 200 Dex");
					return FALSE;
				}
				break;

			default:
				break;
		}

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

			if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[m_pClientList[iClientH]->m_iSpecialAbilityEquipPos], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[m_pClientList[iClientH]->m_iSpecialAbilityEquipPos], TRUE);
				}
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], FALSE);
			else {
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND], FALSE);
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND], FALSE);
			}
		}
		else {
			if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND], FALSE);
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], FALSE);
		}

		if (cEquipPos == DEF_EQUIPPOS_FULLBODY) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], FALSE);
			else {
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD], FALSE);
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY], TRUE);
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS], FALSE);
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS], FALSE);
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS], FALSE);
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK], FALSE);
			}
		}
		else {
			if ((cEquipPos == DEF_EQUIPPOS_HEAD) || (cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_ARMS)
				|| (cEquipPos == DEF_EQUIPPOS_LEGGINGS) || (cEquipPos == DEF_EQUIPPOS_PANTS) || (cEquipPos == DEF_EQUIPPOS_BACK)) {
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY] != -1)
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY], FALSE);
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], FALSE);
		}
		m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;

		switch (cEquipPos) {
			case DEF_EQUIPPOS_RHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4);
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0x0FFFFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				else iTemp = iTemp | (0 << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0x0FFFFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 28);
				else iTemp = iTemp | (0 << 28);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;

				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);

				m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;

				sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
				if (sSpeed < 0) sSpeed = 0;

				iTemp = iTemp | sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_LHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xFFF0;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue));
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xF0FFFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
				else iTemp = iTemp | (0 << 24);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xF0FFFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 24);
				else iTemp = iTemp | (0 << 24);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_TWOHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4);
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0x0FFFFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				else iTemp = iTemp | (0 << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0x0FFFFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 28);
				else iTemp = iTemp | (0 << 28);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;

				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);

				m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;

				sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
				if (sSpeed < 0) sSpeed = 0;

				iTemp = iTemp | sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_BODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr ���� ����. 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
				}
				else {
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr ���� ����. 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
					sTemp = m_pClientList[iClientH]->m_sAppr4;
					sTemp = sTemp | 0x080;
					m_pClientList[iClientH]->m_sAppr4 = sTemp;
				}

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFF0FFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
				else iTemp = iTemp | (0 << 20);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFF0FFFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 20);
				else iTemp = iTemp | (0 << 20);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_BACK:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xF0FF;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8);
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFF0FFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
				else iTemp = iTemp | (0 << 16);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFF0FFFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 16);
				else iTemp = iTemp | (0 << 16);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_ARMS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFFF0;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue));
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFF0FFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
				else iTemp = iTemp | (0 << 12);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFF0FFF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 12);
				else iTemp = iTemp | (0 << 12);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_PANTS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xF0FF;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8);
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFF0FF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
				else iTemp = iTemp | (0 << 8);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFFF0FF;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 8);
				else iTemp = iTemp | (0 << 8);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_LEGGINGS:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0x0FFF;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12);
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFF0F;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
				else iTemp = iTemp | (0 << 4);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFFFF0F;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15) << 4);
				else iTemp = iTemp | (0 << 4);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_HEAD:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFF0F;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4);
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFFF0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor <= 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
				else iTemp = iTemp | (0);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFFFFF0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor > 15)
					iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor - 15));
				else iTemp = iTemp | (0);
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_FULLBODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12);
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFF0FFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFF0FFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
				case 0: break;
				case 1: m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	break;
				case 2: m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C; break;
				case 3: m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	break;
			}
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
				case 0: break;
				case 50:
				case 51:
				case 52:
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;	// 10
					break;

				default:
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;	 // 01
					break;
			}
		}

		cHeroChecker = CheckHeroItemEquipHandler(iClientH);
		if (cHeroChecker != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroBonus = cHeroChecker;

		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		CalcTotalItemEffect(iClientH, sItemIndex, bNotify);

		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bEquipItemHandler");
	}
#endif
	return FALSE;
}

void CMapServer::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
	int i, iRet, iShortCutIndex = 0;
	char  * cp, cData[100];
	DWORD * dwp, dwTime;
	WORD * wp;
	short * sp;
	BOOL bFlag;
	char  cKey;

#ifdef DEF_DEBUG
	try {
#endif
		cKey = (char)(rand() % 255) + 1; // v1.4

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = wMsgType;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = sX;
		cp += 2;

		sp = (short *)cp;
		*sp = sY;
		cp += 2;

		sp = (short *)cp;
		*sp = sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = sV4;
		cp += 2;

		dwTime = timeGetTime();

		bFlag = TRUE;
		iShortCutIndex = 0;
		while (bFlag == TRUE) {
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;			

			int fix_x = 0;
			int fix_y = 0;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {

			if (m_pClientList[i]->sResolution == C640x480)
			{
				fix_x = 10;
				fix_y = 8;
			}
			else if (m_pClientList[i]->sResolution == C800x600)
			{
				fix_x = 12;
				fix_y = 10;
			}
			else if (m_pClientList[i]->sResolution == C1024x768) 
			{
				fix_x = 16;
				fix_y = 12;
			}

				if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
					(m_pClientList[i]->m_sX >= sX - fix_x) &&
					(m_pClientList[i]->m_sX <= sX + fix_x) &&
					(m_pClientList[i]->m_sY >= sY - fix_y) &&
					(m_pClientList[i]->m_sY <= sY + fix_y)) {

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 22, cKey);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(i, TRUE, TRUE);
						break;
					}
				}
			}
	}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEventToNearClient_TypeB");
	}
#endif
}

int CMapServer::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
	char cData[100];
	DWORD * dwp;
	WORD  * wp;
	int     iRet;
	short   sOwnerH;
	char    cOwnerType;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return 0;
		if ((cDir <= 0) || (cDir > 8))       return 0;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

		if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
			if (sOwnerH != NULL) {
				m_pClientList[iClientH]->NoDelete = FALSE;
				m_pClientList[iClientH]->NoClear = FALSE;

				m_pClientList[iClientH]->m_bForceDisconnect = true;
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}

		ClearSkillUsingStatus(iClientH);

		int iStX, iStY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
			iStX = m_pClientList[iClientH]->m_sX / 20;
			iStY = m_pClientList[iClientH]->m_sY / 20;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
				case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
				case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
			}
		}

		m_pClientList[iClientH]->m_cDir = cDir;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOTION_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
		return 1;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iClientMotion_Stop_Handler");
		return 0;
	}
#endif
}

void CMapServer::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
	register int i;
	WORD  * wp, wResult = NULL;
	DWORD * dwp;
	char  * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

#ifdef DEF_DEBUG
	try {
#endif
		ZeroMemory(cCharName, sizeof(cCharName));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		memcpy_secure(cCharName, cp, 10);
		cp += 10;

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
				(m_pClientList[i]->m_iLevel >= 99) && (m_pClientList[i]->m_iCharisma >= 10)) {

				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				switch (*wp) {
					case DEF_MSGTYPE_CONFIRM:
						wResult = DEF_MSGTYPE_CONFIRM;
						m_pClientList[i]->m_iGuildRank = 0;
						wsprintf(cTxt, "New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
						CharacterLogList(cTxt);
						if (!m_pClientList[i]->Achivements[7].Complete)
							CheckCompleteAchivement(i, 7, TRUE);
						break;

					case DEF_MSGTYPE_REJECT:
						wResult = DEF_MSGTYPE_REJECT;
						ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
						memcpy_secure(m_pClientList[i]->m_cGuildName, "NONE", 4);
						m_pClientList[i]->m_iGuildRank = -1;
						m_pClientList[i]->m_iGuildGUID = -1;
						SetItemCount(i, "Gold", dwGetItemCount(i, "Gold") + dwCreateGuildGoldCost);
						iCalcTotalWeight(i);
						wsprintf(cTxt, "New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
						CharacterLogList(cTxt);
						break;
				}

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_CREATENEWGUILD;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = wResult;

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(i, TRUE, TRUE);
						return;
				}
				return;
			}
		wsprintf(cTxt, "Non-existing player data received from Log server(2): CharName(%s)", cCharName);
		CharacterLogList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ResponseCreateNewGuildHandler");
	}
#endif
}

void CMapServer::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cGuildName[21], cTxt[120], cData[100];
	DWORD * dwp, dwGoldCount;
	WORD  * wp;
	int     iRet;
	SYSTEMTIME SysTime;
	char cGoldValueInfo[100];

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_bIsCrusadeMode == TRUE) return;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		cp += 10;
		cp += 10;
		cp += 10;

		ZeroMemory(cGuildName, sizeof(cGuildName));
		memcpy_secure(cGuildName, cp, 20);
		cp += 20;
		dwGoldCount = dwGetItemCount(iClientH, "Gold");

		if (m_pClientList[iClientH]->m_iGuildRank != -1) {
			wsprintf(cTxt, "Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
			CharacterLogList(cTxt);
		}
		else {
			if ((m_pClientList[iClientH]->m_iLevel < 100) || (dwGetItemCount(iClientH, "Gold") < DEF_GUILDCOST) ||
				(m_pClientList[iClientH]->m_iCharisma < 10) || ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (!m_pClientList[iClientH]->Assasain))) {
				ZeroMemory(cData, sizeof(cData));

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_CREATENEWGUILD;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
			}
			else if (dwGoldCount < DEF_GUILDCOST) {
				ZeroMemory(cData, sizeof(cData));

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_CREATENEWGUILD;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}

				if (dwGetItemCount(iClientH, "Gold") < DEF_GUILDCOST) {
					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_NOTENOUGHGOLD;
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = -1;
					cp++;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					ZeroMemory(cGoldValueInfo, sizeof(cGoldValueInfo));
					wsprintf(cGoldValueInfo, " The price for creating a guild is %lu gold.", dwCreateGuildGoldCost);
					ShowClientMsg(iClientH, cGoldValueInfo);
				}
			}
			else {
				SetItemCount(iClientH, "Gold", dwGetItemCount(iClientH, "Gold") - DEF_GUILDCOST);
				iCalcTotalWeight(iClientH);
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy_secure(m_pClientList[iClientH]->m_cGuildName, cGuildName);
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy_secure(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
				GetLocalTime(&SysTime);
				m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
				bSendMsgToLS(NUCLEO_REQUEST_CREATENEWGUILD, iClientH);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestCreateNewGuildHandler");
	}
#endif
}

void CMapServer::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cGuildName[21], cTxt[120];

		if (m_bIsCrusadeMode == TRUE) return;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cGuildName, sizeof(cGuildName));

		cp += 10;
		cp += 10;
		cp += 10;

		memcpy_secure(cGuildName, cp, 20);
		cp += 20;

		if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
			wsprintf(cTxt, "Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
			CharacterLogList(cTxt);
		}
		else bSendMsgToLS(NUCLEO_REQUEST_DISBANDGUILD, iClientH);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestDisbandGuildHandler");
	}
#endif
}

void CMapServer::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		WORD  * wp, wResult = NULL;
		DWORD * dwp;
		char  * cp, cCharName[11], cData[100], cTxt[120];
		int iRet;

		ZeroMemory(cCharName, sizeof(cCharName));
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		memcpy_secure(cCharName, cp, 10);
		cp += 10;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				switch (*wp) {
					case DEF_MSGTYPE_CONFIRM:
						wResult = DEF_MSGTYPE_CONFIRM;
						wsprintf(cTxt, "Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
						CharacterLogList(cTxt);

						SendGuildMsg(i, CLIENT_RESPONSE_GUILDDISBANDED, NULL, NULL, NULL);
						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 0, 0, 0);

						ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
						memcpy_secure(m_pClientList[i]->m_cGuildName, "NONE", 4);
						m_pClientList[i]->m_iGuildRank = -1;		// ���� ��ũ�� -1. �������� �ƴϴ�. 
						m_pClientList[i]->m_iGuildGUID = -1;
						break;

					case DEF_MSGTYPE_REJECT:
						wResult = DEF_MSGTYPE_REJECT;
						wsprintf(cTxt, "Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
						CharacterLogList(cTxt);
						break;
				}

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_DISBANDGUILD;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = wResult;

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(i, TRUE, TRUE);
						return;
				}
				return;
			}
		}
		wsprintf(cTxt, "Non-existing player data received from Log server(2): CharName(%s)", cCharName);
		CharacterLogList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ResponseDisbandGuildHandler");
	}
#endif
}

void CMapServer::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
	class CItem * pItem;
	char  * cp, cItemName[21], cData[100];
	short * sp;
	DWORD * dwp, dwGoldCount, dwItemCount;
	WORD  * wp, wTempPrice;
	int * ip;
	int   i, iRet, iEraseReq, iGoldWeight;
	int   iCost, iCost2, iDiscountRatio, iDiscountCost;
	double dTmp1, dTmp2, dTmp3;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsOnShop == FALSE) return;

		ZeroMemory(cData, sizeof(cData));
		ZeroMemory(cItemName, sizeof(cItemName));

		if (memcmp(pItemName, DEF_ITEMNAME_10ARROWS, 8) == 0) {
			strcpy_secure(cItemName, DEF_ITEMNAME_ARROW);
			dwItemCount = 10;
		}
		else if (memcmp(pItemName, DEF_ITEMNAME_100ARROWS, 9) == 0) {
			strcpy_secure(cItemName, DEF_ITEMNAME_ARROW);
			dwItemCount = 100;
		}
		else {
			memcpy_secure(cItemName, pItemName, 20);
			dwItemCount = 1;
		}

		for (i = 1; i <= iNum; i++) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) delete pItem;
			else {
				if (pItem->m_bIsForSale == FALSE) {
					delete pItem;
					return;
				}

				pItem->m_dwCount = dwItemCount;
				pItem->m_sTouchEffectType = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1, 100000);

				// Anti Dup System
				SYSTEMTIME SysTime;
				char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				pItem->m_sTouchEffectValue2 = iDice(1, 100000);
				wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue2 = atoi(cTemp);

				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);

				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					iCost = (int)((float)(pItem->m_wPrice) * 0.9f + 0.5f);
					iCost = iCost * pItem->m_dwCount;
					iCost2 = pItem->m_wPrice * pItem->m_dwCount;
				}
				else iCost2 = iCost = pItem->m_wPrice * pItem->m_dwCount;

				dwGoldCount = dwGetItemCount(iClientH, "Gold");
				iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma - 10) / 4);

				dTmp1 = (double)(iDiscountRatio);
				dTmp2 = dTmp1 / 100.0f;
				dTmp1 = (double)iCost;
				dTmp3 = dTmp1 * dTmp2;
				iDiscountCost = (int)dTmp3;

				if ((iCost - iDiscountCost) <= (iCost2 / 2)) {
					iDiscountCost = iCost - (iCost2 / 2) + 1;
				}

				if (dwGoldCount < (DWORD)(iCost - iDiscountCost)) {
					delete pItem;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_NOTENOUGHGOLD;
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = -1; // -1�̸� �ǹ̾���.
					cp++;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					return;
				}

				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMPURCHASED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)4; // ���� �������̹Ƿ� �������� �ʾҴ�.
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					ip = (int *)cp;
					*ip = (iCost - iDiscountCost);
					wTempPrice = (iCost - iDiscountCost);
					cp += 4;

					if (iEraseReq == 1) {
						delete pItem;
						pItem = NULL;
					}

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 50);

					iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
					iCalcTotalWeight(iClientH);

					m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;

					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
				else {
					delete pItem;

					iCalcTotalWeight(iClientH);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestPurchaseItemHandler");
	}
#endif
}

void CMapServer::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
	register int iRet, iEraseReq;
	short * sp, sOwnerH;
	char  * cp, cOwnerType, cData[100], cCharName[21];
	DWORD * dwp;
	WORD  * wp;
	class CItem * pItem;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;	//DEBUG
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
		if (iAmount <= 0) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		if (FinalFight && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0) return;
		if (DKEvent && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_EVENTDK) == 0 && m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0) return;

		if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
			PutLogList("GiveItemHandler - Not matching Item name");
			return;
		}
		
		ZeroMemory(cCharName, sizeof(cCharName));

		if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount)) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
				delete pItem;
				return;
			}
			else pItem->m_dwCount = iAmount;			

			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
			SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if (wObjectID != NULL) {
				if (wObjectID < 10000) {
					if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
						if (m_pClientList[wObjectID] != NULL) {
							if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
						}
					}
				}
				else {
					// NPC
					if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
						if (m_pNpcList[wObjectID - 10000] != NULL) {
							if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
						}
					}
				}
			}

			if (sOwnerH == NULL) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (wObjectID != NULL) {
					if (wObjectID < 10000) {
						if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
							if (m_pClientList[wObjectID] != NULL) {
								if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
							}
						}
					}
				}
				if (sOwnerH == NULL) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
					pItem->m_dwTimeDrop = timeGetTime();
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);
					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
				}
				else {
					ShowClientMsg(iClientH, "Do not trade with who is doing 'Pretend Corpse'");
					return;
				}
			}
			else {
				if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
					memcpy_secure(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
					if (sOwnerH == iClientH) {
						delete pItem;
						return;
					}

					if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
						dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
						*dwp = CLIENT_NOTIFY;
						wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
						*wp = CLIENT_NOTIFY_ITEMOBTAINED;

						cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

						_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

						*cp = 1;
						cp++;

						memcpy_secure(cp, pItem->m_cName, 20);
						cp += 20;

						dwp = (DWORD *)cp;
						*dwp = pItem->m_dwCount;	// ������ �Է� 
						cp += 4;

						*cp = pItem->m_cItemType;
						cp++;

						*cp = pItem->m_cEquipPos;
						cp++;

						*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
						cp++;

						sp = (short *)cp;
						*sp = pItem->m_sLevelLimit;
						cp += 2;

						*cp = pItem->m_cGenderLimit;
						cp++;

						wp = (WORD *)cp;
						*wp = pItem->m_wCurLifeSpan;
						cp += 2;

						wp = (WORD *)cp;
						*wp = pItem->m_wWeight;
						cp += 2;

						sp = (short *)cp;
						*sp = pItem->m_sSprite;
						cp += 2;

						sp = (short *)cp;
						*sp = pItem->m_sSpriteFrame;
						cp += 2;

						*cp = pItem->m_cItemColor;
						cp++;

					//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					//	cp++;
						//cambio lalomanu
						sp = (short *)cp;
						*sp = pItem->m_sItemSpecEffectValue2;
						cp += 2;

						dwp = (DWORD *)cp;
						*dwp = pItem->m_dwAttribute;
						cp += 4;

						*cp = (char)pItem->m_sItemSpecEffectValue3;
						cp++;

						if (iEraseReq == 1) delete pItem;

						//iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 54);
						//cambio lalomanu
						iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 55);
						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(sOwnerH, TRUE, TRUE);
								break;
						}
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
					}
					else {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							pItem);
						pItem->m_dwTimeDrop = timeGetTime();
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);

						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

						dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
						*dwp = CLIENT_NOTIFY;
						wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
						*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

						iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(sOwnerH, TRUE, TRUE);
								break;
						}
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
					}
				}
				else {
					// NPC
					memcpy_secure(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);
					if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
						if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
							pItem->m_dwTimeDrop = timeGetTime();
							_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);
							SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
								pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
						}
					}
					else {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
						pItem->m_dwTimeDrop = timeGetTime();
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);
						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
				}
			}
		}
		else {
			ReleaseItemHandler(iClientH, sItemIndex, TRUE);
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)
				m_pClientList[iClientH]->m_cArrowIndex = -1;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // �������� dX, dY�� �ִ� ĳ���Ϳ��� �ش�. ���� ���� ĳ���Ͱ� �������� ���� ���� ��Ȳ�̶��� ���� ��������.  

			if (wObjectID != NULL) {
				if (wObjectID < 10000) {
					if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
						if (m_pClientList[wObjectID] != NULL) {
							if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
						}
					}
				}
				else { // NPC
					if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
						if (m_pNpcList[wObjectID - 10000] != NULL) {
							if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
						}
					}
				}
			}

			if (sOwnerH == NULL) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (wObjectID != NULL) {
					if (wObjectID < 10000) {
						if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
							if (m_pClientList[wObjectID] != NULL) {
								if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
							}
						}
					}
				}

				if (sOwnerH == NULL) {
					ShowClientMsg(iClientH, "Cerra bien el shop & el BS , Luego abri el Warehouse!");
					return;
					//cambio por perdida items en BS
				/*	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwTimeDrop = timeGetTime();
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);					

					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);*/
				}
				else {
					ShowClientMsg(iClientH, "Do not trade with who is doing 'Pretend Corpse'");
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTSELLITEM, sItemIndex, NULL, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName);
					return;
				}
			}
			else {
				if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
					//NADA CON ID
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
						ShowClientMsg(iClientH, "Item con ID no puedes Givearlo!");
						return;
					}
					memcpy_secure(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
					pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];
					if (pItem->m_sIDnum == 88) {
						if ((m_pClientList[iClientH]->m_iGuildRank == -1) &&
							((m_pClientList[iClientH]->m_cSide != DEF_NETURAL) || (m_pClientList[iClientH]->Assasain)) &&
							(m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) &&
							(m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
							SendNotifyMsg(iClientH, sOwnerH, CLIENT_RESPONSE_JOINGUILD, NULL, NULL, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);
							_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, pItem);
							goto REMOVE_ITEM_PROCEDURE;
						}
					}

					if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
						if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
							(m_pClientList[iClientH]->m_iGuildRank != -1) &&
							(m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
							SendNotifyMsg(iClientH, sOwnerH, CLIENT_RESPONSE_DISMISSGUILD, NULL, NULL, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);
							_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, pItem);
							goto REMOVE_ITEM_PROCEDURE;
						}
					}

					if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
						_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

						dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
						*dwp = CLIENT_NOTIFY;
						wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
						*wp = CLIENT_NOTIFY_ITEMOBTAINED;

						cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

						*cp = 1;
						cp++;

						memcpy_secure(cp, pItem->m_cName, 20);
						cp += 20;

						dwp = (DWORD *)cp;
						*dwp = pItem->m_dwCount;
						cp += 4;

						*cp = pItem->m_cItemType;
						cp++;

						*cp = pItem->m_cEquipPos;
						cp++;

						*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
						cp++;

						sp = (short *)cp;
						*sp = pItem->m_sLevelLimit;
						cp += 2;

						*cp = pItem->m_cGenderLimit;
						cp++;

						wp = (WORD *)cp;
						*wp = pItem->m_wCurLifeSpan;
						cp += 2;

						wp = (WORD *)cp;
						*wp = pItem->m_wWeight;
						cp += 2;

						sp = (short *)cp;
						*sp = pItem->m_sSprite;
						cp += 2;

						sp = (short *)cp;
						*sp = pItem->m_sSpriteFrame;
						cp += 2;

						*cp = pItem->m_cItemColor;
						cp++;

					//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
						//cp++;
						//cambio lalomanu
						sp = (short *)cp;
						*sp = pItem->m_sItemSpecEffectValue2;
						cp += 2;

						dwp = (DWORD *)cp;
						*dwp = pItem->m_dwAttribute;
						cp += 4;

						*cp = (char)pItem->m_sItemSpecEffectValue3;
						cp++;

						if (iEraseReq == 1) delete pItem;

						//iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 54);
						//lalomanu
						iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 55);

						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(sOwnerH, TRUE, TRUE);
								break;
						}
					}
					else {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						pItem->m_dwTimeDrop = timeGetTime();
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
						*dwp = CLIENT_NOTIFY;
						wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
						*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

						iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(sOwnerH, TRUE, TRUE);
								break;
						}
						ZeroMemory(cCharName, sizeof(cCharName));
					}
				}
				else { // NPC
					memcpy_secure(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

					if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
						if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
								m_pClientList[iClientH]->m_sY,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]);
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwTimeDrop = timeGetTime();
							_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

							SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
						}
					}
					else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
						if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
							if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
								bSendMsgToLS(NUCLEO_REQUEST_DELGUILDSMAN, iClientH);
								SendNotifyMsg(iClientH, iClientH, CLIENT_COMMON_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
								ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
								memcpy_secure(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
								m_pClientList[iClientH]->m_iGuildRank = -1;
								m_pClientList[iClientH]->m_iGuildGUID = -1;
								SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
								m_pClientList[iClientH]->m_iExp -= 300;
								if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
							}
							delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
							m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;//Agregado Lalo882
						}
						else {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
								m_pClientList[iClientH]->m_sY,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]);
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwTimeDrop = timeGetTime();
							_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

							SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
								m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
							ZeroMemory(cCharName, sizeof(cCharName));

						}
					}
					else {
						ShowClientMsg(iClientH, "Fijate donde apuntas, vas a perder el item!");
						return;
					/*	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwTimeDrop = timeGetTime();

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						ZeroMemory(cCharName, sizeof(cCharName));*/
					}
				}
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
			}

		REMOVE_ITEM_PROCEDURE:;
			if (m_pClientList[iClientH] == NULL) return;

			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
			m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
		}
		iCalcTotalWeight(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GiveItemHandler");
	}
#endif
}

void CMapServer::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2, char cValueA)
{
	char cData[1000];
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	short * sp;
	int   * ip, iRet;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iToH] == NULL) return;
		if (m_pClientList[iToH]->NoClear == TRUE) return;

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_NOTIFY;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = wMsgType;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	
		switch (wMsgType) {

		case NOTIFYMSG:
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case NOTIFY_EVENT_STATUS:
			Push(cp, EventID(sV1));
			Push(cp, bool(sV2));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, cp - cData);
			break;

		case NOTIFY_EVENT_STATUS2:
			Push(cp, EventID(sV1));
			Push(cp, bool(sV2));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, cp - cData);
			break;

			case CLIENT_NOTIFY_QUESTCOUNTER:
				sp = (short *)cp;
				*sp = sV1;
				cp += 2;

				ip = (int *)cp;
				if (m_pClientList[iToH]->m_bIsQuestCompleted[sV1])
					*ip = (unsigned int)0;
				else *ip = (unsigned int)sV2;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
				break;

			case CLIENT_NOTIFY_CHANGEPLAYMODE:
				memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
				break;

			case CLIENT_NOTIFY_REQGUILDNAMEANSWER:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
				break;

			case CLIENT_NOTIFY_TCLOC:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = (WORD)sV4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV5;
				cp += 2;

				memcpy_secure(cp, pString2, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
				break;

			case CLIENT_NOTIFY_PARTY:
				switch (sV1) {
					case 4:
					case 6:
						wp = (WORD *)cp;
						*wp = (WORD)sV1;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV2;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV3;
						cp += 2;
						memcpy_secure(cp, pString, 10);
						cp += 10;
						iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + 10);
						break;

					case 5:
						wp = (WORD *)cp;
						*wp = (WORD)sV1;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV2;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV3;
						cp += 2;
						memcpy_secure(cp, pString, sV3 * 11);
						cp += sV3 * 11;
						iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + sV3 * 11);
						break;

					default:
						wp = (WORD *)cp;
						*wp = (WORD)sV1;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV2;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV3;
						cp += 2;
						wp = (WORD *)cp;
						*wp = (WORD)sV4;
						cp += 2;
						iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
						break;
				}
				break;

			case CLIENT_NOTIFY_GRANDMAGICRESULT:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV3;
				cp += 2;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = (WORD)sV4;
				cp += 2;

				if (sV9 > 0) {
					memcpy_secure(cp, pString2, (sV9 + 1) * 2);
					cp += (sV9 + 1) * 2;
				}
				else {
					sp = (short *)cp;
					*sp = (short)0;
					cp += 2;
				}

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24 + (sV9 + 1) * 2);
				break;

			case CLIENT_NOTIFY_MAPSTATUSNEXT:
				memcpy_secure(cp, pString, sV1);
				cp += sV1;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + sV1);
				break;

			case CLIENT_NOTIFY_MAPSTATUSLAST:
				memcpy_secure(cp, pString, sV1);
				cp += sV1;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + sV1);
				break;

			case CLIENT_NOTIFY_LOCKEDMAP:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
				break;

			case CLIENT_NOTIFY_BUILDITEMSUCCESS:
			case CLIENT_NOTIFY_BUILDITEMFAIL:

				if (sV1 >= 0) {
					sp = (short *)cp;
					*sp = (short)sV1;
					cp += 2;
				}
				else {
					sp = (short *)cp;
					*sp = (short)sV1 +10000;
					cp += 2;
				}

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_QUESTREWARD:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				ip = (int *)cp;
				*ip = (int)sV4;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV5;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 40);
				break;

			case CLIENT_NOTIFY_CANNOTCONSTRUCT:
			case CLIENT_NOTIFY_METEORSTRIKECOMING:
			case CLIENT_NOTIFY_METEORSTRIKEHIT:
			case CLIENT_NOTIFY_SPECIALABILITYENABLED:
			case CLIENT_NOTIFY_FORCEDISCONN:
			case CLIENT_NOTIFY_OBSERVERMODE:
			case CLIENT_NOTIFY_QUESTCOMPLETED:
			case CLIENT_NOTIFY_QUESTABORTED:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;


			case CLIENT_NOTIFY_QUESTCONTENTS:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV4;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV5;
				cp += 4;

				sp = (short *)cp;
				*sp = (short)sV6;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV7;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV8;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV9;
				cp += 2;

				if (pString2 != NULL) memcpy_secure(cp, pString2, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 46);
				break;

			case CLIENT_NOTIFY_ITEMATTRIBUTECHANGE:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV2;
				cp += 4;

				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV3;
				cp += 4;

				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV4;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 20);
				break;

			case CLIENT_NOTIFY_GIZONITEMUPGRADELEFT:
				sp = (short *)cp;
				*sp = m_pClientList[iToH]->m_iGizonItemUpgradeLeft;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_ITEMUPGRADEFAIL:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_UPGRADEHEROCAPE:
			case CLIENT_NOTIFY_GIZONITEMCANGE:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				*cp = (char)sV2;
				cp++;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV4;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV5;
				cp += 2;

				*cp = (char)sV6;
				cp++;

				//*cp = (char)sV7;
				//cp++;
				//lalomanu
				sp = (short *)cp;
				*sp = (short)sV7;
				cp += 2;

				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV8;
				cp += 4;

				memcpy_secure(cp, pString, 20);
				cp += 20;


				//iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 41);
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
				break;

			case CLIENT_NOTIFY_ENERGYSPHERECREATED:
			case CLIENT_NOTIFY_ITEMCOLORCHANGE:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_NOMOREAGRICULTURE:	   //? ���۹� ����
			case CLIENT_NOTIFY_AGRICULTURESKILLLIMIT: //? ��ų ����	
			case CLIENT_NOTIFY_AGRICULTURENOAREA:     //? ���۹��� ������ �ִ� ������ �ƴϴ�.
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_NOMORECRUSADESTRUCTURE:
			case CLIENT_NOTIFY_EXCHANGEITEMCOMPLETE:
			case CLIENT_NOTIFY_CANCELEXCHANGEITEM:
			case CLIENT_RESPONSE_DELETEHACK:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

				//Fix Endu 
			case CLIENT_NOTIFY_SETEXCHANGEITEM:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV4;
				cp += 4;

				*cp = (char)sV5;
				cp++;

				//Cur Span
				ip = (int *)cp;
				*ip = (int)sV6;
				cp += 4;

				//MaxSpan
				ip = (int *)cp;
				*ip = (int)sV7;
				cp += 4;

				sp = (short *)cp;
				*sp = (short)sV8;
				cp += 2;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				memcpy_secure(cp, m_pClientList[iFromH]->m_cCharName, 10);
				cp += 10;

				// v1.42
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV9;
				cp += 4;

				*cp = cValueA;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 62);
				break;

			case CLIENT_NOTIFY_OPENEXCHANGEWINDOW:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV4;
				cp += 4;

				*cp = (char)sV5;
				cp++;

				//Life span
				ip = (int *)cp;
				*ip = (int)sV6;
				cp += 4;

				// Max life
				ip = (int *)cp;
				*ip = (int)sV7;
				cp += 4;

				sp = (short *)cp;
				*sp = (short)sV8;
				cp += 2;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				memcpy_secure(cp, m_pClientList[iFromH]->m_cCharName, 10);
				cp += 10;

				// v1.42
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV9;
				cp += 4;

				*cp = cValueA;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 62);
				break;

			case CLIENT_NOTIFY_NOTFLAGSPOT:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_CRUSADE:
				ip = (int *)cp;
				*ip = (int)sV1;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV3;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV4;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
				break;

			case CLIENT_NOTIFY_CONSTRUCTIONPOINT:
			case CLIENT_NOTIFY_SPECIALABILITYSTATUS:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
				break;

			case CLIENT_NOTIFY_DAMAGEMOVE:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
				break;

			case CLIENT_NOTIFY_STATUSCHAR:
				*cp = (unsigned char)sV1;
				cp++;

				*cp = (unsigned char)sV2;
				cp++;

				*cp = (unsigned char)sV3;
				cp++;

				*cp = (unsigned char)sV4;
				cp++;

				*cp = (unsigned char)sV5;
				cp++;

				*cp = (unsigned char)sV6;
				cp++;

				*cp = (unsigned char)sV7;
				cp++;

				*cp = (unsigned char)sV8;
				cp++;

				//lalomerien
				sp = (short *)cp;
				*sp = (short)sV9;
				cp += 2;

				//lalomerien
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
				break;

			case CLIENT_NOTIFY_CHARSTATUS:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;
				//agregado
				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				*cp = (unsigned char)sV4;
				cp++;

				*cp = (unsigned char)sV5;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);//12
				break;

			case CLIENT_NOTIFY_F5DATA:
				ip = (int *)cp;
				*ip = (int)sV1;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV3;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV4;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV5;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV6;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
				break;

			case CLIENT_NOTIFY_DOWNSKILLINDEXSET:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_ADMINIFO:
				switch (sV1) {
					case 1:
						// NPC�� ������ �����´�.
						ip = (int *)cp;
						*ip = m_pNpcList[sV2]->m_iHP;
						cp += 4;

						ip = (int *)cp;
						*ip = m_pNpcList[sV2]->m_iDefenseRatio;
						cp += 4;

						ip = (int *)cp;
						*ip = m_pNpcList[sV2]->m_bIsSummoned;
						cp += 4;

						ip = (int *)cp;
						*ip = m_pNpcList[sV2]->m_cActionLimit;
						cp += 4;

						ip = (int *)cp;
						*ip = m_pNpcList[sV2]->m_iHitDice;
						cp += 4;

						dwp = (DWORD *)cp; // v1.4
						*dwp = m_pNpcList[sV2]->m_dwDeadTime;
						cp += 4;

						dwp = (DWORD *)cp;
						*dwp = m_pNpcList[sV2]->m_dwRegenTime;
						cp += 4;

						ip = (int *)cp;
						*ip = (int)m_pNpcList[sV2]->m_bIsKilled;
						cp += 4;

						iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
						break;
				}
				break;

			case CLIENT_NOTIFY_NPCTALK:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV4;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV5;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV6;
				cp += 4;

				sp = (short *)cp;
				*sp = (short)sV7;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV8;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV9;
				cp += 2;

				if (pString != NULL) memcpy_secure(cp, pString, 20);
				cp += 20;

				if (pString2 != NULL) memcpy_secure(cp, pString2, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 66);
				break;

			case CLIENT_NOTIFY_CRAFTING_FAIL:
				ip = (int *)cp;
				*ip = (int)sV1;
				cp += 4;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_CRAFTING_SUCCESS:
			case CLIENT_NOTIFY_PORTIONSUCCESS:
			case CLIENT_NOTIFY_LOWPORTIONSKILL:
			case CLIENT_NOTIFY_PORTIONFAIL:
			case CLIENT_NOTIFY_NOMATCHINGPORTION:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_SAFEATTACKMODE:
				*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_NOTIFY_TPFAST:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_QUERY_JOINPARTY:
			case CLIENT_NOTIFY_STRINGMSG:
				strcpy_secure(cp, pString);
				cp += strlen(pString);

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
				break;

			case CLIENT_NOTIFY_REWARDGOLD:
				dwp = (DWORD *)cp;
				*dwp = m_pClientList[iToH]->m_iRewardGold;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_GLOBALATTACKMODE:
			case CLIENT_NOTIFY_WHETHERCHANGE:
				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_NOTIFY_FISHCANCELED:
			case CLIENT_NOTIFY_FISHSUCCESS:
			case CLIENT_NOTIFY_FISHFAIL:
			case CLIENT_NOTIFY_FISHCHANCE:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_ENERGYSPHEREGOALIN:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
				break;

			case CLIENT_NOTIFY_EVENTFISHMODE:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV3;
				cp += 2;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
				break;

			case CLIENT_NOTIFY_NOTICEMSG:
				memcpy_secure(cp, pString, strlen(pString)); //ver aca zero crash
				cp += strlen(pString);

				*cp = NULL;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
				break;

			case CLIENT_NOTIFY_NOTICEEKMSG:
				memcpy_secure(cp, pString, strlen(pString));
				cp += strlen(pString);

				*cp = NULL;
				cp++;

				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 8);
				break;

			case CLIENT_NOTIFY_CANNOTRATING:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_RATINGPLAYER:
				*cp = (char)sV1;
				cp++;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				ip = (int *)cp;
				*ip = m_pClientList[iToH]->m_iRating;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
				break;

			case CLIENT_NOTIFY_ADMINUSERLEVELLOW:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_PLAYERSHUTUP:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
				break;

			case CLIENT_NOTIFY_HUNGER:
			case CLIENT_NOTIFY_TIMECHANGE:
				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_NOTIFY_HAPPYHOURSTAR: // MORLA 2.3 - HAPPY HOUR ON
			case CLIENT_NOTIFY_HAPPYHOUREND: // MORLA 2.3 - HAPPY HOUR OFF
			case CLIENT_NOTIFY_HAPPYDAYSTAR: // Lalo 4.0- HAPPY DAY ON
			case CLIENT_NOTIFY_HAPPYDAYEND: // Lalo 4.0 - HAPPY DAY OFF
			case CLIENT_NOTIFY_TOBERECALLED:
			case CLIENT_NOTIFY_PRICECLOSE:
			case CLIENT_NOTIFY_ARENAPVPEVENT_INIT:
			case CLIENT_NOTIFY_ARENAPVPEVENT_CLOSE:
			case CLIENT_NOTIFY_ANGELIC_STATS:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_PLAYERPROFILE:
				if (strlen(pString) > 100) {
					memcpy_secure(cp, pString, 100);
					cp += 100;
				}
				else {
					memcpy_secure(cp, pString, strlen(pString));
					cp += strlen(pString);
				}
				*cp = NULL;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
				break;

			case CLIENT_NOTIFY_PLAYERONGAME:
				memcpy_secure(cp, pString, 10);
				cp += 10;
				if (pString != NULL) {
					memcpy_secure(cp, pString2, 14);
					cp += 14;
				}
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
				break;

			case CLIENT_NOTIFY_WHISPERMODEON:
			case CLIENT_NOTIFY_WHISPERMODEOFF:
			case CLIENT_NOTIFY_PLAYERNOTONGAME:
				memcpy_secure(cp, pString, 10);
				cp += 10;
				memcpy_secure(cp, "             ", 10);
				cp += 10;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
				break;

			case CLIENT_NOTIFY_ITEMSOLD:
			case CLIENT_NOTIFY_ITEMREPAIRED:
			case CLIENT_NOTIFY_ITEMREPAIRED2:
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV1;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV2;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;

			case CLIENT_NOTIFY_REPAIRITEMPRICE:
			case CLIENT_NOTIFY_SELLITEMPRICE:
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV1;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV2;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV3;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = (DWORD)sV4;
				cp += 4;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
				break;

			case CLIENT_NOTIFY_CANNOTREPAIRITEM:
			case CLIENT_NOTIFY_CANNOTSELLITEM:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

				break;

			case CLIENT_NOTIFY_SKILLUSINGEND:
				wp = (WORD *)cp;  // ���� ���� ���� 
				*wp = (WORD)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_RESPONSE_TOTALUSERS:

				wp = (WORD *)cp;
				*wp = (WORD)(m_iTotalGameServerClients + m_iAddUser + m_iAFKUsers);
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_PINGPLAYERS:
				dwp = (DWORD *)cp;
				*dwp = (DWORD)(m_pClientList[iToH]->m_iLastPing);
				cp += 4;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_MAGICEFFECTOFF:
			case CLIENT_NOTIFY_MAGICEFFECTON:
				wp = (WORD *)cp;  // ���� ȿ�� ���� 
				*wp = (WORD)sV1;
				cp += 2;

				dwp = (DWORD *)cp;  // ���� ȿ�� ȿ��  
				*dwp = (DWORD)sV2;
				cp += 4;

				dwp = (DWORD *)cp;  // ���� ȿ�� ȿ��  
				*dwp = (DWORD)sV3;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
				break;

			case CLIENT_NOTIFY_CANNOTITEMTOBANK:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_SERVERCHANGE:
				memcpy_secure(cp, m_pClientList[iToH]->m_cMapName, 10);
				cp += 10;

				memcpy_secure(cp, m_cLogServerAddr, 15);
				cp += 15;

				ip = (int *)cp;
				*ip = m_iExtHGServerPort;
				cp += 4;

				ip = (int *)cp;//lalito
				*ip = m_iLogServerPort;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 + 19);
				break;

			case CLIENT_NOTIFY_SKILL:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_SETITEMCOUNT:
				wp = (WORD *)cp;  // ������ �ε��� ��ȣ 
				*wp = (WORD)sV1;
				cp += 2;

				dwp = (DWORD *)cp;  // �������� ���� ���� 
				*dwp = (DWORD)sV2;
				cp += 4;

				*cp = (char)sV3;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
				break;

			case CLIENT_NOTIFY_ITEMDEPLETED_ERASEITEM:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_DROPITEMFIN_COUNTCHANGED:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
				break;

			case CLIENT_NOTIFY_DROPITEMFIN_ERASEITEM:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
				break;

			case CLIENT_NOTIFY_CANNOTGIVEITEM:
			case CLIENT_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
				break;

			case CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
				break;

			case CLIENT_NOTIFY_ENEMYKILLREWARD:
				dwp = (DWORD *)cp;
				*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
				cp += 4;
				//REMOVER!!!
				memcpy_secure(cp, m_pClientList[sV1]->m_cCharName, 10);
				cp += 10;
				memcpy_secure(cp, m_pClientList[sV1]->m_cGuildName, 20);
				cp += 20;
				sp = (short *)cp;
				*sp = (short)m_pClientList[sV1]->m_iGuildRank;
				cp += 2;
				sp = (short *)cp;
				*sp = (short)m_pClientList[iToH]->m_iWarContribution;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
				break;

			case CLIENT_NOTIFY_PKCAPTURED:
				// PK�� ���Ҵ�.
				// PK�� PKcount
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;
				wp = (WORD *)cp;
				*wp = (WORD)sV2;
				cp += 2;
				memcpy_secure(cp, pString, 10);
				cp += 10;
				dwp = (DWORD *)cp;
				*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = m_pClientList[iToH]->m_iExp;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
				break;

			case CLIENT_NOTIFY_PKPENALTY:
				// PK ����Ƽ�� �Ծ���.
				dwp = (DWORD *)cp;
				*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
				cp += 4;
				dwp = (DWORD *)cp;
				*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;

			case CLIENT_NOTIFY_TRAVELERLIMITEDLEVEL:
				dwp = (DWORD *)cp;
				*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
				cp += 4;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_ITEMRELEASED:
			case CLIENT_NOTIFY_ITEMLIFESPANEND:
				sp = (short *)cp;
				*sp = (short)sV1;	// ���� ��ġ 
				cp += 2;
				sp = (short *)cp;
				*sp = (short)sV2;	// ������ ��ȣ  
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_KILLED:
				memcpy_secure(cp, pString, 20);
				cp += 20;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
				RefreshParty(iToH, 2);
				break;

			case CLIENT_NOTIFY_EXP:
				dwp = (DWORD *)cp;
				*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_HP:
				sp = (short *)cp;
				*sp = m_pClientList[iToH]->m_iHP;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				RefreshParty(iToH, 2);
				break;

			case CLIENT_NOTIFY_MP:
				sp = (short *)cp;
				*sp = (DWORD)m_pClientList[iToH]->m_iMP;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_SP:
				sp = (short *)cp;
				*sp = (DWORD)m_pClientList[iToH]->m_iSP;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

				//MOG Fixes
			case CLIENT_RESPONSE_CHECKPROCESS:
			case CLIENT_NOTIFY_STATECHANGE_FAILED:		// 2003-04-14 ���� ����Ʈ�� ���� ������ ����..korean buttplugs
			case CLIENT_NOTIFY_SETTING_FAILED:
			case CLIENT_NOTIFY_SETTING_STATS:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_SPELL_SKILL:
			case CLIENT_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 ���� ����Ʈ�� ���� ������ ����.. wtf korean junk
				int i;

				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					*cp = m_pClientList[iToH]->m_cMagicMastery[i];
					cp++;
				}

				for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
					*cp = m_pClientList[iToH]->m_cSkillMastery[i];
					cp++;
				}

				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
				break;

			case CLIENT_NOTIFY_SETTING_SUCCESS:
				*cp = m_pClientList[iToH]->m_iStr;
				cp++;

				*cp = m_pClientList[iToH]->m_iVit;
				cp++;

				*cp = m_pClientList[iToH]->m_iDex;
				cp++;

				*cp = m_pClientList[iToH]->m_iInt;
				cp++;

				*cp = m_pClientList[iToH]->m_iMag;
				cp++;

				*cp = m_pClientList[iToH]->m_iCharisma;
				cp++;

				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
				break;

			case CLIENT_NOTIFY_LEVELUP:
				ip = (int *)cp;
				*ip = m_pClientList[iToH]->m_iLevel;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_LUPOOL:
				sp = (short *)cp;
				*sp = m_pClientList[iToH]->m_iLU_Pool - 3;
				sp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_RESPONSE_DISMISSGUILD:
			case CLIENT_RESPONSE_JOINGUILD:
				memcpy_secure(cp, m_pClientList[iFromH]->m_cCharName, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
				break;

			case CLIENT_COMMON_JOINGUILDAPPROVE:
				if (m_pClientList[iFromH] != NULL)
					memcpy_secure(cp, m_pClientList[iFromH]->m_cGuildName, 20);
				else memcpy_secure(cp, "?", 1);
				cp += 20;

				sp = (short *)cp;
				*sp = DEF_GUILDSTARTRANK;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);

				if (!m_pClientList[iToH]->Achivements[7].Complete)
					CheckCompleteAchivement(iToH, 7, TRUE);
				break;

			case CLIENT_COMMON_JOINGUILDREJECT:
			case CLIENT_COMMON_DISMISSGUILDAPPROVE:
			case CLIENT_COMMON_DISMISSGUILDREJECT:
				if (m_pClientList[iFromH] != NULL)
					memcpy_secure(cp, m_pClientList[iFromH]->m_cGuildName, 20);
				else memcpy_secure(cp, "?", 1);
				cp += 20;

				sp = (short *)cp;
				*sp = DEF_GUILDSTARTRANK;
				cp += 2;

				memcpy_secure(cp, m_pClientList[iToH]->m_cLocation, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
				break;

			case CLIENT_RESPONSE_GUILDDISBANDED:
				memcpy_secure(cp, pString, 20);
				cp += 20;

				memcpy_secure(cp, m_pClientList[iToH]->m_cLocation, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
				break;

			case CLIENT_NOTIFY_FLAGCOUNTER:
				*cp = (char)sV1;
				cp++;

				*cp = (char)sV2;
				cp++;

				*cp = (char)sV3;
				cp++;

				*cp = (char)sV4;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_NOTIFY_NOGUILDMASTERLEVEL:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_CANNOTBANGUILDMAN:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_APOCGATECLOSE:
			case CLIENT_NOTIFY_APOCGATEOPEN:
				ip = (int *)cp;
				*ip = sV1;
				cp += 4;

				ip = (int *)cp;
				*ip = sV2;
				cp += 4;

				ip = (int *)cp;
				*ip = sV3;
				cp += 4;

				memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
				break;

			case CLIENT_NOTIFY_NORECALL:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_ENDALLVSALL:
			case CLIENT_NOTIFY_ABADDONKILLED:
				memcpy_secure(cp, m_pClientList[iFromH]->m_cCharName, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
				break;

			case CLIENT_NOTIFY_RECALLTIMELEFT:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_MONSTERCOUNT:
			case CLIENT_NOTIFY_SLATE_STATUS:
				wp = (WORD *)cp;
				*wp = (WORD)sV1;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;


			case CLIENT_NOTIFY_RESURRECTPLAYER:
			case CLIENT_NOTIFY_SLATE_EXP:
			case CLIENT_NOTIFY_SLATE_MANA:
			case CLIENT_NOTIFY_SLATE_INVINCIBLE:
			case CLIENT_NOTIFY_SLATE_CREATEFAIL:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_NOTIFY_SLATE_CREATESUCCESS:
			case CLIENT_NOTIFY_COINS:
			case CLIENT_NOTIFY_ASSASAINSPOINTS:
				dwp = (DWORD *)cp;
				*dwp = sV1;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

				// ZeroEoyPnk - NewMessage
			case CLIENT_NOTIFY_EVENTDATA:
				*cp = (char)sV1;
				cp++;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV4;
				cp += 2;

				*cp = (char)sV5;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;

			case CLIENT_RESPONSE_DELETE_SELL_LIST:
			case CLIENT_RESPONSE_MARKET:
			case CLIENT_NOTIFY_CVCEND:
			//WorldWar LaloRamos
			case CLIENT_NOTIFY_WWEND:
			case CLIENT_NOTIFY_WWENDII:
			case CLIENT_NOTIFY_CAPTURETHEFLAG:
			case CLIENT_NOTIFY_FIGHTZONERESERVE:
			case CLIENT_NOTIFY_RUSH:
			case CLIENT_NOTIFY_TOWERDEFENCE:
				*cp = (int)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_NOTIFY_STRUCTURES:
			case CLIENT_NOTIFY_TD_STRUCTURES:
				*cp = (char)sV1;
				cp++;

				*cp = (char)sV2;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;


			case CLIENT_NOTIFY_DKEVENT:
			case CLIENT_NOTIFY_DKEVENTOFF:
			//Lalo V10
			case CLIENT_NOTIFY_HUNTON:
			case CLIENT_NOTIFY_HUNTOFF:
			case CLIENT_NOTIFY_QUEST2:
			case CLIENT_NOTIFY_QUEST3:
			case CLIENT_NOTIFY_QUEST2OFF:
			case CLIENT_NOTIFY_QUEST3OFF:
			//Lalov9Fake
			case CLIENT_NOTIFY_FAKE:
			//TowerHell - LaloRamos
			case CLIENT_NOTIFY_TOHEND:
			case CLIENT_NOTIFY_TOHNOW:
			//ExtremeFight - LaloRamos
			case CLIENT_NOTIFY_EXTREND:
			case CLIENT_NOTIFY_EXTRNOW:
			//Abby
			case CLIENT_NOTIFY_ABADDONMAP:
			case CLIENT_NOTIFY_ABADDONMAPCLOSE:
			case CLIENT_NOTIFY_OPENPORTALS:
			case CLIENT_NOTIFY_INITALLVSALL:
			case CLIENT_NOTIFY_ALLEKSON:
			case CLIENT_NOTIFY_ALLEKSOFF:
			case CLIENT_NOTIFY_ALLDKEKSON:
			case CLIENT_NOTIFY_ALLDKEKSOFF:

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

			case CLIENT_SEND_HPRELIQUIA:
				ip = (int *)cp;
				*ip = (int)sV1;
				cp += 4;

				ip = (int *)cp;
				*ip = (int)sV2;
				cp += 4;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;


			case CLIENT_REPONSE_SELLTYPE:
			case CLIENT_REPONSE_PLAYERREP:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_NOTIFY_CVCNOW:
			case CLIENT_NOTIFY_WWNOW: //WorldWar
			case CLIENT_NOTIFY_WWNOWII:
			case CLIENT_NOTIFY_MYDATAEVENT:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
				break;

			case CLIENT_NOTIFY_SUPERATTACKLEFT1:
			case CLIENT_NOTIFY_CONTRIBUTION1:
			case CLIENT_NOTIFY_ENEMYKILLS1:
				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_NOTIFY_SUPERATTACKLEFT2:
			case CLIENT_NOTIFY_CONTRIBUTION2:
			case CLIENT_NOTIFY_ENEMYKILLS2:
				sp = (short *)cp;
				*sp = (unsigned short)sV1;
				cp += 2;

				*cp = (char)sV2;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 9);
				break;

			case CLIENT_NOTIFY_SUPERATTACKLEFT3:
			case CLIENT_NOTIFY_CONTRIBUTION3:
			case CLIENT_NOTIFY_ENEMYKILLS3:
				ip = (int *)cp;
				*ip = (int)sV1;
				cp += 4;

				*cp = (char)sV2;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
				break;

			case CLIENT_NOTIFY_ACHIVEMENTS:
			case CLIENT_NOTIFY_SUMMONEVENT:
			case CLIENT_NOTIFY_STATUSFRIEND:
				*cp = (char)sV1;
				cp++;

				*cp = (char)sV2;
				cp++;

				*cp = (char)sV3;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 9);
				break;

			case CLIENT_NOTIFY_STATUSFRIEND2:
				memcpy_secure(cp, pString, 10);
				cp += 10;
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
				break;

			case CLIENT_NOTIFY_NEXTROUND:
				*cp = (char)sV1;
				cp++;

				*cp = (char)sV2;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 9);
				break;

			case CLIENT_NOTIFY_HELLOFDEATH:
				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_NOTIFY_HPSTRUCTURE:
				sp = (short *)cp;
				*sp = (short)sV1;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
				break;

			case CLIENT_RESPONSE_EXCHANGEITEMCONFIRM:
			case CLIENT_RESPONSE_INITPLAYER_OLD:
				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
				break;

				// New Party System - ZeroEoyPnk
			case CLIENT_RESPONSE_PARTYCOORDS:
				*cp = (char)sV1;
				cp++;

				sp = (short *)cp;
				*sp = (short)sV2;
				cp += 2;

				sp = (short *)cp;
				*sp = (short)sV3;
				cp += 2;

				if (pString != NULL) memcpy_secure(cp, pString, 12);
				cp += 12;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 23);
				break;

			case CLIENT_RESPONSE_PARTYHP:
				*cp = (char)sV1;
				cp++;

				*cp = (char)sV2;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
				break;

			case CLIENT_RESPONSE_PARTYNAME:
				*cp = (char)sV1;
				cp++;

				if (pString != NULL) memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 17);
				break;

			case CLIENT_RESPONSE_REMOVEITEMEXCHANGE:
			case CLIENT_RESPONSE_WEIGHTEXCHANGE:
				*cp = (char)sV1;
				cp++;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
				break;

			case CLIENT_RESPONSE_GUILDMEMBER:
				*cp = (char)sV1;
				cp++;

				if (pString != NULL) memcpy_secure(cp, pString, 10);
				cp += 10;

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 17);
				break;

			//case CLIENT_RESPONSE_PROCESSBLOCKED:
			case CLIENT_RESPONSE_PELMASO:
				memcpy_secure(cp, pString, strlen(pString));
				cp += strlen(pString);

				iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
				break;
		}
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				//Lo remuevo para ver que pasa... ZeroEoyPnk
				//DeleteClient(iToH, TRUE, TRUE); //habilitar o deshabilitar //Agregado Lalo882
				return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendNotifyMsg");
	}
#endif
}

void CMapServer::JoinGuildApproveHandler(int iClientH, char * pName)
{
	register int i;
	BOOL bIsExist = FALSE;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
				if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) return;

				ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy_secure(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);

				m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

				ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
				strcpy_secure(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

				m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRank�� ������ DEF_GUILDSTARTRANK

				SendNotifyMsg(iClientH, i, CLIENT_COMMON_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 0, 0, 0);
				SendGuildMsg(i, CLIENT_RESPONSE_NEWGUILDSMAN, NULL, NULL, NULL);
				bSendMsgToLS(NUCLEO_REQUEST_NEWGUILDSMAN, i);

				if (!m_pClientList[i]->Achivements[7].Complete)	CheckCompleteAchivement(i, 7, TRUE);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: JoinGuildApproveHandler");
	}
#endif
}

void CMapServer::JoinGuildRejectHandler(int iClientH, char * pName)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

				SendNotifyMsg(iClientH, i, CLIENT_COMMON_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: JoinGuildRejectHandler");
	}
#endif
}

void CMapServer::DismissGuildApproveHandler(int iClientH, char * pName)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

				bSendMsgToLS(NUCLEO_REQUEST_DELGUILDSMAN, i);

				ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy_secure(m_pClientList[i]->m_cGuildName, "NONE");
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;

				SendNotifyMsg(iClientH, i, CLIENT_COMMON_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 0, 0, 0);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DismissGuildApproveHandler");
	}
#endif
}

void CMapServer::DismissGuildRejectHandler(int iClientH, char * pName)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

				SendNotifyMsg(iClientH, i, CLIENT_COMMON_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DismissGuildRejectHandler");
	}
#endif
}

DWORD CMapServer::dwGetItemCount(int iClientH, char * pName)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		char cTmpName[21];

		if (m_pClientList[iClientH] == NULL) return NULL;

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pName);

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
				return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
			}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: dwGetItemCount");
	}
#endif
	return 0;
}

int CMapServer::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		char cTmpName[21];
		WORD wWeight;

		if (m_pClientList[iClientH] == NULL) return -1;

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pItemName);

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
				wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

				if (dwCount == 0) ItemDepleteHandler(iClientH, i, FALSE);
				else {
					m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
				}
				return wWeight;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetItemCount");
	}
#endif
	return -1;
}

int CMapServer::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
#ifdef DEF_DEBUG
	try {
#endif
		WORD wWeight;

		if (m_pClientList[iClientH] == NULL) return -1;
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;

		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

		if (dwCount == 0) ItemDepleteHandler(iClientH, iItemIndex, FALSE);
		else {
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
		}

		return wWeight;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetItemCount");
	}
#endif
	return 0;
}

void CMapServer::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
	char  * cp, cAttackerName[21], cData[120], cEKMsg[255];
	short sAttackerWeapon;
	int   * ip, i, iExH;
	BOOL  bIsSAattacked = FALSE;
	BOOL EK = TRUE;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

		if ((Soccer == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone6") == 0)) {
			m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
			return;
		}

		if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) && (AllVsAll == FALSE)) {
			m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
			wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
			PutLogList(G_cTxt);
		}

		m_pClientList[iClientH]->m_bIsKilled = TRUE;

		m_pClientList[iClientH]->m_iHP = 0;

		shinning_clear(iClientH);

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) //DEATHMATCH EVENT HEATON
		{
			if (m_pClientList[iClientH] != NULL && m_pClientList[iAttackerH] != NULL)
			{
				if (m_pClientList[iClientH]->IsInMap("dm") && m_pClientList[iAttackerH]->IsInMap("dm"))
				{
					c_dm->kill_enemy(iAttackerH, iClientH);
					m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
					RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
					ZeroMemory(cAttackerName, sizeof(cAttackerName));
					memcpy_secure(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
					sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
					//Ek Anuncier Por LaloRamos
					EkAnnoucer(cAttackerName, m_pClientList[iClientH]->m_cCharName, EK);

					SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
					return;
				}
			}			
		}

		if (FinalFight && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && cAttackerType == DEF_OWNERTYPE_PLAYER) {
			m_pClientList[iClientH]->Event_Death++;
			//funcion antilam Final Fight
			if (DEF_ACTIVE_ANTILAM) {
				if (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIPaddress) == 0) {
					char cMsg[150];
					ZeroMemory(cMsg, sizeof(cMsg));
					wsprintf(cMsg, "Your Point(%s) has been blocked. Kill any other player!", m_pClientList[iClientH]->m_cCharName);
					ShowClientMsg(iAttackerH, cMsg);
					//return;
				}
				else m_pClientList[iAttackerH]->Event_Killed++;
			}
			else m_pClientList[iAttackerH]->Event_Killed++;
		//	m_pClientList[iAttackerH]->Event_Killed++;
			CheckNewNivel(iAttackerH, FALSE);

			m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
			m_pClientList[iClientH]->m_iMP = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2);
			m_pClientList[iClientH]->m_iSP = (2 * m_pClientList[iClientH]->m_iStr) + (2 * m_pClientList[iClientH]->m_iLevel);
			m_pClientList[iClientH]->m_iHungerStatus = 100;
			m_pClientList[iClientH]->m_bIsKilled = FALSE;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);

			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);

			RequestTeleportHandler(iClientH, "2   ", DEF_EVENTMAP_PVPEVENT, 80, 60);
			return;
		}

		m_pClientList[iClientH]->TotalDeath++;

		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		ZeroMemory(cAttackerName, sizeof(cAttackerName));
		switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER_INDIRECT:
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[iAttackerH] != NULL)
					memcpy_secure(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[iAttackerH] != NULL)
					memcpy_secure(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
				break;
			default:
				break;
		}

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			m_pClientList[iAttackerH]->TotalClientKilled++;
			if (!m_pClientList[iAttackerH]->Achivements[4].Complete)
				CheckCompleteAchivement(iAttackerH, 4, TRUE);
			else if (!m_pClientList[iAttackerH]->Achivements[13].Complete)
				CheckCompleteAchivement(iAttackerH, 13, TRUE);
			else if (!m_pClientList[iAttackerH]->Achivements[27].Complete)
				CheckCompleteAchivement(iAttackerH, 27, TRUE);

			if (m_pClientList[iAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
				if (m_pClientList[iAttackerH]->m_pItemList[m_pClientList[iAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW)
					CheckCompleteAchivement(iAttackerH, 8, TRUE);
			}

			if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iClientH]->m_cSide || m_pClientList[iAttackerH]->Assasain) EK = FALSE;

			sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
			//Ek Anuncier Por LaloRamos
			EkAnnoucer(cAttackerName, m_pClientList[iClientH]->m_cCharName, EK);
		}
		else sAttackerWeapon = 1;

		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		//allvsall fix restart
		if (m_pClientList[iClientH] != NULL) {
			if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) TotalCompetidores++;

				ChequearAllVsAll();
				return;
			}
		}

		//Fix All Vs All
		if ((strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) != 0) || (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) != 0))
		{
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 1, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 2, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 4, NULL, NULL);
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
		}

		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;

		//50Cent - Capture The Flag
		if (bCheckIfIsFlagCarrier(iClientH)) {
			SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			SetFlagCarrierFlag(iClientH, false);
		}

		if (m_pClientList[iClientH] != NULL)
			if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) return;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
					bIsSAattacked = TRUE;
					break;
			}

			if (iAttackerH == iClientH) return;

			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
				if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
					if (m_pClientList[iAttackerH]->Assasain) {
						if (m_pClientList[iClientH]->Assasain)
							ApplyPkPoint(iAttackerH, iClientH, TRUE);
					}
				}
				else {
					if (!m_pClientList[iAttackerH]->Assasain) {
						if (m_pClientList[iClientH]->Assasain)
							EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				if (m_pClientList[iClientH]->m_iGuildRank == -1) {
					if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) { // Es neutral
						if (m_pClientList[iAttackerH]->Assasain) // Es asessino
							ApplyPkPoint(iAttackerH, iClientH);
						else {
							if (m_pClientList[iClientH]->m_iPKCount == 0)
								ApplyPKpenalty(iAttackerH, iClientH);
						}
					}
					else {
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK, 8) == 0) {
							EnemyKillRewardHandler(iAttackerH, iClientH);
						}
						else if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK, 8) == 0) {
							EnemyKillRewardHandler(iAttackerH, iClientH);
						}
						else if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
							if (m_pClientList[iClientH]->m_iPKCount == 0)
								ApplyPKpenalty(iAttackerH, iClientH);
							else PK_KillRewardHandler(iAttackerH, iClientH);
						}
						else EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
				else {
					if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
						if (m_pClientList[iAttackerH]->Assasain)
							ApplyPkPoint(iAttackerH, iClientH);
						else {
							if (m_pClientList[iClientH]->m_iPKCount == 0)
								ApplyPKpenalty(iAttackerH, iClientH);
						}
					}
					else {
						if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK, 8) == 0) {
							EnemyKillRewardHandler(iAttackerH, iClientH);
						}
						else if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK, 8) == 0) {
							EnemyKillRewardHandler(iAttackerH, iClientH);
						}
						else if (m_pClientList[iClientH]->m_cSide == m_pClientList[iAttackerH]->m_cSide) {
							if (m_pClientList[iClientH]->m_iPKCount == 0)
								ApplyPKpenalty(iAttackerH, iClientH);
							else PK_KillRewardHandler(iAttackerH, iClientH);
						}
						else EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}

			if (m_pClientList[iClientH] == NULL || m_pClientList[iAttackerH] == NULL) return;

			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL && m_pClientList[iClientH]->Assasain)
				ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
			else {
				if (m_pClientList[iClientH]->m_iPKCount == 0) {
					// Innocent
					if (m_pClientList[iAttackerH]->m_cSide == DEF_NETURAL) {
						if (m_pClientList[iAttackerH]->Assasain)
							ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
					}
					else {
						if (m_pClientList[iClientH]->m_cSide != m_pClientList[iAttackerH]->m_cSide) {
							ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
						}
					}
				}
				else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
					// Criminal 
					ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked, TRUE);
				}
				else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
					// Murderer 
					ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked, TRUE);
				}
				else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
					// Slaughterer 
					ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked, TRUE);
				}
			}
		}
		else if (cAttackerType == DEF_OWNERTYPE_NPC) {
			_bPKLog(DEF_PKLOG_BYNPC, (int)-1, iClientH, cAttackerName);
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked, TRUE);

			if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {
				if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
					for (i = 1; i < DEF_MAXCLIENTS; i++) {
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
							(m_pClientList[i]->m_iCrusadeDuty == 3)) {
							m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

							if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
								m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

							wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
							PutLogList(G_cTxt);
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
							return;
						}
					}
				}
			}
		}
		else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
			_bPKLog(DEF_PKLOG_BYOTHER, (int)-1, iClientH, NULL);
		}
		ZeroMemory(cEKMsg, sizeof(cEKMsg));
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClientKilledHandler");
	}
#endif
}

BOOL CMapServer::bAddMagicAngelInt(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		for (int i = 0; i < DEF_MAXMAGICTYPE; i++) {
			if (m_pMagicConfigList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_cMagicMastery[i] == 2) && (m_pMagicConfigList[i]->m_sIntLimit <= ((m_pClientList[iClientH]->m_iInt) + (m_pClientList[iClientH]->m_sRankAddInt) + (m_pClientList[iClientH]->m_iAngelicInt))))
					m_pClientList[iClientH]->m_cMagicMastery[i] = 1;
			}
		}
		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bAddMagicAngelInt");
		return FALSE;
	}
#endif
}

BOOL CMapServer::bCheckAngelInt(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		for (int i = 0; i < DEF_MAXMAGICTYPE; i++) {
			if (m_pMagicConfigList[i] != NULL) {
				if (m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->m_iInt) {
					if (m_pClientList[iClientH]->m_cMagicMastery[i] == 1) m_pClientList[iClientH]->m_cMagicMastery[i] = 2;
					else m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
				}
			}
		}
		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DismissGuildApproveHandler");
		return FALSE;
	}
#endif
}
void CMapServer::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{
	char cEquipPos, cHeroChecker;
	short sTemp;
	int   iTemp;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
		if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
		if (cEquipPos == DEF_EQUIPPOS_RHAND) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) ||
					(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
					m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
				}
			}
		}
		else if (cEquipPos == DEF_EQUIPPOS_LFINGER) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 910) {
					bCheckAngelInt(iClientH);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				}
				else if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 908) ||
					(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 909) ||
					(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 911)) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
				}
			}
		}

		switch (cEquipPos) {
			case DEF_EQUIPPOS_RHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;

				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				break;

			case DEF_EQUIPPOS_LHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xFFF0;
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xF0FFFFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xF0FFFFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_TWOHAND:
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_BODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xFF7F;
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFF0FFFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFF0FFFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_BACK:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xF0FF;
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFF0FFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFF0FFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_ARMS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFFF0;
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFF0FFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFF0FFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_PANTS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xF0FF;
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFF0FF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFFF0FF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_LEGGINGS:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0x0FFF;
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFF0F;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFFFF0F;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_HEAD:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFF0F;
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFFFFFF0;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFFFFFF0;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;

			case DEF_EQUIPPOS_FULLBODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor;
				iTemp = iTemp & 0xFFF0FFFF;
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// New Colors -> ZeroEoyPnk
				iTemp = m_pClientList[iClientH]->m_iApprColor2;
				iTemp = iTemp & 0xFFF0FFFF;
				m_pClientList[iClientH]->m_iApprColor2 = iTemp;
				break;
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY)
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;

		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;

		if (bNotice == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		cHeroChecker = CheckHeroItemEquipHandler(iClientH);
		if (cHeroChecker != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroBonus = cHeroChecker;

		CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReleaseItemHandler");
	}
#endif
}

BOOL CMapServer::_bDecodeNpcConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iNpcConfigListIndex = 0;
	class CStrTok * pStrTok;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading NPC configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();
		//token = strtok(pContents, seps);
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								// NPC
								if (strlen(token) > 20) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
								memcpy_secure(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
								cReadModeB = 2;
								break;
							case 2:
								// m_sType
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
								cReadModeB = 3;
								break;
							case 3:
								// m_iHitDice
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
								cReadModeB = 4;
								break;
							case 4:
								// m_iDefenseRatio
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
								cReadModeB = 5;
								break;
							case 5:
								// m_iHitRatio
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
								cReadModeB = 6;
								break;
							case 6:
								// m_iMinBravery
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
								cReadModeB = 7;
								break;
							case 7:
								// m_iExpDiceMin
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMin = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// m_iExpDiceMax
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMax = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// m_iGoldDiceMin
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMin = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								// m_iGoldDiceMax
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMax = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								// m_cAttackDiceThrow
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
								cReadModeB = 12;
								break;

							case 12:
								// m_cAttackDiceRange
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
								cReadModeB = 13;
								break;

							case 13:
								// m_cSize
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
								cReadModeB = 15;
								break;

							case 15:
								// ActionLimit 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
								cReadModeB = 16;
								break;

							case 16:
								// Action Time
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
								cReadModeB = 17;
								break;

							case 17:
								// ResistMagic
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
								cReadModeB = 18;
								break;

							case 18:
								// cMagicLevel
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
								cReadModeB = 19;
								break;

							case 19:
								// cGenDayWeekLimit  // Æ¯Á¤ ¿äÀÏ¿¡¸¸ »ý¼ºµÇ´Â ¸ó½ºÅÍ¿©ºÎ 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
								cReadModeB = 20;
								break;

							case 20:
								// cChatMsgPresence
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);

								if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {

								}
								cReadModeB = 21;
								break;

							case 21:
								// m_cTargetSearchRange
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);

								cReadModeB = 22;
								break;

							case 22:
								// Npc Àç »ý¼º±îÁöÀÇ ½Ã°£
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);

								cReadModeB = 23;
								break;

							case 23:
								// Attribute
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);

								cReadModeB = 24;
								break;

							case 24:
								// Absorb Magic Damage
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);

								cReadModeB = 25;
								break;

							case 25:
								// Maximum Mana Point
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);

								cReadModeB = 26;
								break;

							case 26:
								// MagicHitRatio
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);

								cReadModeB = 27;
								break;

							case 27:
								// AttackRange
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);

								cReadModeA = 0;
								cReadModeB = 0;
								iNpcConfigListIndex++;
								break;
						}
						break;

					case 2:
						m_iPlayerMaxLevel = atoi(token);
						sprintf(cTxt, "Max Player Level : %d", m_iPlayerMaxLevel);
						ConfigList(cTxt);
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "Npc", 3) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
					m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
				}

				if (memcmp(token, "world-server-max-level", 22) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
		PutLogList(cTxt);

		return TRUE;
	}
}

BOOL CMapServer::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, iTemp;
		char cTmpName[21];
		int  sTemp;
		double dV1, dV2, dV3;

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pNpcName);

		for (i = 0; i < DEF_MAXNPCTYPES; i++) {
			if (m_pNpcConfigList[i] != NULL) {
				if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
					ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
					memcpy_secure(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);

					pNpc->m_sType = m_pNpcConfigList[i]->m_sType;

					// HitDice
					if (m_pNpcConfigList[i]->m_iHitDice <= 5)
						pNpc->m_iHP = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
					else pNpc->m_iHP = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));

					if (pNpc->m_iHP == 0) pNpc->m_iHP = 1;

					pNpc->m_iExpDiceMin = m_pNpcConfigList[i]->m_iExpDiceMin;
					pNpc->m_iExpDiceMax = m_pNpcConfigList[i]->m_iExpDiceMax;
					pNpc->m_iGoldDiceMin = m_pNpcConfigList[i]->m_iGoldDiceMin;
					pNpc->m_iGoldDiceMax = m_pNpcConfigList[i]->m_iGoldDiceMax;
					pNpc->m_iExp = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);

					pNpc->m_iHitDice = m_pNpcConfigList[i]->m_iHitDice;
					pNpc->m_iDefenseRatio = m_pNpcConfigList[i]->m_iDefenseRatio;
					pNpc->m_iHitRatio = m_pNpcConfigList[i]->m_iHitRatio;
					pNpc->m_iMinBravery = m_pNpcConfigList[i]->m_iMinBravery;
					pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
					pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
					pNpc->m_cSize = m_pNpcConfigList[i]->m_cSize;
					pNpc->m_cSide = m_pNpcConfigList[i]->m_cSide;
					pNpc->m_cActionLimit = m_pNpcConfigList[i]->m_cActionLimit;
					pNpc->m_dwActionTime = m_pNpcConfigList[i]->m_dwActionTime;
					pNpc->m_dwRegenTime = m_pNpcConfigList[i]->m_dwRegenTime;
					pNpc->m_cResistMagic = m_pNpcConfigList[i]->m_cResistMagic;
					pNpc->m_cMagicLevel = m_pNpcConfigList[i]->m_cMagicLevel;
					pNpc->m_iMaxMana = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
					pNpc->m_iMana = m_pNpcConfigList[i]->m_iMaxMana;
					pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
					pNpc->m_cDayOfWeekLimit = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
					pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
					pNpc->m_sAreaSize = m_pNpcConfigList[i]->m_sAreaSize;

					switch (sClass) {
						case 43:
						case 44:
						case 45:
						case 46:
						case 47: // ������ ������ ���� ������ ���ݸ� �ϴ� ������ ����.
						case 51:
							pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
							break;

						case 53: // ��Ȧ���� ���� ������ ���� Ž�� ������ �ִ�.
							cSA = 1;
							break;

						default:
							pNpc->m_iAttackStrategy = iDice(1, 10);
							break;
					}

					pNpc->m_iAILevel = iDice(1, 3);
					pNpc->m_iAbsDamage = m_pNpcConfigList[i]->m_iAbsDamage;
					pNpc->m_iMagicHitRatio = m_pNpcConfigList[i]->m_iMagicHitRatio;
					pNpc->m_iAttackRange = m_pNpcConfigList[i]->m_iAttackRange;
					pNpc->m_cSpecialAbility = cSA;
					pNpc->m_iBuildCount = m_pNpcConfigList[i]->m_iMinBravery;
					pNpc->m_cAttribute = m_pNpcConfigList[i]->m_cAttribute;

					switch (pNpc->m_cSpecialAbility) {
						case 1:
							dV2 = (double)pNpc->m_iExp;
							dV3 = 25.0f / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;

						case 2:
							dV2 = (double)pNpc->m_iExp;
							dV3 = 30.0f / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;

						case 3: // Absorbing Physical Damage
							if (pNpc->m_iAbsDamage > 0) {
								pNpc->m_cSpecialAbility = NULL;
								cSA = NULL;
							}
							else {
								iTemp = 20 + iDice(1, 60);
								pNpc->m_iAbsDamage -= iTemp;
								if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
							}

							dV2 = (double)pNpc->m_iExp;
							dV3 = (double)abs(pNpc->m_iAbsDamage) / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;

						case 4: // Absorbing Magical Damage
							if (pNpc->m_iAbsDamage < 0) {
								pNpc->m_cSpecialAbility = NULL;
								cSA = NULL;
							}
							else {
								iTemp = 20 + iDice(1, 60);
								pNpc->m_iAbsDamage += iTemp;
								if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
							}

							dV2 = (double)pNpc->m_iExp;
							dV3 = (double)(pNpc->m_iAbsDamage) / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;

						case 5:
							dV2 = (double)pNpc->m_iExp;
							dV3 = 15.0f / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;

						case 6:
						case 7:
							dV2 = (double)pNpc->m_iExp;
							dV3 = 20.0f / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;

						case 8:
							dV2 = (double)pNpc->m_iExp;
							dV3 = 25.0f / 100.0f;
							dV1 = dV2 * dV3;
							pNpc->m_iExp += (int)dV1;
							break;
					}

					pNpc->m_iNoDieRemainExp = (pNpc->m_iExp) - (pNpc->m_iExp / 3);

					pNpc->m_iStatus = pNpc->m_iStatus & 0xFFFFF0FF;
					sTemp = cSA;
					sTemp = sTemp << 8;
					pNpc->m_iStatus = pNpc->m_iStatus | sTemp;

					pNpc->m_iStatus = pNpc->m_iStatus & 0xFFFFFFF0;
					pNpc->m_iStatus = pNpc->m_iStatus | (sClass);

					return TRUE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bInitNpcAttr");
	}
#endif
	return FALSE;
}

int CMapServer::iDice(int iThrow, int iRange)
{
	register int i, iRet;

	if (iRange <= 0) return 0;

	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}

void CMapServer::OnStartGameSignal()
{
	int i;
	PutLogList("Game Server Activated.");

	wsprintf(G_cTxt, "Max Player Connect : %d", m_iMaxClients);
	ConfigList(G_cTxt);

	wsprintf(G_cTxt, "Total Player Connect : %d", m_iTotalClients);
	ConfigList(G_cTxt);

	wsprintf(G_cTxt, "Users Added : %d", m_iAddUser);
	ConfigList(G_cTxt);

	/*wsprintf(G_cTxt, "Users Afk : %d", m_iAFKUsers); //agregadov11
	ConfigList(G_cTxt);*/

	//wsprintf(G_cTxt, "Total Visible Users : %d", m_iTotalGameServerClients + m_iAddUser + m_iAFKUsers);
	wsprintf(G_cTxt, "Total Visible Users : %d", m_iTotalGameServerClients + m_iAddUser);
	ConfigList(G_cTxt);

	Actualizar = TRUE;
	m_pGold = new class CItem;
	_bInitItemAttr(m_pGold, "Gold");
}

void CMapServer::TimeHitPointsUp(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int iMaxHP, iTemp, iTotal;
		double dV1, dV2, dV3;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 ����ô�ϱ� ���� �����߿��� ü�� ������ ����.

		iMaxHP = iGetMaxHP(iClientH);

		if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
			iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));
			if (iTemp < (m_pClientList[iClientH]->m_iVit / 2)) iTemp = (m_pClientList[iClientH]->m_iVit / 2);

			if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
				iTemp = iTemp - (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

			iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;
			iTotal += m_pClientList[iClientH]->m_iHPStatic_stock;

			if (m_pClientList[iClientH]->m_iAddHP != 0) {
				dV2 = (double)iTotal;
				dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
				dV1 = (dV3 / 100.0f)*dV2;
				iTotal += (int)dV1;
			}

			m_pClientList[iClientH]->m_iHP += iTotal; // Hit Point�� 17�ʸ��� 1D(Vit) + HPstock�� �ö󰣴�.
			if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;
			if (m_pClientList[iClientH]->m_iHP <= 0)     m_pClientList[iClientH]->m_iHP = 0;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		m_pClientList[iClientH]->m_iHPstock = 0;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: TimeHitPointsUp");
	}
#endif
}

void CMapServer::TimeManaPointsUp(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int iMaxMP, iTotal;
		double dV1, dV2, dV3;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 ����ô�ϱ� ���� �����߿��� ���� ������ ����.

		iMaxMP = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2); // v1.4
		if (m_pClientList[iClientH]->m_iMP < iMaxMP) {

			iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag));
			if (m_pClientList[iClientH]->m_iAddMP != 0) {
				dV2 = (double)iTotal;
				dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
				dV1 = (dV3 / 100.0f)*dV2;
				iTotal += (int)dV1;
			}

			m_pClientList[iClientH]->m_iMP += iTotal;
			if (m_pClientList[iClientH]->m_iMP > iMaxMP) m_pClientList[iClientH]->m_iMP = iMaxMP;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: TimeManaPointsUp");
	}
#endif
}

void CMapServer::TimeStaminarPointsUp(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int iMaxSP, iTotal;
		double dV1, dV2, dV3;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 ����ô�ϱ� ���� �����߿��� ���׹̳� ������ ����.

		iMaxSP = (2 * (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr)) + (2 * m_pClientList[iClientH]->m_iLevel);
		if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

			iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit / 3)); // Staminar Point�� 10�ʸ��� 1D(Vit/3)�� �ö󰣴�.
			if (m_pClientList[iClientH]->m_iAddSP != 0) {
				dV2 = (double)iTotal;
				dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
				dV1 = (dV3 / 100.0f)*dV2;
				iTotal += (int)dV1;
			}

			if (m_pClientList[iClientH]->m_iLevel <= 20) iTotal += 15;
			else if (m_pClientList[iClientH]->m_iLevel <= 40) iTotal += 10;
			else if (m_pClientList[iClientH]->m_iLevel <= 60) iTotal += 5;

			m_pClientList[iClientH]->m_iSP += iTotal;
			if (m_pClientList[iClientH]->m_iSP > iMaxSP)
				m_pClientList[iClientH]->m_iSP = iMaxSP;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: TimeStaminarPointsUp");
	}
#endif
}

void CMapServer::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
	char cData[500];
	DWORD * dwp;
	WORD  * wp;
	char  * cp;
	register int i, iRet = 0;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0)) {

				ZeroMemory(cData, sizeof(cData));

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = wNotifyMsgType;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

				switch (wNotifyMsgType) {
					case CLIENT_RESPONSE_GUILDDISBANDED:
						if (i == iClientH) break; // <-- ���� ������ �ڽſ��Դ� �޽����� ������ �ʴ´�.
						memcpy_secure(cp, m_pClientList[iClientH]->m_cGuildName, 20);
						cp += 20;

						memcpy_secure(cp, m_pClientList[iClientH]->m_cLocation, 10);
						cp += 10;

						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 36);
						ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
						strcpy_secure(m_pClientList[i]->m_cGuildName, "NONE");
						m_pClientList[i]->m_iGuildRank = -1;
						m_pClientList[i]->m_iGuildGUID = -1;
						break;

					case CLIENT_RESPONSE_NEWGUILDSMAN:
						memcpy_secure(cp, m_pClientList[iClientH]->m_cCharName, 10);
						cp += 10;

						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
						break;

					case CLIENT_RESPONSE_DISMISSGUILDSMAN:
						memcpy_secure(cp, m_pClientList[iClientH]->m_cCharName, 10);
						cp += 10;

						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
						break;
				}

				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(i, TRUE, TRUE);
						return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendGuildMsg");
	}
#endif
}

void CMapServer::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;
	char cData[9];

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

		ZeroMemory(cData, sizeof(cData));

		sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

		m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.17

		if (sAppr2 == 0)  m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
		else m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);

		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ToggleCombatModeHandler");
	}
#endif
}

int CMapServer::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
	char cData[100];
	DWORD * dwp;
	WORD  * wp;
	int     iRet;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return 0;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

		if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

		if (m_pClientList[iClientH]->KilledClientAFK != -1) m_pClientList[iClientH]->KilledClientAFK = -1;

		int iStX, iStY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
			iStX = m_pClientList[iClientH]->m_sX / 20;
			iStY = m_pClientList[iClientH]->m_sY / 20;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

			switch (m_pClientList[iClientH]->m_cSide) {
				case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
				case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
				case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
			}
		}

		ClearSkillUsingStatus(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}

		m_pClientList[iClientH]->m_cDir = cDir;

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOTION_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
		return 1;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iClientMotion_Magic_Handler");
	}
#endif
	return 0;
}

int  _tmp_iMCProb[] = { 0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40 };
int  _tmp_iMLevelPenalty[] = { 0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40 };
void CMapServer::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)
{
	short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic;
	char   * cp, cData[120], cDir, cOwnerType, cName[11], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int    tX, tY, iManaCost, iMagicAttr, iItemID;
	class  CItem * pItem;
	BOOL Summon;
	DWORD * dwp, dwTime = timeGetTime();
	WORD  * wp, wWeaponType;
	short sTemp;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
			(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;
		if (m_pMagicConfigList[sType]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt)) return;
		if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;

		if ((sType < 0) || (sType >= 100))     return;
		if (m_pMagicConfigList[sType] == NULL) return;
		if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return;

		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
			wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
			if ((wWeaponType >= 34) && (wWeaponType <= 39)) {}
			else return;
		}

		if (m_pClientList[iClientH]->m_bInhibition == TRUE) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;
		}
		if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] != -1) ||
			(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;

		if ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 100) return;
		m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

		sX = m_pClientList[iClientH]->m_sX;
		sY = m_pClientList[iClientH]->m_sY;

		sMagicCircle = (sType / 10) + 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0) dV1 = 1.0f;
		else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];

		if (bItemEffect == TRUE) dV1 = (double)100.0f;

		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)_tmp_iMCProb[sMagicCircle];

		dV1 = dV2 * dV3;
		iResult = (int)dV1;

		if (m_pClientList[iClientH]->m_iInt > 50) iResult += (m_pClientList[iClientH]->m_iInt - 50) / 2;

		sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
		if (sMagicCircle != sLevelMagic) {
			if (sMagicCircle > sLevelMagic) {
				dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
				dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
				dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
				dV4 = (dV1 / dV3)*dV2;
				iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
			}
			else iResult += 5 * abs(sMagicCircle - sLevelMagic); // v1.4
		}

		switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
			case 0: break;
			case 1: iResult = iResult - (iResult / 24); break; // ���� �� ���� ������ 4, 8, 20% ���� 
			case 2:	iResult = iResult - (iResult / 12); break;
			case 3: iResult = iResult - (iResult / 5);  break;
		}

		if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
			dV1 = (double)iResult;
			dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
			dV3 = dV1 + dV2;
			iResult = (int)dV3;
		}

		if (iResult <= 0) iResult = 1;

		iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

		iManaCost = m_pMagicConfigList[sType]->m_sValue1;

		if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
			dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
			dV2 = (double)(dV1 / 100.0f);
			dV3 = (double)iManaCost;
			dV1 = dV2 * dV3; // �� ���� �����Ǵ� �� 
			dV2 = dV3 - dV1;
			iManaCost = (int)dV2;
			if (iManaCost <= 0) iManaCost = 1;
		}

		if (iResult < 100) {
			iDiceRes = iDice(1, 100);
			if (iResult < iDiceRes) {
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
				return;
			}
		}

		if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1, 1000) <= 100)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;
		}

		if (m_pClientList[iClientH]->m_iMP < iManaCost) return;

		iResult = m_pClientList[iClientH]->m_cSkillMastery[4];

		if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += (m_pClientList[iClientH]->m_iMag - 50);

		sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
		if (sMagicCircle != sLevelMagic) {
			if (sMagicCircle > sLevelMagic) {
				dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
				dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
				dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
				dV4 = (dV1 / dV3)*dV2;
				iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
			}
			else iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}

		iResult += m_pClientList[iClientH]->m_iAddAR;
		iResult += m_pClientList[iClientH]->m_iAddMagicHitting;

		if (iResult <= 0) iResult = 1;
		if (sType >= 80) iResult += 10000;

		if (m_pMagicConfigList[sType]->m_cCategory == 1)
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;

		iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		if ((m_bIsCrusadeMode == FALSE) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
			if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
			if (((m_pClientList[iClientH]->m_bIsHunter == TRUE) ||
				(m_pClientList[sOwnerH]->m_bIsHunter == TRUE)) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide))
				goto MAGIC_NOEFFECT;

			if ((m_pClientList[iClientH]->m_bIsHunter == TRUE) && (m_pClientList[sOwnerH]->m_bIsHunter == FALSE)) {
				switch (m_pMagicConfigList[sType]->m_sType) {
					case DEF_MAGICTYPE_SPDOWN_AREA:
					case DEF_MAGICTYPE_SUMMON:
					case DEF_MAGICTYPE_PROTECT:
					case DEF_MAGICTYPE_HOLDOBJECT:
					case DEF_MAGICTYPE_INVISIBILITY:
					case DEF_MAGICTYPE_BERSERK:
					case DEF_MAGICTYPE_POISON:
					case DEF_MAGICTYPE_HPUP_SPOT:
						goto MAGIC_NOEFFECT;
						break;
				}
			}
		}

		if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
			switch (m_pMagicConfigList[sType]->m_sType) {
				case DEF_MAGICTYPE_POLYMORPH:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] != 0) goto MAGIC_NOEFFECT;
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] = (char)m_pMagicConfigList[sType]->m_sValue4;
							m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
							m_pClientList[sOwnerH]->m_sType = 18;
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_POLYMORPH] = (char)m_pMagicConfigList[sType]->m_sValue4;
							m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
							m_pNpcList[sOwnerH]->m_sType = 18;
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							break;
					}

					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
						sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					break;

				case DEF_MAGICTYPE_DAMAGE_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_SPOT_SPDOWN:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_SCAN:
					ZeroMemory(cScanMessage, sizeof(cScanMessage));
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) goto MAGIC_NOEFFECT;
								if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) {
									ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
									goto MAGIC_NOEFFECT;
								}
								wsprintf(cScanMessage, "Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
								ShowClientMsg(iClientH, cScanMessage);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, "NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
								ShowClientMsg(iClientH, cScanMessage);
								break;
						}
						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, 10);
					}
					break;

				case DEF_MAGICTYPE_CANCELLATION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) goto MAGIC_NOEFFECT;

						// Eventos y mapas especiales:
						if (iClientH != sOwnerH) {
							if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "masacre") == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "bisle") == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ArenaPvP") == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ArGEvent") == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) ||
								(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Extreme") == 0)) {
							}
							else {
								// Son de la misma city y no son assasains 
								if ((m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) &&
									(m_pClientList[iClientH]->m_cSide != 0)) {

									// Que pertenezcan a la misma guild :P
									if ((m_pClientList[iClientH]->m_iGuildGUID == m_pClientList[sOwnerH]->m_iGuildGUID) &&
										(m_pClientList[iClientH]->m_iGuildGUID != -1)) {
									}
									else {
										// No est� en party, o bien la party id no coincide.
										if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL ||
											m_pClientList[iClientH]->m_iPartyID != m_pClientList[sOwnerH]->m_iPartyID) goto MAGIC_NOEFFECT;
									}
								}
							}
						}

						// Removes Invisibility Flag 0x0010
						if (m_pClientList[sOwnerH]->m_iStatus & 0x10) {
							// No Effect en cvc to friends
							if ((CityVsCity == TRUE) && (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)
								&& (m_pClientList[sOwnerH] != m_pClientList[iClientH]) && (!m_pClientList[sOwnerH]->Assasain))  goto MAGIC_NOEFFECT;


							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
						}

						// Removes Illusion Flag 0x01000000
						if (m_pClientList[iClientH] != NULL) {
							if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)){
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								goto MAGIC_NOEFFECT;
							}
							else {
								if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0))
								{
								}
								else if (m_pClientList[sOwnerH]->m_iStatus & 0x01000000) {
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
									SetIllusionFlag(sOwnerH, cOwnerType, FALSE);
									SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
								}
							}
						}

						// Removes Defense Shield Flag 0x02000000
						// Removes Great Defense Shield Flag 0x02000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x02000000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetDefenseShieldFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 3, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						if (m_pClientList[sOwnerH]->m_iStatus & 0x40) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);
							SetIceFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = NULL;
						}

						// Removes Absolute Magic Protection Flag 0x04000000	
						// Removes Protection From Magic Flag 0x04000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x04000000) {
							// No Effect en cvc to friends
							if ((CityVsCity == TRUE) && (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)
								&& (m_pClientList[sOwnerH] != m_pClientList[iClientH]) && (!m_pClientList[sOwnerH]->Assasain))  goto MAGIC_NOEFFECT;
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetMagicProtectionFlag(sOwnerH, cOwnerType, FALSE);
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 2, NULL, NULL);
							else SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 5, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						// Removes Protection From Arrow Flag 0x08000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x08000000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetProtectionFromArrowFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 1, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						// Removes Illusion Movement Flag 0x00200000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x00200000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
							SetIllusionMovementFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 4, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
						}

						// Removes Berserk Flag 0x0020
						if (m_pClientList[sOwnerH]->m_iStatus & 0x20) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
							SetBerserkFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_BERSERK, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = NULL;
						}

						// Removes Fury Of War Flag 0x100000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x100000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
							SetFuryWarFlag(sOwnerH, cOwnerType, FALSE);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = NULL;
						}

						//Remove Inhibition
						if (m_pClientList[sOwnerH]->m_bInhibition == TRUE) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INHIBITION] = NULL;
							m_pClientList[sOwnerH]->m_bInhibition = FALSE;
						}

						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
					//No esw en barracks
				/*	if (strcmp(m_pClientList[iClientH]->m_cMapName, "MBarracks") == 0) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}*/

					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}

						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
							}
						}
						if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

											}
											break;
									}
								}
							}
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								}
								break;
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

									}
									break;
							}
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_LINEAR:
					if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}
					if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK, 8) == 0) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 11; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}
						if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
							}
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
						}
					}
					break;

				case DEF_MAGICTYPE_ICE_LINEAR:
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
								}
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
								}
							}
						}
						if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
									}
								}
							}
						}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
										SetIceFlag(sOwnerH, cOwnerType, TRUE);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
									}
								}
								break;
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
							}
						}
					}
					break;

				case DEF_MAGICTYPE_HPUP_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					break;

				case DEF_MAGICTYPE_INHIBITION:
					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && FinalFight) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_WORLDWARII) == 0 && WorldWarII) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0 && AllEks) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0 && AllDkEks) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					if ((DKEvent == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0)) {
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						break;
					}

					if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						break;
					}
					if ((PriceHODEvent || SummonLaunched)) {
						if ((strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
							(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
							(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0) ||
							(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0)) {
							goto MAGIC_NOEFFECT;
							break;
						}
					}
					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0) {
						goto MAGIC_NOEFFECT;
						break;
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INHIBITION] != 0) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) goto MAGIC_NOEFFECT;

							if ((CityVsCity == TRUE) && (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide)
								&& (m_pClientList[sOwnerH] != m_pClientList[iClientH]) && (!m_pClientList[sOwnerH]->Assasain))  goto MAGIC_NOEFFECT;

							//Assasain
							if (memcmp(m_pClientList[sOwnerH]->m_cLocation, "NONE", 4) == 0)
								if (!m_pClientList[sOwnerH]->Assasain)	goto MAGIC_NOEFFECT;

							if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) goto MAGIC_NOEFFECT;
							m_pClientList[sOwnerH]->m_bInhibition = TRUE;
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INHIBITION, NULL, NULL, NULL);
							break;
					}
					break;

				case DEF_MAGICTYPE_TREMOR: // v1.4 �ֺ� ���� ȿ���� �̾� �ܷ� ȿ���� �ִ�.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
							}
						}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE)
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								if (iDice(1, 3) == 1)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								if (sType == 82)
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr, TRUE);
								else
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE)
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										if (iDice(1, 3) == 1)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									}
							}
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
					for (iy = dY - 1; iy <= dY + 1; iy++) {
						for (ix = dX - 1; ix <= dX + 1; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
								}
							}
						}
					}
					break;

				case DEF_MAGICTYPE_SPDOWN_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
					}
					break;

				case DEF_MAGICTYPE_SPUP_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
					}
					break;

				case DEF_MAGICTYPE_TELEPORT:
					if (m_pClientList[iClientH]->m_bRecall == FALSE) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, "Por 10 segundos no puedes usar Recall");
						goto MAGIC_NOEFFECT;
						break;
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					//50Cent - Capture The Flag
					if (bCheckIfIsFlagCarrier(iClientH)) {
						ShowClientMsg(iClientH, "You can not use that magic being a flag carrier.");
						goto MAGIC_NOEFFECT;
						break;
					}

					if (m_pClientList[iClientH] != NULL) {
						if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
							ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
							goto MAGIC_NOEFFECT;
							break;
						}
					}

					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH)) {
								if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
									(m_pClientList[iClientH]->m_bIsKilled == FALSE) && (m_pClientList[iClientH]->m_iHP > 0)) {
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
								}
								else {
									if (bCheckIfIsFlagCarrier(iClientH)) {
										ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
									}
									else if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
										ShowClientMsg(iClientH, "No puedes usar este item en el evento.");
									}
									else {
										RequestTeleportHandler(iClientH, "1   ");
									}
								}
							}
							break;
					}
					break;

				case DEF_MAGICTYPE_SUMMON:
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;

					if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) && m_pMagicConfigList[sType]->m_sValue4 == 5) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)) {
						iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

						if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4] / 20)) break;
						iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

							ZeroMemory(cNpcName, sizeof(cNpcName));

							switch (iV1) {
								case NULL: // �Ϲ����� ���� 
									iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

									if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20)
										iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

									switch (iResult) {
										case 1: strcpy_secure(cNpcName, "Slime"); break;
										case 2: strcpy_secure(cNpcName, "Giant-Ant"); break;
										case 3: strcpy_secure(cNpcName, "Amphis"); break;
										case 4: strcpy_secure(cNpcName, "Orc"); break;
										case 5: strcpy_secure(cNpcName, "Skeleton"); break;
										case 6:	strcpy_secure(cNpcName, "Clay-Golem"); break;
										case 7:	strcpy_secure(cNpcName, "Stone-Golem"); break;
										case 8: strcpy_secure(cNpcName, "Orc-Mage"); break;
										case 9:	strcpy_secure(cNpcName, "Hellbound"); break;
										case 10: strcpy_secure(cNpcName, "Ettin"); break;
									}
									break;
								case 1:	strcpy_secure(cNpcName, "Orc"); break;
								case 2: strcpy_secure(cNpcName, "Skeleton"); break;
								case 3: strcpy_secure(cNpcName, "Clay-Golem"); break;
								case 4: strcpy_secure(cNpcName, "Stone-Golem"); break;
								case 5: strcpy_secure(cNpcName, "Hellbound"); break;
								case 6: strcpy_secure(cNpcName, "Ettin"); break;
								case 7: strcpy_secure(cNpcName, "Troll"); break;
								case 8: strcpy_secure(cNpcName, "Orge"); break;
							}

							if (m_pClientList[iClientH]->Assasain == TRUE)
								Summon = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, 11, FALSE, TRUE);
							else
								Summon = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE);

							if (Summon == FALSE) m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							else {
								ZeroMemory(cName_Master, sizeof(cName_Master));
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										memcpy_secure(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
										break;
									case DEF_OWNERTYPE_NPC:
										memcpy_secure(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
										break;
								}
								bSetNpcFollowMode(cName, cName_Master, cOwnerType);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_CREATE:
					if ((strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
						(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
						(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0) ||
						(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0) ||
						(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						goto MAGIC_NOEFFECT;
						break;
					}
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE) goto MAGIC_NOEFFECT;
					pItem = new class CItem;

					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							if (iDice(1, 2) == 1) iItemID = 99;
							else iItemID = 98;
							break;
					}

					_bInitItemAttr(pItem, iItemID);

					pItem->m_sTouchEffectType = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1, 100000);

					// Anti Dup System
					SYSTEMTIME SysTime;
					char cTemp[256];
					GetLocalTime(&SysTime);
					ZeroMemory(cTemp, sizeof(cTemp));
					pItem->m_sTouchEffectValue2 = iDice(1, 100000);
					wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue2 = atoi(cTemp);

					ZeroMemory(cTemp, sizeof(cTemp));
					wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
					pItem->m_dwTimeDrop = timeGetTime();

					//_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);

					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					break;

				case DEF_MAGICTYPE_PROTECT:
					if (m_pClientList[iClientH] != NULL) {
						if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
							ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
							goto MAGIC_NOEFFECT;
						}

						if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK, 8) == 0) && m_pMagicConfigList[sType]->m_sValue4 == 5) {
							ShowClientMsg(iClientH, "Magic Blocked in this map");
							return;
						}

						if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK, 8) == 0) && m_pMagicConfigList[sType]->m_sValue4 == 5) {
							ShowClientMsg(iClientH, "Magic Blocked in this map");
							return;
						}

						if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) && m_pMagicConfigList[sType]->m_sValue4 == 5) {
							ShowClientMsg(iClientH, "Magic Blocked in this map");
							return;
						}
					}
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL)
								if (!m_pClientList[sOwnerH]->Assasain) goto MAGIC_NOEFFECT;

							// Eventos y mapas especiales:
							if (iClientH != sOwnerH) {
								if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "masacre") == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "bisle") == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ArenaPvP") == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ArGEvent") == 0) ||
									(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Extreme") == 0)) {
								}
								else {
									// Son de la misma city y no son assasains 
									if ((m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) &&
										(m_pClientList[iClientH]->m_cSide != 0)) {

										// Que pertenezcan a la misma guild :P
										if ((m_pClientList[iClientH]->m_iGuildGUID == m_pClientList[sOwnerH]->m_iGuildGUID) &&
											(m_pClientList[iClientH]->m_iGuildGUID != -1)) {
										}
										else {
											// No est� en party, o bien la party id no coincide.
											if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL ||
												m_pClientList[iClientH]->m_iPartyID != m_pClientList[sOwnerH]->m_iPartyID) {
												if (m_pMagicConfigList[sType]->m_sValue4 != 5) goto MAGIC_NOEFFECT;
											}
										}
									}
								}
							}

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
							switch (m_pMagicConfigList[sType]->m_sValue4) {
								case 1:
									SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
									break;
								case 2:
									SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
									break;
								case 5:
									SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
									break;

								case 3:
								case 4:
									SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
									break;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
							break;
					}

					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000), sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					break;

				case DEF_MAGICTYPE_HOLDOBJECT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL)
									if (!m_pClientList[sOwnerH]->Assasain) goto MAGIC_NOEFFECT;
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
								}

								// Eventos y mapas especiales:
								if (iClientH != sOwnerH) {
									if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "masacre") == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "bisle") == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ArenaPvP") == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ArGEvent") == 0) ||
										(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Extreme") == 0)) {
									}
									else {
										// Son de la misma city y no son assasains 
										if ((m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) &&
											(m_pClientList[iClientH]->m_cSide != 0)) {

											// Que pertenezcan a la misma guild :P
											if ((m_pClientList[iClientH]->m_iGuildGUID == m_pClientList[sOwnerH]->m_iGuildGUID) &&
												(m_pClientList[iClientH]->m_iGuildGUID != -1)) {
											}
											else {
												// No est� en party, o bien la party id no coincide.
												if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL ||
													m_pClientList[iClientH]->m_iPartyID != m_pClientList[sOwnerH]->m_iPartyID) goto MAGIC_NOEFFECT;
											}
										}
									}
								}

								if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) && FinalFight)
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;

								if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
									m_bIsCrusadeMode == FALSE && m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide))
									goto MAGIC_NOEFFECT;

								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 ���� ���� 6�̻��� ��ġ�� �̻��� ���� �����Ϳ��Դ� ���� ���� ������ �ʴ´�.
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;
						}
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					break;

				case DEF_MAGICTYPE_INVISIBILITY:
					if (bCheckIfIsFlagCarrier(iClientH)) {
						ShowClientMsg(iClientH, "You can not use that magic being a flag carrier.");
						goto MAGIC_NOEFFECT;
						break;
					}
					if (((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
						|| memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) {
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						break;
					}

					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0)
					{
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						break;
					}

					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0)
					{
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						break;
					}

					if ((DKEvent == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0)) {
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						break;
					}

					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) goto MAGIC_NOEFFECT;
									//No Invi En Personas
								/*	if ((strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "2ndmiddle") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "areuni") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "BtField") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "elvuni") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "VipMap1") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "MapaVip") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "procella") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "icebound") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "MBarracks") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "abaddon") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "towerofh") == 0)) {
										goto MAGIC_NOEFFECT;
										break;
									}		*/										
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL)
										if (!m_pClientList[sOwnerH]->Assasain) goto MAGIC_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
									RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto MAGIC_NOEFFECT;
									if ((HellOfDeath || PriceHODEvent || SummonLaunched)) {
										if ((strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
											(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
											(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0) ||
											(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0)) {
											goto MAGIC_NOEFFECT;
										}
									}
									if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0) {
										goto MAGIC_NOEFFECT;
										break;
									}
									//No Invi En Summons
									/*if ((strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "2ndmiddle") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "areuni") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "BtField") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "elvuni") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "VipMap1") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "MapaVip") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "procella") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "icebound") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "MBarracks") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "abaddon") == 0) ||
										(strcmp(m_pClientList[iClientH]->m_cMapName, "towerofh") == 0)) {
										goto MAGIC_NOEFFECT;
										break;
									}*/
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = (char)m_pMagicConfigList[sType]->m_sValue4;
										SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
										RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
									}
									break;
							}
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;

						case 2:
							if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL)
								if (!m_pClientList[iClientH]->Assasain) goto MAGIC_NOEFFECT;

							for (ix = dX - 8; ix <= dX + 8; ix++) {
								for (iy = dY - 8; iy <= dY + 8; iy++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (sOwnerH != NULL) {
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;
										}
									}
								}
							}
							break;
					}
					break;

				case DEF_MAGICTYPE_CREATE_DYNAMIC:
					switch (m_pMagicConfigList[sType]->m_sValue10) {
						case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
						case DEF_DYNAMICOBJECT_FIRE:
						case DEF_DYNAMICOBJECT_SPIKE:
							//LaloFireWall en cvc
						//	if (m_bIsCrusadeMode == FALSE) {
							if ((m_bIsCrusadeMode == FALSE) && (CityVsCity == FALSE)) {
								if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
								if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
							}

							if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni") == 0) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en este mapa!");
								return;
							}

							switch (m_pMagicConfigList[sType]->m_sValue11) {
								case 1: // wall - type
									cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
									switch (cDir) {
										case 1:	rx = 1; ry = 0;   break;
										case 2: rx = 1; ry = 1;   break;
										case 3: rx = 0; ry = 1;   break;
										case 4: rx = -1; ry = 1;  break;
										case 5: rx = 1; ry = 0;   break;
										case 6: rx = -1; ry = -1; break;
										case 7: rx = 0; ry = -1;  break;
										case 8: rx = 1; ry = -1;  break;
									}
									iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
										dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000);

									bAnalyzeCriminalAction(iClientH, dX, dY);

									for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
										iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
											dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
										bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

										iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
											dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
										bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
									}
									break;

								case 2: // Field - Type
									BOOL bFlag = FALSE;
									int cx, cy;
									for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++) {
										for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
											iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
												ix, iy, m_pMagicConfigList[sType]->m_dwLastTime * 1000, m_pMagicConfigList[sType]->m_sValue5);

											if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
												bFlag = TRUE;
												cx = ix;
												cy = iy;
											}
										}
									}
									if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
									break;
							}
							break;

						case DEF_DYNAMICOBJECT_ICESTORM:
							if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && FinalFight) {
								ShowClientMsg(iClientH, "Magic Blocked in this map");
								return;
							}

							if ((DKEvent == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0)) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								return;
							}

							if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0)
							{
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								return;
							}

							if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0)
							{
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								return;
							}

							if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_WORLDWARII) == 0 && WorldWarII) {
								ShowClientMsg(iClientH, "Magic Blocked in this map");
								return;
							}
							if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								return;
							}

							if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni") == 0) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en este mapa!");
								return;
							}

							if (m_bIsCrusadeMode == FALSE) {
								if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
								if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
							}
							// Ice-Storm Dynamic Object 
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000,
								m_pClientList[iClientH]->m_cSkillMastery[4]);
							break;

						case DEF_DYNAMICOBJECT_HEALSPOT:
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000,
								m_pClientList[iClientH]->m_cSkillMastery[4]);
							break;

						case DEF_DYNAMICOBJECT_BLUEFIRE:
							if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni") == 0) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en este mapa!");
								return;
							}
							if ((DKEvent == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0)) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								return;
							}

							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000,
								m_pClientList[iClientH]->m_cSkillMastery[4]);
							break;

						default: break;
					}
					break;

				case DEF_MAGICTYPE_POSSESSION:
					if (_iCalcPlayerNum(m_pClientList[iClientH]->m_cMapIndex, dX, dY, 1) != 0) break;

					pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
					if (pItem != NULL) {
						if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
							pItem->m_dwTimeDrop = -1;

							_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

							dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = CLIENT_NOTIFY;
							wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp = CLIENT_NOTIFY_ITEMOBTAINED;

							cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

							*cp = 1;
							cp++;

							memcpy_secure(cp, pItem->m_cName, 20);
							cp += 20;

							dwp = (DWORD *)cp;
							*dwp = pItem->m_dwCount;
							cp += 4;

							*cp = pItem->m_cItemType;
							cp++;

							*cp = pItem->m_cEquipPos;
							cp++;

							*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
							cp++;

							sp = (short *)cp;
							*sp = pItem->m_sLevelLimit;
							cp += 2;

							*cp = pItem->m_cGenderLimit;
							cp++;

							wp = (WORD *)cp;
							*wp = pItem->m_wCurLifeSpan;
							cp += 2;

							wp = (WORD *)cp;
							*wp = pItem->m_wWeight;
							cp += 2;

							sp = (short *)cp;
							*sp = pItem->m_sSprite;
							cp += 2;

							sp = (short *)cp;
							*sp = pItem->m_sSpriteFrame;
							cp += 2;

							*cp = pItem->m_cItemColor;
							cp++;

						//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
						//	cp++;
							//cambio lalomanu
							sp = (short *)cp;
							*sp = pItem->m_sItemSpecEffectValue2;
							cp += 2;

							dwp = (DWORD *)cp;
							*dwp = pItem->m_dwAttribute;
							cp += 4;

							*cp = (char)pItem->m_sItemSpecEffectValue3;
							cp++;

							if (iEraseReq == 1) delete pItem;

							SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY, sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4

						//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
							//cambio lalomanu
							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									DeleteClient(iClientH, TRUE, TRUE);
									return;
							}
						}
						else {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
							pItem->m_dwTimeDrop = timeGetTime();

							dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = CLIENT_NOTIFY;
							wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									DeleteClient(iClientH, TRUE, TRUE);
									return;
							}
						}
					}
					break;

				case DEF_MAGICTYPE_CONFUSE:
					if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) && FinalFight) {
						ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
						goto MAGIC_NOEFFECT;
						return;
					}
					//No mim en barracks
					if (strcmp(m_pClientList[iClientH]->m_cMapName, "MBarracks") == 0) {
						ShowClientMsg(iClientH, "Magic Blocked in this map");
						return;
					}

					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1: // confuse Language�̴�. 
						case 2: // Confusion, Mass Confusion 	
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == NULL) goto PMH_SKIP_CONFUSE; // v2.172
										if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto PMH_SKIP_CONFUSE; // v2.172 ���� ������ ȥ�� ���� ��ȿ 
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = (char)m_pMagicConfigList[sType]->m_sValue4;
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
										}
									}
								PMH_SKIP_CONFUSE:;
								}
							}
							break;

						case 3: // Ilusion, Mass-Ilusion
							if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
								ShowClientMsg(iClientH, "Esta magia esta restringida en el evento!");
								goto MAGIC_NOEFFECT;
								break;
							}
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = (char)m_pMagicConfigList[sType]->m_sValue4;
											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 3:
													SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}
							}
							break;

						case 4: // Ilusion Movement
							if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (m_pClientList[sOwnerH]->m_cSide == m_pClientList[iClientH]->m_cSide) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = (char)m_pMagicConfigList[sType]->m_sValue4;
											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 4:
													SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}
							}
							break;
					}
					break;

				case DEF_MAGICTYPE_POISON:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL)
						if (!m_pClientList[iClientH]->Assasain) goto MAGIC_NOEFFECT;

					if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL)
									if (!m_pClientList[sOwnerH]->Assasain) goto MAGIC_NOEFFECT;

								bAnalyzeCriminalAction(iClientH, dX, dY);

								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
										m_pClientList[sOwnerH]->m_bIsPoisoned = TRUE;
										SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
										SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
										SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
									}
								}
								break;
						}
					}
					else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
									m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
									SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
									SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
								break;
						}
					}
					break;

				case DEF_MAGICTYPE_BERSERK:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) goto MAGIC_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
									if (m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;

									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
									break;
							}
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;

						case 2:
							if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) {
								ShowClientMsg(iClientH, "Magic Blocked in this map");
								return;
							}
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0) goto MAGIC_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetFuryWarFlag(sOwnerH, cOwnerType, TRUE);
									break;
							}

							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;

					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
								}
							}
						}
					}
					break;

				case DEF_MAGICTYPE_ICE:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);

							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (m_pClientList[sOwnerH]->m_bIsHunter == TRUE) goto MAGIC_NOEFFECT;
										if (m_pClientList[sOwnerH]->m_cSide == DEF_NETURAL)
											if (!m_pClientList[sOwnerH]->Assasain) goto MAGIC_NOEFFECT;

										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
									}
								}
							}
						}
					}
					break;

				default:
					break;
			}
		}
		else {
			if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
				if (m_pClientList[iClientH] != NULL && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
					m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == FALSE) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (m_pClientList[sOwnerH] != NULL) {
						if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
							(m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) return;

						if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != NULL && m_pClientList[sOwnerH]->m_iHP <= 0) {
							m_pClientList[sOwnerH]->m_bIsBeingResurrected = TRUE;
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
							if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
								m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
								m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
								m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
								m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

								sTemp = m_pClientList[iClientH]->m_sAppr4;
								sTemp = 0xFF0F & sTemp;
								sTemp = sTemp | 0x40;
								m_pClientList[iClientH]->m_sAppr4 = sTemp;
							}
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 1, 55, m_pMagicConfigList[sType]->m_dwDelayTime, NULL);
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						}
					}
				}
			}
		}

	MAGIC_NOEFFECT:;

		if (m_pClientList[iClientH] == NULL) return;
		if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			iManaCost = 0;
		}
		if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
			m_pClientList[iClientH]->m_iMP -= iManaCost;
			if (m_pClientList[iClientH]->m_iMP < 0)
				m_pClientList[iClientH]->m_iMP = 0;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
		}

		SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType + 100), m_pClientList[iClientH]->m_sType);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: PlayerMagicHandler");
	}
#endif
}

void CMapServer::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
	short  sOwnerH;
	char   cOwnerType;
	register int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
	DWORD  dwTime = timeGetTime();

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pNpcList[iNpcH] == NULL) return;
		if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
			(dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;

		if ((sType < 0) || (sType >= 100))     return;
		if (m_pMagicConfigList[sType] == NULL) return;

		if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return;

		iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
		iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);
		iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

		if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) {
			m_pNpcList[iNpcH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = 0;
			SetInvisibilityFlag(iNpcH, DEF_OWNERTYPE_NPC, FALSE);
		}

		if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
			switch (m_pMagicConfigList[sType]->m_sType) {
				// Added Ihini
				case DEF_MAGICTYPE_INHIBITION:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {

						if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto NMH_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) goto NMH_NOEFFECT;
						m_pClientList[sOwnerH]->m_bInhibition = TRUE;
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INHIBITION, NULL, NULL, NULL);
					}
					break;

					// Added Cancel
				case DEF_MAGICTYPE_CANCELLATION:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) goto NMH_NOEFFECT;

						// Removes Invisibility Flag 0x0010
						if (m_pClientList[sOwnerH]->m_iStatus & 0x10) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
						}

						// Removes Illusion Flag 0x01000000
						if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
							goto NMH_NOEFFECT;
						}
						else {
							if (m_pClientList[sOwnerH]->m_iStatus & 0x01000000) {
								bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
								SetIllusionFlag(sOwnerH, cOwnerType, FALSE);
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
							}
						}

						// Removes Defense Shield Flag 0x02000000
						// Removes Great Defense Shield Flag 0x02000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x02000000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetDefenseShieldFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 3, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						if (m_pClientList[sOwnerH]->m_iStatus & 0x40) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);
							SetIceFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = NULL;
						}

						// Removes Absolute Magic Protection Flag 0x04000000	
						// Removes Protection From Magic Flag 0x04000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x04000000) {
							// No Effect en cvc to friends
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetMagicProtectionFlag(sOwnerH, cOwnerType, FALSE);
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 2, NULL, NULL);
							else SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 5, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						// Removes Protection From Arrow Flag 0x08000000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x08000000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
							SetProtectionFromArrowFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, 1, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
						}

						// Removes Illusion Movement Flag 0x00200000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x00200000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
							SetIllusionMovementFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 4, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
						}

						// Removes Berserk Flag 0x0020
						if (m_pClientList[sOwnerH]->m_iStatus & 0x20) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
							SetBerserkFlag(sOwnerH, cOwnerType, FALSE);
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_BERSERK, NULL, NULL, NULL);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = NULL;
						}

						// Removes Fury Of War Flag 0x100000
						if (m_pClientList[sOwnerH]->m_iStatus & 0x100000) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
							SetFuryWarFlag(sOwnerH, cOwnerType, FALSE);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = NULL;
						}

						//Remove Inhibition
						if (m_pClientList[sOwnerH]->m_bInhibition == TRUE) {
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INHIBITION] = NULL;
							m_pClientList[sOwnerH]->m_bInhibition = FALSE;
						}
					}
					break;

				case DEF_MAGICTYPE_INVISIBILITY:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto NMH_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
									RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) goto NMH_NOEFFECT;
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
									RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
									break;
							}

							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;

						case 2:
							for (ix = dX - 8; ix <= dX + 8; ix++) {
								for (iy = dY - 8; iy <= dY + 8; iy++) {
									m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (sOwnerH != NULL) {
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;
										}
									}
								}
							}
							break;
					}
					break;

				case DEF_MAGICTYPE_HOLDOBJECT:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) goto NMH_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4 ���� ���� 6�̻��� ��ġ�� �̻��� ���� �����Ϳ��Դ� ���� ���� ������ �ʴ´�.
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) goto NMH_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;
						}

						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					break;


				case DEF_MAGICTYPE_DAMAGE_LINEAR:
					sX = m_pNpcList[iNpcH]->m_sX;
					sY = m_pNpcList[iNpcH]->m_sY;

					for (i = 2; i < 6; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						// tx-1, ty
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						// tx+1, ty
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						// tx, ty-1
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}

						// tx, ty+1
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
								if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
						}
						if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
							}
						}
					}

					// dX, dY
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_SPOT:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}
					break;

				case DEF_MAGICTYPE_HPUP_SPOT:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					break;


				case DEF_MAGICTYPE_DAMAGE_AREA:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
							}
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
								if (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE) {
									if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}

							}
						}
					}
					break;

				case DEF_MAGICTYPE_SPDOWN_AREA:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
					}
					break;

				case DEF_MAGICTYPE_SPUP_AREA:
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++) {
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
					}
					break;
			}
		}

	NMH_NOEFFECT:;

		m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1�� Mana Cost
		if (m_pNpcList[iNpcH]->m_iMana < 0)
			m_pNpcList[iNpcH]->m_iMana = 0;

		SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType + 100), m_pNpcList[iNpcH]->m_sType);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcMagicHandler");
	}
#endif
}

void CMapServer::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
	char  cTempMapName[21];
	char  cDestMapName[11], cDir, cMapIndex;
	short sX, sY, aX, aY;
	int   i, iDestX, iDestY, iExH, iMapSide, iTmpMapSide, iGate = 0;
	BOOL    bRet, bIsLockedMapNotify;
	BOOL ActivarTP;
	//Auto Save ZeroEoyPnk
	DWORD dwTime;
	dwTime = timeGetTime();

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

		if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			&& ((pData[0] == '1') || (pData[0] == '3')) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

		if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
			&& ((pData[0] == '1') || (pData[0] == '3')) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

		if ((m_pClientList[iClientH]->m_cSide == DEF_NETURAL) && (m_pClientList[iClientH]->Assasain == TRUE)
			&& ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
				|| (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0))
			&& ((pData[0] == '1') || (pData[0] == '3')) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;

		bIsLockedMapNotify = FALSE;
		ActivarTP = TRUE;

		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		shinning_clear(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

		sX = m_pClientList[iClientH]->m_sX;
		sY = m_pClientList[iClientH]->m_sY;

		ZeroMemory(cDestMapName, sizeof(cDestMapName));
		bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

		//Dungeon tp en sade
		if (m_bIsCrusadeMode) {
			if ((strcmp(cDestMapName, "aresden") == 0) && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0))
				ActivarTP = FALSE;
			else if ((strcmp(cDestMapName, "elvine") == 0) && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0))
				ActivarTP = FALSE;
		}

		if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
			iMapSide = iGetMapLocationSide(cDestMapName);
			if (iMapSide >= 3) iMapSide -= 2;

			if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {}
			else {
				iDestX = iDestY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cDestMapName, sizeof(cDestMapName));
				strcpy_secure(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
		}

		if ((bRet == TRUE) && (cMapName == NULL) && (ActivarTP)) {
			for (i = 0; i < DEF_MAXMAPS; i++) {
				if (m_pMapList[i] != NULL) {
					if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT, 8) == 0) {
						if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
							if (m_pClientList[iClientH]->m_cSide == 1) { // Aresden Point
								switch (iDice(1, 2)) {
									case 1: dX = Random(158, 181); dY = Random(158, 176); break;
									case 2: dX = Random(170, 184); dY = Random(148, 158); break;
								}
							}
							else if (m_pClientList[iClientH]->m_cSide == 2) { // Elvine Point
								switch (iDice(1, 2)) {
									case 1: dX = Random(69, 85); dY = Random(105, 116); break;
									case 2: dX = Random(74, 100); dY = Random(92, 105); break;
								}
							}
							m_pClientList[iClientH]->m_sX = dX;
							m_pClientList[iClientH]->m_sY = dY;
							m_pClientList[iClientH]->m_cDir = cDir;
							m_pClientList[iClientH]->m_cMapIndex = i;
							ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
							goto RTH_NEXTSTEP;
						}
					}
					else if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) == 0) {
						if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
							switch (iDice(1, 5)) {
								case 1: dX = Random(39, 62); dY = Random(36, 50); break;
								case 2: dX = Random(46, 57); dY = Random(34, 36); break;
								case 3: dX = Random(62, 66); dY = Random(39, 47); break;
								case 4: dX = Random(35, 39); dY = Random(40, 47); break;
								case 5: dX = Random(45, 58); dY = Random(50, 53); break;
							}
							m_pClientList[iClientH]->m_sX = dX;
							m_pClientList[iClientH]->m_sY = dY;
							m_pClientList[iClientH]->m_cDir = cDir;
							m_pClientList[iClientH]->m_cMapIndex = i;
							ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
							goto RTH_NEXTSTEP;
						}
					}
					else if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
						m_pClientList[iClientH]->m_sX = iDestX;
						m_pClientList[iClientH]->m_sY = iDestY;
						m_pClientList[iClientH]->m_cDir = cDir;
						m_pClientList[iClientH]->m_cMapIndex = i;
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
						goto RTH_NEXTSTEP;
					}
				}
			}

			m_pClientList[iClientH]->m_sX = iDestX;
			m_pClientList[iClientH]->m_sY = iDestY;
			m_pClientList[iClientH]->m_cDir = cDir;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy_secure(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // �� �̸��� �ٲ۴�.

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
			SetSlateFlag(iClientH, CLIENT_NOTIFY_SLATECLEAR, FALSE);

			if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight)
				bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);

			bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);

			m_pClientList[iClientH]->m_bIsOnServerChange = m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;
		}
		else {
			switch (pData[0]) {
				case '0': // Forced Recall.         
				case '1': // Recall
					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && m_pClientList[iClientH]->Heredado == TRUE)
						RestoreItems(iClientH);

					ZeroMemory(cTempMapName, sizeof(cTempMapName));
					if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
						if (m_pClientList[iClientH]->Assasain) strcpy_secure(cTempMapName, "Whouse");
						else strcpy_secure(cTempMapName, "default");
					}
					else {
						if (m_pClientList[iClientH]->m_iLevel > 80) {
							if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) strcpy_secure(cTempMapName, "aresden");
							else strcpy_secure(cTempMapName, "elvine");
						}
						else {
							if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) strcpy_secure(cTempMapName, "aresden");
							else strcpy_secure(cTempMapName, "elvine");
						}
					}

					if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
						bIsLockedMapNotify = TRUE;
						ZeroMemory(cTempMapName, sizeof(cTempMapName));
						strcpy_secure(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
					}

					for (i = 0; i < DEF_MAXMAPS; i++) {
						if (m_pMapList[i] != NULL && memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
							if (m_pClientList[iClientH]->RecallCoordX != -1) {
								m_pClientList[iClientH]->m_sX = m_pClientList[iClientH]->RecallCoordX;
								m_pClientList[iClientH]->m_sY = m_pClientList[iClientH]->RecallCoordY;
								m_pClientList[iClientH]->RecallCoordX = m_pClientList[iClientH]->RecallCoordY = -1;
							}
							else {
								GetMapInitialPoint(i, &aX, &aY, m_pClientList[iClientH]->m_cLocation);
								m_pClientList[iClientH]->m_sX = aX;
								m_pClientList[iClientH]->m_sY = aY;
							}
							m_pClientList[iClientH]->m_cMapIndex = i;
							ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
							goto RTH_NEXTSTEP;
						}
					}

					m_pClientList[iClientH]->m_sX = m_pClientList[iClientH]->m_sY = -1;

					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy_secure(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
					SetSlateFlag(iClientH, CLIENT_NOTIFY_SLATECLEAR, FALSE);

					if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight)
						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);

					bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);

					m_pClientList[iClientH]->m_bIsOnServerChange = m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
					return;
					break;

				case '2': // Crusade
					if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0) &&
						(memcmp(cMapName, "resurr", 6) != 0)) {
						dX = dY = -1;
						bIsLockedMapNotify = TRUE;
						ZeroMemory(cTempMapName, sizeof(cTempMapName));
						strcpy_secure(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
					}
					else {
						ZeroMemory(cTempMapName, sizeof(cTempMapName));
						strcpy_secure(cTempMapName, cMapName);
					}

					cMapIndex = iGetMapIndex(cTempMapName);
					if (cMapIndex == -1) {
						m_pClientList[iClientH]->m_sX = dX;
						m_pClientList[iClientH]->m_sY = dY;

						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);

						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
							m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE], NULL, NULL);
						SetSlateFlag(iClientH, CLIENT_NOTIFY_SLATECLEAR, FALSE);

						if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight)
							bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);

						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);

						m_pClientList[iClientH]->m_bIsOnServerChange = m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
						return;
					}

					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && strcmp(m_pMapList[cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) != 0
						&& strcmp(cDestMapName, DEF_EVENTMAP_PVPEVENT) != 0 && m_pClientList[iClientH]->Heredado == TRUE) RestoreItems(iClientH);

					m_pClientList[iClientH]->m_sX = dX;
					m_pClientList[iClientH]->m_sY = dY;
					m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy_secure(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);

					if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && FinalFight) InitItemsClient(iClientH);
					break;

				case '3':
					if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)
						&& (memcmp(cMapName, "resurr", 6) != 0)) {
						dX = dY = -1;
						bIsLockedMapNotify = TRUE;
						ZeroMemory(cTempMapName, sizeof(cTempMapName));
						strcpy_secure(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
					}
					else {
						ZeroMemory(cTempMapName, sizeof(cTempMapName));
						strcpy_secure(cTempMapName, cMapName);
					}

					cMapIndex = iGetMapIndex(cTempMapName);
					if (cMapIndex == -1) {
						m_pClientList[iClientH]->m_sX = dX;
						m_pClientList[iClientH]->m_sY = dY;

						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);

						if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight)
							bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);

						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);

						m_pClientList[iClientH]->m_bIsOnServerChange = m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
						return;
					}
					m_pClientList[iClientH]->m_sX = dX;
					m_pClientList[iClientH]->m_sY = dY;
					m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy_secure(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);
					break;
			}
		}

	RTH_NEXTSTEP:;
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		iSetSide(iClientH);

		if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		SendRestPlayerData(iClientH);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

		if (m_pClientList[iClientH] == NULL) return; //Added new check for crash in 27-05-13 -> ZeroEoyPnk

		if ((DEF_ARESDEN == m_pClientList[iClientH]->m_cSide) && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			SetForceRecallTime(iClientH);
		}
		else if ((DEF_ELVINE == m_pClientList[iClientH]->m_cSide) && (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			SetForceRecallTime(iClientH);
		}
		else if ((DEF_NETURAL == m_pClientList[iClientH]->m_cSide) && (!m_pClientList[iClientH]->Assasain) &&
			(m_bIsCrusadeMode == TRUE) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0)
				|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}

		iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
		if (iMapSide >= 3) iTmpMapSide = iMapSide - 2;
		else iTmpMapSide = iMapSide;

		m_pClientList[iClientH]->m_bIsInBuilding = FALSE;
		if ((m_pClientList[iClientH]->m_cSide != iTmpMapSide) && (iMapSide != 0)) {
			if ((iMapSide <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) && (m_pClientList[iClientH]->m_cSide != DEF_NETURAL)) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInBuilding = TRUE;
			}
		}
		else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
			&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
			else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20 * 5) m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
		}
		else {
			m_pClientList[iClientH]->m_bIsWarLocation = FALSE;
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		}

		if (m_pClientList[iClientH] != NULL) {
			if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 999;
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_RECALLTIMELEFT, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
			wsprintf(G_cTxt, "Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall / 20);
			PutLogList(G_cTxt);
		}

		//if ((HellOfDeath || PriceHODEvent || SummonLaunched)) {
		if ((HellOfDeath || SummonLaunched)) {
			if ((strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
				(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
				(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0)) { // ||
				//(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0)) {
				m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
			}
		}

		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0) {
			m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
		}

		_SendQuestContents(iClientH);
		_CheckQuestEnvironment(iClientH);

		if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
		if (m_bIsCrusadeMode == TRUE) {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
				m_pClientList[iClientH]->m_iCrusadeDuty = m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			}
			else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
				m_pClientList[iClientH]->m_iCrusadeDuty = m_pClientList[iClientH]->m_iConstructionPoint = m_pClientList[iClientH]->m_iWarContribution = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
		}
		else {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)
				m_pClientList[iClientH]->m_iCrusadeDuty = m_pClientList[iClientH]->m_iConstructionPoint = 0;
			else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
				m_pClientList[iClientH]->m_iWarContribution = m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			}
		}

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsGateAvailable == TRUE) {
			for (iGate = 0; iGate < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalDynamicGate; iGate++) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_APOCGATEOPEN, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateX1,
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sDynamicGateY1, NULL, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
			}
		}
		RefreshParty(iClientH, 3);

		if (m_pClientList[iClientH]->b_AutoSaveTime == TRUE) {
			if ((memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight) {
				bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
				m_pClientList[iClientH]->m_dwAutoSaveTime = dwTime;
				m_pClientList[iClientH]->b_AutoSaveTime = FALSE;
			}
		}

		if (m_pClientList[iClientH] != NULL) {
			if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0) {
				RequestDismissPartyHandler(iClientH);
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = 3;
				SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 3, iClientH, NULL);
				m_pClientList[iClientH]->ActiveAvA = dwTime;
			}
			if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) RequestDismissPartyHandler(iClientH);

			if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) {
				RequestDismissPartyHandler(iClientH);
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = 3;
				SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 3, iClientH, NULL);

			}


			if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) {
				RequestDismissPartyHandler(iClientH);
				DkMapUnEquipItems(iClientH);
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = 3;
				SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, 3, iClientH, NULL);

			}
		}

		DWORD dwClientTime = GetTickCount();
		if (m_pClientList[iClientH] != NULL) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
		}
		/*
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TPFAST, NULL, NULL, NULL, NULL);*/
		m_pClientList[iClientH]->m_sNoCheckSpeed = true;
		SendCommand(iClientH, "/freecmd");

		

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestTeleportHandler");
	}
#endif
}

void CMapServer::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
				if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
					(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
					(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {

					m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReleaseFollowMode");
	}
#endif
}

BOOL CMapServer::_bDecodeMagicConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iMagicConfigListIndex = 0;
	class CStrTok * pStrTok;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading MAGIC configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}

								m_pMagicConfigList[atoi(token)] = new class CMagic;
								iMagicConfigListIndex = atoi(token);

								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
								memcpy_secure(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								// m_sValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								// m_sValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// m_sValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// m_sValue4
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								// m_sValue5
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								// m_sValue6
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
								cReadModeB = 12;
								break;

							case 12:
								// m_sValue7
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
								cReadModeB = 13;
								break;

							case 13:
								// m_sValue8
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								// m_sValue9
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
								cReadModeB = 15;
								break;

							case 15:
								// m_sValue10
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
								cReadModeB = 16;
								break;

							case 16:
								// m_sValue11
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
								cReadModeB = 17;
								break;

							case 17:
								// m_sValue12
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
								cReadModeB = 18;
								break;

							case 18:
								// m_sIntLimit
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
								cReadModeB = 19;
								break;

							case 19:
								// m_iGoldCost
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);

								cReadModeB = 20;
								break;

							case 20:
								// m_cCategory
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
								cReadModeB = 21;
								break;

							case 21:
								// m_iAttribute
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "magic", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
		PutLogList(cTxt);

		return TRUE;
	}
}

BOOL CMapServer::_bDecodeSkillConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSkillConfigListIndex = 0;
	class CStrTok * pStrTok;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading SKILL configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}

								if (m_pSkillConfigList[atoi(token)] != NULL) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate skill number.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[atoi(token)] = new class CSkill;
								iSkillConfigListIndex = atoi(token);

								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
								memcpy_secure(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								// m_sValue1
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								// m_sValue2
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								// m_sValue3
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								// m_sValue4
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// m_sValue5
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// m_sValue6
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "skill", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
		PutLogList(cTxt);

		return TRUE;
	}
}

void CMapServer::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase)
{
	char  * cp, cMagicName[31], cData[100];
	DWORD * dwp, dwGoldCount;
	WORD  * wp;
	int   * ip, iReqInt, iCost, iRet;
	BOOL bMagic = TRUE;
	char Temp;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		ZeroMemory(cData, sizeof(cData));

		ZeroMemory(cMagicName, sizeof(cMagicName));
		memcpy_secure(cMagicName, pName, 30);

		iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
		if (iRet != -1) {
			if (bIsPurchase == TRUE) {
				if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE; // �Ϲ������� ������ ���� �����̶���(������ ����) ���� �� ����.
				dwGoldCount = dwGetItemCount(iClientH, "Gold");
				if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE; // ���� �����ص� ���� �� ����.
			}

			if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;
			if ((iReqInt <= (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt)) && (bMagic == TRUE)) {

				if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
				else {
					if (!m_pClientList[iClientH]->Achivements[16].Complete)
						CheckCompleteAchivement(iClientH, 16, TRUE);
				}
				iCalcTotalWeight(iClientH);
				m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;

				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_MAGICSTUDYSUCCESS;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = iRet;
				cp++;

				memcpy_secure(cp, cMagicName, 30);
				cp += 30;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
				Temp = 0;
				for (short i = 0; i < DEF_MAXMAGICTYPE; i++) {
					if (m_pClientList[iClientH]->m_cMagicMastery[i] != NULL)
						Temp++;
				}
			}
			else {
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_MAGICSTUDYFAIL;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;

				*cp = iRet;
				cp++;

				memcpy_secure(cp, cMagicName, 30);
				cp += 30;

				ip = (int *)cp;
				*ip = iCost;
				cp += 4;

				ip = (int *)cp;
				*ip = iReqInt;
				cp += 4;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestStudyMagicHandler");
	}
#endif
}

int CMapServer::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		char cTmpName[31];

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pMagicName);

		for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
			if (m_pMagicConfigList[i] != NULL) {
				if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
					*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
					*pCost = (int)m_pMagicConfigList[i]->m_iGoldCost;

					return i;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iGetMagicNumber");
	}
#endif
	return -1;
}

void CMapServer::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
	char  * cp, cData[100];
	DWORD * dwp;
	WORD  * wp;
	int   iRet;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((iSkillNum < 0) || (iSkillNum > 100)) return;
		if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

		if (bSuccess == TRUE) {
			if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;

			m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
			bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_SKILLTRAINSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = iSkillNum;
			cp++;

			*cp = iSkillLevel;
			cp++;

			if (m_pSkillConfigList[iSkillNum]->m_cName != NULL)
				_bItemLog(DEF_ITEMLOG_SKILLLEARN, iClientH, m_pSkillConfigList[iSkillNum]->m_cName, NULL);

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: TrainSkillResponse");
	}
#endif
}

BOOL CMapServer::__bReadMapInfo(int iMapIndex)
{
	char * pContents, *token, *pTile, cTxt[250], cFn[255];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iTeleportLocIndex = 0;
	int  iWayPointCfgIndex = 0;
	int  iTotalNpcSetting = 0;
	int  iMGARCfgIndex = 0;
	int  iSMGRCfgIndex = 0;
	int  iNMRCfgIndex = 0;
	int  iFishPointIndex = 0;
	int  iMineralPointIndex = 0;
	int  iStrategicPointIndex = 0;
	int  iIndex = 0;
	int  iNumMob = 0;

	int  iNamingValue;
	class CStrTok * pStrTok;
	HANDLE hFile;
	DWORD  dwFileSize, dwReadSize;
	FILE * pFile;

	char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
	short sIPindex, dX, dY;
	SYSTEMTIME SysTime;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fight", 5) == 0)
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0)
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;

	GetLocalTime(&SysTime);
	if (SysTime.wYear == 2007 && SysTime.wMonth == 12 && SysTime.wDay == 25) {
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = TRUE;
	}

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize + 1];
	ZeroMemory(pContents, dwFileSize + 1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		wsprintf(cTxt, "Cannot open file : %s.txt", m_pMapList[iMapIndex]->m_cName);
		ErrorList(cTxt);
		return FALSE;
	}
	else {
		wsprintf(cTxt, "Reading Map info file : %s.txt", m_pMapList[iMapIndex]->m_cName);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName,
								sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
							strcpy_secure(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
							iTeleportLocIndex++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 2:
					switch (cReadModeB) {
						case 1:
							// waypoint ��ȣ   
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iWayPointCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
								ErrorList("CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 3:
					// Npc�� Ư����ġ�� ��ġ��Ų��.
					switch (cReadModeB) {
						case 1:
							// NPC�� �̸�. 
							ZeroMemory(cNpcName, sizeof(cNpcName));
							strcpy_secure(cNpcName, token);
							cReadModeB = 2;
							break;
						case 2:
							// NpcMoveType
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cNpcMoveType = atoi(token);
							cReadModeB = 3;
							break;
						default:
							// WayPoint0~waypoint9
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cNpcWaypointIndex[cReadModeB - 3] = atoi(token);
							cReadModeB++;
							break;
						case 13:
							// cNamePrefix
							cNamePrefix = token[0];

							iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
							if (iNamingValue == -1) {}
							else {
								// NPC�� �����Ѵ�.
								ZeroMemory(cName, sizeof(cName));
								wsprintf(cName, "XX%d", iNamingValue);
								cName[0] = cNamePrefix;
								cName[1] = iMapIndex + 65;

								if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
									m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
								}
							}
							cReadModeA = 0;
							cReadModeB = 0;
							iTotalNpcSetting++;
							break;
					}
					break;

				case 4:
					switch (cReadModeB) {
						case 1:
							// Random-Mob-Generator ���� ���� 
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL)atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							// Mob- Level
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 5:
					// Maximum object
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 6:
					switch (cReadModeB) {
						case 1:
							// Rect ��ȣ 
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iMGARCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
								// �̹� �Ҵ��Ǿ��ִ� Waypoint ��ȣ�̴�.
								ErrorList("CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							cReadModeB = 2;
							break;

						case 2:
							// left
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							// top
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// right
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// bottom
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 7:
					switch (cReadModeB) {
						case 1:
							// Rect ��ȣ m_stSpotMobGenerator[]
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iSMGRCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
								// �̹� �Ҵ��Ǿ��ִ� �� ���ʷ����� ��ȣ�̴�.
								ErrorList("CRITICAL ERROR! Map Info file error - ");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);

							if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
								cReadModeB = 3;
							else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
								cReadModeB = 9;  // RECT�� �ƴ϶� Waypoint������ �о��� �Ѵ�.
							break;

						case 3:
							// left
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							// top
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							// right
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
							cReadModeB = 6;
							break;

						case 6:
							// bottom
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							// spot mob type
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
							cReadModeB = 8;
							break;

						case 8:
							// Max Mobs
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
							cReadModeA = 0;
							cReadModeB = 0;
							break;

						default:
							// WayPoint0~waypoint9
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
							cReadModeB++;
							break;

						case 19:
							// spot mob type
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
							cReadModeB = 20;
							break;

						case 20:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
							m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 8:
					ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
					memcpy_secure(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 9:
					switch (cReadModeB) {
						case 1:
							// Initial-Point Index
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							sIPindex = atoi(token);
							if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
								ErrorList("CRITICAL ERROR! Duplicate Initial Point Index!");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							// Initial-Point X
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							// Initial-Point Y
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 10:
					// RECT
					switch (cReadModeB) {
						case 1:
							// 
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iNMRCfgIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
								// �̹� �Ҵ��Ǿ��ִ� No-Magic-Rect ��ȣ�̴�.
								ErrorList("CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 11:
					m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
					if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
						m_pMapList[iMapIndex]->m_bIsFixedSnowMode = FALSE;
					cReadModeA = 0;
					break;

				case 12:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iFishPointIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalFishPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

					cReadModeA = 0;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cType = atoi(token);

					cReadModeA = 0;
					break;

				case 15:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

					cReadModeA = 0;
					break;

				case 16:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 17:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iMineralPointIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 18:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

					cReadModeA = 0;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

					cReadModeA = 0;
					break;

				case 20:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iStrategicPointIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 21:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 22:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
								wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
								PutLogList(G_cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);

							cReadModeB = 5;
							break;

						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);

							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 23:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
								wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
								PutLogList(G_cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
							cReadModeB = 5;
							break;


						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);

							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);

							cReadModeB = 7;
							break;

						case 7:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);

							cReadModeB = 8;
							break;

						case 8:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);

							cReadModeB = 9;
							break;

						case 9:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);

							cReadModeB = 10;
							break;

						case 10:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);

							cReadModeB = 11;
							break;

						case 11:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);

							cReadModeB = 12;
							break;

						case 12:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);

							cReadModeB = 13;
							break;

						case 13:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);

							cReadModeB = 14;
							break;

						case 14:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);

							cReadModeB = 15;
							break;

						case 15:
							ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
							strcpy_secure(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);

							m_pMapList[iMapIndex]->m_iTotalStrikePoints++;

							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 24: // item event
					switch (cReadModeB) {
						case 1: //  index
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex = atoi(token);

							if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
								// �̹� �Ҵ��Ǿ��ִ� Item-Event ��ȣ�̴�.
								wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
								PutLogList(G_cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}

							m_pMapList[iMapIndex]->m_iTotalItemEvents++;
							cReadModeB = 2;
							break;

						case 2: // item_name
							strcpy_secure(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
							cReadModeB = 3;
							break;

						case 3: // amount
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

							cReadModeB = 4;
							break;

						case 4: // total number
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);

							cReadModeB = 5;
							break;

						case 5: // month
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);

							cReadModeB = 6;
							break;

						case 6: // day
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);

							cReadModeB = 7;
							break;

						case 7: // type
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);

							m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob = 0;

							cReadModeB = 8;
							break;

						case 8: // monster list
							if (strcmp(token, "EOL") == 0) {
								cReadModeA = 0;
								cReadModeB = 0;
							}
							else {
								iNumMob = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob;

								if (iNumMob >= 5) {
									cReadModeA = 0;
									cReadModeB = 0;
									PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
									break;
								}

								m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob] = new char[21];

								ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob],
									sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob]));

								strcpy_secure(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob], token);

								m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob++;

								cReadModeB = 8;
							}
							break;
					}
					break;

				case 25:
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
							cReadModeB = 0;
							break;
					}
					break;

				case 26: //ApocalypseMobGenType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 27: // ApocalypseBossMob
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
							cReadModeB = 2;
							break;
						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.left = atoi(token);
							cReadModeB = 3;
							break;
						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.top = atoi(token);
							cReadModeB = 4;
							break;
						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.right = atoi(token);
							cReadModeB = 5;
							break;
						case 5:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_rcApocalypseBossMobRect.bottom = atoi(token);
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 28: //DynamicGateType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 29: //DynamicGateCoord
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateX1 = atoi(token);
							cReadModeB = 2;
							break;

						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateY1 = atoi(token);
							cReadModeB = 3;
							break;

						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateX2 = atoi(token);
							cReadModeB = 4;
							break;

						case 4:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateY2 = atoi(token);
							cReadModeB = 5;
							break;

						case 5:
							memcpy_secure(m_pMapList[iMapIndex]->m_cDynamicGateDestMap, token, strlen(token));
							cReadModeB = 6;
							break;

						case 6:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateTgtX = atoi(token);
							cReadModeB = 7;
							break;

						case 7:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateCoord -  Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_sDynamicGateTgtY = atoi(token);
							m_pMapList[iMapIndex]->m_iTotalDynamicGate++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 30: // RecallImpossible
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 31: // ApocalypseMap
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsApocalypseMap = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 32: // CitizenLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsCitizenLimit = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				case 33: // HeldenianMap
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				case 34: // HeldenianTower
					switch (cReadModeB) {
						case 1: // NpcID
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
							cReadModeB = 2;
							break;
						case 2: // side 
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
							cReadModeB = 3;
							break;
						case 3: // sX
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
							cReadModeB = 4;
							break;
						case 4: // sY
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							iIndex++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
				case 35: // HeldenianModeMap
					if (_bGetIsStringIsNumber(token) == FALSE) {
						ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				case 36: // HeldenianWinningZone
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							dX = atoi(token);
							cReadModeB = 2;
							break;
						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							dY = atoi(token);
							pTile = 0;
							pTile = (char *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
							if (pTile == 0) {
								wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
								PutLogList(cTxt);
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							//pTile->m_iAttribute = 1;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				case 37: // HeldenianGateDoor // 37 
					switch (cReadModeB) {
						case 1:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
							cReadModeB = 2;
							break;
						case 2:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
							cReadModeB = 3;
							break;
						case 3:
							if (_bGetIsStringIsNumber(token) == FALSE) {
								ErrorList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
								delete pContents;
								delete pStrTok;
								return FALSE;
							}
							m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
							iIndex++;
							cReadModeA = 0;
							cReadModeB = 0;
							break;
					}
					break;

				default:
					break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}

			if (memcmp(token, "maximum-object", 14) == 0)
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}

			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}
			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}

RMI_SKIPDECODING:;

	delete pStrTok;
	delete[]pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		ErrorList("CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	m_pMapList[iMapIndex]->_SetupNoAttackArea();
	return TRUE;

}

void CMapServer::Quit()
{
	int i;

	G_bIsThread = FALSE;
	Sleep(300);

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			bCheckClient[i] = FALSE;
			delete m_pClientList[i];
		}
	}

	for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
		if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];
	}
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

	if (m_pGold != NULL) delete m_pGold;

}

int CMapServer::iGetLevelExp(int iLevel)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iRet;

		if (iLevel == 0) return 0;

		iRet = iGetLevelExp(iLevel - 1) + iLevel * (50 + (iLevel * (iLevel / 17) * (iLevel / 17)));
		return iRet;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetLevelExp");
	}
#endif
	return 0;
}

int CMapServer::_iCalcSkillSSNpoint(int iLevel)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet;

		if (iLevel < 1) return 1;

		if (iLevel <= 50) iRet = iLevel;
		else if (iLevel > 50) iRet = (iLevel * iLevel) / 10;

		return iRet;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iCalcSkillSSNpoint");
	}
#endif
	return 0;
}

void CMapServer::rank_operation(int iClientH)
{
	return;
	auto player = m_pClientList[iClientH];
	if (!player) return;

	if ((player->m_sRankLevel >= 20) && ((memcmp(m_pMapList[player->m_cMapIndex]->m_cName, "areuni", 6) == 0) ||
		(memcmp(m_pMapList[player->m_cMapIndex]->m_cName, "VipMap1", 7) == 0))) return;

	player->m_iRankExp++;
	
	if (player->m_sRankLevel != 30)//20
	{
		player->m_iMaxRankExp = c_rank->m_iMaxrankexp[player->m_sRankLevel];
		if (player->m_iRankExp >= player->m_iMaxRankExp)
		{
			player->m_iRankExp = 0;
			player->m_sRankLevel++;
			player->m_iRankPoints++;
			notify_rankup(iClientH);
			send_objects_data(); 
		}
	}

	notify_rankexp(iClientH);
}

void CMapServer::notify_rankup(int iClientH)
{
	return;
	auto player = m_pClientList[iClientH];
	if (!player) return;

	char data[500];
	char* cp = data;

	Push(cp, (u32)NOT_RANKLEVELUP);
	Push(cp, (u16)0);

	Push(cp, player->m_sRankLevel);
	Push(cp, player->m_iRankPoints);

	player->m_pXSock->iSendMsg(data, sizeof(data));
}

void CMapServer::notify_rankexp(int iClientH)
{
	return;
	auto player = m_pClientList[iClientH];
	if (!player) return;

	char data[500];
	char* cp = data;

	Push(cp, (u32)NOT_RANKEXP);
	Push(cp, (u16)0);
	
	Push(cp, player->m_iRankExp);
	Push(cp, player->m_iMaxRankExp);
	player->m_pXSock->iSendMsg(data, sizeof(data));
}

BOOL CMapServer::bCheckLevelUp(int iClientH) // Sobrepaso de lvl fix.
{
	BOOL bStr, bVit, bDex, bInt, bMag, bChr;
	char cLoopCnt;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return FALSE;

		if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL) {
			if (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[DEF_PLAYERMAXLEVEL + 1]) {
				m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[DEF_PLAYERMAXLEVEL];
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
				
				//rank system hbarg
				rank_operation(iClientH);

				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft > DEF_MAXGIZONPOINT) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = DEF_MAXGIZONPOINT; // adamas
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
			}
			return FALSE;
		}

		if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL - 1) && (m_pClientList[iClientH]->m_bIsHunter == TRUE))
			SetNoHunterMode(iClientH, TRUE);

		if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;

		bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
		cLoopCnt = 0;
		while (m_pClientList[iClientH]->m_iExp > m_pClientList[iClientH]->m_iNextLevelExp && m_pClientList[iClientH]->m_iLevel < DEF_PLAYERMAXLEVEL) {
			if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
				m_pClientList[iClientH]->m_iLevel++;
				m_pClientList[iClientH]->m_iLU_Pool += 3; // v2.23
				if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
				if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
				if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
				if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
				if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
				if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

				//ZeroEoyPnk - Al subir nivel, vida, mana, y sp maximo
				if (m_pClientList[iClientH]->m_iHP != 0)
				{
					m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
					m_pClientList[iClientH]->m_iMP = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2);
					m_pClientList[iClientH]->m_iSP = (2 * (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr)) + (2 * m_pClientList[iClientH]->m_iLevel);
				}

				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LUPOOL, NULL, NULL, NULL, NULL);

				//ZeroEoyPnk - Lo mismo que dije antes, pero notifico
				if (m_pClientList[iClientH]->m_iHP != 0)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
				}
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);

				m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

				CalcTotalItemEffect(iClientH, -1, FALSE);

				//Skills - ZeroEoyPnk
				//Skills por level - ZeroEoyPnk
				m_pClientList[iClientH]->m_cSkillMastery[3] = (char)(abs(m_pClientList[iClientH]->m_iLevel / 1.8));
				if (m_pClientList[iClientH]->m_cSkillMastery[3] > 100)
					m_pClientList[iClientH]->m_cSkillMastery[3] = 100;

				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, 3, m_pClientList[iClientH]->m_cSkillMastery[3], 1, NULL);

				if (m_pClientList[iClientH]->m_cSkillMastery[19] < 50) {
					m_pClientList[iClientH]->m_cSkillMastery[19] = (char)(abs(m_pClientList[iClientH]->m_iLevel / 1.8));
					if (m_pClientList[iClientH]->m_cSkillMastery[19] > 50)
						m_pClientList[iClientH]->m_cSkillMastery[19] = 50;
				}

				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, 19, m_pClientList[iClientH]->m_cSkillMastery[19], 1, NULL);
				//sacado por crash
				/*if (m_pClientList[iClientH]->m_iLevel > 1 && m_pClientList[iClientH]->m_iLevel <= 100)
					GoldPorLevel(iClientH);*/

				if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL && DEF_ACTIVE_KITSTARTER)
					ObteinStarterKit(iClientH);
			}
			else return TRUE;
		}
		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckLevelUp");
		return FALSE;
	}
#endif
}

void CMapServer::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp;
	short * sp;
	short cStr, cVit, cDex, cInt, cMag, cChar;
	short TempMajestic;
	int iTotalSetting = 0;
	int iRestHP;

#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (FinalFight && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0) return;
		if (DKEvent && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_EVENTDK ) == 0 && m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
		if (m_pClientList[iClientH]->m_iLU_Pool <= 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
			PutLogList("error 0");
			return;
		}

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		cStr = *sp;
		cp += 2;

		sp = (short *)cp;
		cVit = *sp;
		cp += 2;

		sp = (short *)cp;
		cDex = *sp;
		cp += 2;

		sp = (short *)cp;
		cInt = *sp;
		cp += 2;

		sp = (short *)cp;
		cMag = *sp;
		cp += 2;

		sp = (short *)cp;
		cChar = *sp;
		cp += 2;

		sp = (short *)cp;
		TempMajestic = *sp;
		cp += 2;

		if (TempMajestic == 0) {
			if ((cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
				return;
			}

			if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0)) return;
			if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0)) return;
			if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0)) return;
			if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0)) return;
			if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0)) return;
			if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0)) return;

			iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
				m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

			/*if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool - 3 > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70)) {
				int bobdole;
				bobdole = 3;
				m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70 - iTotalSetting;

				if (m_pClientList[iClientH]->m_iLU_Pool < 3)
					m_pClientList[iClientH]->m_iLU_Pool = 3;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
				PutLogList("error 2");
				return;
			}

			if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar) > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70)) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
				return;
			}*/

			int maxstats1 = ((m_pClientList[iClientH]->m_iLevel - 1) * 3) + 70;
			maxstats1 = maxstats1 + m_pClientList[iClientH]->getRebirthStats();

			if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool - 3 > maxstats1)
			{
				int totalset = 3 + ((m_pClientList[iClientH]->m_iLevel - 1) * 3) + 70 - iTotalSetting;
				totalset = totalset + m_pClientList[iClientH]->getRebirthStats();
				m_pClientList[iClientH]->m_iLU_Pool = totalset;

				if (m_pClientList[iClientH]->m_iLU_Pool < 3)
					m_pClientList[iClientH]->m_iLU_Pool = 3;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
				return;
			}

			int maxstats2 = ((m_pClientList[iClientH]->m_iLevel - 1) * 3) + 70;
			maxstats2 = maxstats2 + m_pClientList[iClientH]->getRebirthStats();

			if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar) > maxstats2)
			{
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
				return;
			}

			m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);
		}
		m_pClientList[iClientH]->m_iStr += cStr;
		m_pClientList[iClientH]->m_iVit += cVit;
		m_pClientList[iClientH]->m_iDex += cDex;
		m_pClientList[iClientH]->m_iInt += cInt;
		m_pClientList[iClientH]->m_iMag += cMag;
		m_pClientList[iClientH]->m_iCharisma += cChar;

		if (TempMajestic > 0) {
			//Calculo los m_iLU_Pool restantes
			iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
				m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;
			if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool - 3 < ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70))
				m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70 - iTotalSetting;

			//Actualizo los majestics :P
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= TempMajestic;
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0)
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);

			if (cInt != 0) bCheckMagicInt(iClientH);

			//Actualizo el HP del cliente
			if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) {
				iRestHP = m_pClientList[iClientH]->m_iHP - iGetMaxHP(iClientH);
				m_pClientList[iClientH]->m_iHP -= iRestHP;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
			}

			// Actualizo el Mp del cliente
			if (m_pClientList[iClientH]->m_iMP > (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) +
				(2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2)) {
				m_pClientList[iClientH]->m_iMP = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) +
					(2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
			}

			//Actualizo el SP del cliente
			if (m_pClientList[iClientH]->m_iSP > (2 * m_pClientList[iClientH]->m_iStr) + (2 * m_pClientList[iClientH]->m_iLevel)) {
				m_pClientList[iClientH]->m_iSP = (2 * m_pClientList[iClientH]->m_iStr) + (2 * m_pClientList[iClientH]->m_iLevel);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}

			//Actualizo el circulo de magias...
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
		}

		AutoSkill(iClientH);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

		if (m_pClientList[iClientH]->m_iLU_Pool - 3 > 0)
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LUPOOL, NULL, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LevelUpSettingsHandler");
	}
#endif
}

void CMapServer::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char cData[100];
	int iFightzoneNum, *ip, iEnableReserveTime;
	DWORD * dwp, dwGoldCount;
	WORD  * wp, wResult;
	int     iRet, iResult = 1, iCannotReserveDay;
	SYSTEMTIME SysTime;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		GetLocalTime(&SysTime);

		iEnableReserveTime = 2 * 20 * 60 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 5 * 20;

		dwGoldCount = dwGetItemCount(iClientH, "Gold");

		ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
		iFightzoneNum = *ip;

		if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

		iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum) % 2;
		if (iEnableReserveTime <= 0) {
			wResult = DEF_MSGTYPE_REJECT;
			iResult = 0;
		}
		else if (m_iFightZoneReserve[iFightzoneNum - 1] != 0) {
			wResult = DEF_MSGTYPE_REJECT;
			iResult = -1;
		}
		else if (dwGoldCount < 1500) {
			wResult = DEF_MSGTYPE_REJECT;
			iResult = -2;
		}
		else if (iCannotReserveDay) {
			wResult = DEF_MSGTYPE_REJECT;
			iResult = -3;
		}
		else if (m_pClientList[iClientH]->m_iFightzoneNumber != 0) {
			wResult = DEF_MSGTYPE_REJECT;
			iResult = -4;
		}
		else {
			wResult = DEF_MSGTYPE_CONFIRM;

			SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
			iCalcTotalWeight(iClientH);

			m_iFightZoneReserve[iFightzoneNum - 1] = iClientH;

			m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneNum;
			m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth * 10000 + SysTime.wDay * 100 + SysTime.wHour;

			if (SysTime.wHour % 2)	m_pClientList[iClientH]->m_iReserveTime += 1;
			else m_pClientList[iClientH]->m_iReserveTime += 2;
			wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);
			CharacterLogList(G_cTxt);

			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 50;
			iResult = 1;
		}

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_FIGHTZONE_RESERVE;

		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = wResult;

		ip = (int *)(cData + DEF_INDEX2_MSGTYPE + 2);
		*ip = iResult;
		ip += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: FightzoneReserveHandler");
	}
#endif
}

BOOL CMapServer::bCheckLimitedUser(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return FALSE;

		if ((m_pClientList[iClientH]->m_cSide == DEF_NETURAL) &&
			(m_pClientList[iClientH]->m_iExp >= m_iLevelExp20)) {

			m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
			return TRUE;
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckLimitedUser");
	}
#endif
	return FALSE;
}

void CMapServer::RequestCivilRightHandler(int iClientH, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		WORD wResult;

		if (m_pClientList[iClientH]->m_cSide != DEF_NETURAL) wResult = 0;
		else wResult = 1;

		if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;

		if (wResult == 1) {
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0)
			m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
			m_pClientList[iClientH]->m_cSide = DEF_ELVINE;

		ChangeLocation(iClientH, wResult);

		RequestHuntmode(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestCivilRightHandler");
	}
#endif
}

void CMapServer::RequestRetrieveItemHandler(int iClientH, char *pData)
{
	char * cp, cMsg[100];
	register int i, j, iRet, iItemWeight;
	DWORD * dwp;
	WORD * wp;
	short * sp;
	short cBankItemIndex;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		cBankItemIndex = *sp;
		cp += 2;

		if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
			ZeroMemory(cMsg, sizeof(cMsg));

			dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = CLIENT_RESPONSE_RETRIEVEITEM;
			wp = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_REJECT;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 9);
		}
		else {
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

			if ((iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
				ZeroMemory(cMsg, sizeof(cMsg));

				dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						break;
				}
				return;
			}

			if ((m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				for (i = 0; i < DEF_MAXITEMS; i++) {
					if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) &&
						(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0)) {
						SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

						delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
						m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

						if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
							if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650)
								_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
							else _bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[i]);
						}

						for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
							if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
								m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

								m_pClientList[iClientH]->m_pItemInBankList[j + 1] = NULL;
							}
						}

						ZeroMemory(cMsg, sizeof(cMsg));

						dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
						*dwp = CLIENT_RESPONSE_RETRIEVEITEM;
						wp = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
						*wp = DEF_MSGTYPE_CONFIRM;

						cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
						sp = (short *)cp;
						*sp = cBankItemIndex;
						cp += 2;

						*cp = i;
						cp++;

						iCalcTotalWeight(iClientH);
						m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

						iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 9);

						m_pClientList[iClientH]->m_bIsBankModified = TRUE;

						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, TRUE, TRUE);
								return;
						}
						return;
					}
				}
				goto RRIH_NOQUANTITY;
			}
			else {
			RRIH_NOQUANTITY:;
				for (i = 0; i < DEF_MAXITEMS; i++) {
					if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
						m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
						m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
						m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
						m_pClientList[iClientH]->m_pItemList[i]->SetBagPosition(40, 30);

						m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

						if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
							if (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == 650)
								_bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[i], TRUE);
							else _bItemLog(DEF_ITEMLOG_RETRIEVE, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[i]);
						}

						for (j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
							if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
								m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

								m_pClientList[iClientH]->m_pItemInBankList[j + 1] = NULL;
							}
						}

						ZeroMemory(cMsg, sizeof(cMsg));

						dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
						*dwp = CLIENT_RESPONSE_RETRIEVEITEM;
						wp = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
						*wp = DEF_MSGTYPE_CONFIRM;

						cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
						sp = (short *)cp;
						*sp = cBankItemIndex;
						cp += 2;
						*cp = i;
						cp++;

						iCalcTotalWeight(iClientH);
						m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

						iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 9);
						m_pClientList[iClientH]->m_bIsBankModified = TRUE;

						switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, TRUE, TRUE);
								return;
						}
						return;
					}
				}
				ZeroMemory(cMsg, sizeof(cMsg));

				dwp = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = CLIENT_RESPONSE_RETRIEVEITEM;
				wp = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp = DEF_MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 9);
			}
		}

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestRetrieveItemHandler");
	}
#endif
}

BOOL CMapServer::bSetItemToBankItem(int iClientH, short sItemIndex)
{
	class CItem * pItem;
	short x = 0, i;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;

		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
				if (m_pClientList[iClientH]->m_pItemInBankList[i]->GetBankPosition() == m_pClientList[iClientH]->WHPage)
					x++;
			}
		}

		if (x >= DEF_MAXBANKITEMPAGE) return FALSE;

		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {

				m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
				pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
				pItem->SetBankPosition(m_pClientList[iClientH]->WHPage);

				m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

				iCalcTotalWeight(iClientH);

				if (SendBankItemData(iClientH, pItem, i)) return TRUE;
				else return FALSE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetItemToBankItem");
	}
	return FALSE;
#endif
}

void CMapServer::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
	int iV1, iV2;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[sAttackerH] == NULL) return;
		if (m_pClientList[sVictumH] == NULL) return;
		if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return;
		if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) return; // v2.95

		//Antilam Pks
		if (DEF_ACTIVE_ANTILAM) {
			if ((strcmp(m_pClientList[sVictumH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cIP2) == 0)
				|| (strcmp(m_pClientList[sVictumH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cIPaddress) == 0)) {
				char cMsg[150];
				ZeroMemory(cMsg, sizeof(cMsg));
				wsprintf(cMsg, "Your PK(%s) has been blocked. Kill any other player!", m_pClientList[sVictumH]->m_cCharName);
				ShowClientMsg(sAttackerH, cMsg);
				_bPKLog(DEF_PKLOG_BYPK, sAttackerH, sVictumH, NULL, TRUE);
				return;
			}
			else _bPKLog(DEF_PKLOG_BYPK, sAttackerH, sVictumH, NULL);
		}
		else _bPKLog(DEF_PKLOG_BYPK, sAttackerH, sVictumH, NULL);

		// PK Count
		m_pClientList[sAttackerH]->m_iPKCount++;
		m_pClientList[sAttackerH]->m_iCityFriendKilled++;

		if (m_pClientList[sAttackerH]->m_iPKCount > 9) {
			if (!m_pClientList[sAttackerH]->Achivements[17].Complete)
				CheckCompleteAchivement(sAttackerH, 17, TRUE);
		}

		iV1 = iDice((m_pClientList[sVictumH]->m_iLevel / 2) + 1, 50);
		iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel / 2) + 1, 50);

		m_pClientList[sAttackerH]->m_iExp -= iV1;
		m_pClientList[sAttackerH]->m_iExp -= iV2;
		if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

		SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);

		SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

		m_pClientList[sAttackerH]->m_iRating -= 10;
		if (m_pClientList[sAttackerH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[sAttackerH]->m_iRating = (DEF_LIMIT_REP * 1000);
		if (m_pClientList[sAttackerH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[sAttackerH]->m_iRating = -(DEF_LIMIT_REP * 1000);
		SendNotifyMsg(NULL, sAttackerH, CLIENT_REPONSE_PLAYERREP, m_pClientList[sAttackerH]->m_iRating, NULL, NULL, NULL);


		if (m_pClientList[sAttackerH]->m_cSide == DEF_ARESDEN) { // 2002-11-15 ����
			ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy_secure(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 15 * 1;
			RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
			return;
		}

		if (m_pClientList[sAttackerH]->m_cSide == DEF_ELVINE) { // 2002-11-15 ����
			ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy_secure(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 15 * 1;
			RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
			return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ApplyPKpenalty");
	}
#endif
}

void CMapServer::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[sAttackerH] == NULL) return;
		if (m_pClientList[sVictumH] == NULL) return;
		if (!m_pClientList[sAttackerH]->Assasain) return;
		if (!m_pClientList[sVictumH]->Assasain)
			if (m_pClientList[sVictumH]->m_cSide == DEF_NETURAL) return;

		_bPKLog(DEF_PKLOG_BYPLAYER, sAttackerH, sVictumH, NULL);

		m_pClientList[sAttackerH]->m_iCityFriendKilled++;

		if (m_pClientList[sAttackerH]->m_iPKCount == 0) {
			m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;

			if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
				m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
			if (m_pClientList[sAttackerH]->m_iRewardGold < 0)
				m_pClientList[sAttackerH]->m_iRewardGold = 0;

			SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: PK_KillRewardHandler");
	}
#endif
}

//New Function - ZeroEoyPnk // LaloRamos Happy x 40 sade x 20
void CMapServer::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	int iRewardExp, iEK_Level;
	short EnemyKillReward;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iAttackerH] == NULL) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iLevel < 21) return;
		//funcion antilam
		if (DEF_ACTIVE_ANTILAM) {
			if ((strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIP2) == 0)
				|| (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIPaddress) == 0)) {
				char cMsg[150];
				ZeroMemory(cMsg, sizeof(cMsg));
				wsprintf(cMsg, "Your EK(%s) has been blocked. Kill any other player!", m_pClientList[iClientH]->m_cCharName);
				ShowClientMsg(iAttackerH, cMsg);
				_bPKLog(DEF_PKLOG_BYENERMY, iAttackerH, iClientH, NULL, TRUE);
				return;
			}
			else _bPKLog(DEF_PKLOG_BYENERMY, iAttackerH, iClientH, NULL);
		}
		else _bPKLog(DEF_PKLOG_BYENERMY, iAttackerH, iClientH, NULL);
		EnemyKillReward = 10;

	//	EnemyKillReward = 20; //Ek sin eventos activados.

		strcpy_secure(m_pClientList[iAttackerH]->m_cIP2, m_pClientList[iClientH]->m_cIPaddress);

		iEK_Level = 1;

		if (m_pClientList[iAttackerH]->m_iPKCount == 0) {
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;
			
			if (bHappyDay) EnemyKillReward = EnemyKillReward * 10;//10
			else if (bHappyHour) EnemyKillReward = EnemyKillReward * 4;//4

			if (m_bIsCrusadeMode == TRUE) {
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp) * 5;
				EnemyKillReward += 10;
				 // EnemyKillReward += 50;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

			//	wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3)) * 6);
			//	PutLogList(G_cTxt);

				SendNotifyMsg(NULL, iAttackerH, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cMapName, "masacre", 7) == 0)
					EnemyKillReward = EnemyKillReward += 10; //* 2;

				//WorldWar - LaloRamos - Ek Aumentado
				if (memcmp(m_pClientList[iAttackerH]->m_cMapName, "FightMap", 8) == 0)
					EnemyKillReward = EnemyKillReward += 10;

				//WorldWarII - LaloRamos - Ek Aumentado
				if (memcmp(m_pClientList[iAttackerH]->m_cMapName, "WorldMap", 8) == 0)
					EnemyKillReward = EnemyKillReward += 10;
			}

			if (m_pClientList[iClientH]->FirstPosition) EnemyKillReward *= 2;

			m_pClientList[iAttackerH]->m_iEnemyKillCount += EnemyKillReward;
			m_pClientList[iAttackerH]->m_iEnemyKillTotalCount++;
			m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
			if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
			if (m_pClientList[iAttackerH]->m_iRewardGold < 0) m_pClientList[iAttackerH]->m_iRewardGold = 0;
			m_pClientList[iAttackerH]->m_iExp += iRewardExp;

			SendEnemyKills(iAttackerH);
			SendNotifyMsg(NULL, iAttackerH, CLIENT_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);

			if (m_pClientList[iAttackerH]->Assasain == FALSE) {
				if (bCheckLimitedUser(iAttackerH) == FALSE)
					SendNotifyMsg(NULL, iAttackerH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}

			bCheckLevelUp(iAttackerH);

			m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;

			if (CityVsCity == TRUE) {
				if (m_pClientList[iAttackerH]->m_cSide == 1) ContadorAresden++;
				else if (m_pClientList[iAttackerH]->m_cSide == 2) ContadorElvine++;
			}

			//WorldWar - LaloRamos
			if ((WorldWar == TRUE) && (memcmp(m_pClientList[iClientH]->m_cMapName, "FightMap", 8) == 0)) {
				if (m_pClientList[iAttackerH]->m_cSide == 1) WWContadorAresden++;
				else if (m_pClientList[iAttackerH]->m_cSide == 2) WWContadorElvine++;
			}

			//WorldWarII - LaloRamos
			if ((WorldWarII == TRUE) && (memcmp(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8) == 0)) {
				if (m_pClientList[iAttackerH]->m_cSide == 1) WWIIContadorAresden++;
				else if (m_pClientList[iAttackerH]->m_cSide == 2) WWIIContadorElvine++;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EnemyKillRewardHandler");
	}
#endif
}

void CMapServer::ApplyCombatKilledPenalty(int iClientH, char cPenaltyLevel, BOOL bIsSAattacked, BOOL bItemDrop)
{
	int iExp;

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->Assasain == FALSE && m_pClientList[iClientH]->m_cSide == DEF_NETURAL) return;
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "masacre", 7) == 0) return;

		if ((ActiveEvent) || (PriceEvent) || (PriceHODEvent)) {
			if (m_pClientList[iClientH]->m_iPKCount > 0 && !m_pClientList[iClientH]->Assasain) {
				m_pClientList[iClientH]->m_iPKCount--;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
				_bPKLog(DEF_PKLOG_REDUCECRIMINAL, (int)-1, iClientH, NULL);
			}
			return;
		}
		else {
			if (m_pClientList[iClientH]->m_iPKCount > 0 && !m_pClientList[iClientH]->Assasain) {
				m_pClientList[iClientH]->m_iPKCount--;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
				_bPKLog(DEF_PKLOG_REDUCECRIMINAL, (int)-1, iClientH, NULL);
			}
			iExp = iDice(1, (5 * cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

			m_pClientList[iClientH]->m_iExp -= iExp;
			if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);

			if ((m_pClientList[iClientH]->m_bIsNeutral != TRUE) || (CityVsCity != TRUE)) {
				if (m_pClientList[iClientH]->m_iLevel < 80) {
					cPenaltyLevel--;
					if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
					_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
				}
				else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ApplyCombatKilledPenalty");
	}
#endif
}


void CMapServer::CreateItemDrop(int client, string map, int id, int x, int y)
{
	if (m_pClientList[client] == NULL) return;
	CItem * it = new CItem;
	_bInitItemAttr(it, id);
	dropitem(client, id, x, y, 0, 0, it->m_cItemColor);
	delete it;
}


void CMapServer::dropitem(int client , int iItemID, int iX, int iY, int dwType, int dwValue, int cColor) {
	class CItem * pItem;
	pItem = new class CItem;
	if (m_pClientList[client] == NULL) return;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
	}

	else {
		if (dwType <= 10) {

			pItem->m_dwAttribute = NULL;
			dwType = dwType << 20;
			dwValue = dwValue << 16;
			pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
		}
		else if (dwType > 10) {

			dwType = dwType << 12;
			dwValue = dwValue << 8;
			pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
		}

		int roll = iDice(1, 2);
		pItem->m_wCurLifeSpan = roll;

		pItem->m_cItemColor = cColor;
		m_pMapList[m_pClientList[client]->m_cMapIndex]->bSetItem(m_pClientList[client]->m_sX, m_pClientList[client]->m_sY, pItem);

		pItem->m_dwTimeDrop = timeGetTime();

		SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[client]->m_cMapIndex, iX, iY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor, pItem->m_dwAttribute);
	}
}

void CMapServer::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked, BOOL bItemDrop)
{

#ifdef DEF_DEBUG
	try {
#endif
		register int i, j, iRemainItem;
		char cItemIndexList[DEF_MAXITEMS], cItemIndex;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		//WorldWar drop - LaloRamos
		if ((m_bIsCrusadeMode) || (CityVsCity) || (TowerDefense) || (m_bIsCTFMode) || (WorldWar) || (WorldWarII) || (HellOfDeath) || (AllEks) || (AllDkEks)) return;

		if (m_bIsRushNetMode == TRUE) return;

		if (m_pClientList[iClientH]->m_sNoDrop == 1)
		{
			if (m_pClientList[iClientH] == NULL) return;
			auto x = m_pClientList[iClientH]->m_sX;
			auto y = m_pClientList[iClientH]->m_sY;
			string mapname = m_pClientList[iClientH]->m_cMapName;
			CreateItemDrop(iClientH, mapname, 650, x, y);
			return;
		}

		if (m_pClientList[iClientH] == NULL) return;
		if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
				if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
					m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
				DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
				iCalcTotalWeight(iClientH);
			}
			else {
				m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
				return;
				for (i = 0; i < DEF_MAXITEMS; i++) {
					if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return;
					if (m_pClientList[iClientH]->m_pItemList == NULL) return;
					if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
						if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
						DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
						m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
						return;
					}
				}
				goto PID_DROP;
			}
			return;
		}

	PID_DROP:;
		for (i = 1; i <= iTotal; i++) {
			iRemainItem = 0;
			ZeroMemory(cItemIndexList, sizeof(cItemIndexList));

			for (j = 0; j < DEF_MAXITEMS; j++) {
				if (m_pClientList[iClientH]->m_pItemList[j] == NULL) return;
				if (m_pClientList[iClientH]->m_pItemList == NULL) return;
				if (m_pClientList[iClientH]->m_pItemList[j] != NULL) {
					cItemIndexList[iRemainItem] = j;
					iRemainItem++;
					/*wsprintf(G_cTxt, "Remain: %d", iRemainItem);
					PutLogHacksFileList(G_cTxt);
					wsprintf(G_cTxt, "J: %d", j);
					PutLogHacksFileList(G_cTxt);*/
				}
			}

			if (iRemainItem == 0) return;
			cItemIndex = cItemIndexList[iDice(1, iRemainItem) - 1];

			if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
				(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			}
			else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
				(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
				(bIsSAattacked == FALSE)) { }
			else if ((m_pClientList[iClientH]->m_bIsLuckyEffect == TRUE) && (iDice(1, 10) == 5)) { }
			else
			{
				DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _PenaltyItemDrop");
	}
#endif
}

void CMapServer::GetRewardMoneyHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
		DWORD * dwp;
		WORD  * wp;
		char  * cp, cData[100], cItemName[21];
		class CItem * pItem;
		short * sp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

		if (iWeightLeft <= 0) return;
		iWeightLeft = iWeightLeft / 2;
		if (iWeightLeft <= 0) return;

		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		wsprintf(cItemName, "Gold");
		_bInitItemAttr(pItem, cItemName);
		if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
			pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
			iRewardGoldLeft = 0;
		}
		else {
			pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
			iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
		}

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy_secure(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
			cp++;

			sp = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

		//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		//	cp++;
			//cambio lalomanu
			sp = (short *)cp;
			*sp = pItem->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;

			if (iEraseReq == 1) delete pItem;

			//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			//cambio lalomanu
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetRewardMoneyHandler");
	}
#endif
}

int CMapServer::_iCalcMaxLoad(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return 0;

		return ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel * 500);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iCalcMaxLoad");
	}
#endif
	return 0;
}

int CMapServer::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{

#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		short sPreType;
		DWORD dwTime, dwRegisterTime;

		m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
		if (sPreType != NULL) return NULL;

		switch (sType) {
			case DEF_DYNAMICOBJECT_FIRE:
			case DEF_DYNAMICOBJECT_FIRE3:
				if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE) return NULL;
				if (m_pMapList[cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return NULL;
				if (dwLastTime != NULL) {
					switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
						case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
						case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
						case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
					}
					if (dwLastTime == NULL) dwLastTime = 1000;
				}
				break;

			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
					return NULL;
				break;

			case DEF_DYNAMICOBJECT_ARESDENFLAG1:
			case DEF_DYNAMICOBJECT_ELVINEFLAG1:
			case DEF_DYNAMICOBJECT_MINERAL1:
			case DEF_DYNAMICOBJECT_MINERAL2:
				if (iV1 == -1)m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, TRUE);
				else
				{
					if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE) return NULL;
					m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
				}
				break;
		}

		for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
			if (m_pDynamicObjectList[i] == NULL) {
				dwTime = timeGetTime();

				if (dwLastTime != NULL)
					dwLastTime += (iDice(1, 4) * 1000);

				m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
				m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
				SendEventToNearClient_TypeB(CLIENT_COMMON_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);
				return i;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iAddDynamicObjectList");
	}
#endif
	return NULL;
}

void CMapServer::CheckDynamicObjectList()
{

#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		DWORD dwTime = timeGetTime(), dwRegisterTime;
		short sType;

		for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
			if ((m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL)) {

				switch (m_pDynamicObjectList[i]->m_sType) {
					case DEF_DYNAMICOBJECT_FIRE:
					case DEF_DYNAMICOBJECT_FIRE3:
						switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
							case 0: break;
							case 1:
							case 2:
							case 3:
								m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime -
									(m_pDynamicObjectList[i]->m_dwLastTime / 10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
								break;
						}
						break;
				}
			}
		}

		for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
			if ((m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) &&
				((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime)) {

				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime);

				if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
					SendEventToNearClient_TypeB(CLIENT_COMMON_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
				}

				switch (sType) {
					case DEF_DYNAMICOBJECT_FISHOBJECT:
					case DEF_DYNAMICOBJECT_FISH:
						bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // �ð��� ������ �����Ⱑ ��������.
						break;
				}

				delete m_pDynamicObjectList[i];
				m_pDynamicObjectList[i] = NULL;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckDynamicObjectList");
	}
#endif
}

void CMapServer::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sSkillIndex;
		int   iOldSSN, iSSNpoint, iWeaponIndex;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

		sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
		if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
		if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

		iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
		m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue * 20;

		iSSNpoint = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1];

		if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
			(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

			m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;

			switch (sSkillIndex) {
				case 0:  // Mining
				case 5:  // Hand-Attack
				case 13: // Manufacturing
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				case 3: // Magic-Resistance
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				case 4:  // Magic
				case 21: // Staff-Attack
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				case 1:  // Fishing
				case 6:  // Archery
				case 7:  // Short-Sword
				case 8:  // Long-Sword
				case 9:  // Fencing 
				case 10: // Axe-Attack
				case 11: // Shield        	
				case 14: // Hammer 
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				case 2:	 // Farming
				case 12: // Alchemy
				case 15: // ����óġ
				case 19: // Pretend-Corpse
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				case 23: // Poison-Resistance
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				//case 19: // Pretend-Corpse
				default:
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;
			}

			if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio++;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio++;
					}
				}
			}

			if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
				bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 2, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalculateSSN_ItemIndex");
	}
#endif
}

void CMapServer::MobGenerator()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, j, iNamingValue, iResult, iTotalMob;
		char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
		char cSA;
		int  pX, pY, iMapLevel = 1, iProbSA, iKindSA, iResultNum, iFirmSAType;
		BOOL bMaster, bFirmBerserk, bIsSpecialEvent;
		short sNpcType = 0;

		if (m_bOnExitProcess == TRUE) return;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			iResultNum = 0;

		/*	if (m_pMapList[i] != NULL) {
				if (strcmp(m_pMapList[i]->m_cName, "BtField") == 0) {
					//if (TowerDefense == TRUE) m_pMapList[i]->m_iMaximumObject = 999;
					if ((TowerDefense == TRUE) || (RespawnON == TRUE)) m_pMapList[i]->m_iMaximumObject = 999;
					else m_pMapList[i]->m_iMaximumObject = 0;
				}
			}*/

			if (m_pMapList[i] != NULL) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);

			if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject)) {
				if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;

				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// Master Mob
					ZeroMemory(cName_Master, sizeof(cName_Master));
					wsprintf(cName_Master, "XX%d", iNamingValue);
					cName_Master[0] = '_';
					cName_Master[1] = i + 65;
					ZeroMemory(cNpcName, sizeof(cNpcName));

					iFirmSAType = NULL;
					bFirmBerserk = FALSE;
					iResult = iDice(1, 100);
					switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {
						case 1:
							if ((iResult >= 1) && (iResult < 20)) iResult = 1;  // ������ 
							else if ((iResult >= 20) && (iResult < 40)) iResult = 2;  // ���� 
							else if ((iResult >= 40) && (iResult < 85)) iResult = 24; // �䳢 
							else if ((iResult >= 85) && (iResult < 95)) iResult = 25; // ������ 
							else if ((iResult >= 95) && (iResult <= 100)) iResult = 3;  // ��ũ 
							iMapLevel = 1;
							break;

						case 2:
							if ((iResult >= 1) && (iResult < 40)) iResult = 1;
							else if ((iResult >= 40) && (iResult < 80)) iResult = 2;
							else iResult = 10;
							iMapLevel = 1;
							break;

						case 3:     // v1.4334 �����ʷ����� ���� // MiddleLand
							if ((iResult >= 1) && (iResult < 20)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 3; break;
									case 2: iResult = 4; break;
								}
							}
							else if ((iResult >= 20) && (iResult < 25)) iResult = 30;
							else if ((iResult >= 25) && (iResult < 50)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 5; break;
									case 2:	iResult = 6; break;
									case 3: iResult = 7; break;
								}
							}
							else if ((iResult >= 50) && (iResult < 75)) {
								// 2002-09-12 #1 Ettin �߰� ���� �����Ϳ�
								switch (iDice(1, 7)) {
									case 1:
									case 2: iResult = 8;  break;
									case 3:	iResult = 11; break;
									case 4:	iResult = 12; break;
									case 5: iResult = 18; break;
									case 6: iResult = 26; break;
									case 7: iResult = 28; break;	// Ettin
								}
							}
							else if ((iResult >= 75) && (iResult <= 100)) {
								switch (iDice(1, 5)) {
									case 1:
									case 2:	iResult = 9;  break;
									case 3:	iResult = 13; break;
									case 4: iResult = 14; break;
									case 5: iResult = 27; break;	// Mountain-Giant
								}
							}
							iMapLevel = 4;
							break;

						case 4:
							if ((iResult >= 1) && (iResult < 50)) {
								switch (iDice(1, 2)) {
									case 1:	iResult = 2; break;
									case 2: iResult = 10; break;
								}
							}
							else if ((iResult >= 50) && (iResult < 80)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 8; break;
									case 2: iResult = 11; break;
								}
							}
							else if ((iResult >= 80) && (iResult < 100)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 14; break;
									case 2:	iResult = 9; break;
								}
							}
							iMapLevel = 2;
							break;

						case 5: //dglv2
							if ((iResult >= 1) && (iResult < 30)) {
								switch (iDice(1, 5)) {
									case 1:
									case 2:
									case 3:
									case 4:
									case 5: iResult = 2; break;
								}
							}
							else if ((iResult >= 30) && (iResult < 60)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 3; break;
									case 2: iResult = 4; break;
								}
							}
							else if ((iResult >= 60) && (iResult < 80)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 5; break;
									case 2: iResult = 7; break;
								}
							}
							else if ((iResult >= 80) && (iResult < 95)) {
								switch (iDice(1, 3)) {
									case 1:
									case 2: iResult = 8;  break;
									case 3:	iResult = 11; break;
								}
							}
							else if ((iResult >= 95) && (iResult <= 100)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 11; break;
									case 2: iResult = 14; break;
									case 3: iResult = 9; break;
								}
							}
							iMapLevel = 3;
							break;

						case 6: // huntzone 3,4
							if ((iResult >= 1) && (iResult < 60)) { //59/100 de posibilidad
								switch (iDice(1, 4)) {
									case 1: iResult = 5; break; // Skeleton
									case 2:	iResult = 6; break; // Orc-Mage
									case 3: iResult = 7; break; // Scorpion
									case 4: iResult = 4; break; // Zombie
								}
							}
							else if ((iResult >= 60) && (iResult < 90)) { //29/100 de posibilidad
								switch (iDice(1, 5)) {
									case 1:
									case 2: iResult = 8;  break; // Stone-Golem
									case 3:	iResult = 11; break; // Clay-Golem
									case 4:	iResult = 12; break; // Troll
									case 5: iResult = 44; break; // Tentocle
								}
							}
							else if ((iResult >= 90) && (iResult <= 100)) { // 10/100 de posibilidad
								switch (iDice(1, 8)) {
									case 1: iResult = 26; break; // Giant-Frog
									case 2:	iResult = 9;  break; // Cyclops
									case 3:	iResult = 13; break; // Orge
									case 4: iResult = 14; break; // Hellbound
									case 5: iResult = 18; break; // WereWolf
									case 6: iResult = 28; break; // Ettin
									case 7: iResult = 27; break; // Mountain-Giant
									case 8: iResult = 29; break; // Cannibal-Plant
								}
							}
							iMapLevel = 4;
							break;

						case 7: // areuni, elvuni
							if ((iResult >= 1) && (iResult < 20)) { //19/100 de posibilidad
								switch (iDice(1, 4)) {
									case 1:	iResult = 1;  break; // Slime
									case 2: iResult = 2;  break; // Giant-Ant
									case 3: iResult = 10; break; // Amphis
									case 4: iResult = 3;  break; // Orc
								}
							}
							else if ((iResult >= 20) && (iResult < 50)) iResult = 30;  //Rudolph	
							else if ((iResult >= 50) && (iResult < 85)) { //34/100 de posibilidad
								switch (iDice(1, 5)) {
									case 1: // Orc-Mage
									case 2: // Orc-Mage
									case 3: iResult = 6;  break; // Orc-Mage
									case 4: iResult = 12; break; // Troll
									case 5: iResult = 40; break; // Giant-Plant
								}
							}
							else if ((iResult >= 85) && (iResult < 100)) { //14/100 de posibilidad
								switch (iDice(1, 4)) {
									case 1: iResult = 12; break; // Troll
									case 2: iResult = 29;  break; //Cannibal-Plant
									case 3:
										if (iDice(1, 100) >= 50)
											iResult = 17; // Unicorn
										else iResult = 12; // Troll
										break;
									case 4: iResult = 29; break; // Cannibal-Plant
								}
							}
							iMapLevel = 4;
							break;

						case 8:
							if ((iResult >= 1) && (iResult < 70)) {
								switch (iDice(1, 2)) {
									case 1:	iResult = 4;  break;
									case 2: iResult = 5;  break;
								}
							}
							else if ((iResult >= 70) && (iResult < 90)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 8;  break;
									case 2: iResult = 11; break;
									case 3: iResult = 14; break;
								}
							}
							else if ((iResult >= 90) && (iResult < 100)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 9;  break;
									case 2: iResult = 14; break;
								}
							}
							iMapLevel = 4;
							break;

						case 9: // dglv3
							if ((iResult >= 1) && (iResult < 70)) {
								switch (iDice(1, 2)) {
									case 1:	iResult = 4;  break; // Zombie
									case 2: iResult = 5;  break; // Skeleton
								}
							}
							else if ((iResult >= 70) && (iResult < 95)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 8;  break; // Stone-Golem
									case 2: iResult = 9;  break; // Cyclops
									case 3: iResult = 13; break; // Orge
								}
							}
							else if ((iResult >= 95) && (iResult < 100)) {
								switch (iDice(1, 6)) {
									case 1:
									case 2:
									case 3: iResult = 9;  break; // Cyclops
									case 4:
									case 5: iResult = 14; break; // Hellbound
									case 6: iResult = 15; break; // Liche
								}
							}
							if ((iDice(1, 3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;

							iMapLevel = 4;
							break;

						case 10: // dglv4
							if ((iResult >= 1) && (iResult < 70)) {
								switch (iDice(1, 2)) {
									case 1:	iResult = 4; break; // Zombie
									case 2: iResult = 5; break; // Skeleton
								}
							}
							else if ((iResult >= 70) && (iResult < 95)) {
								// 
								switch (iDice(1, 3)) {
									case 1:
									case 2:	iResult = 13; break; // Orge
									case 3: iResult = 14; break; // Hellbound
								}
							}
							else if ((iResult >= 95) && (iResult < 100)) {
								switch (iDice(1, 3)) {
									case 1:
									case 2: iResult = 14; break; // Hellbound
									case 3: iResult = 15; break; // Liche
								}
							}
							if ((iDice(1, 3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
							iMapLevel = 5;
							break;

						case 11: // ???
							if ((iResult >= 1) && (iResult < 30)) {
								switch (iDice(1, 5)) {
									case 1:
									case 2:
									case 3:
									case 4:
									case 5: iResult = 2; break; // Giant-Ant
								}
							}
							else if ((iResult >= 30) && (iResult < 60)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 3; break; // Orc
									case 2: iResult = 4; break; // Zombie
								}
							}
							else if ((iResult >= 60) && (iResult < 80)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 5; break; // Skeleton
									case 2: iResult = 7; break; // Scorpion
								}
							}
							else if ((iResult >= 80) && (iResult < 95)) {
								switch (iDice(1, 3)) {
									case 1:
									case 2: iResult = 10;  break; // Clay-Golem
									case 3:	iResult = 11; break;	// Troll
								}
							}
							else if ((iResult >= 95) && (iResult <= 100)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 11; break; // Troll
									case 2: iResult = 7; break; // Scorpion
									case 3: iResult = 8; break; // Stone-Golem
								}
							}
							iMapLevel = 4;
							break;

						case 12: // middled1n, promiseland
							if ((iResult >= 1) && (iResult < 50)) {
								switch (iDice(1, 3)) {
									case 1:	iResult = 1; break; // Slime
									case 2: iResult = 2; break; // Giant-Ant
									case 3: iResult = 10; break; // Amphis
								}
							}
							else if ((iResult >= 50) && (iResult < 85)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 5; break; // Skeleton
									case 2: iResult = 4; break; // Zombie
								}
							}
							else if ((iResult >= 85) && (iResult < 100)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 8; break; // Stone-Golem
									case 2: iResult = 11; break; // Clay-Golem
									case 3: iResult = 26; break; // Giant-Frog
								}
							}
							iMapLevel = 4;
							break;

						case 13: // Toh1
							if ((iResult >= 1) && (iResult < 15)) {
								iResult = 4;	// Zombie
								bFirmBerserk = TRUE;
								iFirmSAType = 4 - (iDice(1, 2) - 1);
							}
							else if ((iResult >= 15) && (iResult < 40)) {
								iResult = 14;	// Hellbound
								bFirmBerserk = TRUE;
								iFirmSAType = 4 - (iDice(1, 2) - 1);
							}
							else if ((iResult >= 40) && (iResult < 60)) {
								iResult = 9; // Cyclops
								bFirmBerserk = TRUE;
								iFirmSAType = 4 - (iDice(1, 2) - 1);
							}
							else if ((iResult >= 60) && (iResult < 75)) {
								iResult = 13; // Orge
								bFirmBerserk = TRUE;
								iFirmSAType = 4 - (iDice(1, 2) - 1);
							}
							else if ((iResult >= 75) && (iResult < 95)) iResult = 23; // Dark-Elf
							else if ((iResult >= 95) && (iResult < 100)) iResult = 22; // Beholder
							iMapLevel = 4;
							break;

						case 14: // Toh2
							if ((iResult >= 1) && (iResult < 30)) iResult = 23;	// Dark-Elf
							else if ((iResult >= 30) && (iResult < 50)) iResult = 22;	// Beholder
							else if ((iResult >= 50) && (iResult < 70)) {
								iResult = 15;	// Liche
								bFirmBerserk = TRUE;
								iFirmSAType = 4 - (iDice(1, 2) - 1);
							}
							else if ((iResult >= 70) && (iResult < 90)) iResult = 16;	// Demon
							else if ((iResult >= 90) && (iResult < 100)) iResult = 21;	// Gagoyle
							iMapLevel = 4;
							break;

						case 15: // Toh3
							if ((iResult >= 1) && (iResult < 35)) {
								iResult = 23;	// Dark-Elf
								bFirmBerserk = TRUE;
							}
							else if ((iResult >= 35) && (iResult < 50)) {
								iResult = 22;	// Beholder
								bFirmBerserk = TRUE;
							}
							else if ((iResult >= 50) && (iResult < 80)) {
								iResult = 16;	// Demon
								bFirmBerserk = TRUE;
							}
							else if ((iResult >= 80) && (iResult < 100)) iResult = 21;	// Gagoyle
							iMapLevel = 4;
							break;

						case 16: //Huntzone 1,2 �ʺ� �̵�.  //v2.19 2002-12-9
							if ((iResult >= 1) && (iResult < 40)) {
								switch (iDice(1, 3)) {
									case 1:	iResult = 1; break;	// Slime
									case 2: iResult = 2; break;	// Giant-Ant
									case 3: iResult = 10; break;	// Amphis
								}
							}
							else if ((iResult >= 40) && (iResult < 50)) iResult = 30;	//v2.19 Rudolph
							else if ((iResult >= 50) && (iResult < 85)) {
								switch (iDice(1, 2)) {
									case 1: iResult = 5; break;	// Skeleton
									case 2: iResult = 4; break;	// Zombie
								}
							}
							else if ((iResult >= 85) && (iResult < 100)) {
								switch (iDice(1, 3)) {
									case 1: iResult = 8; break;	// Stone-Golem
									case 2: iResult = 11; break;	// Clay-Golem
									case 3: iResult = 26; break;	// Giant-Frog
								}
							}
							iMapLevel = 1;
							break;
						case 17:	//v2.19 IceBound
							if ((iResult >= 1) && (iResult < 30)) {
								switch (iDice(1, 4)) {
									case 1:	iResult = 22; break;	// Beholder
									case 2: iResult = 8; break;	// Stone-Golem
									case 3: iResult = 24; break;	// Rabbit
									case 4: iResult = 5; break;	// Skeleton
								}
							}
							else if ((iResult >= 30) && (iResult < 40)) iResult = 30;	//v2.19 Rudolph
							else if ((iResult >= 40) && (iResult < 70)) iResult = 32;	// DireBoar
							else if ((iResult >= 70) && (iResult < 90)) {
								iResult = 31;	// Ice-Golem
								if (iDice(1, 5) == 1) bFirmBerserk = TRUE;
							}
							else if ((iResult >= 90) && (iResult <= 100)) iResult = 33;	// Frost
							iMapLevel = 1;
							break;

						case 18: //v3.2 druncncity
							if ((iResult >= 1) && (iResult < 2)) iResult = 46; // Hellclaw
							else if ((iResult >= 2) && (iResult < 12)) iResult = 36; // ClawTurtle
							else if ((iResult >= 12) && (iResult < 50)) iResult = 43; // Nizie
							else if ((iResult >= 50) && (iResult < 80)) iResult = 38; // Giant-Crayfish
							else if ((iResult >= 80) && (iResult < 90)) iResult = 47; // Stalker
							else if ((iResult >= 90) && (iResult <= 100)) iResult = 26; // Giant-Frog
							iMapLevel = 4;
							break;

						case 19: //v3.2 maze
							if ((iResult >= 1) && (iResult < 15)) iResult = 35; // Centaurus
							else if ((iResult >= 15) && (iResult < 25)) iResult = 42; // Minotaurs
							else if ((iResult >= 25) && (iResult < 35)) iResult = 21; // Gagoyle
							else if ((iResult >= 35) && (iResult < 60)) iResult = 44; // Tentocle
							else if ((iResult >= 60) && (iResult < 85)) iResult = 23; // Dark-Elf
							else if ((iResult >= 85) && (iResult <= 100)) iResult = 22; // Beholder
							iMapLevel = 4;
							break;
						case 20: //v3.51 BtField			
							if ((iResult >= 1) && (iResult < 20)) iResult = 44; //Tentocle
							if ((iResult >= 20) && (iResult < 40)) iResult = 35; //Centaurus
							if ((iResult >= 40) && (iResult < 60)) iResult = 39; //Giant-Lizard
							if ((iResult >= 60) && (iResult < 75)) iResult = 28; //Ettin
							if ((iResult >= 75) && (iResult < 80)) iResult = 16;//Demon
							if ((iResult >= 80) && (iResult < 85)) iResult = 21;//Gagoyle
							if ((iResult >= 85) && (iResult < 93)) iResult = 46;//Hellclaw
							if ((iResult >= 93) && (iResult < 96)) iResult = 47;//Tigerworm
							if ((iResult >= 96) && (iResult < 100)) iResult = 37;//FireWyvern
							break;
					}

					pX = NULL;
					pY = NULL;

					bIsSpecialEvent = FALSE;
					if ((m_bIsSpecialEventTime == TRUE) && (iDice(1, 10) == 3)) bIsSpecialEvent = TRUE;

					if (bIsSpecialEvent == TRUE) {
						switch (m_cSpecialEventType) {
							case 1:
								if (m_pMapList[i]->m_iMaxPx != 0) {
									pX = m_pMapList[i]->m_iMaxPx * 20 + 10;
									pY = m_pMapList[i]->m_iMaxPy * 20 + 10;

									if (pX < 0) pX = 0;
									if (pY < 0) pY = 0;

									if (m_bIsCrusadeMode == TRUE) {
										if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0) iResult = 20;
										else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0) iResult = 19;
									}

									wsprintf(G_cTxt, "Mob-Event Map(%s) Loc(%d,%d)", m_pMapList[i]->m_cName, pX, pY);
									PutLogList(G_cTxt);
								}
								break;

							case 2:
								if (iDice(1, 3) == 2) {
									if ((memcmp(m_pMapList[i]->m_cName, "aresden", 7) == 0) ||
										(memcmp(m_pMapList[i]->m_cName, "middled1n", 9) == 0) ||
										(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ||
										(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
										(memcmp(m_pMapList[i]->m_cName, "elvine", 6) == 0)) {
										if (iDice(1, 30) == 5) iResult = 16;
										else iResult = 5;
									}
									else iResult = 16;
								}
								else iResult = 17;

								m_bIsSpecialEventTime = FALSE;
								break;
						}
					}

					ZeroMemory(cNpcName, sizeof(cNpcName));
					switch (iResult) {
						case 1:  strcpy_secure(cNpcName, "Slime");     sNpcType = 10;   iProbSA = 5;  iKindSA = 1; break;
						case 2:  strcpy_secure(cNpcName, "Giant-Ant"); sNpcType = 16;   iProbSA = 10; iKindSA = 2; break;
						case 3:  strcpy_secure(cNpcName, "Orc");       sNpcType = 14;   iProbSA = 15; iKindSA = 1; break;
						case 4:  strcpy_secure(cNpcName, "Zombie");    sNpcType = 18;   iProbSA = 15; iKindSA = 3; break;
						case 5:  strcpy_secure(cNpcName, "Skeleton");  sNpcType = 11;   iProbSA = 35; iKindSA = 8; break;
						case 6:  strcpy_secure(cNpcName, "Orc-Mage");  sNpcType = 14;   iProbSA = 30; iKindSA = 7; break;
						case 7:  strcpy_secure(cNpcName, "Scorpion");  sNpcType = 17;   iProbSA = 15; iKindSA = 3; break;
						case 8:  strcpy_secure(cNpcName, "Stone-Golem"); sNpcType = 12; iProbSA = 25; iKindSA = 5; break;
						case 9:  strcpy_secure(cNpcName, "Cyclops");    sNpcType = 13;  iProbSA = 35; iKindSA = 8; break;
						case 10: strcpy_secure(cNpcName, "Amphis");     sNpcType = 22;  iProbSA = 20; iKindSA = 3; break;
						case 11: strcpy_secure(cNpcName, "Clay-Golem"); sNpcType = 23;  iProbSA = 20; iKindSA = 5; break;
						case 12: strcpy_secure(cNpcName, "Troll");      sNpcType = 28;  iProbSA = 25; iKindSA = 3; break;
						case 13: strcpy_secure(cNpcName, "Orge");       sNpcType = 29;  iProbSA = 25; iKindSA = 1; break;
						case 14: strcpy_secure(cNpcName, "Hellbound");  sNpcType = 27;  iProbSA = 25; iKindSA = 8; break;
						case 15: strcpy_secure(cNpcName, "Liche");		 sNpcType = 30;  iProbSA = 30; iKindSA = 8; break;
						case 16: strcpy_secure(cNpcName, "Demon");		 sNpcType = 31;  iProbSA = 20; iKindSA = 8; break;
						case 17: strcpy_secure(cNpcName, "Unicorn");	 sNpcType = 32;  iProbSA = 35; iKindSA = 7; break;
						case 18: strcpy_secure(cNpcName, "WereWolf");	 sNpcType = 33;  iProbSA = 25; iKindSA = 1; break;
						case 19: strcpy_secure(cNpcName, "YB-Aresden"); sNpcType = 1;   iProbSA = 15; iKindSA = 1; break;
						case 20: strcpy_secure(cNpcName, "YB-Elvine");	 sNpcType = 1;   iProbSA = 15; iKindSA = 1; break;
						case 21: strcpy_secure(cNpcName, "Gagoyle");	 sNpcType = 52;  iProbSA = 20; iKindSA = 8; break;
						case 22: strcpy_secure(cNpcName, "Beholder");	 sNpcType = 53;  iProbSA = 20; iKindSA = 5; break;
						case 23: strcpy_secure(cNpcName, "Dark-Elf");	 sNpcType = 54;  iProbSA = 20; iKindSA = 3; break;
						case 24: strcpy_secure(cNpcName, "Rabbit");	 sNpcType = 55;  iProbSA = 5; iKindSA = 1; break;
						case 25: strcpy_secure(cNpcName, "Cat");		 sNpcType = 56;  iProbSA = 10; iKindSA = 2; break;
						case 26: strcpy_secure(cNpcName, "Giant-Frog"); sNpcType = 57;  iProbSA = 10; iKindSA = 2; break;
						case 27: strcpy_secure(cNpcName, "Mountain-Giant");  sNpcType = 58; 	iProbSA = 25; iKindSA = 1; break;
						case 28: strcpy_secure(cNpcName, "Ettin");			  sNpcType = 59;	iProbSA = 20; iKindSA = 8; break;
						case 29: strcpy_secure(cNpcName, "Cannibal-Plant");  sNpcType = 60; 	iProbSA = 20; iKindSA = 5; break;
						case 30: strcpy_secure(cNpcName, "Rudolph");    sNpcType = 61; 	iProbSA = 20; iKindSA = 5; break;
						case 31: strcpy_secure(cNpcName, "Ice-Golem");  sNpcType = 65;    iProbSA = 35; iKindSA = 8; break;
						case 32: strcpy_secure(cNpcName, "DireBoar");  sNpcType = 62; 	iProbSA = 20; iKindSA = 5; break;
						case 33: strcpy_secure(cNpcName, "Frost");		 sNpcType = 63;    iProbSA = 30; iKindSA = 8; break;
						case 34: strcpy_secure(cNpcName, "Barlog");   sNpcType = 70;     iProbSA = 20; iKindSA = 1; break;
						case 35: strcpy_secure(cNpcName, "Centaurus"); sNpcType = 71;    iProbSA = 20; iKindSA = 1; break;
						case 36: strcpy_secure(cNpcName, "Claw-Turtle"); sNpcType = 72;  iProbSA = 20; iKindSA = 1; break;
						case 37: strcpy_secure(cNpcName, "Fire-Wyvern"); sNpcType = 73;  iProbSA = 20; iKindSA = 1; break;
						case 38: strcpy_secure(cNpcName, "Giant-Crayfish"); sNpcType = 74; iProbSA = 20; iKindSA = 1; break;
						case 39: strcpy_secure(cNpcName, "Giant-Lizard"); sNpcType = 75; iProbSA = 20; iKindSA = 1; break;
						case 40: strcpy_secure(cNpcName, "Giant-Plant"); sNpcType = 76; iProbSA = 20; iKindSA = 1; break;
						case 41: strcpy_secure(cNpcName, "MasterMage-Orc"); sNpcType = 77; iProbSA = 20; iKindSA = 1; break;
						case 42: strcpy_secure(cNpcName, "Minotaurs"); sNpcType = 78; iProbSA = 20; iKindSA = 1; break;
						case 43: strcpy_secure(cNpcName, "Nizie"); sNpcType = 79; iProbSA = 20; iKindSA = 1; break;
						case 44: strcpy_secure(cNpcName, "Tentocle"); sNpcType = 80; iProbSA = 20; iKindSA = 1; break;
						case 45: strcpy_secure(cNpcName, "Abaddon"); sNpcType = 81; iProbSA = 20; iKindSA = 1; break;
						case 46: strcpy_secure(cNpcName, "Hellclaw"); sNpcType = 49; iProbSA = 20; iKindSA = 1; break;
						case 47: strcpy_secure(cNpcName, "Tigerworm"); sNpcType = 52; iProbSA = 20; iKindSA = 1; break;
						case 48: strcpy_secure(cNpcName, "Wyvern"); sNpcType = 66;  iProbSA = 20; iKindSA = 1; break;
						default: strcpy_secure(cNpcName, "Orc");		      sNpcType = 14; 	iProbSA = 15; iKindSA = 1; break;
					}

					cSA = 0;
					if (iFirmSAType == NULL) {
						if (iDice(1, 100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
					}
					else cSA = (char)iFirmSAType;

					if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
				}

				switch (iResult) {
					case 1:	 iTotalMob = iDice(1, 5) - 1; break;  // Slime 
					case 2:	 iTotalMob = iDice(1, 5) - 1; break; // Giant-Ant
					case 3:	 iTotalMob = iDice(1, 5) - 1; break; // Orc
					case 4:	 iTotalMob = iDice(1, 3) - 1; break; // Zombie
					case 5:	 iTotalMob = iDice(1, 3) - 1; break;
					case 6:  iTotalMob = iDice(1, 3) - 1; break; // Skeleton
					case 7:  iTotalMob = iDice(1, 3) - 1; break; // Scorpion
					case 8:  iTotalMob = iDice(1, 2) - 1; break; // Stone-Golem
					case 9:  iTotalMob = iDice(1, 2) - 1; break;
					case 10: iTotalMob = iDice(1, 5) - 1; break; // Amphis
					case 11: iTotalMob = iDice(1, 3) - 1; break; // Clay-Golem
					case 12: iTotalMob = iDice(1, 5) - 1; break; // Troll
					case 13: iTotalMob = iDice(1, 3) - 1; break; // Orge
					case 14: iTotalMob = iDice(1, 3) - 1; break; // Rabbit
					case 15: iTotalMob = iDice(1, 3) - 1; break; // Cat
					case 16: iTotalMob = iDice(1, 2) - 1; break; // Giant-Frog
					case 17: iTotalMob = iDice(1, 2) - 1; break; // Mountain-Giant
					case 18: iTotalMob = iDice(1, 5) - 1; break; // Ettin
					case 21: iTotalMob = iDice(1, 2) - 1; break; // Cannibal-Plant
					case 22: iTotalMob = iDice(1, 2) - 1; break;
					case 23: iTotalMob = iDice(1, 5) - 1; break;
					case 24: iTotalMob = iDice(1, 2) - 1; break;
					case 25: iTotalMob = iDice(1, 2) - 1; break;
					case 26: iTotalMob = iDice(1, 4) - 1; break;
					case 27: iTotalMob = iDice(1, 2) - 1; break;
					case 28: iTotalMob = iDice(1, 3) - 1; break;
					case 29: iTotalMob = iDice(1, 3) - 1; break;
					case 30: iTotalMob = iDice(1, 3) - 1; break;
					case 31: iTotalMob = iDice(1, 5) - 1; break;
					case 32: iTotalMob = iDice(1, 3) - 1; break;
					case 33: iTotalMob = iDice(1, 3) - 1; break;
					case 34: iTotalMob = 1; break;
					case 35: iTotalMob = 1; break;
					case 36: iTotalMob = iDice(1, 3) - 1; break;
					case 38: iTotalMob = 1; break;
					case 39: iTotalMob = 1; break;
					case 42: iTotalMob = iDice(1, 3) - 1; break;
					case 44: iTotalMob = 1; break;
					default: iTotalMob = 0; break;
				}
				if (bMaster == FALSE) iTotalMob = 0;

				if (iTotalMob >= 2) {
					switch (iResult) {
						case 1:   // Slime 
						case 2:  // Giant-Ant
						case 3:  // Orc
						case 4:  // Zombie
						case 5:  // Skeleton
						case 7:  // Scorpion
						case 8:  // Stone-Golem
						case 10: // Amphis
						case 11: // Clay-Golem
						case 12: // Troll
						case 13: // Orge
						case 24: // Rabbit
						case 25: // Cat
						case 26: // Giant-Frog
						case 27: // Mountain-Giant
						case 28: // Ettin
						case 29: // Cannibal-Plant
						//v2.19 2002-12-11 �絹�� �߰� ���� 
						case 30:
						case 32: // DireBoar
						case 33: // Frost
							if (iDice(1, 5) != 1) iTotalMob = 0;  // 25%
							break;

						case 9:  // Cyclops
						case 6:  // Orc-Mage
						case 14: // Hellbound
						case 15: // Liche
						case 16: // Demon
						case 17: // Unicorn
						case 18: // WereWolf
						case 31: // Ice-Golem
						case 34: // Barlog
						case 35: // Centaurus
						case 36: // Claw-Turtle
						case 37: // Fire-Wyvern
						case 38: // Giant-Crayfish
						case 39: // Giant-Lizard
						case 40: // Giant-Plant
						case 41: // MasterMage-Orc
						case 42: // Minotaurs
						case 43: // Nizie
						case 44: // Tentocle
							if (iDice(1, 5) == 1) iTotalMob = 0;  // 75%
							break;

						default:
							break;
					}
				}

				// Special Event
				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
						case 1:
							if ((iResult != 15) && (iResult != 16) && (iResult != 21))
								iTotalMob = m_pMapList[i]->sMobEventAmount;
						case 2:
							// v2.19 2002-11-12 LocationName m_cName
							if ((memcmp(m_pMapList[i]->m_cName, "aresden", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvine", 6) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0)) {
								iTotalMob = 0;
							}
							break;
					}
					m_bIsSpecialEventTime = FALSE;
				}

				for (j = 0; j < iTotalMob; j++) {
					iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
					if (iNamingValue != -1) {
						// Slave Mob
						ZeroMemory(cName_Slave, sizeof(cName_Slave));
						wsprintf(cName_Slave, "XX%d", iNamingValue);
						cName_Slave[0] = '_';
						cName_Slave[1] = i + 65;

						cSA = 0;
						if (iFirmSAType == NULL) {
							if (iDice(1, 100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
						}
						else cSA = (char)iFirmSAType;

						if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
						}
						else bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
			// random mob generator	^

			// spot mob generator 
			if ((m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject)) {
				for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++) {
					if ((iDice(1, 3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
						(m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs)) {
						iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {

							ZeroMemory(cNpcName, sizeof(cNpcName));
							switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
								case 10:  strcpy_secure(cNpcName, "Slime");        iProbSA = 5;  iKindSA = 1; break;
								case 16:  strcpy_secure(cNpcName, "Giant-Ant");    iProbSA = 10; iKindSA = 2; break;
								case 14:  strcpy_secure(cNpcName, "Orc");          iProbSA = 15; iKindSA = 1; break;
								case 18:  strcpy_secure(cNpcName, "Zombie");       iProbSA = 15; iKindSA = 3; break;
								case 11:  strcpy_secure(cNpcName, "Skeleton");     iProbSA = 35; iKindSA = 8; break;
								case 6:   strcpy_secure(cNpcName, "Orc-Mage");     iProbSA = 30; iKindSA = 7; break;
								case 17:  strcpy_secure(cNpcName, "Scorpion");     iProbSA = 15; iKindSA = 3; break;
								case 12:  strcpy_secure(cNpcName, "Stone-Golem");  iProbSA = 25; iKindSA = 5; break;
								case 13:  strcpy_secure(cNpcName, "Cyclops");      iProbSA = 35; iKindSA = 8; break;
								case 22:  strcpy_secure(cNpcName, "Amphis");       iProbSA = 20; iKindSA = 3; break;
								case 23:  strcpy_secure(cNpcName, "Clay-Golem");   iProbSA = 20; iKindSA = 5; break;
								case 24:  strcpy_secure(cNpcName, "Guard-Aresden"); iProbSA = 20; iKindSA = 1; break;
								case 25:  strcpy_secure(cNpcName, "Guard-Elvine"); iProbSA = 20; iKindSA = 1; break;
								case 26:  strcpy_secure(cNpcName, "Guard-Neutral"); iProbSA = 20; iKindSA = 1; break;
								case 27:  strcpy_secure(cNpcName, "Hellbound");    iProbSA = 20; iKindSA = 1; break;
								case 28:  strcpy_secure(cNpcName, "Troll");		   iProbSA = 20; iKindSA = 1; break;
								case 29:  strcpy_secure(cNpcName, "Orge");         iProbSA = 20; iKindSA = 1; break;
								case 30:  strcpy_secure(cNpcName, "Liche");        iProbSA = 30; iKindSA = 8; break;
								case 31:  strcpy_secure(cNpcName, "Demon");        iProbSA = 20; iKindSA = 8; break;
								case 32:  strcpy_secure(cNpcName, "Unicorn");      iProbSA = 35; iKindSA = 7; break;
								case 33:  strcpy_secure(cNpcName, "WereWolf");     iProbSA = 25; iKindSA = 1; break;
								case 34:  strcpy_secure(cNpcName, "Dummy");        iProbSA = 5;  iKindSA = 1; break;
								case 35:  strcpy_secure(cNpcName, "Attack-Dummy"); iProbSA = 5;  iKindSA = 1; break;
								case 48:  strcpy_secure(cNpcName, "Stalker");      iProbSA = 20; iKindSA = 3; break;
								case 49:
									if (iDice(1, 40 * 60 * 60) == 13) {
										strcpy_secure(cNpcName, "Hellclaw");
										iProbSA = 20;
										iKindSA = 8;
									}
									break;

								case 50:
									if (iDice(1, 2 * 60 * 30) == 135) {
										strcpy_secure(cNpcName, "Tigerworm");
										iProbSA = 20;
										iKindSA = 8;
									}
									else {
										strcpy_secure(cNpcName, "Stalker");
										iProbSA = 15;
										iKindSA = 1;
									}
									break;

								case 51:  strcpy_secure(cNpcName, "Hellclaw");      iProbSA = 20; iKindSA = 8; break;
								case 52:  strcpy_secure(cNpcName, "Tigerworm");     iProbSA = 20; iKindSA = 8; break;
								case 53:  strcpy_secure(cNpcName, "Dark-Elf");      iProbSA = 20; iKindSA = 8; break;
								case 54:  strcpy_secure(cNpcName, "Beholder");      iProbSA = 20; iKindSA = 8; break;
								case 55:  strcpy_secure(cNpcName, "Gagoyle");       iProbSA = 20; iKindSA = 8; break;
								case 56:
									if (iDice(1, 2 * 60 * 30) == 13) {
										strcpy_secure(cNpcName, "Hellclaw");
										iProbSA = 20;
										iKindSA = 8;
									}
									break;

								case 57:   strcpy_secure(cNpcName, "Giant-Frog");		iProbSA = 10; iKindSA = 2; break;
								case 58:   strcpy_secure(cNpcName, "Mountain-Giant");	iProbSA = 25; iKindSA = 1; break;
								case 59:   strcpy_secure(cNpcName, "Ettin");			iProbSA = 20; iKindSA = 8; break;
								case 60:   strcpy_secure(cNpcName, "Cannibal-Plant");	iProbSA = 20; iKindSA = 5; break;
								case 61:   strcpy_secure(cNpcName, "Rudolph");			iProbSA = 20; iKindSA = 1; break;
								case 62:   strcpy_secure(cNpcName, "DireBoar");			iProbSA = 20; iKindSA = 1; break;
								case 63:   strcpy_secure(cNpcName, "Frost");			iProbSA = 20; iKindSA = 8; break;
								case 65:   strcpy_secure(cNpcName, "Ice-Golem");		iProbSA = 20; iKindSA = 8; break;
								case 66:   strcpy_secure(cNpcName, "Wyvern");			iProbSA = 20; iKindSA = 1; break;
								case 5:    strcpy_secure(cNpcName, "Rabbit");			iProbSA = 20; iKindSA = 1; break;
								case 67:   strcpy_secure(cNpcName, "McGaffin");			iProbSA = 20; iKindSA = 1; break;
								case 68:   strcpy_secure(cNpcName, "Perry");			iProbSA = 20; iKindSA = 1; break;
								case 69:   strcpy_secure(cNpcName, "Devlin");			iProbSA = 20; iKindSA = 1; break;
								case 70:   strcpy_secure(cNpcName, "Barlog");     iProbSA = 20; iKindSA = 1; break;
								case 71:   strcpy_secure(cNpcName, "Centaurus");  iProbSA = 20; iKindSA = 1; break;
								case 72:   strcpy_secure(cNpcName, "Claw-Turtle"); iProbSA = 20; iKindSA = 1; break;
								case 73:   strcpy_secure(cNpcName, "Fire-Wyvern"); iProbSA = 20; iKindSA = 1; break;
								case 74:   strcpy_secure(cNpcName, "Giant-Crayfish"); iProbSA = 20; iKindSA = 1; break;
								case 75:   strcpy_secure(cNpcName, "Giant-Lizard"); iProbSA = 20; iKindSA = 1; break;
								case 76:   strcpy_secure(cNpcName, "Giant-Plant"); iProbSA = 20; iKindSA = 1; break;
								case 77:   strcpy_secure(cNpcName, "MasterMage-Orc"); iProbSA = 20; iKindSA = 1; break;
								case 78:   strcpy_secure(cNpcName, "Minotaurs"); iProbSA = 20; iKindSA = 1; break;
								case 79:   strcpy_secure(cNpcName, "Nizie"); iProbSA = 20; iKindSA = 1; break;
								case 80:   strcpy_secure(cNpcName, "Tentocle"); iProbSA = 20; iKindSA = 1; break;
								case 81:   strcpy_secure(cNpcName, "Abaddon"); iProbSA = 20; iKindSA = 1; break;
								case 93:   strcpy_secure(cNpcName, "Ice-Worm"); iProbSA = 20; iKindSA = 1; break;
								case 94:   strcpy_secure(cNpcName, "Fire-Worm"); iProbSA = 20; iKindSA = 1; break;
								case 95:   strcpy_secure(cNpcName, "Blue-Demon"); iProbSA = 20; iKindSA = 1; break;
								case 96:   strcpy_secure(cNpcName, "Red-Demon"); iProbSA = 20; iKindSA = 1; break;
								case 97:   strcpy_secure(cNpcName, "Wood-Golem"); iProbSA = 20; iKindSA = 1; break;
								case 98:   strcpy_secure(cNpcName, "Ice-Lizard"); iProbSA = 20; iKindSA = 1; break;
								case 99:   strcpy_secure(cNpcName, "Butcher"); iProbSA = 20; iKindSA = 1; break;
								case 100:   strcpy_secure(cNpcName, "Snoob"); iProbSA = 20; iKindSA = 1; break;
								case 101:   strcpy_secure(cNpcName, "Fire-Snoob"); iProbSA = 20; iKindSA = 1; break;
								case 102:   strcpy_secure(cNpcName, "Satan"); iProbSA = 20; iKindSA = 1; break;
								case 103:   strcpy_secure(cNpcName, "Giant-Spider"); iProbSA = 20; iKindSA = 1; break;
								case 104:   strcpy_secure(cNpcName, "Diablo"); iProbSA = 20; iKindSA = 1; break;
								case 105:   strcpy_secure(cNpcName, "Phamton"); iProbSA = 20; iKindSA = 1; break;
								case 106:   strcpy_secure(cNpcName, "Yeti"); iProbSA = 20; iKindSA = 1; break;
								case 107:   strcpy_secure(cNpcName, "GrandEttin"); iProbSA = 20; iKindSA = 1; break;
								case 108:   strcpy_secure(cNpcName, "HellDeath"); iProbSA = 20; iKindSA = 1; break;
								case 109:   strcpy_secure(cNpcName, "LightWorm"); iProbSA = 20; iKindSA = 1; break;
								case 112:   strcpy_secure(cNpcName, "Houndeath"); iProbSA = 20; iKindSA = 1; break;
								case 113:   strcpy_secure(cNpcName, "Helliche"); iProbSA = 20; iKindSA = 1; break;
								case 114:   strcpy_secure(cNpcName, "DeathWyvern"); iProbSA = 20; iKindSA = 1; break;
								case 115:   strcpy_secure(cNpcName, "HellButcher"); iProbSA = 20; iKindSA = 1; break;
								case 116:   strcpy_secure(cNpcName, "HellTroll"); iProbSA = 20; iKindSA = 1; break;
								case 117:   strcpy_secure(cNpcName, "MountDeath"); iProbSA = 20; iKindSA = 1; break;
								case 118:   strcpy_secure(cNpcName, "Hellgoyle"); iProbSA = 20; iKindSA = 1; break;
								case 119:   strcpy_secure(cNpcName, "HellDemon"); iProbSA = 20; iKindSA = 1; break;
								case 120:   strcpy_secure(cNpcName, "HellAbaddon"); iProbSA = 20; iKindSA = 1; break;
								case 121:   strcpy_secure(cNpcName, "GhostAba"); iProbSA = 20; iKindSA = 1; break;
								case 122:   strcpy_secure(cNpcName, "Goblin"); iProbSA = 20; iKindSA = 1; break;
								case 123:   strcpy_secure(cNpcName, "GmGoblin"); iProbSA = 20; iKindSA = 1; break;
								case 124:   strcpy_secure(cNpcName, "Danny"); iProbSA = 20; iKindSA = 1; break;
								//Nuevos Guardias
								case 125:   strcpy_secure(cNpcName, "Guard_Sword-Aresden"); iProbSA = 20; iKindSA = 1; break;
								case 126:   strcpy_secure(cNpcName, "Guard_Sword-Elvine"); iProbSA = 20; iKindSA = 1; break;
								case 127:   strcpy_secure(cNpcName, "Guard_Sword-Neutral"); iProbSA = 20; iKindSA = 1; break;	
								case 128:   strcpy_secure(cNpcName, "Guard_Axe-Aresden"); iProbSA = 20; iKindSA = 1; break;
								case 129:   strcpy_secure(cNpcName, "Guard_Axe-Elvine"); iProbSA = 20; iKindSA = 1; break;
								case 130:   strcpy_secure(cNpcName, "Guard_Axe-Neutral"); iProbSA = 20; iKindSA = 1; break;
								case 131:   strcpy_secure(cNpcName, "Guard_Archer-Aresden"); iProbSA = 20; iKindSA = 1; break;
								case 132:   strcpy_secure(cNpcName, "Guard_Archer-Elvine"); iProbSA = 20; iKindSA = 1; break;
								case 133:   strcpy_secure(cNpcName, "Guard_Archer-Neutral"); iProbSA = 20; iKindSA = 1; break;
								//Nuevo BlackWyvern
								case 134:	strcpy_secure(cNpcName, "BlackWyvern"); iProbSA = 20; iKindSA = 1; break;
								default:
									strcpy_secure(cNpcName, "Orc");
									iProbSA = 15;
									iKindSA = 1;
									break;
							}

							// Spot Mob Generator�� FirmBersek
							bFirmBerserk = FALSE;
							if ((m_pMapList[i]->m_cRandomMobGeneratorLevel >= 9) && (iMapLevel >= 4) && (iDice(1, 3) == 1)) bFirmBerserk = TRUE;

							ZeroMemory(cName_Master, sizeof(cName_Master));
							wsprintf(cName_Master, "XX%d", iNamingValue);
							cName_Master[0] = '_';
							cName_Master[1] = i + 65;

							cSA = 0;
							if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1, 100) <= iProbSA)) {
								cSA = _cGetSpecialAbility(iKindSA);
							}

							switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
								case 1:
									// RANDOMAREA
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
									}
									else m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									break;

								case 2:
									// RANDOMWAYPOINT
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
									}
									else m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									break;
							}
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MobGenerator");
	}
#endif
}

void CMapServer::CalcNextWayPointDestination(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sRange, sX, sY;
		register int i, j, iMapIndex;
		BOOL bFlag;

		switch (m_pNpcList[iNpcH]->m_cMoveType) {
			case DEF_MOVETYPE_GUARD:
				break;

			case DEF_MOVETYPE_SEQWAYPOINT:
				m_pNpcList[iNpcH]->m_cCurWaypoint++;
				if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
					m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
				m_pNpcList[iNpcH]->m_dX = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[m_pNpcList[iNpcH]->m_iWayPointIndex[m_pNpcList[iNpcH]->m_cCurWaypoint]].x);
				m_pNpcList[iNpcH]->m_dY = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[m_pNpcList[iNpcH]->m_iWayPointIndex[m_pNpcList[iNpcH]->m_cCurWaypoint]].y);
				break;

			case DEF_MOVETYPE_RANDOMWAYPOINT:
				m_pNpcList[iNpcH]->m_cCurWaypoint = ((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
				m_pNpcList[iNpcH]->m_dX = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[m_pNpcList[iNpcH]->m_iWayPointIndex[m_pNpcList[iNpcH]->m_cCurWaypoint]].x);
				m_pNpcList[iNpcH]->m_dY = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[m_pNpcList[iNpcH]->m_iWayPointIndex[m_pNpcList[iNpcH]->m_cCurWaypoint]].y);
				break;

			case DEF_MOVETYPE_RANDOMAREA:
				sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
				m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
				sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
				m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
				break;

			case DEF_MOVETYPE_RANDOM:
				iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

				for (i = 0; i <= 30; i++) {
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

					bFlag = TRUE;
					for (j = 0; j < DEF_MAXMGAR; j++)
						if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
							if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
								(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
								(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
								(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {

								bFlag = FALSE;
							}
						}
					if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
				}
				m_pNpcList[iNpcH]->m_tmp_iError = 0;
				return;

			CNW_GET_VALIDLOC_SUCCESS:;
				m_pNpcList[iNpcH]->m_dX = sX;
				m_pNpcList[iNpcH]->m_dY = sY;
				break;
		}
		m_pNpcList[iNpcH]->m_tmp_iError = 0;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalcNextWayPointDestination");
	}
#endif
}


void CMapServer::RequestFullObjectData(int iClientH, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD * dwp;
		WORD  * wp, wObjectID;
		char  * cp, cData[100];
		short * sp, sX, sY;
		int   iTemp, iTemp2;
		int   * ip, iRet;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		wObjectID = *wp;

		ZeroMemory(cData, sizeof(cData));
		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_COMMON_EVENT_MOTION;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTSTOP;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		//6
		if (wObjectID < 10000) {
			if ((wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS)) return;
			if (m_pClientList[wObjectID] == NULL) return;

			wp = (WORD *)cp;
			*wp = wObjectID;			// ObjectID
			cp += 2;
			//8
			sp = (short *)cp;
			sX = m_pClientList[wObjectID]->m_sX;
			*sp = sX;
			cp += 2;
			//10
			sp = (short *)cp;
			sY = m_pClientList[wObjectID]->m_sY;
			*sp = sY;
			cp += 2;
			//12
			sp = (short *)cp;
			*sp = m_pClientList[wObjectID]->m_sType;
			cp += 2;
			//14
			*cp = m_pClientList[wObjectID]->m_cDir;
			cp++;
			//15
			memcpy_secure(cp, m_pClientList[wObjectID]->m_cCharName, 10);
			cp += 10;
			//25
			sp = (short *)cp;
			*sp = m_pClientList[wObjectID]->m_sAppr1;
			cp += 2;
			//27
			sp = (short *)cp;
			*sp = m_pClientList[wObjectID]->m_sAppr2;
			cp += 2;
			//29
			sp = (short *)cp;
			*sp = m_pClientList[wObjectID]->m_sAppr3;
			cp += 2;
			//31
			sp = (short *)cp;
			*sp = m_pClientList[wObjectID]->m_sAppr4;
			cp += 2;
			//33
			//v1.4 ApprColor
			ip = (int *)cp;
			*ip = m_pClientList[wObjectID]->m_iApprColor;
			cp += 4;

			// New Colors -> ZeroEoyPnk
			ip = (int *)cp;
			*ip = m_pClientList[wObjectID]->m_iApprColor2;
			cp += 4;
			//37
			ip = (int *)cp;

			iTemp = m_pClientList[wObjectID]->m_iStatus;
			iTemp = 0x0FFFFFFF & iTemp; // ���� 4��Ʈ Ŭ����
			iTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
			iTemp = (iTemp | (iTemp2 << 28));

			*ip = iTemp;
			cp += 4;
			//41

			if (m_pClientList[wObjectID]->m_iAdminUserLevel > 0 && m_pClientList[wObjectID]->m_iAdminUserLevel <= 9)
				*cp = (char)m_pClientList[wObjectID]->m_iAdminUserLevel;
			else {
				if (m_pClientList[wObjectID]->OpenSell == TRUE) *cp = 99;
				else *cp = 0;
			}
			cp++; // 42

			if ((m_pClientList[wObjectID]->m_bIsKilled == TRUE) || (m_pClientList[wObjectID]->m_bSkillUsingStatus[19] == TRUE))
				*cp = 1;
			else *cp = 0;
			cp++; // 43

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 47); // v1.4  //dimencion
		}
		else {
			// NPC�� ������ ���Ѵ�.
			if (((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS)) return;
			if (m_pNpcList[wObjectID - 10000] == NULL) return;

			wp = (WORD *)cp;
			*wp = wObjectID;
			cp += 2;
			//8
			wObjectID -= 10000;

			sp = (short *)cp;
			sX = m_pNpcList[wObjectID]->m_sX;
			*sp = sX;
			cp += 2;
			//10
			sp = (short *)cp;
			sY = m_pNpcList[wObjectID]->m_sY;
			*sp = sY;
			cp += 2;
			//12
			sp = (short *)cp;
			*sp = m_pNpcList[wObjectID]->m_sType;
			cp += 2;
			//14
			*cp = m_pNpcList[wObjectID]->m_cDir;
			cp++;
			//15
			memcpy_secure(cp, m_pNpcList[wObjectID]->m_cName, 5);
			cp += 5;
			//20
			sp = (short *)cp;
			*sp = m_pNpcList[wObjectID]->m_sAppr2;
			cp += 2;
			//22
			ip = (int *)cp;

			iTemp = m_pNpcList[wObjectID]->m_iStatus;
			iTemp = 0x0FFFFFFF & iTemp; // ���� 4��Ʈ Ŭ����

			iTemp2 = iGetNpcRelationship(wObjectID, iClientH);
			iTemp = (iTemp | (iTemp2 << 28));
			*ip = iTemp;
			cp += 4;
			//26
			if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) *cp = 1;
			else *cp = 0;
			cp++;
			//27
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); // v2.23 // v1.4
		}

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestFullObjectData");
	}
#endif
}

int CMapServer::_iGetArrowItemIndex(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		if (m_pClientList[iClientH] == NULL) return -1;

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0))
					return i;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iGetArrowItemIndex");
	}
#endif
	return -1;
}

void CMapServer::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult, BOOL bIsLog)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

		if ((bIsLog == TRUE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_CONSUME)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EAT)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_USE_DEPLETE)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_USE_DEPLETE_DEST)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_MATERIAL)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 380)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 381)
			&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 382))
			_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

		ReleaseItemHandler(iClientH, sItemIndex, TRUE);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);

		delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
		iCalcTotalWeight(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ItemDepleteHandler");
	}
#endif
}

void CMapServer::NpcBehavior_Stop(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  cTargetType;
		short sTarget = NULL;
		BOOL  bFlag;

		if (m_pNpcList[iNpcH] == NULL) return;

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

		switch (m_pNpcList[iNpcH]->m_cActionLimit) {
			case 5:
				switch (m_pNpcList[iNpcH]->m_sType) {
					case 38: // Mana Collector
						if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
							bFlag = _bNpcBehavior_ManaCollector(iNpcH);
							if (bFlag == TRUE) {
								SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1);
							}
						}
						break;

					case 39: // Detector
						if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
							bFlag = _bNpcBehavior_Detector(iNpcH);
							if (bFlag == TRUE) {
								SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1);
							}
						}
						break;

					case 40: // Energy Shield Generator
						break;

					case 41: // Grand Magic Generator
						if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
							m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
							_NpcBehavior_GrandMagicGenerator(iNpcH);
						}
						break;

					case 42: // ManaStone: v2.05 ���������� ���������� �������� 5�� �����Ѵ�.
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[iNpcH]->m_iV1 += 5;
						if (m_pNpcList[iNpcH]->m_iV1 >= 5) m_pNpcList[iNpcH]->m_iV1 = 5;
						break;

					default:
						TargetSearch(iNpcH, &sTarget, &cTargetType);
						break;
				}
				break;
		}

		if ((sTarget != NULL)) {
			m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType = cTargetType;
			return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcBehavior_Stop");
	}
#endif
}

void CMapServer::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iTemp, iMax, Cbs, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
		DWORD dwTime;
		short sTemp, sTmpType, sTmpAppr1;
		char cSlateType[20], cTxt[512];
		SYSTEMTIME SysTime;
		GetLocalTime(&SysTime);
		int iNamingValue;
		short m_sCandyInsert;
		short m_sCandyDelete;


		dwTime = timeGetTime();
		ZeroMemory(cSlateType, sizeof(cSlateType));
		ZeroMemory(cTxt, sizeof(cTxt));

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3052) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3053) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3054) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3055) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST)) {

		}
		else return;

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3052) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3053) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3054) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME &&
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 3055) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT)) {

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
				case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5 �ص� �þ�. 
					if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 1) {
						bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1 * 1000),
							iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
					}
					m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
					break;

				case DEF_ITEMEFFECTTYPE_SLATES:
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
						// Full Ancient Slate ??
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
							switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
								case 2: // Bezerk slate
									m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = TRUE;
									SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
										iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);
									strcpy_secure(cSlateType, "Berserk");
									break;

								case 1: // Invincible slate
									if (strlen(cSlateType) == 0) strcpy_secure(cSlateType, "Invincible");
								case 3: // Mana slate
									if (strlen(cSlateType) == 0) strcpy_secure(cSlateType, "Mana");
								case 4: // Exp slate
									if (strlen(cSlateType) == 0) strcpy_secure(cSlateType, "Exp");

									SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, TRUE);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2,
										dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

									switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
										case 1: iEffectResult = 4; break;
										case 3: iEffectResult = 5; break;
										case 4: iEffectResult = 6; break;
									}
							}
						}
					}
					break;

				case DEF_ITEMEFFECTTYPE_HP:
					iMax = iGetMaxHP(iClientH);
					if (m_pClientList[iClientH]->m_iHP < iMax) {
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
							iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
							iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
						}
						else {
							iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
							iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
							if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 908) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 909) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 910) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 911))
								iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3; //corregir para angel
							else iV3 = 0;
						}

						m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3);
						if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
						if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

						iEffectResult = 1;
					}
					break;


				case DEF_ITEMEFFECTTYPE_MP:
					iMax = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2);
					if (m_pClientList[iClientH]->m_iMP < iMax) {
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
							iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
							iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
						}
						else {
							iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
							iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
							if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 908) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 909) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 910) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 911))
								iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3; //corregir para angel
							else iV3 = 0;
						}

						m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3);
						if (m_pClientList[iClientH]->m_iMP > iMax)
							m_pClientList[iClientH]->m_iMP = iMax;

						iEffectResult = 2;
					}
					break;

				case DEF_ITEMEFFECTTYPE_SP:
					iMax = (2 * (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr)) + (2 * m_pClientList[iClientH]->m_iLevel);
					if (m_pClientList[iClientH]->m_iSP < iMax) {
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
							iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
							iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
						}
						else {
							iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
							iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
							if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 908) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 909) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 910) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 911))
								iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3; //corregir para angel
							else iV3 = 0;
						}

						m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3);
						if (m_pClientList[iClientH]->m_iSP > iMax)
							m_pClientList[iClientH]->m_iSP = iMax;

						iEffectResult = 3;
					}

					if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
						m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
						SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
					}
					break;

				case DEF_ITEMEFFECTTYPE_HPSTOCK:
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;

					m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
					if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
					if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

					m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
					if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
					if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
					break;

				case DEF_ITEMEFFECTTYPE_STUDYSKILL:
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					if (iSEV1 == 0) TrainSkillResponse(TRUE, iClientH, iV1, iV2);
					else TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
					break;

				case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					if (m_pMagicConfigList[iV1] != NULL)
						RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, FALSE);
					break;

				case DEF_ITEMEFFECTTYPE_MAGIC:
					if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
						SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

						bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
						m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
					}

					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
						case 1:// creo q es este el case del ticket del recall hay que poner q si es lvl mayor a 179 return...
							
							if (bCheckIfIsFlagCarrier(iClientH))
								ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
							else if (m_pClientList[iClientH]->m_iLevel > 179) 
							{
								ShowClientMsg(iClientH, "Este item solo funciona hasta el nivel 179.");
							}
							else if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
								ShowClientMsg(iClientH, "No puedes usar este item en el evento.");
							else {
								if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
									(m_pClientList[iClientH]->m_bIsKilled == FALSE) && (m_pClientList[iClientH]->m_iHP > 0)) {
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
								}
								else {
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 == 1) {
										if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0)
											RequestTeleportHandler(iClientH, "2   ", "elvine", -1, -1);
										else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
											RequestTeleportHandler(iClientH, "2   ", "aresden", -1, -1);
										else RequestTeleportHandler(iClientH, "1   ");
									}
									else RequestTeleportHandler(iClientH, "1   ");
								}
							}
							break;

						case 2:
							if (bCheckIfIsFlagCarrier(iClientH))
								ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
							else if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
								ShowClientMsg(iClientH, "No puedes usar este item en el evento.");
							else PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
							break;

						case 3:
							if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
							break;


						case 4:
							int z;
							z = 0;
							// fixed location teleportation: ÀÔÀå±Ç µîµî
							switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
								case 1:
									if (bCheckIfIsFlagCarrier(iClientH))
										ShowClientMsg(iClientH, "You can not use that item being a flag carrier.");
									else if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0))
										ShowClientMsg(iClientH, "No puedes usar este item, en el evento.");
									else {
										if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
											ItemDepleteHandler(iClientH, sItemIndex, TRUE, TRUE);
											RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
										}
									}
									break;

									//NetBox(Big) - ZeroEoyPnk
								case 2:
									if (_iGetItemSpaceLeft(iClientH) == 0) {
										SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
										return;
									}
									PandoraBox(iClientH, 2);
									break;

									//NetBox(Medium) - ZeroEoyPnk
								case 3:
									if (_iGetItemSpaceLeft(iClientH) == 0) {
										SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
										return;
									}
									PandoraBox(iClientH, 1);
									break;

									//NetBox(Small) - ZeroEoyPnk
								case 4:
									if (_iGetItemSpaceLeft(iClientH) == 0) {
										SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
										return;
									}
									PandoraBox(iClientH, 0);
									break;

								case 5:
									PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
									break;

								case 6: // Teleports Scrolls
									char cDestMapName[11];
									ZeroMemory(cDestMapName, sizeof(cDestMapName));
									wsprintf(cDestMapName, "VipMap%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3);
									if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
										ItemDepleteHandler(iClientH, sItemIndex, TRUE);
										RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
									}
									break;

								case 11:
								case 12:
								case 13:
								case 14:
								case 15:
								case 16:
								case 17:
								case 18:
								case 19:
									if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) |
										(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
										(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour)) {
									}
									else {
										char cDestMapName[11];
										ZeroMemory(cDestMapName, sizeof(cDestMapName));
										wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
										if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
											//v1.42
											ItemDepleteHandler(iClientH, sItemIndex, TRUE);
											// v2.16 2002-6-2 �����ǵ� ���������� ���� �Ұ����ϰ� �ϱ�����
											RequestTeleportHandler(iClientH, "3   ", cDestMapName, -1, -1);
										}
									}
									break;
							}
							break;
					}
					break;

				case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
					m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20 * 30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20 * 30; // �ִ� 30�а� 
					break;
					//RepPotions+
				case DEF_ITEMEFFECTTYPE_ADDREPUTATION:
					/*if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 0) && (m_pClientList[iClientH]->m_iRating < 0))
						m_pClientList[iClientH]->m_iRating = 0;
					else m_pClientList[iClientH]->m_iRating += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
					if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
					SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);*/
					break;
					//RepPotion-
				case DEF_ITEMEFFECTTYPE_DEDUCTREPUTATION:
					/*if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 0) && (m_pClientList[iClientH]->m_iRating > 0))
						m_pClientList[iClientH]->m_iRating = 0;
					else m_pClientList[iClientH]->m_iRating -= m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
					if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
					SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);*/
					break;
					//ticket Rankup+1
				case DEF_ITEMEFFECTTYPE_RANKUPDIEZ:
					if (m_pClientList[iClientH] == NULL) return;

					if ((m_pClientList[iClientH]->m_sRankLevel >= 0) && (m_pClientList[iClientH]->m_sRankLevel < 10))
					{
						m_pClientList[iClientH]->m_iRankExp = 0;
						m_pClientList[iClientH]->m_sRankLevel++;
						m_pClientList[iClientH]->m_iRankPoints++;
						notify_rankup(iClientH);
						send_objects_data();
						notify_rankexp(iClientH);
					}
					else
					{
						ShowClientMsg(iClientH, "Use this ticket to increase Rank between lvl 0 and 10!");
						return;
					}
					break;

				case DEF_ITEMEFFECTTYPE_RANKUPVEINTE:
					if (m_pClientList[iClientH] == NULL) return;

					if ((m_pClientList[iClientH]->m_sRankLevel >= 0) && (m_pClientList[iClientH]->m_sRankLevel < 20))
					{
						m_pClientList[iClientH]->m_iRankExp = 0;
						m_pClientList[iClientH]->m_sRankLevel++;
						m_pClientList[iClientH]->m_iRankPoints++;
						notify_rankup(iClientH);
						send_objects_data();
						notify_rankexp(iClientH);
					}
					else
					{
						ShowClientMsg(iClientH, "Use this ticket to increase Rank between lvl 0 and 20!");
						return;
					}
					break;

				case DEF_ITEMEFFECTTYPE_RANKUPMAX:
					if (m_pClientList[iClientH] == NULL) return;

					if ((m_pClientList[iClientH]->m_sRankLevel >= 0) && (m_pClientList[iClientH]->m_sRankLevel < 30))
					{
						m_pClientList[iClientH]->m_iRankExp = 0;
						m_pClientList[iClientH]->m_sRankLevel++;
						m_pClientList[iClientH]->m_iRankPoints++;
						notify_rankup(iClientH);
						send_objects_data();
						notify_rankexp(iClientH);
					}
					else
					{
						ShowClientMsg(iClientH, "Use this ticket to increase Rank between lvl 0 and 30!.");
						return;
					}
					break;

				case DEF_ITEMEFFECTTYPE_CANDYINSERT:
					if (m_pClientList[iClientH] == NULL) return;

					if (m_pClientList[iClientH]->m_sCandyInsert == NULL)
					{
						m_pClientList[iClientH]->m_sCandyInsert = true;
						NotifyCInsert(iClientH);
						ShowClientMsg(iClientH, "RedCandy with Insert Enabled.");
						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
					}
					else
					{
						ShowClientMsg(iClientH, "You already have RedCandy with Insert Enabled.");
						return;
					}
					break;
				case DEF_ITEMEFFECTTYPE_CANDYSUPRIMIR:
					if (m_pClientList[iClientH] == NULL) return;

					if (m_pClientList[iClientH]->m_sCandyDelete == NULL)
					{
						m_pClientList[iClientH]->m_sCandyDelete = true;
						NotifyCDelete(iClientH);
						ShowClientMsg(iClientH, "BlueCandy with Delete Enabled.");
						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
					}
					else
					{
						ShowClientMsg(iClientH, "You already have BlueCandy with Delete Enabled.");
						return;
					}
					break;

					//LaloRamos CriticalsBall
				case DEF_ITEMEFFECTTYPE_ADDCRITICALS:
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 0) && (m_pClientList[iClientH]->m_iSuperAttackLeft < 0))
						m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
					else {
						if (m_pClientList[iClientH]->m_iSuperAttackLeft >= 99900) {
							if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 100) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, "Maximum amounts of critical allowed");
								m_pClientList[iClientH]->m_iContribution += 100;
								SendContribution(iClientH);
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, "Added 100 Contribution for Crit Ball consumed");
							}
							else {
								if (m_pClientList[iClientH]->m_iSuperAttackLeft >= 99000) {
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, "Maximum amounts of critical allowed");
									m_pClientList[iClientH]->m_iContribution += 1000;
									SendContribution(iClientH);
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, "Added 1000 Contribution for Crit Ball consumed");
								}
								else m_pClientList[iClientH]->m_iSuperAttackLeft += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							}
						}
						else m_pClientList[iClientH]->m_iSuperAttackLeft += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;

						SendCriticals(iClientH);
					}
					break;

				case ITEMEFFECTTYPE_BALL:
				{
					auto val = m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetBallValue();
					switch ((BItemID)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum)
					{
					case BItemID::ContributionBall:
						m_pClientList[iClientH]->m_iContribution += val;
						SendCommand(iClientH, "/contrib", m_pClientList[iClientH]->m_iContribution);
						wsprintf(G_cTxt, "You get %d of contribution from contribball", val);
						ShowClientMsg(iClientH, G_cTxt);
						break;

					case BItemID::MajesticBall:
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += val;
						SendCommand(iClientH, "/majs", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
						wsprintf(G_cTxt, "You get %d of majestics from majball", val);
						ShowClientMsg(iClientH, G_cTxt);
						break;

					case BItemID::CoinBall:
						m_pClientList[iClientH]->m_iCoins += val;
						SendCommand(iClientH, "/coins", m_pClientList[iClientH]->m_iCoins);
						wsprintf(G_cTxt, "You get %d of coins from coinball", val);
						ShowClientMsg(iClientH, G_cTxt);
						break;

					case BItemID::RepBall:						
						m_pClientList[iClientH]->m_iRating += val;
						if (m_pClientList[iClientH]->m_iRating > DEF_LIMIT_REP) m_pClientList[iClientH]->m_iRating = DEF_LIMIT_REP;
						SendCommand(iClientH, "/rep", m_pClientList[iClientH]->m_iRating);
						wsprintf(G_cTxt, "You get %d of reputation from repball", val);
						ShowClientMsg(iClientH, G_cTxt);
						break;
					}
					break;
				}
					//LaloRamos ContribBall
				case DEF_ITEMEFFECTTYPE_CONTRIBUTION:
				case DEF_ITEMEFFECTTYPE_ADDCOINS:
					/*iMax = 3000000;//
					if (DEF_ITEMEFFECTTYPE_CONTRIBUTION == m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
						if (m_pClientList[iClientH]->m_iContribution > iMax) return;
					}
					if (DEF_ITEMEFFECTTYPE_ADDCOINS == m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
						if (m_pClientList[iClientH]->m_iCoins > iMax) return;
					}

					Cbs = 5;
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
						case 1:	break; // 5
						case 2: Cbs *= 2; break; // 10
						case 3: Cbs *= 4; break; // 20
						case 4: Cbs *= 10; break; // 50
						case 5: Cbs *= 20; break; // 100
						case 6: Cbs *= 40; break; // 200
						case 7:	Cbs *= 100; break; // 500
						case 8:	Cbs *= 140; break; // 700
						case 9:	Cbs *= 200; break; // 1000
						case 10: Cbs *= 1000; break; // 5000
						case 11: Cbs *= 2000; break; // 10000
						case 12: Cbs *= 4000; break; // 20000
						case 13: Cbs *= 10000; break; // 50000
						case 14: Cbs *= 20000; break; // 100000
						default: break;
					}
					if (DEF_ITEMEFFECTTYPE_CONTRIBUTION == m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
						m_pClientList[iClientH]->m_iContribution += Cbs;  //la cantidad que quieras
						SendContribution(iClientH);
					}
					else if (DEF_ITEMEFFECTTYPE_ADDCOINS == m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
						m_pClientList[iClientH]->m_iCoins += Cbs;  //la cantidad que quieras
						wsprintf(cTxt, "Character: %s - Coins Obteined: %d - Total Coins: %d - CoinBall", m_pClientList[iClientH]->m_cCharName, Cbs, m_pClientList[iClientH]->m_iCoins);

						PutLogCoinsFileList(cTxt);
						if ((m_pClientList[iClientH]->m_iCoins >= 500) && (!m_pClientList[iClientH]->Achivements[12].Complete))
							CheckCompleteAchivement(iClientH, 12, TRUE);
						SendNotifyMsg(iClientH, NULL, CLIENT_NOTIFY_COINS, m_pClientList[iClientH]->m_iCoins, NULL, NULL, NULL);
						ShowClientMsg(iClientH, "Coins Obteined");*/
					//}
					break;

				case DEF_ITEMEFFECTTYPE_SUMMONBALL:
					break;

				case DEF_ITEMEFFECTTYPE_CHANGEATTR:
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
						case 1:
							m_pClientList[iClientH]->m_cHairColor++;
							if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

							sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
							m_pClientList[iClientH]->m_sAppr1 = sTemp;
							break;

						case 2:
							m_pClientList[iClientH]->m_cHairStyle++;
							if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

							sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
							m_pClientList[iClientH]->m_sAppr1 = sTemp;
							break;

						case 3:
							m_pClientList[iClientH]->m_cSkin++;
							if (m_pClientList[iClientH]->m_cSkin > 3)
								m_pClientList[iClientH]->m_cSkin = 1;

							if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
							else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4;

							switch (m_pClientList[iClientH]->m_cSkin) {
								case 2:	sTemp += 1; break;
								case 3:	sTemp += 2; break;
							}
							m_pClientList[iClientH]->m_sType = sTemp;
							break;

						case 4:
							sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
							if (sTemp == 0) {
								if (m_pClientList[iClientH]->m_cSex == 1)
									m_pClientList[iClientH]->m_cSex = 2;
								else m_pClientList[iClientH]->m_cSex = 1;

								if (m_pClientList[iClientH]->m_cSex == 1) sTmpType = 1;
								else if (m_pClientList[iClientH]->m_cSex == 2) sTmpType = 4;

								switch (m_pClientList[iClientH]->m_cSkin) {
									case 1: break;
									case 2: sTmpType += 1; break;
									case 3: sTmpType += 2; break;
								}

								sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
								m_pClientList[iClientH]->m_sType = sTmpType;
								m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;
							}
							break;

						case 5: // v2.16 2002-5-27 �ӿ� ��ȯ �þ� �߰� 
							m_pClientList[iClientH]->m_cUnderwear++;
							if (m_pClientList[iClientH]->m_cUnderwear > 7) m_pClientList[iClientH]->m_cUnderwear = 0;

							sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
							m_pClientList[iClientH]->m_sAppr1 = sTemp;
							break;
					}

					SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;
			}
			// *** Request Teleport Handler
			ItemDepleteHandler(iClientH, sItemIndex, TRUE);

			switch (iEffectResult) {
				case 1:
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
					break;
				case 2:
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
					break;
				case 3:
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
					break;
				case 4: // Invincible
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
					break;
				case 5: // Mana
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
					break;
				case 6: // EXP
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
					break;
				default:
					break;
			}
		}
		else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
			if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE)
				ItemDepleteHandler(iClientH, sItemIndex, TRUE);
		}
		else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
		}
		else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) ||
				(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
				(m_pClientList[iClientH]->m_bSkillUsingStatus[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] == TRUE)) {
				return;
			}
			else {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0) {
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
					}
					else {
						int iSkillUsingTimeID = (int)timeGetTime();

						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill,
							dwTime + m_pSkillConfigList[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill]->m_sValue2 * 1000,
							iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY,
							m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill], iSkillUsingTimeID, NULL);

						m_pClientList[iClientH]->m_bSkillUsingStatus[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] = TRUE;
						m_pClientList[iClientH]->m_iSkillUsingTimeID[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] = iSkillUsingTimeID; //v1.12
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UseItemHandler");
	}
#endif
}

void CMapServer::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
		char cAttackerSide, cDamageMoveDir;
		DWORD dwTime;
		register double dTmp1, dTmp2, dTmp3;
		short sAtkX = 0, sAtkY = 0, sTgtX, sTgtY, dX, dY, sItemIndex;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH] == NULL) return;
			if ((m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) && (m_pClientList[sAttackerH]->m_iAdminUserLevel < 5)) return;
		}

		if (cAttackerType == DEF_OWNERTYPE_NPC)
			if (m_pNpcList[sAttackerH] == NULL) return;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER && cTargetType == DEF_OWNERTYPE_PLAYER) {
			if (memcmp(m_pClientList[sTargetH]->m_cMapName, "VipMap1", 7) == 0) return;
			//Safe en Event Garden
			if (memcmp(m_pClientList[sTargetH]->m_cMapName, "areuni", 6) == 0) return;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sTargetH] == NULL) return;
			if (m_pClientList[sTargetH]->m_iAdminUserLevel >= 1) return;
		}

		dwTime = timeGetTime();

		iDamage = iDice(sV1, sV2) + sV3;
		if (iDamage <= 0) iDamage = 0;

		iPartyID = 0;
		switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0 && m_pClientList[sAttackerH]->m_iAdminUserLevel < 3) return;

				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || //BerserkWand
						m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) { //BerserkWand
						//iDamage += (int)(iDamage*1.2);
						iDamage += (int)(iDamage*1.1);
					}
					//ms20 dmg
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 683 || //683	WizMagicWand(MS20)
						m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 684) { //684	WizMagicWand(MS10)
						iDamage += (int)(iDamage*0.1);
					}

					//chaosheroWand dmg add
					else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 2090) {
						iDamage += (iDamage*1.6);
					}
					//3116	BlackZWand(MS.32)
					else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 3116) {
						iDamage += (iDamage*1.3);
					}
					//WorldWar - LaloRamos - Aumento DMg Magico
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "FightMap") == 0) {
						iDamage += iDamage / 3;
					}

					//WorldWarII - LaloRamos - Aumento DMg Magico
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "WorldMap") == 0) {
						iDamage += iDamage / 2;
					}

					//All Eks - LaloRamos - DMG Bonus
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "evento13") == 0) {
						iDamage += iDamage / 3;
					}

					//All Dk Eks - LaloRamos - DMG Bonus
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "evento14") == 0) {
						iDamage += iDamage / 3;
					}

					//EventDk - LaloRamos - DMG Bonus
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "EventDk") == 0) {
						iDamage += iDamage / 3;
					}

					//FinalFight - LaloRamos - Aumento DMg Magico
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "Counter") == 0) {
						iDamage += iDamage / 3;
					}
					//Nueva Funcion Kloness Vs Assasain
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || //KlonessWand(MS.30)
						m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) { //KlonessWand(MS.10)
						if (m_pClientList[sAttackerH]->m_iRating > 0) {
							iRepDamage = m_pClientList[sAttackerH]->m_iRating / 200;
							iDamage += iRepDamage;
							if (cTargetType == DEF_OWNERTYPE_PLAYER) {
								if (m_pClientList[sTargetH] != NULL) {
									if (m_pClientList[sTargetH]->m_iRating < 0) {
										iRepDamage = abs(m_pClientList[sTargetH]->m_iRating) / 100;
										iDamage += iRepDamage / 4;
									}
									// Bonus Victima KWands
									else if (m_pClientList[sTargetH]->m_iRating > 0) {
										iRepDamage = m_pClientList[sTargetH]->m_iRating / 200;
										iDamage -= iRepDamage / 4;
									}
									if ((m_pClientList[sTargetH]->Assasain) && (m_pClientList[sTargetH]->m_iRating > 0)) {
										iRepDamage = abs(m_pClientList[sTargetH]->m_iRating) / 100;
										iDamage += iRepDamage / 2;
										//	}
									}
								}
							}
						}
					}

					// Aca Lalin
					if (m_pClientList[sAttackerH]->Assasain == TRUE) {
						if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 4973) || //AssasainWand(MS.40)	
							(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 4974)) { //AssasainWand(MS.20)		
							if (m_pClientList[sAttackerH]->m_iRating < 0) {
								iRepDamage = abs(m_pClientList[sAttackerH]->m_iRating) / 200; //100
								iDamage += iRepDamage; // / 2;
								if (cTargetType == DEF_OWNERTYPE_PLAYER) {
									if (m_pClientList[sTargetH] != NULL) {
										if (m_pClientList[sTargetH]->m_iRating > 0) {
											iRepDamage = m_pClientList[sTargetH]->m_iRating / 100;
											iDamage += iRepDamage / 4;
										}
										else if (m_pClientList[sTargetH]->m_iRating < 0) {
											iRepDamage = m_pClientList[sTargetH]->m_iRating / 100;
											iDamage += iRepDamage / 4;
										}
									}
								}
							}
						}
					}
				}

				if (m_bIsCrusadeMode == FALSE && (m_pClientList[sAttackerH]->m_bIsHunter == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

				dTmp1 = (double)iDamage;
				if ((m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_sRankAddMag + m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
					dTmp2 = 1.0f;
				else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_sRankAddMag + m_pClientList[sAttackerH]->m_iAngelicMag);

				dTmp2 = dTmp2 / 3.3f;
				dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
				iDamage = (int)(dTmp3 + 0.5f);

				if (iDamage <= 0) iDamage = 0;

				iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
					iDamage += iDamage / 3;

				if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
					if (m_pClientList[sAttackerH]->m_iLevel <= 80) iDamage += (iDamage * 7) / 10;
					else if (m_pClientList[sAttackerH]->m_iLevel <= 100) iDamage += iDamage / 2;
					else iDamage += iDamage / 2;
				}

				cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
				sAtkX = m_pClientList[sAttackerH]->m_sX;
				sAtkY = m_pClientList[sAttackerH]->m_sY;

				iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
				break;

			case DEF_OWNERTYPE_NPC:
				cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
				sAtkX = m_pNpcList[sAttackerH]->m_sX;
				sAtkY = m_pNpcList[sAttackerH]->m_sY;
				break;
		}

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return;
				if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
				if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

				if ((m_bIsCrusadeMode == FALSE) &&
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_bIsHunter == TRUE) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER)) return;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return;
				if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
				if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return;
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

				if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
						iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
						if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {}
						else {
							if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
								if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {}
								else return;
							}
							else return;
						}
					}
					if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
				}

				ClearSkillUsingStatus(sTargetH);

				switch (iAttr) {
					case 1:
						if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					case 2:
						if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					case 3:
						if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					case 4:
						if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					default:
						break;
				}

				iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
				if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
					switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
						case 335: // ���Ӷ��� ���� 20%
							dTmp1 = (double)iDamage;
							dTmp2 = dTmp1 * 0.2f;
							dTmp3 = dTmp1 - dTmp2;
							iDamage = (int)(dTmp3 + 0.5f);
							break;

						case 337: // ���� ���� 10%
							dTmp1 = (double)iDamage;
							dTmp2 = dTmp1 * 0.1f;
							dTmp3 = dTmp1 - dTmp2;
							iDamage = (int)(dTmp3 + 0.5f);
							break;
					}
					if (iDamage <= 0) iDamage = 0;

					iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
					if (iRemainLife <= iDamage) ItemDepleteHandler(sTargetH, iIndex, TRUE);
					else m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 70:
							m_pClientList[sAttackerH]->m_iHP -= iDamage;
							SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
							SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
							if (m_pClientList[sAttackerH]->m_iHP <= 0)
								ClientKilledHandler(sAttackerH, NULL, NULL, iDamage);
							iDamage = 0;
							break;
					}
				}

				//Fix Reflex LaloRamos
				if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
					dTmp3 = (dTmp2 / 100.0f)*dTmp1;
					iDamage = iDamage - (int)dTmp3;
				}

				// fix lalo ramos
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
					if (iDamage <= 0) iDamage = 0;//1 //0
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) &&
					(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
					iDamage = m_pClientList[sTargetH]->m_iHP - 1;
				}
				switch (cAttackerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
							iDamage = iDamage / 2;
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sAttackerH]->m_sType != 65)
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
								iDamage = iDamage / 2;
						break;
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 51:
						case 52:
							return;
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iDamage;
				if (m_pClientList[sTargetH]->m_iHP <= 0) ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
				else {
					if (iDamage > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iDamage;
							dTmp3 = (dTmp1 / 100.0f)*dTmp2 + 1.0f;

							iTemp = (2 * (m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_sRankAddMag + m_pClientList[sTargetH]->m_iAngelicMag)) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt + m_pClientList[sTargetH]->m_sRankAddInt + m_pClientList[sTargetH]->m_iAngelicInt) / 2);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}

						// fix lalo ramos
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							if (iDice(1, 100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);//10
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) {
									m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendCriticals(sTargetH);
								}
							}
						}

						//No recall por 10 segundos - ZeroEoyPnk
						m_pClientList[sTargetH]->m_bRecall = FALSE;
						m_pClientList[sTargetH]->RecallTime = dwTime;
						SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

						if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
							m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
							m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
							// Hold-Person �Ǿ� �־��� ���¶��� Ǯ����. �������� �з������� �� �͵� Ǯ����.
							// 1: Hold-Person 
							// 2: Paralize
							SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

							m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}
					}
				}

				sTgtX = m_pClientList[sTargetH]->m_sX;
				sTgtY = m_pClientList[sTargetH]->m_sY;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sTargetH] == NULL) return;
				if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
				if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

				sTgtX = m_pNpcList[sTargetH]->m_sX;
				sTgtY = m_pNpcList[sTargetH]->m_sY;

				switch (m_pNpcList[sTargetH]->m_cActionLimit) {
					case 1:
					case 2:
					case 6: // v2.20 2002-12-20 ���� NPC ���� �ʵǰ� 
						return;

					case 4: // �¾��� ���� �̵��ϴ� ������Ʈ.
						if (sTgtX == sAtkX) {
							if (sTgtY == sAtkY) return;
							else if (sTgtY > sAtkY) cDamageMoveDir = 5;
							else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}
						else if (sTgtX > sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 3;
							else if (sTgtY > sAtkY) cDamageMoveDir = 4;
							else if (sTgtY < sAtkY) cDamageMoveDir = 2;
						}
						else if (sTgtX < sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 7;
							else if (sTgtY > sAtkY) cDamageMoveDir = 6;
							else if (sTgtY < sAtkY) cDamageMoveDir = 8;
						}

						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
							cDamageMoveDir = iDice(1, 8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
						}

						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX = dX;
						m_pNpcList[sTargetH]->m_sY = dY;
						m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
							cDamageMoveDir = iDice(1, 8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
						}

						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX = dX;
						m_pNpcList[sTargetH]->m_sY = dY;
						m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

						if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) DeleteNpc(sTargetH);
						return;
				}

				if (RunSummonEvent == TRUE || RunSummonEvent2 == TRUE || RunSummonEvent3 == TRUE) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 38:
						case 39:
							return;
					}
				}

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 36:
						case 37:
						case 38:
						case 39:
						case 40:
						case 41:
						case 87:
						case 89:
							if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
							break;

						case 64:
							if (m_bIsCrusadeMode == TRUE) return;
							break;
						case 92:
							if ((m_bIsRushNetMode) || (HellOfDeath)) {
								//Reliquia elvine
								if ((!HellOfDeath) && (!AttackElvine) && (m_pNpcList[sTargetH]->m_cSide == 2)) return;
								else {
									if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
								}

								//Reliquia Aresden
								if ((!HellOfDeath) && (!AttackAresden) && (m_pNpcList[sTargetH]->m_cSide == 1)) return;
								else {
									if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
								}
							}
							break;
					}
				}

				if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
					dTmp3 = dTmp1 * dTmp2;
					dTmp2 = dTmp1 - dTmp3;
					iDamage = (int)dTmp2;
					if (iDamage < 0) iDamage = 1;
				}

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
					iDamage = iDamage / 2;

				m_pNpcList[sTargetH]->m_iHP -= iDamage;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER && cTargetType == DEF_OWNERTYPE_NPC)
				{
					if (m_pClientList[sAttackerH] != NULL && m_pNpcList[sTargetH] != NULL)
					{
						if (m_pNpcList[sTargetH]->m_iHP > m_pNpcList[sTargetH]->m_iMaxHP) m_pNpcList[sTargetH]->m_iMaxHP = m_pNpcList[sTargetH]->m_iHP;
						notifyNpcHealth(sAttackerH, sTargetH);
					}
				}

				if (m_pNpcList[sTargetH]->m_iHP < 0) NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				else {
					switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
								&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
							break;
					}

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

					if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
						if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
							(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
							(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

						// ActionLimit�� 1�̸� �ݰ��� ���� �ʴ´�. ���� �����ϼ��� ������.
						m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;

						// Damage�� ���� �������� ���� ����ȿ��.
						m_pNpcList[sTargetH]->m_dwTime = dwTime;

						if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
							// Hold �Ǿ� �־��� ���¶��� Ǯ����. 	
							m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
						}

						// Crusade
						int iExp;

						// NPC�� ���� ������ ���������Ƿ� �����ڰ� �÷��̾����� ���� ������ ��ŭ�� ����ġ�� �����ڿ��� �ش�. 
						if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) &&
							(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
							// ExpStock�� �ø���. �� ��ȯ���� ���� ����ġ�� �ø��� �ʴ´�.
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
								// Crusade
								iExp = iDamage;
								if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

								if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
									dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
									dTmp2 = (double)iExp;
									dTmp3 = (dTmp1 / 100.0f)*dTmp2;
									iExp += (int)dTmp3;
								}

								if (m_pClientList[sAttackerH]->m_iLevel > 100) {
									switch (m_pNpcList[sTargetH]->m_sType) {
										case 55:
										case 56:
											iExp = 0;
											break;
										default: break;
									}
								}

								if (bExp == TRUE) GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
								else GetExp(sAttackerH, (iExp / 2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
								m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
							}
							else {
								// Crusade
								iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
								if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

								if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
									dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
									dTmp2 = (double)iExp;
									dTmp3 = (dTmp1 / 100.0f)*dTmp2;
									iExp += (int)dTmp3;
								}

								if (m_pClientList[sAttackerH]->m_iLevel > 100) {
									switch (m_pNpcList[sTargetH]->m_sType) {
										case 55:
										case 56:
											iExp = 0;
											break;
										default: break;
									}
								}

								if (bExp == TRUE)
									GetExp(sAttackerH, iExp, TRUE); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
								else GetExp(sAttackerH, (iExp / 2), TRUE); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
								m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
							}
						}
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Effect_Damage_Spot");
	}
#endif
}

void CMapServer::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr, BOOL bFly)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
		DWORD dwTime;
		char cAttackerSide, cDamageMoveDir;
		register double dTmp1, dTmp2, dTmp3;
		int iPartyID, iMoveDamage, dX, dY;
		short sTgtX, sTgtY, sItemIndex;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH] == NULL) return;
			if ((m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) && (m_pClientList[sAttackerH]->m_iAdminUserLevel < 5)) return;
		}

		if (cAttackerType == DEF_OWNERTYPE_NPC)
			if (m_pNpcList[sAttackerH] == NULL) return;
		//crash aca
		if (cAttackerType == DEF_OWNERTYPE_PLAYER && cTargetType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sTargetH] == NULL) return;
			if (memcmp(m_pClientList[sTargetH]->m_cMapName, "VipMap1", 7) == 0) return;
			//Safe en Event Garden
			if (memcmp(m_pClientList[sTargetH]->m_cMapName, "areuni", 6) == 0) return;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sTargetH] == NULL) return;
			if (m_pClientList[sTargetH]->m_iAdminUserLevel >= 1) return;
		}

		dwTime = timeGetTime();
		sTgtX = 0;
		sTgtY = 0;

		iDamage = iDice(sV1, sV2) + sV3;
		if (iDamage <= 0) iDamage = 0;

		iPartyID = 0;

		switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0 && m_pClientList[sAttackerH]->m_iAdminUserLevel < 3) return;

				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL))
				{
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || //BerserkWand
						m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) { //BerserkWand
						iDamage += (int)(iDamage*1.1);//0.8
					}

					//ms20 dmg
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 683 || //683	WizMagicWand(MS20)
						m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 684) { //684	WizMagicWand(MS10)
						iDamage += (int)(iDamage*0.1);
					}
					//chaosheroWand dmg add
					else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 2090) { //PowerHeroWand
						iDamage += (iDamage*1.6);
					}
					//3116	BlackZWand(MS.32)
					else if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 3116) {
						iDamage += (iDamage*1.3);
					}
					//WorldWar - LaloRamos - Aumento DMg Magico
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "FightMap") == 0) {
						iDamage += iDamage / 3;
					}

					//WorldWarII - LaloRamos - Aumento DMg Magico
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "WorldMap") == 0) {
						iDamage += iDamage / 2;
					}

					//All Eks - LaloRamos - DMG Bonus
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "evento13") == 0) {
						iDamage += iDamage / 3;
					}

					//All Dk Eks - LaloRamos - DMG Bonus
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "evento14") == 0) {
						iDamage += iDamage / 3;
					}

					//EventDk - LaloRamos - DMG Bonus
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "EventDk") == 0) {
						iDamage += iDamage / 3;
					}

					//FinalFight - LaloRamos - Aumento DMg Magico
					if (strcmp(m_pClientList[sAttackerH]->m_cMapName, "Counter") == 0) {
						iDamage += iDamage / 3;
					}
					//Nueva Funcion Kloness Vs Assasain
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || //KlonessWand(MS.30)
						m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) { //KlonessWand(MS.10)
						if (m_pClientList[sAttackerH]->m_iRating > 0) {
							iRepDamage = m_pClientList[sAttackerH]->m_iRating / 200;
							iDamage += iRepDamage;
							if (cTargetType == DEF_OWNERTYPE_PLAYER) {
								if (m_pClientList[sTargetH] != NULL) {
									if (m_pClientList[sTargetH]->m_iRating < 0) {
										iRepDamage = abs(m_pClientList[sTargetH]->m_iRating) / 100;
										iDamage += iRepDamage / 4;
									}
									// Bonus Victima KWands
									else if (m_pClientList[sTargetH]->m_iRating > 0) {
										iRepDamage = m_pClientList[sTargetH]->m_iRating / 200;
										iDamage -= iRepDamage / 4;
									}
									if ((m_pClientList[sTargetH]->Assasain) && (m_pClientList[sTargetH]->m_iRating > 0)) {
										iRepDamage = abs(m_pClientList[sTargetH]->m_iRating) / 100;
										iDamage += iRepDamage / 2;
									}
								}
							}
						}
					}

					// aca Lalin
					if (m_pClientList[sAttackerH]->Assasain == TRUE) {
						if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 4973) || //AssasainWand(MS.40)	
							(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 4974)) { //AssasainWand(MS.20)		
							if (m_pClientList[sAttackerH]->m_iRating < 0) {
								iRepDamage = abs(m_pClientList[sAttackerH]->m_iRating) / 200; //100
								iDamage += iRepDamage; //2
								if (cTargetType == DEF_OWNERTYPE_PLAYER) {
									if (m_pClientList[sTargetH] != NULL) {
										if (m_pClientList[sTargetH]->m_iRating > 0) {
											iRepDamage = m_pClientList[sTargetH]->m_iRating / 100;
											iDamage += iRepDamage / 4;
										}
										else if (m_pClientList[sTargetH]->m_iRating < 0) {
											iRepDamage = m_pClientList[sTargetH]->m_iRating / 100;
											iDamage += iRepDamage / 4;
										}
									}
								}
							}
						}
					}
				}

				if ((m_bIsCrusadeMode == FALSE) &&
					(m_pClientList[sAttackerH]->m_bIsHunter == TRUE) &&
					cTargetType == DEF_OWNERTYPE_PLAYER) return;

				dTmp1 = (double)iDamage;
				if ((m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_sRankAddMag + m_pClientList[sAttackerH]->m_iAngelicMag) <= 0)
					dTmp2 = 1.0f;
				else dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_sRankAddMag + m_pClientList[sAttackerH]->m_iAngelicMag);

				dTmp2 = dTmp2 / 3.3f;
				dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
				iDamage = (int)(dTmp3 + 0.5f);
				if (iDamage <= 0) iDamage = 0;

				iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)
					iDamage += iDamage / 3;
				if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
					if (m_pClientList[sAttackerH]->m_iLevel <= 80) iDamage += (iDamage * 7) / 10;
					else if (m_pClientList[sAttackerH]->m_iLevel <= 100) iDamage += iDamage / 2;
					else iDamage += iDamage / 3;
				}

				switch (m_pClientList[sAttackerH]->m_cHeroBonus) {
					case 2: iDamage += 3; break;
					case 4: iDamage += 6; break;
					case 6: iDamage += 7; break;
					case 8: iDamage += 8; break;
					case 10: iDamage += 10; break;
					default: break;
				}

				cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

				iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
				break;

			case DEF_OWNERTYPE_NPC:
				cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
				break;
		}

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return;
				if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
				if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
				if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
				if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
				if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return;
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

				if ((m_bIsCrusadeMode == FALSE) &&
					(m_pClientList[sTargetH]->m_iPKCount == 0) &&
					(m_pClientList[sTargetH]->m_bIsHunter == TRUE) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER)) return;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == DEF_NONPK)) return;
				if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

					if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
						iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
						if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {}
						else {
							if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
								if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {}
								else return;
							}
							else return;
						}
					}
					if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
				}

				ClearSkillUsingStatus(sTargetH);

				switch (iAttr) {
					case 1:
						if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					case 2:
						if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					case 3:
						if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					case 4:
						if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
							dTmp1 = (double)iDamage;
							dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
							dTmp3 = (dTmp2 / 100.0f)*dTmp1;
							iDamage = iDamage - (int)(dTmp3);
							if (iDamage < 0) iDamage = 0;
						}
						break;

					default: break;
				}

				iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
				if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
					switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
						case 335: // ���Ӷ��� ���� 20%
							dTmp1 = (double)iDamage;
							dTmp2 = dTmp1 * 0.2f;
							dTmp3 = dTmp1 - dTmp2;
							iDamage = (int)(dTmp3 + 0.5f);
							break;

						case 337: // ���� ���� 10%
							dTmp1 = (double)iDamage;
							dTmp2 = dTmp1 * 0.1f;
							dTmp3 = dTmp1 - dTmp2;
							iDamage = (int)(dTmp3 + 0.5f);
							break;
					}
					if (iDamage <= 0) iDamage = 0;

					iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
					if (iRemainLife <= iDamage) ItemDepleteHandler(sTargetH, iIndex, TRUE);
					else m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 70:
							m_pClientList[sAttackerH]->m_iHP -= iDamage;
							SendNotifyMsg(NULL, sAttackerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
							SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
							if (m_pClientList[sAttackerH]->m_iHP <= 0)
								ClientKilledHandler(sAttackerH, NULL, NULL, iDamage);
							iDamage = 0;
							break;
					}
				}

				//Fix Reflex LaloRamos
				if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
					dTmp3 = (dTmp2 / 100.0f)*dTmp1;
					iDamage = iDamage - (int)dTmp3;
				}
				// Fix Lalo Ramos
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
					if (iDamage <= 0) iDamage = 0;//1 //0
				}

				switch (cAttackerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
							iDamage = iDamage / 2;
						break;
					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sAttackerH]->m_sType != 65) {
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
								iDamage = iDamage / 2;
						}
						break;
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) &&
					(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
					iDamage = m_pClientList[sTargetH]->m_iHP - 1;
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 51:
						case 52:
							return;
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iDamage;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
				}
				else {
					if (iDamage > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iDamage;
							dTmp3 = (dTmp1 / 100.0f)*dTmp2 + 1.0f;

							iTemp = (2 * (m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_sRankAddMag + m_pClientList[sTargetH]->m_iAngelicMag)) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iInt + m_pClientList[sTargetH]->m_sRankAddInt + m_pClientList[sTargetH]->m_iAngelicInt) / 2);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}

						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							if (iDice(1, 100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) {
									m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendCriticals(sTargetH);
								}
							}
						}

						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE))
							iMoveDamage = 80;
						else iMoveDamage = 50;

						if (iDamage >= iMoveDamage) {
							///		char cDamageMoveDir;
							sTgtX = m_pClientList[sTargetH]->m_sX;
							sTgtY = m_pClientList[sTargetH]->m_sY;

							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;
							}

							m_pClientList[sTargetH]->m_iLastDamage = iDamage;
							//No recall por 10 segundos - ZeroEoyPnk
							m_pClientList[sTargetH]->m_bRecall = FALSE;
							m_pClientList[sTargetH]->RecallTime = dwTime;
							SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
							SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
						}
						else {
						EDSD_SKIPDAMAGEMOVE:;
							//No recall por 10 segundos - ZeroEoyPnk
							m_pClientList[sTargetH]->m_bRecall = FALSE;
							m_pClientList[sTargetH]->RecallTime = dwTime;
							SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
							SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
						}

						if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
							m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
							m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
							// Hold-Person �Ǿ� �־��� ���¶��� Ǯ����. �������� �з������� �� �͵� Ǯ����.
							// 1: Hold-Person 
							// 2: Paralize
							SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

							m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sTargetH] == NULL) return;
				if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
				if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

				switch (m_pNpcList[sTargetH]->m_cActionLimit) {
					case 1:
					case 2:
					case 4:
					case 6: // v2.20 2002-12-20 ���� NPC ���� �ʵǰ� 
						return;
				}

				if (RunSummonEvent == TRUE || RunSummonEvent2 == TRUE || RunSummonEvent3 == TRUE) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 38:
						case 39:
							return;
							break;
					}
				}

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 36:
						case 37:
						case 38:
						case 39:
						case 40:
						case 41:
						case 87:
						case 89:
							if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
							break;

						case 64:
							if (m_bIsCrusadeMode == TRUE) return;
							break;
						case 92:
							if (m_bIsRushNetMode == TRUE) {
								//Reliquia elvine
								if ((AttackElvine == FALSE) && (m_pNpcList[sTargetH]->m_cSide == 2))
									return;
								else
									if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;

								//Reliquia Aresden
								if ((AttackAresden == FALSE) && (m_pNpcList[sTargetH]->m_cSide == 1))
									return;
								else
									if ((m_pClientList[sAttackerH]->m_cSide == 0 && m_pClientList[sAttackerH]->Assasain == FALSE) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
							}
							break;
					}
				}

				if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
					dTmp1 = (double)iDamage;
					dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
					dTmp3 = dTmp1 * dTmp2;
					dTmp2 = dTmp1 - dTmp3;
					iDamage = (int)dTmp2;
					if (iDamage < 0) iDamage = 1;
				}

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
					iDamage = iDamage / 2;

				m_pNpcList[sTargetH]->m_iHP -= iDamage;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER && cTargetType == DEF_OWNERTYPE_NPC)
				{
					if (m_pClientList[sAttackerH] != NULL && m_pNpcList[sTargetH] != NULL)
					{
						if (m_pNpcList[sTargetH]->m_iHP > m_pNpcList[sTargetH]->m_iMaxHP) m_pNpcList[sTargetH]->m_iMaxHP = m_pNpcList[sTargetH]->m_iHP;
						notifyNpcHealth(sAttackerH, sTargetH);
					}
				}

				if (m_pNpcList[sTargetH]->m_iHP < 0) {
					NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				}
				else {
					switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
								&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
							break;
					}
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

					if (bFly == TRUE) {
						switch (m_pNpcList[sTargetH]->m_sType) {
							case 21:
							case 36:
							case 37:
							case 38:
							case 39:
							case 40:
							case 41:
							case 42:
							case 87:
							case 89:
							case 91:
								bFly = FALSE;
								break;
						}
					}

					if ((iDamage > 50) && (bFly == TRUE)) {
						sTgtX = m_pNpcList[sTargetH]->m_sX;
						sTgtY = m_pNpcList[sTargetH]->m_sY;
						if (sTgtX == sAtkX) {
							if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
							else if (sTgtY > sAtkY) cDamageMoveDir = 5;
							else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}
						else if (sTgtX > sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 3;
							else if (sTgtY > sAtkY) cDamageMoveDir = 4;
							else if (sTgtY < sAtkY) cDamageMoveDir = 2;
						}
						else if (sTgtX < sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 7;
							else if (sTgtY > sAtkY) cDamageMoveDir = 6;
							else if (sTgtY < sAtkY) cDamageMoveDir = 8;
						}

						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
							cDamageMoveDir = iDice(1, 8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
						}

						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX = dX;
						m_pNpcList[sTargetH]->m_sY = dY;
						m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
							cDamageMoveDir = iDice(1, 8);
							dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
							dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

							if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
						}

						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
						m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[sTargetH]->m_sX = dX;
						m_pNpcList[sTargetH]->m_sY = dY;
						m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

					}

				CAE_SKIPDAMAGEMOVE2:;

					if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
						if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
							(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
							(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

						// ActionLimit
						m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;

						// Damage
						m_pNpcList[sTargetH]->m_dwTime = dwTime;

						if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
							// Hold
							m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
						}

						//Crusade
						int iExp;

						// NPC
						if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) &&
							(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
							// ExpStock
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
								// Crusade
								iExp = iDamage;
								if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

								if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
									dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
									dTmp2 = (double)iExp;
									dTmp3 = (dTmp1 / 100.0f)*dTmp2;
									iExp += (int)dTmp3;
								}

								if (m_pClientList[sAttackerH]->m_iLevel > 100) {
									switch (m_pNpcList[sTargetH]->m_sType) {
										case 55:
										case 56:
											iExp = 0;
											break;
										default: break;
									}
								}

								if (bExp == TRUE)
									GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
								else GetExp(sAttackerH, (iExp / 2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
								m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
							}
							else {
								// Crusade
								iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
								if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

								if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
									dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
									dTmp2 = (double)iExp;
									dTmp3 = (dTmp1 / 100.0f)*dTmp2;
									iExp += (int)dTmp3;
								}

								if (m_pClientList[sAttackerH]->m_iLevel > 100) {
									switch (m_pNpcList[sTargetH]->m_sType) {
										case 55:
										case 56:
											iExp = 0;
											break;
										default: break;
									}
								}

								if (bExp == TRUE)
									GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
								else GetExp(sAttackerH, (iExp / 2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
								m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;


							}
						}
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Effect_Damage_Spot_DamageMove");
	}
#endif
}

void CMapServer::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{

#ifdef DEF_DEBUG
	try {
#endif
		int iHP, iMaxHP;
		DWORD dwTime = timeGetTime();

		if (cAttackerType == DEF_OWNERTYPE_PLAYER)
			if (m_pClientList[sAttackerH] == NULL) return;

		iHP = iDice(sV1, sV2) + sV3;

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return;
				if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

				iMaxHP = (3 * m_pClientList[sTargetH]->m_iVit) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_sRankAddStr + m_pClientList[sTargetH]->m_iAngelicStr) / 2); // v1.4

				if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0)
					iMaxHP = iMaxHP - (iMaxHP / m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);

				if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
					m_pClientList[sTargetH]->m_iHP += iHP;

					if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
					if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;

					SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sTargetH] == NULL) return;
				if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
				if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;

				iMaxHP = m_pNpcList[sTargetH]->m_iHitDice * 4;
				if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
					m_pNpcList[sTargetH]->m_iHP += iHP;

					if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
					if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Effect_HpUp_Spot");
	}
#endif
}

void CMapServer::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iSP, iMaxSP, iSideCondition;
		DWORD dwTime = timeGetTime();

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH] == NULL) return;
			if ((m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) && (m_pClientList[sAttackerH]->m_iAdminUserLevel < 5)) return;
		}

		iSP = iDice(sV1, sV2) + sV3;

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return;
				if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
				if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
					if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (m_pClientList[sAttackerH]->m_iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;

					if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
						iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
						if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {}
						else {
							if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
								if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {}
								else return;
							}
							else return;
						}
					}
				}

				iMaxSP = (2 * (m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_sRankAddStr + m_pClientList[sTargetH]->m_iAngelicStr)) + (2 * m_pClientList[sTargetH]->m_iLevel);
				if (m_pClientList[sTargetH]->m_iSP > 0) {
					if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
						m_pClientList[sTargetH]->m_iSP -= iSP;
						if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
						SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Effect_SpDown_Spot");
	}
#endif
}

void CMapServer::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{

#ifdef DEF_DEBUG
	try {
#endif
		int iSP, iMaxSP;
		DWORD dwTime = timeGetTime();

		if (cAttackerType == DEF_OWNERTYPE_PLAYER)
			if (m_pClientList[sAttackerH] == NULL) return;

		iSP = iDice(sV1, sV2) + sV3;

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return;
				if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

				iMaxSP = (2 * (m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_sRankAddStr + m_pClientList[sTargetH]->m_iAngelicStr)) + (2 * m_pClientList[sTargetH]->m_iLevel);
				if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
					m_pClientList[sTargetH]->m_iSP += iSP;

					if (m_pClientList[sTargetH]->m_iSP > iMaxSP)
						m_pClientList[sTargetH]->m_iSP = iMaxSP;

					SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_SP, NULL, NULL, NULL, NULL);
				}
				break;

			case DEF_OWNERTYPE_NPC:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Effect_SpUp_Spot");
	}
#endif
}

//LaloRamos Fix Magic Resistent
BOOL CMapServer::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio, char cNpc)
{
#ifdef DEF_DEBUG
	try {
#endif
		double dTmp1, dTmp2, dTmp3;
		int    iTargetMagicResistRatio = 0, iDestHitRatio, iResult;//=0
		char   cTargetDir, cProtect = 0;

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return FALSE;
				if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
				if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return TRUE;
				if (cNpc == 65) return FALSE;

				cTargetDir = m_pClientList[sTargetH]->m_cDir;

			//	iTargetMagicResistRatio = (m_pClientList[sTargetH]->m_cSkillMastery[3] * 0.86) + m_pClientList[sTargetH]->m_iAddMR; // 3�� Resisting Magic
				iTargetMagicResistRatio = (m_pClientList[sTargetH]->m_cSkillMastery[3] * 0.80) + m_pClientList[sTargetH]->m_iAddMR; // LaloMr

				if ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_sRankAddMag + m_pClientList[sTargetH]->m_iAngelicMag) > 50)
					iTargetMagicResistRatio += ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_sRankAddMag + m_pClientList[sTargetH]->m_iAngelicMag) - 50);
				iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
				cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sTargetH] == NULL) return FALSE;
				cTargetDir = m_pNpcList[sTargetH]->m_cDir;
				iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
				cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
				break;
		}

		// Absolute Magic Protection
		if (cProtect == 5) return TRUE;

		if ((iHitRatio < 1000) && (cProtect == 2)) return TRUE;

		if (iHitRatio >= 10000) iHitRatio -= 10000;

		if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;

		dTmp1 = (double)(iHitRatio);
		dTmp2 = (double)(iTargetMagicResistRatio);

		dTmp3 = (dTmp1 / dTmp2)*50.0f;
		iDestHitRatio = (int)(dTmp3);

		if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;

		if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

		if (iDestHitRatio >= 100) return FALSE;

		iResult = iDice(1, 100);
		if (iResult <= iDestHitRatio) return FALSE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckResistingMagicSuccess");
	}
#endif
	return TRUE;
}

BOOL CMapServer::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iTargetIceResistRatio = 0, iResult;

		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sTargetH] == NULL) return FALSE;
				if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;

				iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater * 2;
				if (m_pClientList[sTargetH]->m_dwWarmEffectTime != NULL) {
					if ((timeGetTime() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000 * 30) return TRUE;
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sTargetH] == NULL) return FALSE;
				if (m_pNpcList[sTargetH]->m_cAttribute == DEF_ATTRIBUTE_WATER) return TRUE; // 2002-12-20 �� �Ӽ��� ���� NPC�� ICE �迭�� �������� ���� �ʴ´�.
				iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic / 3); // ���⿡ ���� ���� ��ġ �Է�. NPC�� ���� ���� ������ 70% ���� 
				break;
		}

		if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;

		iResult = iDice(1, 100);
		if (iResult <= iTargetIceResistRatio) return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckResistingIceSuccess");
	}
#endif
	return FALSE;
}

BOOL CMapServer::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
#ifdef DEF_DEBUG
	try {
#endif
		int x = 0, i;

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pItem == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_bIsOnWarehouse == FALSE) return FALSE;

		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
				if (m_pClientList[iClientH]->m_pItemInBankList[i]->GetBankPosition() == m_pClientList[iClientH]->WHPage)
					x++;
			}
		}

		if (x >= DEF_MAXBANKITEMPAGE) return FALSE;

		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
				m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
				m_pClientList[iClientH]->m_pItemInBankList[i]->SetBankPosition(m_pClientList[iClientH]->WHPage);

				if (SendBankItemData(iClientH, pItem, i)) return TRUE;
				else return FALSE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetItemToBankItem");
	}
#endif
	return FALSE;
}

BOOL CMapServer::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
		short sDownSkillIndex;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		iTotalPoints = 0;
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
			iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

		iRemainPoint = iTotalPoints - 2300;

		if (iRemainPoint > 0) {
			while (iRemainPoint > 0) {
				sDownSkillIndex = -1; // v1.4
				if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) {

					switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
						case 3:
						default:
							if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
								sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
							}
							else {
								iDownSkillSSN = 99999999;
								for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
									if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) &&
										(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {

										iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
										sDownSkillIndex = i;
									}
								}
							}
							break;
					}
				}

				if (sDownSkillIndex != -1) {
					if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
						iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
					else iDownPoint = 1;

					m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
					m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] + 1] - 1;
					iRemainPoint -= iDownPoint; // v1.4

					if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
						iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
							m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
							if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
						}
					}

					if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
						iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
						if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
							m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
							if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
						}
					}
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], 2, NULL);
				}
				else return FALSE;
			}
			return TRUE;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckTotalSkillMasteryPoints");
	}
#endif
	return FALSE;
}

void CMapServer::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
		case VK_F1: m_bF1pressed = TRUE; break;
		case VK_F4: m_bF4pressed = TRUE; break;
		case VK_F12: m_bF12pressed = TRUE; break;
	}
}

void CMapServer::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
	int i;
	switch (wParam) {
		case VK_F1: m_bF1pressed = FALSE; break;
		case VK_F4: m_bF4pressed = FALSE; break;
		case VK_F12: m_bF12pressed = FALSE; break;

		case VK_F9:
			if ((m_bF1pressed == TRUE)) {
				PutLogList("(!!!) Resume Crusade Mode...");
				LocalStartCrusadeMode(NULL);
			}
			break;

		case VK_F11:
			if ((m_bF1pressed == TRUE)) {
				PutLogList("(!!!) ManualEndCrusadeMode: side 0");
				ManualEndCrusadeMode(0);
			}
			break;

			//Crusade Testcode
		case VK_HOME:
			if ((m_bF1pressed == TRUE)) LocalStartCrusadeMode(timeGetTime());
			break;

		case VK_END:
			break;
		case VK_INSERT:
		case VK_DELETE:
			return;
			break;
	}
}

int CMapServer::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iTotal;

		iTotal = 0;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW)) {
				if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
					iTotal++;
			}
		}

		return iTotal;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetFollowerNumber");
	}
#endif
	return 0;
}

BOOL CMapServer::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		for (i = 0; i < DEF_MAXDELAYEVENTS; i++) {
			if (m_pDelayEventList[i] == NULL) {

				m_pDelayEventList[i] = new class CDelayEvent;

				m_pDelayEventList[i]->m_iDelayType = iDelayType;
				m_pDelayEventList[i]->m_iEffectType = iEffectType;

				m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
				m_pDelayEventList[i]->m_dX = dX;
				m_pDelayEventList[i]->m_dY = dY;

				m_pDelayEventList[i]->m_iTargetH = iTargetH;
				m_pDelayEventList[i]->m_cTargetType = cTargetType;
				m_pDelayEventList[i]->m_iV1 = iV1;
				m_pDelayEventList[i]->m_iV2 = iV2;
				m_pDelayEventList[i]->m_iV3 = iV3;

				m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bRegisterDelayEvent");
	}
#endif
	return FALSE;
}

void CMapServer::DelayEventProcessor()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iSkillNum, iResult, iTemp = 0;
		DWORD dwTime = timeGetTime();

		for (i = 0; i < DEF_MAXDELAYEVENTS; i++) {
			if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

				switch (m_pDelayEventList[i]->m_iDelayType) {
					case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
						if (m_pDelayEventList[i] != NULL) {
							if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x400000) != 0)  iTemp = 1;
							else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x800000) != 0) iTemp = 3;
							else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x10000) != 0) iTemp = 4;

							SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, CLIENT_NOTIFY_SLATE_STATUS, iTemp, NULL, NULL, NULL);
							SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, FALSE);
						}
						break;

					case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
						if (m_pDelayEventList[i] != NULL)
							CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
						break;

					case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
						if (m_pDelayEventList[i] != NULL)
							DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
						break;

					case DEF_DELAYEVENTTYPE_METEORSTRIKE:
						if (m_pDelayEventList[i] != NULL)
							MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
						break;

					case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
						if (m_pDelayEventList[i] != NULL) {
							switch (m_pDelayEventList[i]->m_cTargetType) {
								case DEF_OWNERTYPE_PLAYER:
									iSkillNum = m_pDelayEventList[i]->m_iEffectType;

									if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL) break;
									if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE) break;
									if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
									m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
									m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;

									iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
										m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

									SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, CLIENT_NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
									break;
							}
						}
						break;

					case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
						break;

					case DEF_DELAYEVENTTYPE_MAGICRELEASE:
						if (m_pDelayEventList[i] != NULL) {
							switch (m_pDelayEventList[i]->m_cTargetType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pDelayEventList[i] != NULL) { // Agregue este chequeo en todas partes de esta funcion.
										if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL) break;

										SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, CLIENT_NOTIFY_MAGICEFFECTOFF,
											m_pDelayEventList[i]->m_iEffectType, m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType], NULL, NULL);

										if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL) break;
										m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType] = NULL;

										// Inbitition casting 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
											m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = FALSE;

										// Invisibility ȿ�� ���� 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY) {
											SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
											SendNotifyMsg(NULL, i, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
										}

										// Berserk ȿ�� ����
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK) {
											SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
											SetFuryWarFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
										}

										// polymorph ȿ�� ���� 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
											m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
											SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
										}

										// Confusion
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE) {
											switch (m_pDelayEventList[i]->m_iV1) {
												case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
												case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
											}
										}

										// Ice ȿ�� ���� 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
											SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

										// v2.23 Protection Magic
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
											switch (m_pDelayEventList[i]->m_iV1) {
												case 1:
													SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
													break;
												case 2:
												case 5:
													SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
													break;
												case 3:
												case 4:
													SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
													break;
											}
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pDelayEventList[i] != NULL) {
										if (m_pNpcList[m_pDelayEventList[i]->m_iTargetH] == NULL) break;

										m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType] = NULL;

										// Invisibility ȿ�� ���� 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
											SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

										// Berserk ȿ�� ����
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
											SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

										// polymorph ȿ�� ���� 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
											m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
											SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
										}

										// Ice ȿ�� ���� 
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
											SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

										// Illusion
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
											SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

										// Protection Magic
										if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
											switch (m_pDelayEventList[i]->m_iV1) {
												case 1:
													SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
													break;
												case 2:
												case 5:
													SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
													break;
												case 3:
												case 4:
													SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
													break;
											}
										}
									}
									break;
							}
						}
						break;
				}
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DelayEventProcessor");
	}
#endif
}

BOOL CMapServer::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		for (i = 0; i < DEF_MAXDELAYEVENTS; i++) {
			if (m_pDelayEventList[i] != NULL) {
				if (iEffectType == NULL) {
					if ((m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType)) {
						delete m_pDelayEventList[i];
						m_pDelayEventList[i] = NULL;
					}
				}
				else {
					if ((m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
						(m_pDelayEventList[i]->m_iEffectType == iEffectType)) {
						delete m_pDelayEventList[i];
						m_pDelayEventList[i] = NULL;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bRemoveFromDelayEventList");
	}
#endif
	return TRUE;
}

void CMapServer::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000010;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFEF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000010;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFEF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetInvisibilityFlag");
	}
#endif
}

void CMapServer::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000020;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFDF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000020;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFDF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetBerserkFlag");
	}
#endif
}

void CMapServer::SetFuryWarFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetFuryWarFlag");
	}
#endif
}

void CMapServer::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000040;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFBF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000040;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFBF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetIceFlag");
	}
#endif
}

void CMapServer::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x04000000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFBFFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x04000000;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFBFFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetMagicProtectionFlag");
	}
#endif
}

void CMapServer::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x08000000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xF7FFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x08000000;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xF7FFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetProtectionFromArrowFlag");
	}
#endif
}

void CMapServer::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x02000000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFDFFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x02000000;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFDFFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetDefenseShieldFlag");
	}
#endif
}

void CMapServer::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000080;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFF7F;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000080;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFF7F;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetPoisonFlag");
	}
#endif
}

void CMapServer::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00020000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00020000;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFDFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetHeroFlag");
	}
#endif
}

void CMapServer::SendObjectMotionRejectMsg(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * cp, cData[30];
		DWORD * dwp;
		WORD  * wp;
		short * sp;
		int     iRet;

		m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_COMMAND_MOTION;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOTION_REJECT;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sY;
		cp += 2;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendObjectMotionRejectMsg");
	}
#endif
}

void CMapServer::DynamicObjectEffectProcessor()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, ix, iy, iIndex;
		short sOwnerH, iDamage, sType;
		char  cOwnerType;
		DWORD dwTime = timeGetTime(), dwRegisterTime;

		for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) {
			if (m_pDynamicObjectList[i] != NULL) {
				switch (m_pDynamicObjectList[i]->m_sType) {
					case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
						for (ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++) {
							for (iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {

								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									// Poison Damage�� �Դ´�.
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) break;
											if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
											if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) break;

											if (m_pDynamicObjectList[i]->m_iV1 < 20)
												iDamage = iDice(1, 6);
											else iDamage = iDice(1, 8);

											m_pClientList[sOwnerH]->m_iHP -= iDamage;

											if (m_pClientList[sOwnerH]->m_iHP <= 0) {
												ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
											}
											else {
												if (iDamage > 0) {
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
													m_pClientList[sOwnerH]->m_bRecall = FALSE;
													m_pClientList[sOwnerH]->RecallTime = dwTime;

													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
														// 1: Hold-Person 
														// 2: Paralize
														SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

														m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
														bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
													}
												}
												if (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE)
												{
													if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
														if (!m_pClientList[sOwnerH]->m_bIsPoisoned) {
															m_pClientList[sOwnerH]->m_bIsPoisoned = TRUE;
															m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
															m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
															SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
															SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
														}
													}
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) break;

											if (m_pDynamicObjectList[i]->m_iV1 < 20)
												iDamage = iDice(1, 6);
											else iDamage = iDice(1, 8);

											switch (m_pNpcList[sOwnerH]->m_sType) {
												case 40:
												case 41:
												case 6:
													iDamage = 0;
													break;
											}

											// HP
											switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
												case 0: // �Ϲ�
												case 3: // ���̷�
												case 5: // ���๰ 
													m_pNpcList[sOwnerH]->m_iHP -= iDamage;
													break;
											}

											if (m_pNpcList[sOwnerH]->m_iHP <= 0) NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0);
											else {
												if (iDice(1, 3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;

												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL; // Hold
												if (!ActiveEvent && !PriceEvent && !AbaddonEvent)
													SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
											}
											break;
									}
								}
							}
						}
						break;

					case DEF_DYNAMICOBJECT_HEALSPOT:
						for (ix = m_pDynamicObjectList[i]->m_sX; ix <= m_pDynamicObjectList[i]->m_sX; ix++) {
							for (iy = m_pDynamicObjectList[i]->m_sY; iy <= m_pDynamicObjectList[i]->m_sY; iy++) {
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) break;
											if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

											if (m_pDynamicObjectList[i]->m_iV1 < 20)
												iDamage = iDice(1, 100);
											else iDamage = iDice(1, 100);

											m_pClientList[sOwnerH]->m_iHP += iDamage;

											if (m_pClientList[sOwnerH]->m_iHP < iGetMaxHP(sOwnerH)) {
												SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
												//SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) break;

											if (m_pDynamicObjectList[i]->m_iV1 < 20)
												iDamage = iDice(1, 6);
											else iDamage = iDice(1, 8);

											switch (m_pNpcList[sOwnerH]->m_sType) {
												case 40:
												case 41:
												case 6:
													iDamage = 0;
													break;
											}

											switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
												case 0:
												case 3:
												case 5:
													m_pNpcList[sOwnerH]->m_iHP += iDamage;
													break;
											}

											if (iDice(1, 3) == 2)
												m_pNpcList[sOwnerH]->m_dwTime = dwTime;

											SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
											break;
									}
								}
							}
						}
						break;

					case DEF_DYNAMICOBJECT_ICESTORM:
						// Ice-Storm 
						for (ix = m_pDynamicObjectList[i]->m_sX - 2; ix <= m_pDynamicObjectList[i]->m_sX + 2; ix++) {
							for (iy = m_pDynamicObjectList[i]->m_sY - 2; iy <= m_pDynamicObjectList[i]->m_sY + 2; iy++) {
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									// Ice Damage�� �Դ´�.
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) break;
											if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
											// v2.17 2002-8-5 ��ڴ� �ʵ��� ������ �������� ���� �ʴ´�. 
											if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) break;
											if ((PriceHODEvent || SummonLaunched))
											{
												if ((strcmp(m_pClientList[sOwnerH]->m_cMapName, "ESAresden") == 0) ||
													(strcmp(m_pClientList[sOwnerH]->m_cMapName, "ESElvine") == 0) ||
													(strcmp(m_pClientList[sOwnerH]->m_cMapName, "ESAssasain") == 0) ||
													(strcmp(m_pClientList[sOwnerH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0))
													break;
											}

											iDamage = iDice(3, 3) + 5;
											m_pClientList[sOwnerH]->m_iHP -= iDamage;

											if (m_pClientList[sOwnerH]->m_iHP <= 0) {
												ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
											}
											else {
												if (iDamage > 0) {
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
													m_pClientList[sOwnerH]->m_bRecall = FALSE;
													m_pClientList[sOwnerH]->RecallTime = dwTime;

													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] == 1) {
														// 1: Hold-Person 
														// 2: Paralize
														SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

														m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
														bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
													}
												}

												// v1.42 Ice ȿ��
												if ((bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
													(m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0)) {

													m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) break;

											iDamage = iDice(3, 3) + 5;

											switch (m_pNpcList[sOwnerH]->m_sType) {
												case 40:
												case 41:
												case 6: // v2.20 2002-12-20 ���� NPC ���� �ʵǰ� 
													iDamage = 0;
													break;
											}

											switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
												case 0: // �Ϲ�
												case 3: // ���̷�
												case 5: // ���๰ 
													m_pNpcList[sOwnerH]->m_iHP -= iDamage;
													break;
											}

											if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
												NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0);
											}
											else {
												// Damage�� ���� �������� ���� ����ȿ��.
												if (iDice(1, 3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;

												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;

												// NPC�� �������� ������ ��ȯ��Ų��.
												SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);

												if ((bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
													(m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] == 0)) {

													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_ICE] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20 * 1000),
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
								}

								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
								if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE)) {
									iDamage = iDice(3, 2);
									m_pClientList[sOwnerH]->m_iHP -= iDamage;

									if (m_pClientList[sOwnerH]->m_iHP <= 0) {
										ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
									}
									else {
										if (iDamage > 0) {
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
											m_pClientList[sOwnerH]->m_bRecall = FALSE;
											m_pClientList[sOwnerH]->RecallTime = dwTime;
										}
									}
								}

								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
								if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != NULL))
									m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
							}
						}
						break;

					case DEF_DYNAMICOBJECT_BLUEFIRE:
						for (ix = m_pDynamicObjectList[i]->m_sX; ix <= m_pDynamicObjectList[i]->m_sX; ix++) {
							for (iy = m_pDynamicObjectList[i]->m_sY; iy <= m_pDynamicObjectList[i]->m_sY; iy++) {
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) break;
											if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
											if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0) break;

											iDamage = iDice(1, 50) + 5;
											m_pClientList[sOwnerH]->m_iHP -= iDamage;

											if (m_pClientList[sOwnerH]->m_iHP <= 0) {
												ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
											}
											else {
												if (iDamage > 0) {
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
													m_pClientList[sOwnerH]->m_bRecall = FALSE;
													m_pClientList[sOwnerH]->RecallTime = dwTime;
													SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) break;

											iDamage = iDice(1, 50) + 5;;

											switch (m_pNpcList[sOwnerH]->m_sType) {
												case 40:
												case 41:
												case 6: // v2.20 2002-12-20 ���� NPC ���� �ʵǰ� 
													iDamage = 0;
													break;
											}

											switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
												case 0: // �Ϲ�
												case 3: // ���̷�
												case 5: // ���๰ 
													m_pNpcList[sOwnerH]->m_iHP -= iDamage;
													break;
											}

											if (m_pNpcList[sOwnerH]->m_iHP <= 0)
												NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0);
											else {
												if (iDice(1, 3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;
												SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
											}
											break;
									}
								}

								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
								if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE)) {
									iDamage = iDice(1, 50) + 5;
									m_pClientList[sOwnerH]->m_iHP -= iDamage;

									if (m_pClientList[sOwnerH]->m_iHP <= 0)
										ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
									else {
										if (iDamage > 0) SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
									}
								}
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
							}
						}
						break;

					case DEF_DYNAMICOBJECT_FIRE:
						// Fire-Wall 
						if (m_pDynamicObjectList[i]->m_iCount == 1)
							CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);

						m_pDynamicObjectList[i]->m_iCount++;
						if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10;

						for (ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++) {
							for (iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									// Fire Damage¸¦ ÀÔ´Â´Ù.
									switch (cOwnerType) {

										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) break;
											if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

											iDamage = iDice(1, 6);
											if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
												m_pClientList[sOwnerH]->m_iHP -= iDamage;

											if (m_pClientList[sOwnerH]->m_iHP <= 0) {
												ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
											}
											else {
												if (iDamage > 0) {
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
													m_pClientList[sOwnerH]->m_bRecall = FALSE;
													m_pClientList[sOwnerH]->RecallTime = dwTime;

													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
														// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. Fire Field·Î´Â ÆÐ·²¶óÀÌÁî µÈ°Íµµ Ç®¸°´Ù. 	
														// 1: Hold-Person 
														// 2: Paralize	
														SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

														m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
														bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
													}
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) break;

											iDamage = iDice(1, 6);
											switch (m_pNpcList[sOwnerH]->m_sType) {
												case 40:
												case 41:
													iDamage = 0;
													break;
											}

											switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
												case 0: // ÀÏ¹Ý
												case 3: // ´õ¹Ì·ù
												case 5: // °ÇÃà¹° 
													m_pNpcList[sOwnerH]->m_iHP -= iDamage;
													break;
											}

											if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
												NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
											}
											else {
												if (iDice(1, 3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;

												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
												SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
											}
											break;
									}
								}
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
								if ((sType == DEF_DYNAMICOBJECT_FIRE) && (m_pDynamicObjectList[iIndex] != NULL))
									m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
							}
						}
						break;

					case DEF_DYNAMICOBJECT_FIRE3:
						// Fire-Wall·ùÀÇ Å¸´Â ºÒ²É
						if (m_pDynamicObjectList[i]->m_iCount == 1) {
							CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
						}
						m_pDynamicObjectList[i]->m_iCount++;
						if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10;

						for (ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++) {
							for (iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {

								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (sOwnerH != NULL) {
									// Fire Damage¸¦ ÀÔ´Â´Ù.
									switch (cOwnerType) {

										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) break;
											if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

											iDamage = iDice(1, 6);
											if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0) m_pClientList[sOwnerH]->m_iHP -= iDamage;

											if (m_pClientList[sOwnerH]->m_iHP <= 0) ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
											else {
												if (iDamage > 0) {
													SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
													m_pClientList[sOwnerH]->m_bRecall = FALSE;
													m_pClientList[sOwnerH]->RecallTime = dwTime;

													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
														// 1: Hold-Person 
														// 2: Paralize	
														SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

														m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
														bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
													}
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) break;
											iDamage = iDice(1, 6);

											switch (m_pNpcList[sOwnerH]->m_sType) {
												case 40:
												case 41:
													iDamage = 0;
													break;
											}

											switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
												case 0: // ÀÏ¹Ý
												case 3: // ´õ¹Ì·ù
												case 5: // °ÇÃà¹° 
													m_pNpcList[sOwnerH]->m_iHP -= iDamage;
													break;
											}

											if (m_pNpcList[sOwnerH]->m_iHP <= 0) NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0);
											else {
												if (iDice(1, 3) == 2) m_pNpcList[sOwnerH]->m_dwTime = dwTime;
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;

												SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
											}
											break;
									}
								}
								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
								if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_bSkillUsingStatus[19] == TRUE)) {
									iDamage = iDice(1, 6);
									m_pClientList[sOwnerH]->m_iHP -= iDamage;

									if (m_pClientList[sOwnerH]->m_iHP <= 0) {
										ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
									}
									else {
										if (iDamage > 0) {
											SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
											m_pClientList[sOwnerH]->m_bRecall = FALSE;
											m_pClientList[sOwnerH]->RecallTime = dwTime;
										}
									}
								}

								m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
								if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL))
									m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
							}
						}
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DynamicObjectEffectProcessor");
	}
#endif
}

void CMapServer::ClearSkillUsingStatus(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		short tX, fX, tY, fY, sOwnerH;
		char cOwnerType;

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
			tX = m_pClientList[iClientH]->m_sX;
			tY = m_pClientList[iClientH]->m_sY;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
			if (sOwnerH == NULL || sOwnerH != iClientH) {
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, NULL) == FALSE) {
					fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
					fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, NULL) == FALSE) {
						m_pClientList[iClientH]->m_cDir = iDice(1, 8);
						fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
						fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
						if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, NULL) == FALSE) {
							return;
						}
					}
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, NULL, NULL, NULL);
				}
			}
		}
		for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
			m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
			m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL;
		}

		if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
			if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)
				m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

			m_pClientList[iClientH]->m_iAllocatedFish = NULL;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClearSkillUsingStatus");
	}
#endif
}

int CMapServer::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
#ifdef DEF_DEBUG
	try {
#endif

		class CItem * pItem;
		short lX, lY;
		int   iResult, iFish, iItemID = 0;

		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[iOwnerH] == NULL) return 0;
				if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
				lX = m_pClientList[iOwnerH]->m_sX;
				lY = m_pClientList[iOwnerH]->m_sY;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[iOwnerH] == NULL) return 0;
				if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
				lX = m_pNpcList[iOwnerH]->m_sX;
				lY = m_pNpcList[iOwnerH]->m_sY;
				break;
		}

		if (cOwnerSkill == 0) return 0;

		iResult = iDice(1, 105);
		if (cOwnerSkill <= iResult)	return 0;
		if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

		switch (m_pSkillConfigList[iSkillNum]->m_sType) {
			case DEF_SKILLEFFECTTYPE_TAMING: _TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY); break;
			case DEF_SKILLEFFECTTYPE_GET:
				switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
					case 1: iItemID = 99;  break;
					case 2:
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
							if (iFish == NULL) iItemID = 100; // ������ 
						}
						else iItemID = 100; // ������ 
						break;
				}

				if (iItemID != 0) {
					if (iItemID == 100) {
						SendNotifyMsg(NULL, iOwnerH, CLIENT_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
						GetExp(iOwnerH, iDice(2, 5)); //m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
					}

					pItem = new class CItem;
					if (pItem == NULL) return 0;
					if (_bInitItemAttr(pItem, iItemID) == TRUE) {

						pItem->m_sTouchEffectType = DEF_ITET_ID;
						pItem->m_sTouchEffectValue1 = iDice(1, 100000);

						// Anti Dup System
						SYSTEMTIME SysTime;
						char cTemp[256];
						GetLocalTime(&SysTime);
						ZeroMemory(cTemp, sizeof(cTemp));
						pItem->m_sTouchEffectValue2 = iDice(1, 100000);
						wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
						pItem->m_sTouchEffectValue2 = atoi(cTemp);

						ZeroMemory(cTemp, sizeof(cTemp));
						wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
						pItem->m_sTouchEffectValue3 = atoi(cTemp);

						m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
						pItem->m_dwTimeDrop = timeGetTime();

						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, cMapIndex,
							lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iCalculateUseSkillItemEffect");
	}
#endif
	return 1;
}

void CMapServer::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  cOwnerType;
		short sAttackerWeapon, sOwnerH;
		int   iResult, iPlayerSkillLevel;
		DWORD dwTime = timeGetTime();

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
		if (m_pSkillConfigList[iV1] == NULL) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;
		m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

		iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
		iResult = iDice(1, 100);

		if (iResult > iPlayerSkillLevel) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
			return;
		}

		switch (m_pSkillConfigList[iV1]->m_sType) {
			case DEF_SKILLEFFECTTYPE_PRETEND://chequear aca
				return;
			/*	switch (m_pSkillConfigList[iV1]->m_sValue1) {
					case 1:
						if (m_pClientList[iClientH] == NULL) return;
						if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) return;

						if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
							return;
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
						if (sOwnerH != NULL) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
							return;
						}

						iResult = 0;
						if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY - 1);
							iResult += sOwnerH;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 1);
							iResult += sOwnerH;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY);
							iResult += sOwnerH;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY);
							iResult += sOwnerH;

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY - 1);
							iResult += sOwnerH;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY - 1);
							iResult += sOwnerH;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY + 1);
							iResult += sOwnerH;
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY + 1);
							iResult += sOwnerH;
						}

						if (iResult != 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
							return;
						}

						if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
							SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

							bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
						}
						sAttackerWeapon = 1;
						SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
						break;
				}*/
				break;
		}
		m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UseSkillHandler");
	}
#endif
}

void CMapServer::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cItemCategory;
		short sRemainLife;
		int   iPrice;
		double d1, d2, d3;
		BOOL   bNeutral;
		DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((cItemID < 0) || (cItemID >= 50)) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
		if (iNum <= 0) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

		iCalcTotalWeight(iClientH);

		bNeutral = FALSE;
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) bNeutral = TRUE;

		switch (cSellToWhom) {
			case 15:
			case 24:
				cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
				if ((cItemCategory >= 11) && (cItemCategory <= 50)) {

					iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
					sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

					if (bNeutral == TRUE) iPrice = iPrice / 2;
					if (iPrice <= 0)    iPrice = 1;
					if (iPrice > 1000000) iPrice = 1000000;


					if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) < (DWORD)_iCalcMaxLoad(iClientH)) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
					}
					else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
				}
				else if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
					sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

					if (sRemainLife == 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
					}
					else {
						d1 = (double)sRemainLife;
						if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
							d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
						else d2 = 1.0f;
						d3 = (d1 / d2) * 0.5f;
						d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ���� ���� 
						d3 = d3 * d2; // �߻��� ���� 

						iPrice = (int)d3;
						iPrice = iPrice*iNum;

						dwAddPrice1 = 0;
						dwAddPrice2 = 0;
						if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;
							dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

							switch (dwSWEType) {
								case 6: dwMul1 = 2; break;  // ������ 
								case 8: dwMul1 = 2; break;  // ��ȭ��
								case 5: dwMul1 = 3; break;  // ��ø��
								case 1: dwMul1 = 4; break;  // �ʻ��� 
								case 7: dwMul1 = 5; break;  // ������
								case 2: dwMul1 = 6; break;  // �ߵ���
								case 3: dwMul1 = 15; break; // ������ 
								case 9: dwMul1 = 20; break; // ���빮�� 
								default: dwMul1 = 1; break;
							}

							d1 = (double)iPrice*dwMul1;
							switch (dwSWEValue) {
								case 1: d2 = 10.0f; break;
								case 2: d2 = 20.0f; break;
								case 3: d2 = 30.0f; break;
								case 4: d2 = 35.0f; break;
								case 5: d2 = 40.0f; break;
								case 6: d2 = 50.0f; break;
								case 7: d2 = 100.0f; break;
								case 8: d2 = 200.0f; break;
								case 9: d2 = 300.0f; break;
								case 10: d2 = 400.0f; break;
								case 11: d2 = 500.0f; break;
								case 12: d2 = 700.0f; break;
								case 13: d2 = 900.0f; break;
								default: d2 = 0.0f; break;
							}
							d3 = d1*(d2 / 100.0f);

							dwAddPrice1 = (int)(d1 + d3);
						}

						if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;
							dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

							switch (dwSWEType) {
								case 1:
								case 12: dwMul2 = 2; break;

								case 2:
								case 3:
								case 4:
								case 5:
								case 6:
								case 7: dwMul2 = 4; break;

								case 8:
								case 9:
								case 10:
								case 11: dwMul2 = 6; break;
							}

							d1 = (double)iPrice*dwMul2;
							switch (dwSWEValue) {
								case 1: d2 = 10.0f; break;
								case 2: d2 = 20.0f; break;
								case 3: d2 = 30.0f; break;
								case 4: d2 = 35.0f; break;
								case 5: d2 = 40.0f; break;
								case 6: d2 = 50.0f; break;
								case 7: d2 = 100.0f; break;
								case 8: d2 = 200.0f; break;
								case 9: d2 = 300.0f; break;
								case 10: d2 = 400.0f; break;
								case 11: d2 = 500.0f; break;
								case 12: d2 = 700.0f; break;
								case 13: d2 = 900.0f; break;
								default: d2 = 0.0f; break;
							}
							d3 = d1*(d2 / 100.0f);

							dwAddPrice2 = (int)(d1 + d3);
						}

						iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1 / 3)) + (dwAddPrice2 - (dwAddPrice2 / 3));

						if (bNeutral == TRUE) iPrice = iPrice / 2;
						if (iPrice <= 0)    iPrice = 1;
						if (iPrice > 1000000) iPrice = 1000000;

						if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) < (DWORD)_iCalcMaxLoad(iClientH)) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
						}
						else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
					}
				}
				else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				break;

			default:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqSellItemHandler");
	}
#endif
}

void CMapServer::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItemGold;
		short sRemainLife;
		int   iPrice;
		double d1, d2, d3;
		char   * cp, cItemName[21], cData[120], cItemCategory;
		DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
		WORD   * wp;
		int    iEraseReq, iRet;
		short * sp;
		BOOL   bNeutral;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((cItemID < 0) || (cItemID >= 50)) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
		if (iNum <= 0) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;
		if (m_pClientList[iClientH]->m_bIsOnShop == FALSE) return;


		iCalcTotalWeight(iClientH);
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

		bNeutral = FALSE;
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) bNeutral = TRUE;

		iPrice = 0;
		if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife <= 0) return;
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ���� ���� 
				d3 = d3 * d2;

				iPrice = (short)d3;
				iPrice = iPrice*iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

					switch (dwSWEType) {
						case 6: dwMul1 = 2; break;  // ������ 
						case 8: dwMul1 = 2; break;  // ��ȭ��
						case 5: dwMul1 = 3; break;  // ��ø��
						case 1: dwMul1 = 4; break;  // �ʻ��� 
						case 7: dwMul1 = 5; break;  // ������
						case 2: dwMul1 = 6; break;  // �ߵ���
						case 3: dwMul1 = 15; break; // ������ 
						case 9: dwMul1 = 20; break; // ���빮�� 
						default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
						case 1: d2 = 10.0f; break;
						case 2: d2 = 20.0f; break;
						case 3: d2 = 30.0f; break;
						case 4: d2 = 35.0f; break;
						case 5: d2 = 40.0f; break;
						case 6: d2 = 50.0f; break;
						case 7: d2 = 100.0f; break;
						case 8: d2 = 200.0f; break;
						case 9: d2 = 300.0f; break;
						case 10: d2 = 400.0f; break;
						case 11: d2 = 500.0f; break;
						case 12: d2 = 700.0f; break;
						case 13: d2 = 900.0f; break;
						default: d2 = 0.0f; break;
					}
					d3 = d1*(d2 / 100.0f);
					dwAddPrice1 = (int)(d1 + d3);
				}

				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

					switch (dwSWEType) {
						case 1:
						case 12: dwMul2 = 2; break;

						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7: dwMul2 = 4; break;

						case 8:
						case 9:
						case 10:
						case 11: dwMul2 = 6; break;
					}

					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
						case 1: d2 = 10.0f; break;
						case 2: d2 = 20.0f; break;
						case 3: d2 = 30.0f; break;
						case 4: d2 = 35.0f; break;
						case 5: d2 = 40.0f; break;
						case 6: d2 = 50.0f; break;
						case 7: d2 = 100.0f; break;
						case 8: d2 = 200.0f; break;
						case 9: d2 = 300.0f; break;
						case 10: d2 = 400.0f; break;
						case 11: d2 = 500.0f; break;
						case 12: d2 = 700.0f; break;
						case 13: d2 = 900.0f; break;
						default: d2 = 0.0f; break;
					}
					d3 = d1*(d2 / 100.0f);
					dwAddPrice2 = (int)(d1 + d3);
				}

				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1 / 3)) + (dwAddPrice2 - (dwAddPrice2 / 3));

				if (bNeutral == TRUE) iPrice = iPrice / 2;
				if (iPrice <= 0) iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

				_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[cItemID]);

				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
					(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
					SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
				}
				else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
			}
		}
		else {
			if ((cItemCategory >= 11) && (cItemCategory <= 50)) {
				iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
				iPrice = iPrice*iNum;

				if (bNeutral == TRUE) iPrice = iPrice / 2;
				if (iPrice <= 0) iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

				_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[cItemID]);

				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
					(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
					SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
				}
				else ItemDepleteHandler(iClientH, cItemID, FALSE, FALSE);
			}
		}

		// Gold
		if (iPrice <= 0) return;

		pItemGold = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		wsprintf(cItemName, "Gold");
		_bInitItemAttr(pItemGold, cItemName);

		pItemGold->m_dwCount = iPrice;

		if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy_secure(cp, pItemGold->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = pItemGold->m_dwCount;
			cp += 4;

			*cp = pItemGold->m_cItemType;
			cp++;

			*cp = pItemGold->m_cEquipPos;
			cp++;

			*cp = (char)0;
			cp++;

			sp = (short *)cp;
			*sp = pItemGold->m_sLevelLimit;
			cp += 2;

			*cp = pItemGold->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItemGold->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItemGold->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = pItemGold->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = pItemGold->m_sSpriteFrame;
			cp += 2;

			*cp = pItemGold->m_cItemColor;
			cp++;

			//*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
			//cp++;
			//lalomanu
			sp = (short *)cp;
			*sp = pItemGold->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItemGold->m_dwAttribute;
			cp += 4;

			*cp = (char)pItemGold->m_sItemSpecEffectValue3;
			cp++;

			if (iEraseReq == 1) delete pItemGold;

		//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			//cambio lalomanu
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

			iCalcTotalWeight(iClientH);

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					break;
			}
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY, pItemGold);
			pItemGold->m_dwTimeDrop = timeGetTime();

			SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); // v1.4 color

			iCalcTotalWeight(iClientH);

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqSellItemConfirmHandler");
	}
#endif
}

void CMapServer::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cItemCategory;
		short sRemainLife, sPrice;
		double d1, d2, d3;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((cItemID < 0) || (cItemID >= 50)) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

		if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
			if (cRepairWhom != 24) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				return;
			}

			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
			if (sRemainLife == 0) sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
				d3 = d3 * d2; // �߻��� ���� 

				sPrice = short((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3);
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		}
		else if (((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 13))) {

			if (cRepairWhom != 15) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				return;
			}

			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
			if (sRemainLife == 0) sPrice = (short)(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
				d3 = d3 * d2;

				sPrice = (short)((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3);
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		}
		else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqRepairItemHandler");
	}
#endif
}

void CMapServer::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
#ifdef DEF_DEBUG
	try {
#endif
		short    sRemainLife, sPrice;
		char   * cp, cItemCategory, cData[120];
		double   d1, d2, d3;
		DWORD  * dwp, dwGoldCount;
		WORD   * wp;
		int      iRet, iGoldWeight;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((cItemID < 0) || (cItemID >= 50)) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnShop != TRUE) return;

		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

		if (((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) ||
			((cItemCategory >= 11) && (cItemCategory <= 13))) {

			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
			if (sRemainLife == 0) sPrice = (short)(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
			else {
				d1 = (double)abs(sRemainLife);
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ���� ���� 
				d3 = d3 * d2; // �߻��� ���� 

				sPrice = (short)((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3);
			}

			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			if (dwGoldCount < (DWORD)sPrice) {
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_NOTENOUGHGOLD;
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = cItemID;
				cp++;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
				return;
			}
			else {
				m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);

				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice);
				iCalcTotalWeight(iClientH);
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqRepairItemCofirmHandler");
	}
#endif
}

int CMapServer::iCalcTotalWeight(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iWeight = 0;
		short sItemIndex;

		if (m_pClientList[iClientH] == NULL) return 0;

		m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
					case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
							m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
						}
						break;
				}
			}

		iWeight = 0;
		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
			}
		}

		m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

		return iWeight;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iCalcTotalWeight");
	}
#endif
	return 0;
}

void CMapServer::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, *cp, cName[11], cBuff[256], cTemp[120];
		class  CStrTok * pStrTok;
		register int i;
		WORD * wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (dwSize <= 0) return;

		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pMsg, dwSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token == NULL) {
			delete pStrTok;
			return;
		}

		if (strlen(token) > 10)
			memcpy_secure(cName, token, 10);
		else memcpy_secure(cName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {

				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					cp = (char *)cTemp;
					memcpy_secure(cp, m_pClientList[i]->m_cMapName, 10);
					cp += 10;

					wp = (WORD *)cp;
					*wp = (WORD)m_pClientList[i]->m_sX;
					cp += 2;

					wp = (WORD *)cp;
					*wp = (WORD)m_pClientList[i]->m_sY;
					cp += 2;
				}

				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, cTemp);

				delete pStrTok;
				return;
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckAndNotifyPlayerConnection");
	}
#endif
}

void CMapServer::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  seps[] = "= \t\n";
		char  * token, cName[11], cBuff[256];
		class CStrTok * pStrTok;
		register int i;
		char *cp;
		WORD *wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (dwMsgSize <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pMsg, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token == NULL) {
			m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
			// Whisper mode enabled
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
		}
		else {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0))
				{
					if (i == iClientH) {
						delete pStrTok;
						// Whisper self XenX
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You shouldnt talk to yourself!");
						return;
					}
					m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
					ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
					strcpy_secure(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
					break;
				}
			}

			if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
			else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ToggleWhisperPlayer");
	}
#endif
}

void CMapServer::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cTemp[256];
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize - 7) <= 0) return;

		ZeroMemory(cTemp, sizeof(cTemp));
		memcpy_secure(cTemp, (pMsg + 7), dwMsgSize - 7);

		for (i = 0; i < 256; i++) if (cTemp[i] == ' ') cTemp[i] = '_';

		cTemp[255] = NULL;

		ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
		strcpy_secure(m_pClientList[iClientH]->m_cProfile, cTemp);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ToggleWhisperPlayer");
	}
#endif
}

void CMapServer::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cBuff[256], cBuff2[500];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pMsg, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

					ZeroMemory(cBuff2, sizeof(cBuff2));
					wsprintf(cBuff2, "%s Profile:%s", cName, m_pClientList[i]->m_cProfile); // v2.04
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

					delete pStrTok;
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetPlayerProfile");
	}
#endif
}

void CMapServer::___RestorePlayerCharacteristics(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iStr, iDex, iInt, iVit, iMag, iCharisma;
		int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
		int iMax, iA, iB;
		BOOL bFlag;
		char cTxt[120];

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_iLU_Pool > 3) return;

		iStr = m_pClientList[iClientH]->m_iStr;
		iDex = m_pClientList[iClientH]->m_iDex;
		iInt = m_pClientList[iClientH]->m_iInt;
		iVit = m_pClientList[iClientH]->m_iVit;
		iMag = m_pClientList[iClientH]->m_iMag;
		iCharisma = m_pClientList[iClientH]->m_iCharisma;


		iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70;

		iToBeRestoredPoint = iOriginalPoint - iCurPoint;
		if (iToBeRestoredPoint == 0) return;

		if (iToBeRestoredPoint > 0) {
			while (1) {
				bFlag = FALSE;

				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
					bFlag = TRUE;
				}
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
					bFlag = TRUE;
				}
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
					bFlag = TRUE;
				}
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
					bFlag = TRUE;
				}
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
					bFlag = TRUE;
				}
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
					bFlag = TRUE;
				}

				if (bFlag == FALSE)          break;
				if (iToBeRestoredPoint <= 0) break;
			}

			iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

			if (m_pClientList[iClientH]->m_iStr < (iMax / 2)) {
				while (1) {
					if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax / 2))) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}

					if (m_pClientList[iClientH]->m_iStr == (iMax / 2)) break;
					if (iToBeRestoredPoint <= 0) break;
				}
			}

			iA = m_pClientList[iClientH]->m_cSkillMastery[7];
			iB = m_pClientList[iClientH]->m_cSkillMastery[8];
			if (iA > iB) iMax = iA;
			else iMax = iB;
			iA = m_pClientList[iClientH]->m_cSkillMastery[9];
			if (iA > iMax) iMax = iA;
			iA = m_pClientList[iClientH]->m_cSkillMastery[6];
			if (iA > iMax) iMax = iA;

			if (m_pClientList[iClientH]->m_iDex < (iMax / 2)) {
				while (1) {
					if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax / 2))) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}

					if (m_pClientList[iClientH]->m_iDex == (iMax / 2)) break;
					if (iToBeRestoredPoint <= 0) break;
				}
			}

			iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

			if (m_pClientList[iClientH]->m_iInt < (iMax / 2)) {
				while (1) {
					if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax / 2))) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}

					if (m_pClientList[iClientH]->m_iInt == (iMax / 2)) break;
					if (iToBeRestoredPoint <= 0) break;
				}
			}

			iA = m_pClientList[iClientH]->m_cSkillMastery[3];
			iB = m_pClientList[iClientH]->m_cSkillMastery[4];
			if (iA > iB) iMax = iA;
			else iMax = iB;

			if (m_pClientList[iClientH]->m_iMag < (iMax / 2)) {
				while (1) {
					if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax / 2))) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}

					if (m_pClientList[iClientH]->m_iMag == (iMax / 2)) break;
					if (iToBeRestoredPoint <= 0) break;
				}
			}

			while (iToBeRestoredPoint != 0) {
				switch (iDice(1, 6)) {
					case 1:
						if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
							m_pClientList[iClientH]->m_iStr++;
							iToBeRestoredPoint--;
						}
						break;
					case 2:
						if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
							m_pClientList[iClientH]->m_iVit++;
							iToBeRestoredPoint--;
						}
						break;
					case 3:
						if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
							m_pClientList[iClientH]->m_iDex++;
							iToBeRestoredPoint--;
						}
						break;
					case 4:
						if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
							m_pClientList[iClientH]->m_iMag++;
							iToBeRestoredPoint--;
						}
						break;
					case 5:
						if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
							m_pClientList[iClientH]->m_iInt++;
							iToBeRestoredPoint--;
						}
						break;
					case 6:
						if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
							m_pClientList[iClientH]->m_iCharisma++;
							iToBeRestoredPoint--;
						}
						break;
				}
			}

			iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
				m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
				m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

			if (iVerifyPoint != iOriginalPoint) {
				wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
				CharacterLogList(cTxt);

				m_pClientList[iClientH]->m_iStr = iStr;
				m_pClientList[iClientH]->m_iDex = iDex;
				m_pClientList[iClientH]->m_iInt = iInt;
				m_pClientList[iClientH]->m_iVit = iVit;
				m_pClientList[iClientH]->m_iMag = iMag;
				m_pClientList[iClientH]->m_iCharisma = iCharisma;
			}
			else {
				wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
				CharacterLogList(cTxt);
			}
		}
		else {
			while (1) {
				bFlag = FALSE;
				if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
					bFlag = TRUE;
					m_pClientList[iClientH]->m_iStr--;
					iToBeRestoredPoint++;
				}

				if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
					bFlag = TRUE;
					m_pClientList[iClientH]->m_iDex--;
					iToBeRestoredPoint++;
				}

				if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
					bFlag = TRUE;
					m_pClientList[iClientH]->m_iVit--;
					iToBeRestoredPoint++;
				}

				if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
					bFlag = TRUE;
					m_pClientList[iClientH]->m_iInt--;
					iToBeRestoredPoint++;
				}

				if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
					bFlag = TRUE;
					m_pClientList[iClientH]->m_iMag--;
					iToBeRestoredPoint++;
				}

				if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
					bFlag = TRUE;
					m_pClientList[iClientH]->m_iCharisma--;
					iToBeRestoredPoint++;
				}

				if (bFlag == FALSE)	break;
				if (iToBeRestoredPoint >= 0) break;
			}

			if (iToBeRestoredPoint < 0) {
				while (iToBeRestoredPoint != 0) {
					switch (iDice(1, 6)) {
						case 1:
							if (m_pClientList[iClientH]->m_iStr > 10) {
								m_pClientList[iClientH]->m_iStr--;
								iToBeRestoredPoint++;
							}
							break;
						case 2:
							if (m_pClientList[iClientH]->m_iVit > 10) {
								m_pClientList[iClientH]->m_iVit--;
								iToBeRestoredPoint++;
							}
							break;
						case 3:
							if (m_pClientList[iClientH]->m_iDex > 10) {
								m_pClientList[iClientH]->m_iDex--;
								iToBeRestoredPoint++;
							}
							break;
						case 4:
							if (m_pClientList[iClientH]->m_iMag > 10) {
								m_pClientList[iClientH]->m_iMag--;
								iToBeRestoredPoint++;
							}
							break;
						case 5:
							if (m_pClientList[iClientH]->m_iInt > 10) {
								m_pClientList[iClientH]->m_iInt--;
								iToBeRestoredPoint++;
							}
							break;
						case 6:
							if (m_pClientList[iClientH]->m_iCharisma > 10) {
								m_pClientList[iClientH]->m_iCharisma--;
								iToBeRestoredPoint++;
							}
							break;
					}
				}
			}
			else {
				while (iToBeRestoredPoint != 0) {
					switch (iDice(1, 6)) {
						case 1:
							if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
								m_pClientList[iClientH]->m_iStr++;
								iToBeRestoredPoint--;
							}
							break;
						case 2:
							if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
								m_pClientList[iClientH]->m_iVit++;
								iToBeRestoredPoint--;
							}
							break;
						case 3:
							if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
								m_pClientList[iClientH]->m_iDex++;
								iToBeRestoredPoint--;
							}
							break;
						case 4:
							if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
								m_pClientList[iClientH]->m_iMag++;
								iToBeRestoredPoint--;
							}
							break;
						case 5:
							if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
								m_pClientList[iClientH]->m_iInt++;
								iToBeRestoredPoint--;
							}
							break;
						case 6:
							if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
								m_pClientList[iClientH]->m_iCharisma++;
								iToBeRestoredPoint--;
							}
							break;
					}
				}
			}

			iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
				m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
				m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

			if (iVerifyPoint != iOriginalPoint) {
				wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
				CharacterLogList(cTxt);

			}
			else {
				wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
				CharacterLogList(cTxt);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ___RestorePlayerCharacteristics");
	}
#endif
}

void CMapServer::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
#ifdef DEF_DEBUG
	try {
#endif
		register short sItemIndex;
		int  i, iArrowIndex, iPrevSAType, iTemp, iTemp2;
		char cEquipPos;
		double dV1, dV2, dV3;
		DWORD  dwSWEType, dwSWEValue;
		short  sTemp;
		short TempDef, TempHitting = 0;

		if (m_pClientList[iClientH] == NULL) return;

		if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) &&
			(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) {

			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] != NULL) {
				m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
				m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
			}
		}

		m_pClientList[iClientH]->m_iAngelicStr = 0;
		m_pClientList[iClientH]->m_iAngelicInt = 0;
		m_pClientList[iClientH]->m_iAngelicDex = 0;
		m_pClientList[iClientH]->m_iAngelicMag = 0;
		SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

		m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
		m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
		m_pClientList[iClientH]->m_cAttackBonus_SM = 0;

		m_pClientList[iClientH]->m_cAttackDiceThrow_L = 0;
		m_pClientList[iClientH]->m_cAttackDiceRange_L = 0;
		m_pClientList[iClientH]->m_cAttackBonus_L = 0;

		m_pClientList[iClientH]->m_iHitRatio = 0;
		//m_pClientList[iClientH]->m_iDefenseRatio = ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) * 2);
		//lalomerien
		m_pClientList[iClientH]->m_iDefenseRatio = ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) * 1.5);

		m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;

		for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
			m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i] = 0;

		m_pClientList[iClientH]->m_iManaSaveRatio = 0;
		m_pClientList[iClientH]->m_iAddResistMagic = 0;
		m_pClientList[iClientH]->m_iAddMagicHitting = 0;

		m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
		m_pClientList[iClientH]->m_iAddMagicalDamage = 0;

		m_pClientList[iClientH]->m_bIsLuckyEffect = FALSE;
		m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
		m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

		m_pClientList[iClientH]->m_iAddAbsAir = 0;
		m_pClientList[iClientH]->m_iAddAbsEarth = 0;
		m_pClientList[iClientH]->m_iAddAbsFire = 0;
		m_pClientList[iClientH]->m_iAddAbsWater = 0;

		m_pClientList[iClientH]->m_iCustomItemValue_Attack = 0;
		m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

		m_pClientList[iClientH]->m_iMinAP_SM = 0;
		m_pClientList[iClientH]->m_iMinAP_L = 0;

		m_pClientList[iClientH]->m_iMaxAP_SM = 0;
		m_pClientList[iClientH]->m_iMaxAP_L = 0;

		m_pClientList[iClientH]->m_iSpecialWeaponEffectType = 0;
		m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;

		//Fix Lalo Ramos
		m_pClientList[iClientH]->m_iAddHP = 0;
		m_pClientList[iClientH]->m_iAddSP = 0;
		m_pClientList[iClientH]->m_iAddMP = 0;
		m_pClientList[iClientH]->m_iAddAR = 0;
		m_pClientList[iClientH]->m_iAddPR = 0;
		m_pClientList[iClientH]->m_iAddDR = 0;
		m_pClientList[iClientH]->m_iAddMR = 0;
		m_pClientList[iClientH]->m_iAddAbsPD = 0;
		m_pClientList[iClientH]->m_iAddAbsMD = 0;
		m_pClientList[iClientH]->m_iAddCD = 0;
		m_pClientList[iClientH]->m_iAddExp = 0;
		m_pClientList[iClientH]->m_iAddGold = 0;
		m_pClientList[iClientH]->m_iHPStatic_stock = 0;

		//Hero Bonus LaloRamos
		switch (m_pClientList[iClientH]->m_cHeroBonus) {
		case 1:
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 5;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 3;
			m_pClientList[iClientH]->m_iHitRatio += 100;
			m_pClientList[iClientH]->m_iAddMagicHitting += 50;
			break;
		case 2:
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 10;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 6;
			m_pClientList[iClientH]->m_iHitRatio += 150;
			m_pClientList[iClientH]->m_iAddMagicHitting += 100;
			break;
		case 3:
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 11;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 7; 
			m_pClientList[iClientH]->m_iHitRatio += 160;
			m_pClientList[iClientH]->m_iAddMagicHitting += 110;
			break;
		case 4:
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 12;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 8;
			m_pClientList[iClientH]->m_iHitRatio += 170;
			m_pClientList[iClientH]->m_iAddMagicHitting += 120;
			break;
		case 5:
		case 6:
				if (m_pClientList[iClientH]->Assasain == TRUE) {
					if (m_pClientList[iClientH]->FirstPosition == TRUE) {
						m_pClientList[iClientH]->m_iAddAbsPD = 35;
						m_pClientList[iClientH]->m_iAddAbsMD = 35;
						m_pClientList[iClientH]->m_iHitRatio = 160;
					}
					else {
						m_pClientList[iClientH]->m_iAddAbsPD = 25;
						m_pClientList[iClientH]->m_iAddAbsMD = 25;
						m_pClientList[iClientH]->m_iHitRatio = 150;
					}
					m_pClientList[iClientH]->m_iAddPhysicalDamage += 11; 
					m_pClientList[iClientH]->m_iAddMagicalDamage += 7; 
					m_pClientList[iClientH]->m_iAddMagicHitting += 100;
				}
			break;
		case 7:
		case 8:
				if (m_pClientList[iClientH]->Assasain == TRUE) {
					if (m_pClientList[iClientH]->FirstPosition == TRUE) {
						m_pClientList[iClientH]->m_iAddAbsPD = 45;
						m_pClientList[iClientH]->m_iAddAbsMD = 45;
						m_pClientList[iClientH]->m_iHitRatio = 170;
					}
					else {
						m_pClientList[iClientH]->m_iAddAbsPD = 35;
						m_pClientList[iClientH]->m_iAddAbsMD = 35;
						m_pClientList[iClientH]->m_iHitRatio = 160;
					}
					m_pClientList[iClientH]->m_iAddPhysicalDamage += 12;
					m_pClientList[iClientH]->m_iAddMagicalDamage += 8;
					m_pClientList[iClientH]->m_iAddMagicHitting += 110;
				}
			break;
		case 9:
		case 10:
				if (m_pClientList[iClientH]->Assasain == TRUE) {
					if (m_pClientList[iClientH]->FirstPosition == TRUE) {
						m_pClientList[iClientH]->m_iAddAbsPD = 60; //60
						m_pClientList[iClientH]->m_iAddAbsMD = 60; //60
						m_pClientList[iClientH]->m_iHitRatio = 180; //100
					}
					else {
						m_pClientList[iClientH]->m_iAddAbsPD = 45;
						m_pClientList[iClientH]->m_iAddAbsMD = 45;
						m_pClientList[iClientH]->m_iHitRatio = 170; //70
					}
					m_pClientList[iClientH]->m_iAddPhysicalDamage += 13; //12
					m_pClientList[iClientH]->m_iAddMagicalDamage += 9; //10
					m_pClientList[iClientH]->m_iAddMagicHitting += 120; //100
				}
			break;
			default:
				if (m_pClientList[iClientH]->Assasain == TRUE) {
					if (m_pClientList[iClientH]->FirstPosition == TRUE) {
						m_pClientList[iClientH]->m_iAddAbsPD = 10; //10
						m_pClientList[iClientH]->m_iAddAbsMD = 10; //10
						m_pClientList[iClientH]->m_iHitRatio = 10; //10
					}
				}
			break;
		case 11:
			m_pClientList[iClientH]->m_iAddAbsPD = 20;//30;
			m_pClientList[iClientH]->m_iAddAbsMD = 20;//30;
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 15;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 10;
			m_pClientList[iClientH]->m_iHitRatio += 180;
			m_pClientList[iClientH]->m_iAddMagicHitting += 130;
			break;
		case 12:
			m_pClientList[iClientH]->m_iAddAbsPD = 20;//30;
			m_pClientList[iClientH]->m_iAddAbsMD = 20;//30;
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 15;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 10;
			m_pClientList[iClientH]->m_iHitRatio += 180;
			m_pClientList[iClientH]->m_iAddMagicHitting += 130;
			break;
		case 13:
			m_pClientList[iClientH]->m_iAddAbsPD = 25;//35;
			m_pClientList[iClientH]->m_iAddAbsMD = 25;//35;
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 16;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 11;
			m_pClientList[iClientH]->m_iHitRatio += 190;
			m_pClientList[iClientH]->m_iAddMagicHitting += 140;
			break;
		case 14:
			m_pClientList[iClientH]->m_iAddAbsPD = 30;//40;
			m_pClientList[iClientH]->m_iAddAbsMD = 30;//40;
			m_pClientList[iClientH]->m_iAddPhysicalDamage += 17;
			m_pClientList[iClientH]->m_iAddMagicalDamage += 12;
			m_pClientList[iClientH]->m_iHitRatio += 200;
			m_pClientList[iClientH]->m_iAddMagicHitting += 150;
			break;
		}

		iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

		m_pClientList[iClientH]->m_iSpecialAbilityType = 0;
		m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
		m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

		m_pClientList[iClientH]->m_iAddTransMana = 0;
		m_pClientList[iClientH]->m_iAddChargeCritical = 0;

		m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;

		for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
					case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
						break;
				}
			}
		}

		for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) &&
				(m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) {

				cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
					case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
						m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
						break;

					case DEF_ITEMEFFECTTYPE_HP:
						m_pClientList[iClientH]->m_iHPStatic_stock += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
						break;

					case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
					case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
					case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
					case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
					case DEF_ITEMEFFECTTYPE_ATTACK:
						m_pClientList[iClientH]->m_cAttackDiceThrow_SM = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
						m_pClientList[iClientH]->m_cAttackDiceRange_SM = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
						m_pClientList[iClientH]->m_cAttackBonus_SM = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
						m_pClientList[iClientH]->m_cAttackDiceThrow_L = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
						m_pClientList[iClientH]->m_cAttackDiceRange_L = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
						m_pClientList[iClientH]->m_cAttackBonus_L = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;

						iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

						if (iTemp == 15) {
							iTemp += 3;
							m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
							m_pClientList[iClientH]->m_iAddMagicalDamage += (iTemp++);
						}
						else {
							m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
							m_pClientList[iClientH]->m_iAddMagicalDamage += iTemp;
						}
						m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];
						TempHitting = m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];
						m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;

						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
							m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
							if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
								m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

							if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
								m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

							if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
								dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
								dV1 = (dV2 / 100.0f)*(5.0f);
								m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;

								m_pClientList[iClientH]->m_iMinAP_L = m_pClientList[iClientH]->m_cAttackDiceThrow_L + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

								if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
								if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

								if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM))
									m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);

								if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L))
									m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);

							}
							else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
								dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
								dV1 = (dV2 / 100.0f)*(5.0f);
								m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM
									+ m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;

								m_pClientList[iClientH]->m_iMaxAP_L = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L
									+ m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

								if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
								if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

								if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM))
									m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);

								if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L))
									m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
							}
						}

						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
							dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;

							m_pClientList[iClientH]->m_iSpecialWeaponEffectType = (int)dwSWEType;
							m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

							switch (dwSWEType) {
								case 1: // Critical
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4909) {
										m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
										m_pClientList[iClientH]->m_cAttackDiceRange_L += 2;
									}
									break;

								case 3: // Right
									if ((m_pClientList[iClientH]->m_iRating > 0) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cCategory != 8)
										&& ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4908) && // BlackAxe
										(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 849) && // KlonessBlade
											(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 850))) { // KlonessAxe)

										if (abs(m_pClientList[iClientH]->m_iRating / 1000) > 5) {
											m_pClientList[iClientH]->m_cAttackDiceRange_SM += 5;
											m_pClientList[iClientH]->m_cAttackDiceRange_L += 5;
										}
										else {
											m_pClientList[iClientH]->m_cAttackDiceRange_SM += abs(m_pClientList[iClientH]->m_iRating / 1000);
											m_pClientList[iClientH]->m_cAttackDiceRange_L += abs(m_pClientList[iClientH]->m_iRating / 1000);
										}
									}
									break;

								case 7: // Sharp
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4909) {
										m_pClientList[iClientH]->m_cAttackDiceRange_SM += 3;
										m_pClientList[iClientH]->m_cAttackDiceRange_L += 3;
									}
									break;

								case 9: // Ancient
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4909) {
										m_pClientList[iClientH]->m_cAttackDiceRange_SM += 4;
										m_pClientList[iClientH]->m_cAttackDiceRange_L += 4;
									}
									break;
							}
						}

						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
							dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;

							switch (dwSWEType) {
								case 0:  break;
								case 1:  m_pClientList[iClientH]->m_iAddPR += (int)(dwSWEValue * 7); break; // Poison Resistance
								case 2:  m_pClientList[iClientH]->m_iAddAR += (int)(dwSWEValue * 7); break; // Hitting Probability
								case 3:  m_pClientList[iClientH]->m_iAddDR += (int)(dwSWEValue * 10); break; // Defense Ratio
								case 4:  m_pClientList[iClientH]->m_iAddHP += (int)(dwSWEValue * 7); break; // HP Recovery
								case 5:  m_pClientList[iClientH]->m_iAddSP += (int)(dwSWEValue * 7); break; // SP Recovery
								case 6:  m_pClientList[iClientH]->m_iAddMP += (int)(dwSWEValue * 7); break; // MP Recovery
								case 7:  m_pClientList[iClientH]->m_iAddMR += (int)(dwSWEValue * 7); break; // Magic Resistance
								case 8:  m_pClientList[iClientH]->m_iAddAbsPD += (int)(dwSWEValue * 1); break; // Physical Absorption
								case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)(dwSWEValue * 1); break; // Magic Damage Absorption
								case 10: m_pClientList[iClientH]->m_iAddCD += (int)(dwSWEValue); break; // Critical Damage
								case 11: m_pClientList[iClientH]->m_iAddExp += (int)(dwSWEValue * 10); break; // Exp +%d
								case 12: m_pClientList[iClientH]->m_iAddGold += (int)(dwSWEValue * 10); break; // Gold +%d
							}

							switch (dwSWEType) {
								case 8: if (m_pClientList[iClientH]->m_iAddAbsPD > 80) m_pClientList[iClientH]->m_iAddAbsPD = 80; break; // 80%
								case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 85) m_pClientList[iClientH]->m_iAddAbsMD = 85; break; // 80%
							}
						}

						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
							case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
								m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
								break;

							case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
								m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
								if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
								break;

							case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
								m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
								break;

							case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
								m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
								m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
								m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;

								if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
								break;
						}
						break;

					case DEF_ITEMEFFECTTYPE_ADDEFFECT:
						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
							case 1: m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							//case 1: m_pClientList[iClientH]->m_iAddMR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * 7; break;
							case 2:
								m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
								if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
								break;
							case 3: m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 4: m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							//case 4: m_pClientList[iClientH]->m_iAddDR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 * 10; break;
							case 5:
								if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0) m_pClientList[iClientH]->m_bIsLuckyEffect = TRUE;
								else m_pClientList[iClientH]->m_bIsLuckyEffect = FALSE;
								break;

							case 6: m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 7: m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 8: m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 9: m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 10: m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 11: m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 12: m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; break;
							case 13: m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10); break;
							case 14:
								m_pClientList[iClientH]->m_iHitRatio += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 / 10);
								m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
								break;

							case 15: //Magic Emerald
								m_pClientList[iClientH]->m_iAddAbsMD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10); break;

							case 16: // Angel STR//AngelicPandent(STR)
								iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
								iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
								m_pClientList[iClientH]->m_iAngelicStr = (iTemp + iTemp2);
								SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, (iTemp + iTemp2));
								if ((iEquipItemID != -1) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID] != NULL) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 908))
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, 1, NULL, NULL, NULL);
								break;

							case 17: // Angel DEX //AngelicPandent(DEX)
								iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
								iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
								m_pClientList[iClientH]->m_iAngelicDex = (iTemp + iTemp2);
								SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, (iTemp + iTemp2));
								if ((iEquipItemID != -1) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID] != NULL) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 909))
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, 1, NULL, NULL, NULL);
								break;

							case 18: // Angel INT//AngelicPandent(INT)
								iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
								iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
								m_pClientList[iClientH]->m_iAngelicInt = (iTemp + iTemp2);
								SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, (iTemp + iTemp2));
								if ((iEquipItemID != -1) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID] != NULL) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 910))
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, 1, NULL, NULL, NULL);
								break;

							case 19: // Angel MAG//AngelicPandent(MAG)
								iTemp2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
								iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
								m_pClientList[iClientH]->m_iAngelicMag = (iTemp + iTemp2);
								SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, (iTemp + iTemp2));
								if ((iEquipItemID != -1) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID] != NULL) && (m_pClientList[iClientH]->m_pItemList[iEquipItemID]->m_sIDnum == 911))
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SETTING_SUCCESS, 1, NULL, NULL, NULL);
								break;

							case 20: // Magin Sapphire	physical damage decreased(% applied) by the purity formula.				
								m_pClientList[iClientH]->m_iAddAbsPD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
								break;

									// NeckMagicPower
							case 21: m_pClientList[iClientH]->m_iAddMagicHitting += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2; 
									 m_pClientList[iClientH]->m_iManaSaveRatio += 20;
									break;
							case 22: // Formula MagicDiamond LaloRamos				
								m_pClientList[iClientH]->m_iAddMagicHitting += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
								m_pClientList[iClientH]->m_iHitRatio += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
								break;
							case 23: // Formula MagicRuby LaloRamos				
								m_pClientList[iClientH]->m_iAddHP += ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5) * 7);
								break;
							case 24: // Nuevo HP NECK			
								m_pClientList[iClientH]->m_iAddHP += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
								m_pClientList[iClientH]->m_iHitRatio += 50;
								break;
							case 25: // PowerFull_Neck
								m_pClientList[iClientH]->m_iAddAbsWater += 50; //no frost
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize 500
								m_pClientList[iClientH]->m_iManaSaveRatio += 80;
								m_pClientList[iClientH]->m_iAddMagicalDamage += 20;
								m_pClientList[iClientH]->m_iAddMagicHitting += 100;
								m_pClientList[iClientH]->m_iHitRatio += 250;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 20;
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								m_pClientList[iClientH]->m_iAddDR += (100 * 10);
								m_pClientList[iClientH]->m_iAddMR += (100 * 7);
								m_pClientList[iClientH]->m_iAddAbsPD += 100;
								m_pClientList[iClientH]->m_iAddAbsMD += 100;
								break;
							case 26: // ADMIN NECK						
								m_pClientList[iClientH]->m_iHitRatio += 5000;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 5000;
								m_pClientList[iClientH]->m_iAddMagicHitting += 5000;
								m_pClientList[iClientH]->m_iAddMagicalDamage += 5000;
								break;
							case 27: // NeckMasterPower	
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iHitRatio += 150;
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								m_pClientList[iClientH]->m_iAddDR += (25 * 10);
								m_pClientList[iClientH]->m_iAddMR += (25 * 7);
								m_pClientList[iClientH]->m_iAddAbsPD += 10;
								m_pClientList[iClientH]->m_iAddAbsMD += 10;
								break;
							case 28: // NeckPowerMedu
								m_pClientList[iClientH]->m_iManaSaveRatio += 80;
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize 500
								m_pClientList[iClientH]->m_iAddMagicHitting += 25;
								break;
							case 29: // NeckMasterMage
								m_pClientList[iClientH]->m_iManaSaveRatio += 50;
								m_pClientList[iClientH]->m_iAddMagicHitting += 40;
								m_pClientList[iClientH]->m_iAddMagicalDamage += 10;
								m_pClientList[iClientH]->m_iAddDR += (10 * 10);
								break;
							case 30: // NeckMasterDef	
								m_pClientList[iClientH]->m_iManaSaveRatio += 50;
								m_pClientList[iClientH]->m_iAddMagicHitting += 50;
								m_pClientList[iClientH]->m_iHitRatio += 150;
								m_pClientList[iClientH]->m_iAddAbsWater += 50; //no frost
								m_pClientList[iClientH]->m_iAddDR += (40 * 10);
								m_pClientList[iClientH]->m_iAddMR += (40 * 7);
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize 500
								m_pClientList[iClientH]->m_iAddMagicalDamage += 10;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 10;
								m_pClientList[iClientH]->m_iAddAbsPD += 5;
								m_pClientList[iClientH]->m_iAddAbsMD += 5;
								m_pClientList[iClientH]->m_iAddAbsAir += 10;
								break;
							case 31: //	NeckMasterWar	
								m_pClientList[iClientH]->m_iHitRatio += 150;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 10;
								m_pClientList[iClientH]->m_iAddMR += (10 * 7);
								break;
							case 32: //	NeckMasterRec	
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								break;
							case 33: // NeckMasterDef	2
								m_pClientList[iClientH]->m_iManaSaveRatio += 30;
								m_pClientList[iClientH]->m_iAddMagicHitting += 25;
								m_pClientList[iClientH]->m_iHitRatio += 150;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 20;
								m_pClientList[iClientH]->m_iAddAbsWater += 50; //no frost
								m_pClientList[iClientH]->m_iAddDR += (50 * 10);
								m_pClientList[iClientH]->m_iAddMR += (50 * 7);
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize
								m_pClientList[iClientH]->m_iAddAbsPD += 30;
								m_pClientList[iClientH]->m_iAddAbsMD += 30;
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								break;
							case 34: // NeckMasterDef	3
								m_pClientList[iClientH]->m_iManaSaveRatio += 30;
								m_pClientList[iClientH]->m_iAddMagicHitting += 30;
								m_pClientList[iClientH]->m_iHitRatio += 100;
								m_pClientList[iClientH]->m_iAddAbsWater += 50; //no frost
								m_pClientList[iClientH]->m_iAddDR += (25 * 10);
								m_pClientList[iClientH]->m_iAddMR += (25 * 7);
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize 500
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								break;
							case 35: // NeckMasterDef	4
								m_pClientList[iClientH]->m_iManaSaveRatio += 50;
								m_pClientList[iClientH]->m_iAddMagicHitting += 50;
								m_pClientList[iClientH]->m_iHitRatio += 150;
								m_pClientList[iClientH]->m_iAddAbsWater += 50; //no frost
								m_pClientList[iClientH]->m_iAddDR += (30 * 10);
								m_pClientList[iClientH]->m_iAddMR += (30 * 7);
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize 500
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMagicalDamage += 10;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 10; 
								m_pClientList[iClientH]->m_iAddAbsPD += 5;
								m_pClientList[iClientH]->m_iAddAbsMD += 5;
								break;
							case 36: // NeckMasterDef	5
								m_pClientList[iClientH]->m_iManaSaveRatio += 30;
								m_pClientList[iClientH]->m_iAddMagicHitting += 25;
								m_pClientList[iClientH]->m_iHitRatio += 150;
								m_pClientList[iClientH]->m_iAddPhysicalDamage += 10;
								m_pClientList[iClientH]->m_iAddAbsWater += 50; //no frost
								m_pClientList[iClientH]->m_iAddDR += (25 * 10);
								m_pClientList[iClientH]->m_iAddMR += (25 * 7);
								m_pClientList[iClientH]->m_iAddPR += 700; // no lize
								m_pClientList[iClientH]->m_iAddAbsPD += 10;
								m_pClientList[iClientH]->m_iAddAbsMD += 10;
								m_pClientList[iClientH]->m_iAddHP += (100 * 7);
								m_pClientList[iClientH]->m_iAddMP += (100 * 7);
								m_pClientList[iClientH]->m_iAddSP += (100 * 7);
								break;
						}
						break;

					case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
						if ((m_pClientList[iClientH]->m_cArrowIndex != -1) &&
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL)) {
							m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
						}
						else if (m_pClientList[iClientH]->m_cArrowIndex == -1)
							m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

						if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
							m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
							m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
							m_pClientList[iClientH]->m_cAttackBonus_SM = 0;
							m_pClientList[iClientH]->m_cAttackDiceThrow_L = 0;
							m_pClientList[iClientH]->m_cAttackDiceRange_L = 0;
							m_pClientList[iClientH]->m_cAttackBonus_L = 0;
						}
						else {
							iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
							m_pClientList[iClientH]->m_cAttackDiceThrow_SM = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							m_pClientList[iClientH]->m_cAttackDiceRange_SM = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
							m_pClientList[iClientH]->m_cAttackBonus_SM = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
							m_pClientList[iClientH]->m_cAttackDiceThrow_L = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
							m_pClientList[iClientH]->m_cAttackDiceRange_L = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
							m_pClientList[iClientH]->m_cAttackBonus_L = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
						}

						m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];
						TempHitting = m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];
						break;

					case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
					case DEF_ITEMEFFECTTYPE_DEFENSE:
						m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;

						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
							m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;

							dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
							dV3 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							dV1 = (double)(dV2 / 100.0f)*dV3;

							dV1 = dV1 / 2.0f;
							m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
							if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;
						}

						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
							dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;

							switch (dwSWEType) {

								case 1: // Critical
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4909) {
										m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
										m_pClientList[iClientH]->m_cAttackDiceRange_L += 2;
									}
								break;

								case 3: // Right
									if ((m_pClientList[iClientH]->m_iRating > 0) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cCategory != 8)
										&& ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4908) && // BlackAxe
										(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 849) && // KlonessBlade
											(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 850))) { // KlonessAxe)

										if (abs(m_pClientList[iClientH]->m_iRating / 1000) > 5) {
											m_pClientList[iClientH]->m_cAttackDiceRange_SM += 5;
											m_pClientList[iClientH]->m_cAttackDiceRange_L += 5;
										}
										else {
											m_pClientList[iClientH]->m_cAttackDiceRange_SM += abs(m_pClientList[iClientH]->m_iRating / 1000);
											m_pClientList[iClientH]->m_cAttackDiceRange_L += abs(m_pClientList[iClientH]->m_iRating / 1000);
										}
									}
									break;

								case 7: // Sharp
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4909) {
									//	m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
									//	m_pClientList[iClientH]->m_cAttackDiceRange_L++;
										m_pClientList[iClientH]->m_cAttackDiceRange_SM += 3;
										m_pClientList[iClientH]->m_cAttackDiceRange_L += 3;
									}
									break;

								case 9: // Ancient
									if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != 4909) {
										m_pClientList[iClientH]->m_cAttackDiceRange_SM += 4;
										m_pClientList[iClientH]->m_cAttackDiceRange_L += 4;
									}
									break;

								case 11: // Mana Converting
									m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
									if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
									break;

								case 12: // Critical
									m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
									if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
									break;
							}
						}

						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
							dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;

							switch (dwSWEType) {
								case 0:  break;
								case 1:  m_pClientList[iClientH]->m_iAddPR += (int)(dwSWEValue * 7); break;
								case 2:  m_pClientList[iClientH]->m_iAddAR += (int)(dwSWEValue * 7); break;
								case 3:  m_pClientList[iClientH]->m_iAddDR += (int)(dwSWEValue * 10); break;
								case 4:  m_pClientList[iClientH]->m_iAddHP += (int)(dwSWEValue * 7); break;
								case 5:  m_pClientList[iClientH]->m_iAddSP += (int)(dwSWEValue * 7); break;
								case 6:  m_pClientList[iClientH]->m_iAddMP += (int)(dwSWEValue * 7); break;
								case 7:  m_pClientList[iClientH]->m_iAddMR += (int)(dwSWEValue * 7); break;
								case 8:  m_pClientList[iClientH]->m_iAddAbsPD += (int)(dwSWEValue * 1); break; // Physical Absorption
								case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)(dwSWEValue * 1); break; // Magic Damage Absorption
								case 10: m_pClientList[iClientH]->m_iAddCD += (int)(dwSWEValue); break;
								case 11: m_pClientList[iClientH]->m_iAddExp += (int)(dwSWEValue * 10); break;
								case 12: m_pClientList[iClientH]->m_iAddGold += (int)(dwSWEValue * 10); break;
							}

							switch (dwSWEType) {
								case 8: if (m_pClientList[iClientH]->m_iAddAbsPD > 80) m_pClientList[iClientH]->m_iAddAbsPD = 80; break; // 80%
								case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 85) m_pClientList[iClientH]->m_iAddAbsMD = 85; break; // 80%
							}
						}

						switch (cEquipPos) {
							case DEF_EQUIPPOS_LHAND:
								m_pClientList[iClientH]->m_iDamageAbsorption_Shield = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) / 3;
								break;
							default:
								m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
								break;
						}

						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
							case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
								m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
								m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
								m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;

								if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
								break;
						}
						break;
				}
			}
		}

		if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
			if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
				m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
				m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xFF0F;
				m_pClientList[iClientH]->m_sAppr4 = sTemp;
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			}
		}

		if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) &&
			(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) {
			if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
				m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
				m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xFF0F;
				m_pClientList[iClientH]->m_sAppr4 = sTemp;
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			}
		}

		if (m_pClientList[iClientH]->m_iAddAbsPD > 80) m_pClientList[iClientH]->m_iAddAbsPD = 80;
		if (m_pClientList[iClientH]->m_iAddAbsMD > 85) m_pClientList[iClientH]->m_iAddAbsMD = 85;

		//lalomerien
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATUSCHAR, m_pClientList[iClientH]->m_iAddAbsPD, m_pClientList[iClientH]->m_iAddAbsMD, m_pClientList[iClientH]->m_iAddHP / 7, NULL, m_pClientList[iClientH]->m_iAddMP / 7, m_pClientList[iClientH]->m_iAddMR / 7, m_pClientList[iClientH]->m_iAddDR / 10, m_pClientList[iClientH]->m_iAddPR / 7, m_pClientList[iClientH]->m_iAddSP / 7, m_pClientList[iClientH]->m_iDefenseRatio);
	
		TempDef = m_pClientList[iClientH]->m_iDamageAbsorption_Shield;
		for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
			TempDef += m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i];

		//lalo aca
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CHARSTATUS, TempDef, m_pClientList[iClientH]->m_iHitRatio - TempHitting, m_pClientList[iClientH]->m_iAddMagicHitting, NULL, m_pClientList[iClientH]->m_iAddPhysicalDamage, m_pClientList[iClientH]->m_iAddMagicalDamage);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalcTotalItemEffect");
	}
#endif
}

int CMapServer::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int ix, iy, iSum = 0;
		short sOwnerH;
		char  cOwnerType;

		for (ix = dX - cRange; ix <= dX + cRange; ix++) {
			for (iy = dY - cRange; iy <= dY + cRange; iy++) {
				m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
					iSum++;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iGetPlayerNumberOnSpot");
	}
#endif
	return 0;
}

BOOL CMapServer::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   iNamingValue, tX, tY;
		short sOwnerH;
		char  cOwnerType, cName[11], cNpcName[21];
		char  cNpcWaypoint[11];

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
		if (m_bIsCrusadeMode == TRUE) return FALSE;
		if (FinalFight) return FALSE;
		if (CityVsCity == TRUE) return FALSE;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
			if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
				if (bIsCheck == TRUE) return TRUE;
				if (m_pClientList[iClientH]->Assasain) return FALSE;

				ZeroMemory(cNpcName, sizeof(cNpcName));
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) strcpy_secure(cNpcName, "Guard-Aresden");
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) strcpy_secure(cNpcName, "Guard-Elvine");
				else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) strcpy_secure(cNpcName, "Guard-Neutral");
				else strcpy_secure(cNpcName, "XXX");

				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

					ZeroMemory(cName, sizeof(cName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

					tX = (int)m_pClientList[iClientH]->m_sX;
					tY = (int)m_pClientList[iClientH]->m_sY;
					if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
						&tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bAnalyzeCriminalAction");
	}
#endif
	return FALSE;
}

BOOL CMapServer::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (m_pClientList[sOwnerH] == NULL) return FALSE;

		if (iClientH == sOwnerH) return TRUE;
		if (m_pClientList[sOwnerH]->Assasain) return TRUE;

		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
			if ((m_pClientList[sOwnerH]->m_iPKCount != 0) || (m_pClientList[sOwnerH]->Assasain)) return TRUE;
			else return FALSE;
		}
		else {
			if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
				if (m_pClientList[sOwnerH]->m_cSide == 0) {
					if (m_pClientList[sOwnerH]->m_iPKCount != 0) return TRUE;
					else return FALSE;
				}
				else return TRUE;
			}
			else {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) return TRUE;
				else return FALSE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bGetIsPlayerHostile");
	}
#endif
	return FALSE;
}

void CMapServer::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, iIndex;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0)) {
				iIndex = i;
				goto NEXT_STEP_SNAM1;
			}
		}
		return;

	NEXT_STEP_SNAM1:;
		switch (cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[iTargetH] == NULL) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[iTargetH] == NULL) return;
				break;
		}

		m_pNpcList[iIndex]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
		m_pNpcList[iIndex]->m_cTargetType = cTargetType;

		m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetNpcAttackMode");
	}
#endif
}

void CMapServer::PoisonEffect(int iClientH, int iV1)
{

#ifdef DEF_DEBUG
	try {
#endif
		int iPoisonLevel, iDamage, iPrevHP, iProb;

		if (m_pClientList[iClientH] == NULL)     return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

		iDamage = iDice(1, iPoisonLevel);

		iPrevHP = m_pClientList[iClientH]->m_iHP;
		m_pClientList[iClientH]->m_iHP -= iDamage;
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

		if (iPrevHP != m_pClientList[iClientH]->m_iHP)
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);

		iProb = m_pClientList[iClientH]->m_cSkillMastery[23] - 10 + m_pClientList[iClientH]->m_iAddPR;
		if (iProb <= 10) iProb = 10;
		if (iDice(1, 100) <= iProb) {
			m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: PoisonEffect");
	}
#endif
}

BOOL CMapServer::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iResist = 0, iResult;

		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return FALSE;
				iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] + m_pClientList[sOwnerH]->m_iAddPR;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return FALSE;
				iResist = 0;
				break;
		}

		iResult = iDice(1, 100);
		if (iResult >= iResist) return FALSE;
		if (cOwnerType == DEF_OWNERTYPE_PLAYER) CalculateSSN_SkillIndex(sOwnerH, 23, 1);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckResistingPoisonSuccess");
	}
#endif
	return TRUE;
}

void CMapServer::CheckDayOrNightMode()
{
#ifdef DEF_DEBUG
	try {
#endif
		SYSTEMTIME SysTime;
		char cPrevMode;
		int  i;

		cPrevMode = m_cDayOrNight;
		GetLocalTime(&SysTime);
		if ((SysTime.wHour >= 20) || (SysTime.wHour < 6)) {
			if (SysTime.wMonth == 12) m_cDayOrNight = 3;
			else m_cDayOrNight = 2;
		}
		else m_cDayOrNight = 1;

		if (cPrevMode != m_cDayOrNight) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					if ((m_pClientList[i]->m_cMapIndex >= 0) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
						(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckDayOrNightMode");
	}
#endif
}

void CMapServer::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cBuff[256], *cp;
		WORD * wp;
		class  CStrTok * pStrTok;
		register int i, iTime;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pMsg, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			token = pStrTok->pGet();
			if (token == NULL) iTime = 0;
			else iTime = atoi(token);

			if (iTime < 0) iTime = 0;

			// Added - No shutup to GM Lvl 5
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iAdminUserLevel < 5) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					m_pClientList[i]->m_iTimeLeft_ShutUp = iTime * 20;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
					wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName,
						m_pClientList[i]->m_cCharName, iTime);

					delete pStrTok;
					return;
				}

			delete pStrTok;
			return;
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ShutUpPlayer");
	}
#endif
}

void CMapServer::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cBuff[256];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;
		if (m_pClientList[iClientH]->m_iLevel < 15) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

		if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
			return;
		}
		else if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
			if (!m_pClientList[iClientH]->Assasain) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
				return;
			}
		}

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pMsg, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					if (i != iClientH) {
						if (cValue == 0) m_pClientList[i]->m_iRating -= 2;
						else if (cValue == 1) m_pClientList[i]->m_iRating += 2;

						if (m_pClientList[i]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[i]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[i]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[i]->m_iRating = -(DEF_LIMIT_REP * 1000);
						m_pClientList[iClientH]->m_iTimeLeft_Rating = 20 * 60;

						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
						SendNotifyMsg(NULL, i, CLIENT_REPONSE_PLAYERREP, m_pClientList[i]->m_iRating, NULL, NULL, NULL);

						delete pStrTok;
						return;
					}
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetPlayerReputation");
	}
#endif
}

void CMapServer::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cCharName[11];
		register int i;

		ZeroMemory(cCharName, sizeof(cCharName));

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		memcpy_secure(cCharName, cp, 10);

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ResponseSavePlayerDataReplyHandler");
	}
#endif
}

void CMapServer::CalcExpStock(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		BOOL bIsLevelUp;
		class CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iExpStock <= 0) return;

		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
			m_pClientList[iClientH]->m_iExpStock = 0;
			return;
		}

		m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
		m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
		m_pClientList[iClientH]->m_iExpStock = 0;

		if (m_pClientList[iClientH]->Assasain == FALSE) {
			if (bCheckLimitedUser(iClientH) == FALSE)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}

		bIsLevelUp = bCheckLevelUp(iClientH);

		if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, "Gold") == FALSE) {
				delete pItem;
				return;
			}
			else pItem->m_dwCount = (DWORD)100;
			bAddItem(iClientH, pItem, NULL);
		}

		if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel > 5) && (m_pClientList[iClientH]->m_iLevel <= 20)) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, "Gold") == FALSE) {
				delete pItem;
				return;
			}
			else pItem->m_dwCount = (DWORD)300;
			bAddItem(iClientH, pItem, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalcExpStock");
	}
#endif
}

void CMapServer::___RestorePlayerRating(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
		if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
		SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ___RestorePlayerRating");
	}
#endif
}

int CMapServer::iGetExpLevel(int iExp)
{
	register int i;

	for (i = 1; i <= 201; i++)
		if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i + 1] > iExp)) return i;

	return 0;
}

void CMapServer::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
		class  CStrTok * pStrTok;
		register int i, iNamingValue, tX, tY;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0)
						strcpy_secure(cNpcName, "Guard-Aresden");
					else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0)
						strcpy_secure(cNpcName, "Guard-Elvine");
					else strcpy_secure(cNpcName, "Guard-Neutral");

					iNamingValue = m_pMapList[m_pClientList[i]->m_cMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue != -1) {
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = '_';
						cName[1] = m_pClientList[i]->m_cMapIndex + 65;

						tX = (int)m_pClientList[i]->m_sX;
						tY = (int)m_pClientList[i]->m_sY;
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
							&tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
							m_pMapList[m_pClientList[i]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
						}
						else {
							wsprintf(G_cTxt, "GM Order(%s): Guard Attack PC(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
							bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
							PutGMLogData(G_cTxt);
						}
					}
					delete pStrTok;
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CallGuard");
	}
#endif
}

void CMapServer::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, *cp, cBuff[256], cLocation[11], cMapName[11];
		WORD   *wp;
		int    pX, pY, i;
		class  CStrTok * pStrTok;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token == NULL) {
			delete pStrTok;
			return;
		}

		pX = m_pClientList[iClientH]->m_sX;
		pY = m_pClientList[iClientH]->m_sY;

		memcpy_secure(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

		if (strlen(token) > 10)
			memcpy_secure(cLocation, token, 10);
		else memcpy_secure(cLocation, token, strlen(token));

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) {
				RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
			}
		}

		wsprintf(G_cTxt, "GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cLocation, cLocation, cMapName);
		PutGMLogData(G_cTxt);

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SummonAll");
	}
#endif
}

void CMapServer::AdminOrder_SummonDemon(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cName[21], cNpcName[21], cNpcWaypoint[11];
		register int iNamingValue, tX, tY;

		if (m_pClientList[iClientH] == NULL) return;

		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			ZeroMemory(cNpcName, sizeof(cNpcName));
			strcpy_secure(cNpcName, "Demon");

			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

			tX = (int)m_pClientList[iClientH]->m_sX;
			tY = (int)m_pClientList[iClientH]->m_sY;
			if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, (rand() % 9),
				DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				wsprintf(G_cTxt, "GM Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
				PutGMLogData(G_cTxt);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SummonDemon");
	}
#endif
}

void CMapServer::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{

#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		int iNum;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (m_iFightzoneNoForceRecall == 0) {
			m_iFightzoneNoForceRecall = 1;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
		}
		else {
			m_iFightzoneNoForceRecall = 0;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
		}

		if (token == NULL) {
			delete pStrTok;
			return;
		}

		iNum = atoi(token) - 1;

		if (m_iFightZoneReserve[iNum] != -1) {
			wsprintf(G_cTxt, "GM Order(%s): FightzoneNumber(%d) FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum);
			PutGMLogData(G_cTxt);

			m_iFightZoneReserve[iNum] = -1;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FIGHTZONERESERVE, iNum + 1, NULL, NULL, NULL);
		}
		else {
			wsprintf(G_cTxt, "GM Order(%s): FightzoneNumber(%d) Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum);
			PutGMLogData(G_cTxt);
			m_iFightZoneReserve[iNum] = 0;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_ReserveFightzone");
	}
#endif
}

void CMapServer::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cTargetName[11], cBuff[256];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
						if (m_pClientList[iClientH]->m_iAdminUserLevel < m_pClientList[i]->m_iAdminUserLevel) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
							delete pStrTok;
							return;
						}
						wsprintf(G_cTxt, "GM Order(%s): Close Connection PC(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
						PutGMLogData(G_cTxt);
						//Antipull
						m_pClientList[i]->NoDelete = FALSE;

						m_pClientList[i]->m_bForceDisconnect = true;
						DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
					}
					delete pStrTok;
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CloseConn");
	}
#endif
}

void CMapServer::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cTargetName[11], cBuff[256];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		if (m_pClientList[iClientH]->m_iGuildRank != 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
			return;
		}

		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
						delete pStrTok;
						return;
					}					
					if (m_pClientList[i]->m_iGuildRank != -1) {
						if (m_pClientList[i]->m_iGuildRank == 0) {
							bSendMsgToLS(NUCLEO_REQUEST_DISBANDGUILD, i);
							delete pStrTok;
							return;
						}
						else
						{
							RemoveFromGuild(i);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
							delete pStrTok;
							return;
						}
					}
					/*RemoveFromGuild(i);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
					delete pStrTok;
					return;*/
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UserCommand_BanGuildsman");
	}
#endif
}

void CMapServer::RemoveFromGuild(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		bSendMsgToLS(NUCLEO_REQUEST_DELGUILDSMAN, iClientH);
		SendGuildMsg(iClientH, CLIENT_RESPONSE_DISMISSGUILDSMAN, NULL, NULL, NULL);
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy_secure(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_CLEARGUILDNAME, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 0, 0, 0);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveFromGuild");
	}
#endif
}

int CMapServer::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iDynamicHandle;

		if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
		if (m_pMapList[cMapIndex] == NULL) return NULL;
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

		for (i = 1; i < DEF_MAXFISHS; i++) {
			if (m_pFish[i] == NULL) {
				m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
				if (m_pFish[i] == NULL) return NULL;

				switch (pItem->m_sIDnum) {
					case 101: // ����������
					case 102: // �ʷϹ�����
					case 103: // ����������
					case 570:
					case 571:
					case 572:
					case 573:
					case 574:
					case 575:
					case 576:
					case 577:
						iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
						break;
					default:
						iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
						break;
				}

				if (iDynamicHandle == NULL) {
					delete m_pFish[i];
					m_pFish[i] = NULL;
					return NULL;
				}
				m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
				m_pMapList[cMapIndex]->m_iCurFish++;
				return i;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iCreateFish");
	}
#endif
	return NULL;
}

BOOL CMapServer::bDeleteFish(int iHandle, int iDelMode)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, iH;
		DWORD dwTime;

		if (m_pFish[iHandle] == NULL) return FALSE;

		dwTime = timeGetTime();
		iH = m_pFish[iHandle]->m_sDynamicObjectHandle;

		if (m_pDynamicObjectList[iH] != NULL) {
			SendEventToNearClient_TypeB(CLIENT_COMMON_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
			m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
			m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

			delete m_pDynamicObjectList[iH];
			m_pDynamicObjectList[iH] = NULL;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_iAllocatedFish == iHandle)) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
				ClearSkillUsingStatus(i);
			}
		}
		delete m_pFish[iHandle];
		m_pFish[iHandle] = NULL;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bDeleteFish");
	}
#endif
	return TRUE;
}

int CMapServer::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		short sDistX, sDistY;

		if (m_pClientList[iClientH] == NULL) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

		if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;

		for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
			if (m_pDynamicObjectList[i] != NULL) {
				sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
				sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);

				if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) &&
					((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
					(sDistX <= 2) && (sDistY <= 2)) {

					if (m_pFish[m_pDynamicObjectList[i]->m_sOwner] == NULL) return 0;
					if (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

					if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
					if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
					m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
					m_pClientList[iClientH]->m_iFishChance = 1;
					m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice / 2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
						m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

					m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_sEngagingCount++;
					return i;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iCheckFish");
	}
#endif
	return 0;
}

void CMapServer::FishProcessor()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iSkillLevel, iResult, iChangeValue;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && m_pClientList[i]->m_iAllocatedFish != NULL) {

				if (m_pFish[m_pClientList[i]->m_iAllocatedFish] == NULL) break;

				iSkillLevel = m_pClientList[i]->m_cSkillMastery[1];
				iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
				if (iSkillLevel <= 0) iSkillLevel = 1;

				iChangeValue = iSkillLevel / 10;
				if (iChangeValue <= 0) iChangeValue = 1;
				iChangeValue = iDice(1, iChangeValue);

				iResult = iDice(1, 100);
				if (iSkillLevel > iResult) {
					m_pClientList[i]->m_iFishChance += iChangeValue;
					if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
				}
				else if (iSkillLevel < iResult) {
					m_pClientList[i]->m_iFishChance -= iChangeValue;
					if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: FishProcessor");
	}
#endif
}

void CMapServer::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{

#ifdef DEF_DEBUG
	try {
#endif

		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		class  CItem   * pItem;
		register int tX, tY, iType;
		int iItemID = 0;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		tX = tY = iType = 0;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token != NULL) tX = atoi(token);
		token = pStrTok->pGet();
		if (token != NULL) tY = atoi(token);
		token = pStrTok->pGet();
		if (token != NULL) iType = atoi(token);

		if ((tX != 0) && (tY != 0) && (iType != 0)) {
			pItem = new class CItem;
			if (pItem == NULL) {
				delete pStrTok;
				return;
			}
			iItemID = 100;

			if (_bInitItemAttr(pItem, iItemID) == TRUE) {
				iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000 * 20);
				delete pItem;
				pItem = NULL;
			}
			else {
				delete pItem;
				pItem = NULL;
			}
		}
		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CreateFish");
	}
#endif
}

void CMapServer::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cMapName[11];
		class  CStrTok * pStrTok;
		register int dX, dY;
		BOOL   bFlag;

		dX = dY = -1;
		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cMapName, sizeof(cMapName));
			strcpy_secure(cMapName, token);
		}

		token = pStrTok->pGet();
		if (token != NULL) dX = atoi(token);

		token = pStrTok->pGet();
		if (token != NULL) dY = atoi(token);

		bFlag = FALSE;
		bFlag = CheckActiveMaps(cMapName);

		if (bFlag == FALSE) { delete pStrTok; return; }

		if ((dX == -1) && (dY == -1)) wsprintf(G_cTxt, "GM Order(%s): teleport MapName(%s)", m_pClientList[iClientH]->m_cCharName, cMapName);
		else wsprintf(G_cTxt, "GM Order(%s): teleport MapName(%s)(%d %d)", m_pClientList[iClientH]->m_cCharName, cMapName, dX, dY);

		PutGMLogData(G_cTxt);
		RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);

		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Teleport");
	}
#endif
}

void CMapServer::ReqGetFishThisTimeHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int iResult, iFishH;
		class CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

		m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

		iResult = iDice(1, 100);
		if (m_pClientList[iClientH]->m_iFishChance >= iResult) {

			GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 6));
			pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			pItem->m_dwTimeDrop = timeGetTime();

			SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
			iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
			m_pClientList[iClientH]->m_iAllocatedFish = NULL;

			bDeleteFish(iFishH, 1);
			return;
		}

		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqGetFishThisTimeHandler");
	}
#endif
}

void CMapServer::FishGenerator()
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		register int i, iP, tX, tY, iRet;
		int iItemID = 0;
		short sDifficulty = 0;
		DWORD dwLastTime;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((iDice(1, 4) == 1) && (m_pMapList[i] != NULL) &&
				(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) {

				iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
				if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break;

				tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1, 3) - 2);
				tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1, 3) - 2);

				pItem = new class CItem;
				if (pItem == NULL) break;

				switch (iDice(1, 9)) {
					case 1:	iItemID = 570; sDifficulty = iDice(1, 10) + 5; break;	// �����׾� 
					case 2:	iItemID = 571; sDifficulty = iDice(1, 5) + 15;  break;	// �����׾� 
					case 3:	iItemID = 572; sDifficulty = iDice(1, 10) + 20; break;	// �ݻ� �׾� 
					case 4:	iItemID = 573; sDifficulty = 1;  break;				// �ؾ�
					case 5:	iItemID = 574; sDifficulty = iDice(1, 15) + 1;  break;  // û����
					case 6:	iItemID = 576; sDifficulty = iDice(1, 18) + 1;  break;  // ������
					case 7:	iItemID = 575; sDifficulty = iDice(1, 12) + 1;  break;	// ����
					case 8:	iItemID = 577; sDifficulty = iDice(1, 10) + 1;  break;	// ���� 
					case 9:
						switch (iDice(1, 150)) {
							case 1:
							case 2:
							case 3:
								iItemID = 390;  // ���³����þ� 
								sDifficulty = iDice(4, 4) + 20;
								break;

							case 10:
							case 11:
								iItemID = 391;  // �ʰ��³����þ� 
								sDifficulty = iDice(4, 4) + 40;
								break;

							case 20:
								iItemID = 5;  // �ܰ�+2 
								sDifficulty = iDice(4, 4) + 5;
								break;

							case 30:
								iItemID = 19;  // ��-�ҵ�+2 
								sDifficulty = iDice(4, 4) + 10;
								break;

							case 40:
								iItemID = 27;  // �ù�Ÿ+2 
								sDifficulty = iDice(4, 4) + 15;
								break;

							case 50:
								iItemID = 36;  // �����Ǿ�+2 
								sDifficulty = iDice(4, 4) + 35;
								break;

							case 60:
								iItemID = 56;  // �÷�����+2 
								sDifficulty = iDice(4, 4) + 40;
								break;

							case 70:
								iItemID = 73;  // ��-�׽�+2 
								sDifficulty = iDice(4, 4) + 30;
								break;

							case 90:
								iItemID = 351;  // ���� 
								sDifficulty = iDice(4, 4) + 30;
								break;

							case 95:
								iItemID = 350;  // ���̾Ƹ���
								sDifficulty = iDice(4, 4) + 30;
								break;
						}
						break;
				}

				dwLastTime = (60000 * 10) + (iDice(1, 3) - 1)*(60000 * 10);

				if (_bInitItemAttr(pItem, iItemID) == TRUE) iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime);
				else {
					delete pItem;
					pItem = NULL;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetNpcAttackMode");
	}
#endif
}

int CMapServer::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int ix, iy, iRet;
		class CTile * pTile;

		if ((cMapIndex < 0) || (cMapIndex > DEF_MAXMAPS)) return 0;
		if (m_pMapList[cMapIndex] == NULL) return 0;

		iRet = 0;
		for (ix = dX - cRadius; ix <= dX + cRadius; ix++) {
			for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
				if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) ||
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
				}
				else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
					if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
						iRet++;
				}
			}
		}
		return iRet;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetNpcAttackMode");
	}
#endif
	return 0;
}

void CMapServer::WhetherProcessor()
{
#ifdef DEF_DEBUG
	try {
#endif
		char cPrevMode;
		int i, j, iWeather;
		DWORD dwTime;
		SYSTEMTIME SysTime;

		dwTime = timeGetTime();

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {
				cPrevMode = m_pMapList[i]->m_cWhetherStatus;
				if (m_pMapList[i]->m_cWhetherStatus != NULL) {
					if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime)
						m_pMapList[i]->m_cWhetherStatus = NULL;
				}
				else {
					if (iDice(1, 300) == 13) {
						iWeather = iDice(1, 3);
						GetLocalTime(&SysTime);
						if ((SysTime.wMonth == 12) && (m_cDayOrNight == 3)) iWeather += 3;

						m_pMapList[i]->m_cWhetherStatus = iWeather; // 1~3 �� 4~6 : Snow
						m_pMapList[i]->m_dwWhetherStartTime = dwTime;
						m_pMapList[i]->m_dwWhetherLastTime = 60000 * 3 + 60000 * iDice(1, 7);
					}
				}

				// icebound �ʿ����� �׻� ���� ������.
				if (m_pMapList[i]->m_bIsFixedSnowMode == TRUE) {
					m_pMapList[i]->m_cWhetherStatus = iDice(1, 3) + 3;
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime = 60000 * 3 + 60000 * iDice(1, 7);
				}

				if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
					for (j = 1; j < DEF_MAXCLIENTS; j++) {
						if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i))
							SendNotifyMsg(NULL, j, CLIENT_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);
					}
				}

			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: FishGenerator");
	}
#endif
}

void CMapServer::FightzoneReserveProcessor()
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		for (i = 0; i < DEF_MAXFIGHTZONE; i++) {
			if (m_iFightZoneReserve[i] == -1) continue;
			m_iFightZoneReserve[i] = 0;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: FightzoneReserveProcessor");
	}
#endif
}

int CMapServer::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iWheatherBonus;

		iWheatherBonus = 0;
		switch (cWheatherStatus) {
			case 0: break;
			case 1:
			case 2:
			case 3:
				switch (sType) {
					case 10:
					case 37:
					case 43:
					case 51:
						iWheatherBonus = 1;
						break;

					case 20:
					case 30:
						iWheatherBonus = -1;
						break;
				}
				break;
		}
		return iWheatherBonus;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetWhetherMagicBonusEffect");
	}
#endif
	return 0;
}

int CMapServer::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
	int iRet = 0;
#ifdef DEF_DEBUG
	try {
#endif
		

		if (m_pClientList[iClientH] == NULL) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

		if (m_pClientList[iOpponentH] == NULL) return 0;
		if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

		iRet = 0;

		if (m_pClientList[iClientH]->m_iPKCount != 0) {
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
				(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
				iRet = 7;
			else iRet = 2;
		}
		else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
				(m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL))
				iRet = 6;
			else iRet = 2;
		}
		else {
			if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
				if ((m_pClientList[iClientH]->m_cSide != DEF_NETURAL) && (m_pClientList[iOpponentH]->m_cSide != DEF_NETURAL)) {
					iRet = 2;
				}
				else iRet = 0;
			}
			else {
				if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
					if (m_pClientList[iOpponentH]->m_iGuildRank == 0) iRet = 5;
					else iRet = 3;
				}
				else
					if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) &&
						(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
						iRet = 4;
					}
					else iRet = 1;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetPlayerRelationship");
	}
#endif
	return iRet;
}

int CMapServer::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet;

		if (m_pClientList[iWhatH] == NULL) return 0;
		if (m_pClientList[iRecvH] == NULL) return 0;

		iRet = 0;

		if ((m_pClientList[iWhatH]->m_iPKCount != 0) || (m_pClientList[iWhatH]->Assasain)) iRet = 8;
		if (m_pClientList[iWhatH]->m_cSide != DEF_NETURAL) iRet = iRet | 4;
		if (m_pClientList[iWhatH]->m_cSide == DEF_ARESDEN) iRet = iRet | 2;
		if (m_pClientList[iWhatH]->m_bIsHunter == TRUE) iRet = iRet | 1;

		return iRet;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetPlayerABSStatus");
	}
#endif
	return 0;
}
int CMapServer::iGetNpcRelationship(int iWhatH, int iRecvH)
{
	if (m_pClientList[iRecvH] == NULL) return 0;
	if (m_pNpcList[iWhatH] == NULL) return 0;

	int rtn = 0x0000;
	switch (m_pNpcList[iWhatH]->m_cSide) {
		case 0:	break;
		case 1:	rtn |= 0x0001 << 2; rtn |= 0x0001 << 1; break;
		case 2:	rtn |= 0x0001 << 2; break;
		case 11: rtn |= 0x0001; break;
		case 10: rtn |= 0x0001 << 3; break;
	}
	return rtn;
}

int CMapServer::iGetMapIndex(char * pMapName)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, iMapIndex;
		char cTmpName[256];

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pMapName);

		iMapIndex = -1;
		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0)
					iMapIndex = i;
			}
		}
		return iMapIndex;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetMapIndex");
	}
#endif
	return -1;
}

int CMapServer::_iForcePlayerDisconect()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		//aca agregar antipull
		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				m_pClientList[i]->NoClear = FALSE;

			//agregado AntiPullaca
			if (m_pClientList[i]->NoDelete == TRUE) m_pClientList[i]->NoDelete = FALSE;
			
			if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			{
				m_pClientList[i]->m_bForceDisconnect = true;
				DeleteClient(i, TRUE, TRUE);
			}
			else
			{
				m_pClientList[i]->m_bForceDisconnect = true;
				DeleteClient(i, FALSE, FALSE);
			}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iForcePlayerDisconect");
	}
#endif
	return 0;
}

void CMapServer::SpecialEventHandler()
{
#ifdef DEF_DEBUG
	try {
#endif

		DWORD dwTime;

		dwTime = timeGetTime();

		if ((dwTime - m_dwSpecialEventTime) < DEF_MOBEVENTTIME) return;
		m_dwSpecialEventTime = dwTime;
		m_bIsSpecialEventTime = TRUE;

		switch (iDice(1, 350)) {
			case 98: m_cSpecialEventType = 2; break; // ���� Ȥ�� �������� ���� ���ɼ��� 30�п� 1�� 1/30
			default: m_cSpecialEventType = 1; break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SpecialEventHandler");
	}
#endif
}

void CMapServer::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cIP[21], cInfoString[500];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cIP, sizeof(cIP));
			strcpy_secure(cIP, token);

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
					ZeroMemory(cInfoString, sizeof(cInfoString));
					wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s) ID(%d)",
						m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName,
						m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,
						m_pClientList[i]->m_iLevel, NULL,
						m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress, i);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, cInfoString);
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CheckIP");
	}
#endif
}

void CMapServer::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		//if ((HellOfDeath || PriceHODEvent || SummonLaunched)) {
		if ((HellOfDeath || SummonLaunched)) {
			if ((strcmp(m_pClientList[iClientH]->m_cMapName, "ESAresden") == 0) ||
				(strcmp(m_pClientList[iClientH]->m_cMapName, "ESElvine") == 0) ||
				(strcmp(m_pClientList[iClientH]->m_cMapName, "ESAssasain") == 0))// ||
		//		(strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT) == 0))
				return;
		}
		else if (CityVsCity) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY) == 0) return;

		if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
		else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ToggleSafeAttackModeHandler");
	}
#endif
}

void CMapServer::NpcRequestAssistance(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int ix, iy, sX, sY;
		short sOwnerH;
		char  cOwnerType;

		// iNpc
		if (m_pNpcList[iNpcH] == NULL) return;

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		for (ix = sX - 8; ix <= sX + 8; ix++) {
			for (iy = sY - 8; iy <= sY + 8; iy++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) &&
					(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
					(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {

					m_pNpcList[sOwnerH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
					m_pNpcList[sOwnerH]->m_cTargetType = m_pNpcList[iNpcH]->m_cTargetType;

					return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcRequestAssistance");
	}
#endif
}

void CMapServer::ForceDisconnectAccount(char* pAccountName, WORD wCount)
{

#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
				wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)",
					i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);

				CharacterLogList(G_cTxt);

				if (m_pClientList[i]->NoClear == TRUE) {
					m_pClientList[i]->NoClear = FALSE;
					if (m_pClientList[i]->m_bLimbo) m_pClientList[i]->m_bForceDisconnect = true;
					DeleteClient(i, TRUE, TRUE);
				}
				else {
					if (m_pClientList[i]->m_bLimbo) { m_pClientList[i]->m_bForceDisconnect = true; DeleteClient(i, TRUE, TRUE); }
					else SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
				}
				return;
			}
		}

		bSendMsgToLS(NUCLEO_REQUEST_DELETEACCOUNT, NULL, 0, pAccountName);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ForceDisconnectAccount");
	}
#endif
}


void CMapServer::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{

#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (memcmp(token, "off", 3) == 0) {
				m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;
			}
			m_pClientList[iClientH]->m_sType = atoi(token);
		}

		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Polymorph");
	}
#endif
}

void CMapServer::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			else if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		}

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SetInvi");
	}
#endif
}

BOOL CMapServer::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) {
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	}
	else return TRUE;

	return FALSE;
}

void CMapServer::_CheckAttackType(int iClientH, short *spType)
{
#ifdef DEF_DEBUG
	try {
#endif
		WORD wType;

		if (m_pClientList[iClientH] == NULL) return;
		wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

		switch (*spType) {
			case 2:
				if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
				if (wType < 40) *spType = 1;
				break;

			case 20:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
				break;

			case 21:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
				break;

			case 22:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
				break;

			case 23:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
				break;

			case 24:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
				break;

			case 25:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
				if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
				if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
				if (wType < 40) *spType = 1;
				break;
			case 26:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
				break;

			case 27:
				if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
				if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _CheckAttackType");
	}
#endif
}

void CMapServer::ReqCreatePortionHandler(int iClientH, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD * dwp;
		WORD  * wp;
		char  * cp, cI[6], cPortionName[21], cData[120];
		int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
		short * sp, sItemIndex[6], sTemp;
		short  sItemNumber[6], sItemArray[12];
		BOOL   bDup, bFlag;
		class  CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;
		m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

		for (i = 0; i < 6; i++) {
			cI[i] = -1;
			sItemIndex[i] = -1;
			sItemNumber[i] = 0;
		}

		cp = (char *)(pData + 11);
		cI[0] = *cp;
		cp++;
		cI[1] = *cp;
		cp++;
		cI[2] = *cp;
		cp++;
		cI[3] = *cp;
		cp++;
		cI[4] = *cp;
		cp++;
		cI[5] = *cp;
		cp++;

		for (i = 0; i < 6; i++) {
			if (cI[i] >= DEF_MAXITEMS) return;
			if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
		}

		for (i = 0; i < 6; i++)
			if (cI[i] >= 0) {
				bDup = FALSE;
				for (j = 0; j < 6; j++) {
					if (sItemIndex[j] == cI[i]) {
						sItemNumber[j]++;
						bDup = TRUE;
					}
				}
				if (bDup == FALSE) {
					for (j = 0; j < 6; j++) {
						if (sItemIndex[j] == -1) {
							sItemIndex[j] = cI[i];
							sItemNumber[j]++;
							goto RCPH_LOOPBREAK;
						}
					}
				RCPH_LOOPBREAK:;
				}
			}

		for (i = 0; i < 6; i++) {
			if (sItemIndex[i] != -1) {
				if (sItemIndex[i] < 0) return;
				if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
			}
		}

		bFlag = TRUE;
		while (bFlag == TRUE) {
			bFlag = FALSE;
			for (i = 0; i < 5; i++) {
				if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1)) {
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
						(m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum)) {

						sTemp = sItemIndex[i + 1];
						sItemIndex[i + 1] = sItemIndex[i];
						sItemIndex[i] = sTemp;
						sTemp = sItemNumber[i + 1];
						sItemNumber[i + 1] = sItemNumber[i];
						sItemNumber[i] = sTemp;
						bFlag = TRUE;
					}
				}
			}
		}

		j = 0;
		for (i = 0; i < 6; i++) {
			if (sItemIndex[i] != -1) sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
			else sItemArray[j] = sItemIndex[i];

			sItemArray[j + 1] = sItemNumber[i];
			j += 2;
		}

		ZeroMemory(cPortionName, sizeof(cPortionName));

		for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
			if (m_pPortionConfigList[i] != NULL) {
				bFlag = FALSE;
				for (j = 0; j < 12; j++)
					if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;

				if (bFlag == FALSE) {
					ZeroMemory(cPortionName, sizeof(cPortionName));
					memcpy_secure(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
					iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
					iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
				}
			}
		}

		if (strlen(cPortionName) == 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
			return;
		}

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
		if (iSkillLimit > iSkillLevel) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
			return;
		}

		iSkillLevel -= iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		if (m_pClientList[iClientH]->m_cSkillMastery[12] == 100)
			iSkillLevel += 5;

		iResult = iDice(1, 100);
		if (iResult > iSkillLevel) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
			return;
		}

		if (strlen(cPortionName) != 0) {
			pItem = NULL;
			pItem = new class CItem;
			if (pItem == NULL) return;

			for (i = 0; i < 6; i++) {
				if (sItemIndex[i] != -1) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
						SetItemCount(iClientH, sItemIndex[i], m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
					else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
				}
			}

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);
			GetExp(iClientH, iDice(2, (iDifficulty / 3))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty/3));

			if ((_bInitItemAttr(pItem, cPortionName) == TRUE)) {
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					ZeroMemory(cData, sizeof(cData));
					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMOBTAINED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;	// ������ �Է� 
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					//cp++;
					//cambio lalomanu
					sp = (short *)cp;
					*sp = pItem->m_sItemSpecEffectValue2;
					cp += 2;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;

					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;

					if (iEraseReq == 1) delete pItem;

					//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
					//cambio lalomanu
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							// �޽����� ������ ������ �߻��ߴٸ� �����Ѵ�.
							DeleteClient(iClientH, TRUE, TRUE);
							break;
					}
				}
				else {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
					pItem->m_dwTimeDrop = timeGetTime();

					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							break;
					}
				}
			}
			else {
				delete pItem;
				pItem = NULL;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqCreatePortionHandler");
	}
#endif
}

BOOL CMapServer::_bDecodePortionConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iPortionConfigListIndex = 0;
	int  iCraftingConfigListIndex = 0;
	class CStrTok * pStrTok;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading PORTION configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:	// Potion's index
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
									delete pContents; delete pStrTok; return FALSE;
								}
								if (m_pPortionConfigList[atoi(token)] != NULL) {
									ErrorList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pPortionConfigList[atoi(token)] = new class CPortion;
								iPortionConfigListIndex = atoi(token);
								cReadModeB = 2;
								break;

							case 2: // Potion's name
								ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
								memcpy_secure(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
								cReadModeB = 3;
								break;

							default: // m_sArray[0~10]
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
								cReadModeB++;
								break;

							case 14: // m_sArray[11]
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
								cReadModeB = 15;
								break;

							case 15: // Mini Skill
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
								cReadModeB = 16;
								break;

							case 16:// Difficulty
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					case 2: // Crafting
						switch (cReadModeB) {
							case 1:	// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
									delete pContents; delete pStrTok; return FALSE;
								}
								if (m_pCraftingConfigList[atoi(token)] != NULL) {
									ErrorList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pCraftingConfigList[atoi(token)] = new class CPortion;
								iCraftingConfigListIndex = atoi(token);
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
								memcpy_secure(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
								cReadModeB = 3;
								break;

							default: // m_sArray[0~10]
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
								cReadModeB++;
								break;

							case 14: // m_sArray[11]
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
								cReadModeB = 15;
								break;

							case 15: // 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
								cReadModeB = 16;
								break;

							case 16:// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
									delete pContents; delete pStrTok; return FALSE;
								}
								m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;
					default:
						break;
				}
			}
			else {
				if (memcmp(token, "potion", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "CraftItem", 9) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete[]pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
		PutLogList(cTxt);
		wsprintf(cTxt, "CRAFTING(Total:%d) configuration - success!", iCraftingConfigListIndex);
		PutLogList(cTxt);
		return TRUE;
	}
}

void CMapServer::LocalSavePlayerData(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		char * pData, *cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
		int    iSize;
		FILE * pFile;
		SYSTEMTIME SysTime;

		if (m_pClientList[iClientH] == NULL) return;

		pData = new char[30000];
		ZeroMemory(pData, 30000);

		cp = (char *)(pData);
		iSize = _iComposePlayerDataFileContents(iClientH, cp);

		GetLocalTime(&SysTime);
		ZeroMemory(cCharDir, sizeof(cDir));
		wsprintf(cCharDir, "..\\Nucleo\\Character");

		ZeroMemory(cDir, sizeof(cDir));
		ZeroMemory(cFn, sizeof(cFn));
		strcat(cFn, cCharDir);
		strcat(cFn, "\\");
		strcat(cFn, "\\");
		wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
		strcat(cFn, cTxt);
		strcpy_secure(cDir, cFn);
		strcat(cFn, "\\");
		strcat(cFn, "\\");
		strcat(cFn, m_pClientList[iClientH]->m_cCharName);
		strcat(cFn, ".txt");

		_mkdir(cCharDir);
		_mkdir(cDir);

		if (iSize == 0) {
			CharacterLogList("Character data body empty: Cannot create & save temporal player data file.");
			delete[]pData;
			return;
		}

		pFile = fopen(cFn, "wt");
		if (pFile == NULL) {
			wsprintf(cTxt, "Cannot create temporal player data file : Name(%s)", cFn);
			CharacterLogList(cTxt);
		}
		else {
			m_pClientList[iClientH]->save_quest_data();
			SaveCharacterMarket(iClientH);
		/*	wsprintf(cTxt, "Save character data: %s", m_pClientList[iClientH]->m_cCharName);
		//	PutLogHacksFileList(cTxt);
			PutLogList(cTxt);*/
			fwrite(cp, iSize, 1, pFile);
		}

		if (pFile != NULL) fclose(pFile);
		delete[]pData;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalSavePlayerData");
	}
#endif
}

void CMapServer::MineralGenerator()
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, iP, tX, tY, iRet;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((m_pMapList[i] != NULL) &&
				(m_pMapList[i]->m_bMineralGenerator == TRUE) &&
				(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {

				iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
				if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

				tX = m_pMapList[i]->m_MineralPointList[iP].x;
				tY = m_pMapList[i]->m_MineralPointList[iP].y;

				iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MineralGenerator");
	}
#endif
}

int CMapServer::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i, iDynamicHandle, iMineralType;

		if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
		if (m_pMapList[cMapIndex] == NULL) return NULL;

		for (i = 1; i < DEF_MAXMINERALS; i++) {
			if (m_pMineral[i] == NULL) {
				iMineralType = iDice(1, cLevel);
				m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
				if (m_pMineral[i] == NULL) return NULL;

				iDynamicHandle = NULL;
				switch (iMineralType) {
					case 1: // ������
					case 2:
					case 3:
					case 4:
						iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
						break;

					case 5: // ������ 
					case 6:
						iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
						break;

					default:
						// ���� ������ �ڵ� 
						iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
						break;
				}

				if (iDynamicHandle == NULL) {
					delete m_pMineral[i];
					m_pMineral[i] = NULL;
					return NULL;
				}
				m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
				m_pMineral[i]->m_cMapIndex = cMapIndex;

				switch (iMineralType) {
					case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
					case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
					case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
					case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
					case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
					case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
					default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
				}
				m_pMapList[cMapIndex]->m_iCurMineral++;
				return i;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iCreateMineral");
	}
#endif
	return NULL;
}

void CMapServer::_CheckMiningAction(int iClientH, int dX, int dY)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sType;
		DWORD dwRegisterTime;
		int   iDynamicIndex, iSkillLevel, iResult;
		int   iMineralID;
		class CItem * pItem;
		WORD  wWeaponType;

		if (m_pClientList[iClientH] == NULL)  return;

		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
		}


		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

		switch (sType) {
			case DEF_DYNAMICOBJECT_MINERAL1:
			case DEF_DYNAMICOBJECT_MINERAL2:
				wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

				if (wWeaponType != 25) return;
				if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

				iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
				if (iSkillLevel == 0) break;
				if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;

				iSkillLevel -= m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iDifficulty;
				if (iSkillLevel <= 0) iSkillLevel = 1;

				iResult = iDice(1, 100);
				if (iResult <= iSkillLevel) {
					switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
						case 1:
							switch (iDice(1, 5)) {
								case 1:
								case 2:
								case 3:
									iMineralID = 355; // Coal
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 4:
									iMineralID = 357; // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 5:
									iMineralID = 507; // BlondeStone
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
							}
							break;

						case 2:
							switch (iDice(1, 5)) {
								case 1:
								case 2:
									iMineralID = 355; // Coal
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 3:
									iMineralID = 357; // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 4:
									iMineralID = 356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 5:
									iMineralID = 354; // GoldNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
							}
							break;
						case 3:
							switch (iDice(1, 6)) {
								case 1:
									iMineralID = 355;  //Coal
									GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
									break;
								case 2:
									iMineralID = 355;  //Coal
									GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
									break;
								case 3:
									iMineralID = 356;  // SilverNugget
									GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
									break;
								case 4:
									iMineralID = 357;  //IronOre
									GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
									break;
								case 5:
									iMineralID = 357;  //IronOre
									GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
									break;
								case 6:
									iMineralID = 356;  // SilverNugget
									GetExp(iClientH, iDice(2, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
									break;
							}
							break;
						case 4:
							switch (iDice(1, 6)) {
								case 1:
								case 2:
									iMineralID = 355; // Coal
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 3:
									iMineralID = 357; // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
									break;
								case 4:
									iMineralID = 354; // GoldNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 5);
									break;
								case 5:
									iMineralID = 356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
									break;
								case 6:
									iMineralID = 508; // Mithral
									m_pClientList[iClientH]->m_iExpStock += iDice(1, 15);
									break;
							}
							break;
						case 5:
							switch (iDice(1, 18)) {
								case 3:
									iMineralID = 352;  // Sapphire	
									GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									break;
								default:
									iMineralID = 358;  //Crystal
									GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									break;
							}
							break;
						case 6:
							switch (iDice(1, 5)) {
								case 1:
									if (iDice(1, 3) == 3) {
										iMineralID = 353;  //Emerald
										GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
									}
									else {
										iMineralID = 358;  // Crystal
										GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									}
									break;
								case 2:
									if (iDice(1, 3) == 3) {
										iMineralID = 352;  // Sapphire
										GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
									}
									else {
										iMineralID = 358;  // Crystal
										GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									}
									break;
								case 3:
									if (iDice(1, 3) == 3) {
										iMineralID = 351;  // Ruby
										GetExp(iClientH, iDice(3, 4)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,4);
									}
									else {
										iMineralID = 358;  // Crystal
										GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									}
									break;
								case 4:
									iMineralID = 358;  // Crystal
									GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									break;
								case 5:
									if (iDice(1, 3) == 3) {
										iMineralID = 350;  // Diamond
										GetExp(iClientH, iDice(3, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,5);
									}
									else {
										iMineralID = 358;  // Crystal
										GetExp(iClientH, iDice(3, 3)); //m_pClientList[iClientH]->m_iExpStock += iDice(2,3);
									}
							}
							break;
					}

					pItem = new class CItem;
					if (_bInitItemAttr(pItem, iMineralID) == FALSE) delete pItem;
					else {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY, pItem);
						pItem->m_dwTimeDrop = timeGetTime();
						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
					}

					m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
					if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
						bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

						delete m_pDynamicObjectList[iDynamicIndex];
						m_pDynamicObjectList[iDynamicIndex] = NULL;
					}
				}
				break;

			default:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _CheckMiningAction");
	}
#endif
}

BOOL CMapServer::bDeleteMineral(int iIndex)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iDynamicIndex;
		DWORD dwTime;

		dwTime = timeGetTime();

		if (m_pMineral[iIndex] == NULL) return FALSE;
		iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
		if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

		SendEventToNearClient_TypeB(CLIENT_COMMON_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex,
			m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY,
			m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);

		m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
		m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);

		m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

		delete m_pMineral[iIndex];
		m_pMineral[iIndex] = NULL;

		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bDeleteMineral");
	}
#endif
	return FALSE;
}

void CMapServer::NpcTalkHandler(int iClientH, int iWho, int Quest)
{

#ifdef DEF_DEBUG
	try {
#endif
		char cRewardName[21], cTargetName[21];
		int iResMode = 0, iQuestNum = 0, iQuestType = 0, iRewardType = 0, iRewardAmount = 0, iContribution = 0, iX = 0, iY = 0, iRange = 0, iTargetType = 0, iTargetCount = 0;
		short AssasainPoints = 0;
		bool ActiveQuest;

		iQuestNum = 0;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		if (m_pClientList[iClientH] == NULL) return;
		ActiveQuest = FALSE;

		switch (iWho) {
			case 4:
				if (Quest < 0) ActiveQuest = TRUE;
				if ((Quest > 0 && Quest < 100) && (m_pClientList[iClientH]->m_iQuest != NULL)) ActiveQuest = TRUE;
				else if ((Quest > 100 && Quest < 200) && (m_pClientList[iClientH]->m_iItemQuest != NULL)) ActiveQuest = TRUE;
				else if ((Quest > 200 && Quest < 500) && (m_pClientList[iClientH]->m_iStatedQuest != NULL)) ActiveQuest = TRUE;

				if (ActiveQuest) iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
				else {
					_ArmarQuestContens(iClientH, Quest);
					iQuestNum = Quest;
				}
				break;
			case 21:
				iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
				if (iQuestNum >= 1000) return;
				break;
			case 100:
				if (Quest < 0) ActiveQuest = TRUE;
				if ((Quest > 0 && Quest < 100) && (m_pClientList[iClientH]->m_iQuest != NULL)) ActiveQuest = TRUE;
				else if ((Quest < 200) && (m_pClientList[iClientH]->m_iItemQuest != NULL)) ActiveQuest = TRUE;
				else if (m_pClientList[iClientH]->m_iStatedQuest != NULL) ActiveQuest = TRUE;

				if (ActiveQuest) iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
				else iQuestNum = Quest;
				break;
			case 111: AssasainPoints = m_pClientList[iClientH]->AssasainPoint; break;
			default: break;
		}

		ZeroMemory(cRewardName, sizeof(cRewardName));
		if (iQuestNum > 0 && iQuestNum < 100) {
			m_pClientList[iClientH]->m_iAskedQuest = iQuestNum;
			m_pClientList[iClientH]->m_iQuestRewardType = -1;
			m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
				iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
		}
		else if (iQuestNum >= 100 && iQuestNum < 200) {
			m_pClientList[iClientH]->m_iAskedQuest = iQuestNum;
			m_pClientList[iClientH]->m_iItemQuestRewardType = -2;
			m_pClientList[iClientH]->m_iQuestRewardAmount = 1;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
				iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
		}
		else if (iQuestNum >= 200 && iQuestNum < 500) {
			m_pClientList[iClientH]->m_iAskedQuest = iQuestNum;
			m_pClientList[iClientH]->m_iStatedQuestRewardType = -3;
			m_pClientList[iClientH]->m_iQuestRewardAmount = 1;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
				iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
		}
		else {
			switch (iQuestNum) {
				case  0: SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (iWho + 130), NULL, AssasainPoints, NULL, NULL); break;
				case -1:
				case -2:
				case -3:
				case -4:
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, abs(iQuestNum) + 100, NULL, NULL, NULL, NULL);
					break;
				case -5:
					m_pClientList[iClientH]->TotalQuestCompleted++;
					if (!m_pClientList[iClientH]->Achivements[1].Complete)
						CheckCompleteAchivement(iClientH, 1, TRUE);
					else if (!m_pClientList[iClientH]->Achivements[5].Complete)
						CheckCompleteAchivement(iClientH, 5, TRUE);
					else if (!m_pClientList[iClientH]->Achivements[14].Complete)
						CheckCompleteAchivement(iClientH, 14, TRUE);
					else if (!m_pClientList[iClientH]->Achivements[21].Complete)
						CheckCompleteAchivement(iClientH, 21, TRUE);

					if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL && m_pClientList[iClientH]->m_iExp < m_iLevelExpTable[DEF_PLAYERMAXLEVEL]) {
						m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[DEF_PLAYERMAXLEVEL];
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
					}

					//aca mjs
				//	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 10;
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 0;
					if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft > DEF_MAXGIZONPOINT) m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = DEF_MAXGIZONPOINT; // adamas
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
					break;

				case -6: break;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NpcTalkHandler");
	}
#endif
}

void CMapServer::CheckFireBluring(char cMapIndex, int sX, int sY)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int ix, iy, iItemNum;
		register short sSpr, sSprFrame;
		char  cItemColor;
		class CItem * pItem;

		for (ix = sX - 1; ix <= sX + 1; ix++) {
			for (iy = sY - 1; iy <= sY + 1; iy++) {
				iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);

				switch (iItemNum) {
					case 355:
						pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
						if (pItem != NULL) delete pItem;
						iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);

						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_SETITEM, cMapIndex,
							ix, iy, sSpr, sSprFrame, cItemColor);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckFireBluring");
	}
#endif
}

void CMapServer::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cNpcName[256];
		class  CStrTok * pStrTok;
		register int i;

		ZeroMemory(cNpcName, sizeof(cNpcName));

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);

		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cNpcName, sizeof(cNpcName));
			strcpy_secure(cNpcName, token);
		}

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ADMINIFO, 1, i, NULL, NULL);
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_GetNpcStatus");
	}
#endif
}

int CMapServer::_iGetWeaponSkillType(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		WORD wWeaponType;

		if (m_pClientList[iClientH] == NULL) return 0;

		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

		if (wWeaponType == 0)  return 5;
		else if ((wWeaponType >= 1) && (wWeaponType <= 2)) return 7;
		else if ((wWeaponType > 2) && (wWeaponType < 20)) {
			if (wWeaponType == 7) return 9;
			else return 8;
		}
		else if ((wWeaponType >= 20) && (wWeaponType < 30)) return 10;
		else if ((wWeaponType >= 30) && (wWeaponType < 35)) return 14;
		else if ((wWeaponType >= 35) && (wWeaponType < 40)) return 21;
		else if (wWeaponType >= 40) return 6;

		return 1;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iGetWeaponSkillType");
	}
#endif
}

static int ___iCAB5[] = { 0,0, 0,1,2 };
static int ___iCAB6[] = { 0,0, 0,0,0 };
static int ___iCAB7[] = { 0,0, 1,2,3 };
static int ___iCAB8[] = { 0,0, 1,3,5 };
static int ___iCAB9[] = { 0,0, 2,4,8 };
static int ___iCAB10[] = { 0,0, 1,2,3 };

int CMapServer::iGetComboAttackBonus(int iSkill, int iComboCount)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (iComboCount <= 1) return 0;
		if (iComboCount > 6) return 0;
		switch (iSkill) {
			case 5: // Hand-Attack
				return ___iCAB5[iComboCount];
				break;
			case 6: // Archery
				return ___iCAB6[iComboCount];
				break;
			case 7: // Short-Sword
				return ___iCAB7[iComboCount];
				break;
			case 8: // Long-Sword
				return ___iCAB8[iComboCount];
				break;
			case 9: // Fencing
				return ___iCAB9[iComboCount];
				break;
			case 10: // Axe-Attack
				return ___iCAB10[iComboCount];
				break;
			case 14: // Hammer
				return ___iCAB6[iComboCount];
				break;
			case 21: // Staff-Attack
				return ___iCAB10[iComboCount];
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckFireBluring");
	}
#endif
	return 0;
}

void CMapServer::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
			m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetDownSkillIndexHandler");
	}
#endif
}

BOOL CMapServer::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
#ifdef DEF_DEBUG
	try {
#endif
		BOOL bRet;
		DWORD dwSWEType, dwSWEValue, iValue;
		char cInfo[256];
		int Category, Category2, Category3;

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:

				if ((BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 == TRUE)
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 = 100;

				bRet = __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1,    //!!! SpecValue!!!
					iClientH, // ��ġ�� 
					(BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); //

				if (bRet != TRUE)
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);

				return bRet;
				break;

				// crusade
			case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
				bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
					iClientH); // ��ġ�� 
				return bRet;
				break;

			case DEF_ITEMEFFECTTYPE_DYE:
				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
						if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
							(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12)) {
							m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
							return TRUE;
						}
						else {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
							return FALSE;
						}
					}
				}
				break;

			case DEF_ITEMEFFECTTYPE_ARMORDYE:
				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
						if (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) {
							m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
							return TRUE;
						}
						else {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
							return FALSE;
						}
					}
				}
				break;

			case DEF_ITEMEFFECTTYPE_SWEAPONATTRIBUTE_STONE:
				// Bloqueo para GM's
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) {
					wsprintf(G_cTxt, "Los GM's no pueden utilizar este item");
					ShowClientMsg(iClientH, G_cTxt);
					return FALSE;
				}
				if (m_pClientList[iClientH] == NULL) return FALSE;

				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 2) ||
							(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 10) ||
							(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 11) ||
							(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 12)) {
							Category = 1; // Armas
							Category2 = 8; // Wands
							Category3 = -1; // Null
						}
						else {
							Category = 6; // Armaduras normales
							Category2 = 12; // Ropa (incluye capas, y botas)
							Category3 = 5; // Shields
						}

						if (VerificarItem(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_sIDnum) == TRUE) {
							if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == Category) ||
								(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == Category2) ||
								(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == Category3)) {

								dwSWEType = (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_dwAttribute & 0x0000F000) >> 12;
								dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_dwAttribute & 0x00000F00) >> 8;

								if ((dwSWEValue <= 0) && (dwSWEValue < DEF_LIMIT_STATSTONE)) {
									DropItemID(iClientH, sDestItemID,
										m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_sIDnum,
										m_pClientList[iClientH]->m_sX,
										m_pClientList[iClientH]->m_sY,
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
										m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 2);
								}
								else {
									if ((dwSWEValue >= 1) && (dwSWEValue < DEF_LIMIT_STATSTONE) && (dwSWEType == m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)) {
										DropItemID(iClientH, sDestItemID,
											m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_sIDnum,
											m_pClientList[iClientH]->m_sX,
											m_pClientList[iClientH]->m_sY,
											m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
											m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 + dwSWEValue,
											m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 2);
									}
									else {
										wsprintf(cInfo, "El item seleccionado no puede ser mejorado.");
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, cInfo);
										return FALSE;
									}
								}
								return TRUE;
							}
							else return FALSE;
						}
						else {
							wsprintf(cInfo, "El item seleccionado no puede ser mejorado.");
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, cInfo);
							return FALSE;
						}
					}
					else return FALSE;
				}
				else return FALSE;

				break;

			case DEF_ITEMEFFECTTYPE_PWEAPONATTRIBUTE_STONE:
				// Bloqueo para GM's
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) {
					wsprintf(G_cTxt, "Los GM's no pueden utilizar este item");
					ShowClientMsg(iClientH, G_cTxt);
					return FALSE;
				}
				if (m_pClientList[iClientH] == NULL) return FALSE;

				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 11) ||
							(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1 == 12)) {
							Category = 6; // Armaduras normales
							Category2 = 12; // Ropa (incluye capas, y botas)
							Category3 = 5; // Shields
						}
						else {
							Category = 1; // Armas
							Category2 = 8; // Wands
							Category3 = -1; // Null

						}
						if (VerificarItem(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_sIDnum) == TRUE) {
							if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == Category) ||
								(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == Category2) ||
								(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == Category3)) {

								dwSWEType = (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_dwAttribute & 0x00F00000) >> 20;
								dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_dwAttribute & 0x000F0000) >> 16;

								if ((dwSWEValue <= 0) && (dwSWEValue < DEF_LIMIT_STATSTONE)) {
									DropItemID(iClientH, sDestItemID,
										m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_sIDnum,
										m_pClientList[iClientH]->m_sX,
										m_pClientList[iClientH]->m_sY,
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
										m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 1);
								}
								else {
									if ((dwSWEValue >= 1) && (dwSWEValue < DEF_LIMIT_STATSTONE) && (dwSWEType == m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)) {
										DropItemID(iClientH, sDestItemID,
											m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_sIDnum,
											m_pClientList[iClientH]->m_sX,
											m_pClientList[iClientH]->m_sY,
											m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
											m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 + dwSWEValue,
											m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 1);
									}
									else {
										wsprintf(cInfo, "El item seleccionado no puede ser mejorado.");
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, cInfo);
										return FALSE;
									}
								}
								return TRUE;
							}
							else return FALSE;
						}
						else {
							wsprintf(cInfo, "El item seleccionado no puede ser mejorado.");
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, cInfo);
							return FALSE;
						}
					}
					else return FALSE;
				}
				else return FALSE;

				break;
				//cambiado lalo
			case DEF_ITEMEFFECTTYPE_ITEMFARM:	//v2.19 2002-12-16 ���� ��ų ����
				/*bRet = __bSetAgricultureItem(m_pClientList[iClientH]->m_cMapIndex, dX, dY,       // 
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,		//
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,		//
					iClientH); */// ��ġ�� 
			//	return;// bRet;
				break;

			case DEF_ITEMEFFECTTYPE_REMOVEITEMID:
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) {
					wsprintf(G_cTxt, "Los GM's no pueden utilizar este item");
					ShowClientMsg(iClientH, G_cTxt);
				}

				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL)
						RemoveItemUniqueID(iClientH, sDestItemID, sItemIndex);
				}
				break;
				//Nuevo Change Master ID
			case DEF_ITEMEFFECTTYPE_MasterItemID:
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) {
					wsprintf(G_cTxt, "Los GM's no pueden utilizar este item");
					ShowClientMsg(iClientH, G_cTxt);
				}

				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL)
						RemoveItemMasterID(iClientH, sDestItemID, sItemIndex);
				}
				break;	
				//Nuevo Sacar ID
			case DEF_ITEMEFFECTTYPE_SacoItemID:
				if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) {
					wsprintf(G_cTxt, "Los GM's no pueden utilizar este item");
					ShowClientMsg(iClientH, G_cTxt);
				}

				if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
					if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL)
						RemoveTotalID(iClientH, sDestItemID, sItemIndex);
				}
				break;

			default:
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChatMsgHandler");
	}
#endif
	return TRUE;
}

BOOL CMapServer::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAutoFlag)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   iDynamicObjectIndex, iIndex;
		class CTile * pTile;
		DWORD dwTime = timeGetTime();

		if (m_pMapList[cMapIndex] == NULL) return FALSE;

		//ZeroEoyPnk - Plant The Flag
		if (TowerDefense == TRUE) {
			if (FlagAresden == TRUE) {
				if (((dX >= 156) && (dX <= 159)) && ((dY >= 33) && (dY <= 36))) { // Aresden Point
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);

					if (pTile->m_iAttribute != NULL) return FALSE;
					if (pTile->m_iOccupyFlagIndex != NULL) return FALSE;
					if (pTile->m_bIsMoveAllowed == FALSE) return FALSE;
					if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) return FALSE;
					if (m_pClientList[iClientH] == NULL) return FALSE;

					switch (m_pClientList[iClientH]->m_cSide) {
						case 1:	// Aresden
							iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);
							break;
						default: // Others
							return FALSE;
							break;
					}
					if (iDynamicObjectIndex == NULL) return FALSE;
					iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
					if (iIndex == -1) ErrorList("Error registering OccupyFlag.");
					EndTowerDefenceMode(1);
					return TRUE;
				}
			}
			else if (FlagElvine == TRUE) {
				if (((dX >= 44) && (dX <= 47)) && ((dY >= 127) && (dY <= 129))) { // Elvine Point
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);

					if (pTile->m_iAttribute != NULL) return FALSE;
					if (pTile->m_iOccupyFlagIndex != NULL) return FALSE;
					if (pTile->m_bIsMoveAllowed == FALSE) return FALSE;
					if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) return FALSE;
					if (m_pClientList[iClientH] == NULL) return FALSE;

					switch (m_pClientList[iClientH]->m_cSide) {
						case 2: // Elvine	
							iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);
							break;
						default: // Others
							return FALSE;
							break;
					}
					if (iDynamicObjectIndex == NULL) return FALSE;
					iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
					if (iIndex == -1) ErrorList("Error registering OccupyFlag.");
					EndTowerDefenceMode(2);
					return TRUE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: __bSetOccupyFlag");
	}
#endif
	return FALSE;
}

void CMapServer::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iTargetIndex;
		char   seps[] = "= \t\n";
		char   * token, cTargetName[11], cBuff[256];
		class  CStrTok * pStrTok;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_cSide == 0 && m_pClientList[iClientH]->Assasain == FALSE) return;

		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));

		switch (iMode) {
			case 0: // Free ����
			case 1: // Hold ����
				for (i = 0; i < DEF_MAXNPCS; i++) {
					if (m_pNpcList[i] != NULL) {
						if ((m_pNpcList[i]->m_bIsSummoned == TRUE) &&
							(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
							(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {

							m_pNpcList[i]->m_iSummonControlMode = iMode;
							m_pNpcList[i]->m_bIsPermAttackMode = FALSE;
							m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
							m_pNpcList[i]->m_sBehaviorTurnCount = 0;
							m_pNpcList[i]->m_iTargetIndex = NULL;
						}
					}
				}
				break;

			case 2: // target
				if ((dwMsgSize) <= 0) return;
				memcpy_secure(cBuff, pData, dwMsgSize);
				pStrTok = new class CStrTok(cBuff, seps);
				token = pStrTok->pGet();
				token = pStrTok->pGet();

				iTargetIndex = 0;
				if (token != NULL) {
					if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
					else memcpy_secure(cTargetName, token, strlen(token));

					for (i = 1; i < DEF_MAXCLIENTS; i++) {
						if ((m_pClientList[i] != NULL)
							&& (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)
							&& (strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0)) {
							iTargetIndex = i;
							goto SSMA_SKIPSEARCH;
						}
					}
				}
			SSMA_SKIPSEARCH:;
				if ((iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0 || m_pClientList[iTargetIndex]->Assasain == TRUE)
					&& (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
					for (i = 0; i < DEF_MAXNPCS; i++) {
						if (m_pNpcList[i] != NULL) {
							if ((m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)
								&& (m_pNpcList[i]->m_bIsSummoned == TRUE)
								&& (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH)) {
								m_pNpcList[i]->m_iSummonControlMode = iMode;
								m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
								m_pNpcList[i]->m_sBehaviorTurnCount = 0;
								m_pNpcList[i]->m_iTargetIndex = iTargetIndex;
								m_pNpcList[i]->m_cTargetType = DEF_OWNERTYPE_PLAYER;
								m_pNpcList[i]->m_bIsPermAttackMode = TRUE;
							}
						}
					}
				}
				delete pStrTok;
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetSummonMobAction");
	}
#endif
}

void CMapServer::GetFightzoneTicketHandler(int iClientH)
{

#ifdef DEF_DEBUG
	try {
#endif
		int   iRet, iEraseReq, iMonth, iDay, iHour;
		char  * cp, cData[256], cItemName[21];
		class CItem * pItem;
		DWORD * dwp;
		short * sp;
		WORD  * wp;

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) {
			m_pClientList[iClientH]->m_iFightzoneNumber *= -1;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
			return;
		}

		ZeroMemory(cItemName, sizeof(cItemName));

		if (m_pClientList[iClientH]->m_iFightzoneNumber == 1)
			strcpy_secure(cItemName, DEF_ITEMNAME_ARENATICKET);
		else  wsprintf(cItemName, DEF_ITEMNAME_ARENATICKET2, m_pClientList[iClientH]->m_iFightzoneNumber);

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			delete pItem;
			return;
		}

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

			m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber - 1;

			pItem->m_sTouchEffectType = DEF_ITET_DATE;

			iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000;
			iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth * 10000) / 100;
			iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth * 10000 - iDay * 100;

			pItem->m_sTouchEffectValue1 = iMonth;
			pItem->m_sTouchEffectValue2 = iDay;
			pItem->m_sTouchEffectValue3 = iHour;

			_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

			ZeroMemory(cData, sizeof(cData));

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy_secure(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
			cp++;

			sp = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

		//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		//	cp++;
			//cambio lalomanu
			sp = (short *)cp;
			*sp = pItem->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;

			if (iEraseReq == 1) {
				delete pItem;
				pItem = NULL;
			}

			//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			//cambio lalomanu
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
			iCalcTotalWeight(iClientH);

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
		else {
			delete pItem;
			pItem = NULL;

			iCalcTotalWeight(iClientH);

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetFightzoneTicketHandler");
	}
#endif
}

int CMapServer::_iComposeFlagStatusContents(char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		SYSTEMTIME SysTime;
		char cTxt[120];
		int i;

		if (m_iMiddlelandMapIndex < 0) return 0;

		GetLocalTime(&SysTime);
		strcat(pData, "[FILE-DATE]\n\n");

		wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
		strcat(pData, cTxt);
		strcat(pData, "\n\n");

		for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) {
			if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) {

				wsprintf(cTxt, "flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
					m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
					m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
					m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
				strcat(pData, cTxt);
				strcat(pData, "\n");
			}
		}
		strcat(pData, "\n\n");

		return strlen(pData);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iComposeFlagStatusContents");
	}
#endif
	return 0;
}

void CMapServer::GetHeroMantleHandler(int iClientH, int iOpcion)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   i, iNum, iRet, iEraseReq, iRequiredEK = 0, iRequiredContri = 0, iItemID = 0;
		char  * cp, cData[256], cItemName[21];
		class CItem * pItem;
		DWORD * dwp;
		short * sp;
		WORD  * wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
		if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) return;

		if (_iGetItemSpaceLeft(iClientH) == 0) {
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}

		switch (iOpcion) {
			case 1:
				if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) iItemID = 400;
				else if (m_pClientList[iClientH]->m_cSide == DEF_ELVINE) iItemID = 401;
				iRequiredEK = 300;
				iRequiredContri = 0;
				break;

			case 2:
				if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 403;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 404;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 405;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 406;
				iRequiredEK = 150;
				iRequiredContri = 20;
				break;

			case 3:
				if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 407;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 408;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 409;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 410;
				iRequiredEK = 100;
				iRequiredContri = 20;
				break;

			case 4:
				if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 411;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 412;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 413;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 414;
				iRequiredEK = 300;
				iRequiredContri = 30;
				break;

			case 5:
				if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 415;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 416;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 417;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 418;
				iRequiredEK = 200;
				iRequiredContri = 20;
				break;

			case 6:
				if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 419;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 420;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 421;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 422;
				iRequiredEK = 100;
				iRequiredContri = 10;
				break;

			case 7:
				if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 423;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 424;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 1)) iItemID = 425;
				else if ((m_pClientList[iClientH]->m_cSide == DEF_ELVINE) && (m_pClientList[iClientH]->m_cSex == 2)) iItemID = 426;
				iRequiredEK = 150;
				iRequiredContri = 15;
				break;

			default:
				return;
				break;
		}

		if ((m_pClientList[iClientH]->m_iEnemyKillCount < iRequiredEK) || (m_pClientList[iClientH]->m_iContribution < iRequiredContri)) return;

		iNum = 1;
		for (i = 1; i <= iNum; i++) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				pItem = NULL;
			}
			else {
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

					m_pClientList[iClientH]->m_iEnemyKillCount -= iRequiredEK;
					m_pClientList[iClientH]->m_iContribution -= iRequiredContri;

					ZeroMemory(cItemName, sizeof(cItemName));
					memcpy_secure(cItemName, pItem->m_cName, 20);
					wsprintf(G_cTxt, "(*) Get Mantle : Char(%s) Item(%s) Player-EK(%d) Contribution(%d)", m_pClientList[iClientH]->m_cCharName, cItemName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution);
					CharacterLogList(G_cTxt);

					pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMOBTAINED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0;
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

				//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				//	cp++;
					//cambio lalomanu
					sp = (short *)cp;
					*sp = pItem->m_sItemSpecEffectValue2;
					cp += 2;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;

					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;

					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

					if (iEraseReq == 1) {
						delete pItem;
						pItem = NULL;
					}

					//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
					//cambio lalomanu
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

					iCalcTotalWeight(iClientH);

					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					SendEnemyKills(iClientH);
					SendContribution(iClientH);
				}
				else {
					delete pItem;
					pItem = NULL;

					iCalcTotalWeight(iClientH);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetHeroMantleHandler");
	}
#endif
}

void CMapServer::_SetItemPos(int iClientH, char *pData)
{

#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cItemIndex;
		short * sp, sX, sY;

		if (m_pClientList[iClientH] == NULL) return;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		cItemIndex = *cp;
		cp++;

		sp = (short *)cp;
		sX = *sp;
		cp += 2;

		sp = (short *)cp;
		sY = *sp;
		cp += 2;

		if (sY < -10) sY = -10;

		if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cItemIndex] == NULL) return;

		m_pClientList[iClientH]->m_pItemList[cItemIndex]->SetBagPosition(sX, sY);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _SetItemPos");
	}
#endif
}

void CMapServer::CheckUniqueItemEquipment(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iDamage;

		if (m_pClientList[iClientH] == NULL) return;

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
					(m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {

					if ((m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
					}
					else {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
						ReleaseItemHandler(iClientH, i, TRUE);

						iDamage = iDice(10, 10);
						m_pClientList[iClientH]->m_iHP -= iDamage;
						if (m_pClientList[iClientH]->m_iHP <= 0) ClientKilledHandler(iClientH, NULL, NULL, iDamage);
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckUniqueItemEquipment");
	}
#endif
}

void CMapServer::_BWM_Command_Shutup(char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cName[11];
		register int i;

		cp = (char *)(pData + 16);

		ZeroMemory(cName, sizeof(cName));
		memcpy_secure(cName, cp, 10);

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
					m_pClientList[i]->m_iTimeLeft_ShutUp = 20 * 3 * 10; // 1�� 3�ʴ�. 20�̸� 1�� ���� �ϸ� ������ ����Ƽ 10��  
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_PLAYERSHUTUP, 20 * 3 * 10, NULL, NULL, cName);

					wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20 * 3 * 10);
					PutGMLogData(G_cTxt);

					return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _BWM_Command_Shutup");
	}
#endif
}

void CMapServer::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sOwnerH;
		char  cOwnerType;
		short iWeightLeft;
		char Error;

		if (m_pClientList[iClientH] == NULL) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) return;
		if (wObjectID >= DEF_MAXCLIENTS) return;
		if (FinalFight && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0) return;
		if (DKEvent && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_EVENTDK) == 0 && m_pClientList[iClientH]->m_iAdminUserLevel == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0) return;

		//NADA CON ID
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			ShowClientMsg(iClientH, "Item con ID no puedes Tradearlo!");
			return;
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		Error = -1;

		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
			if (wObjectID != NULL) {
				if (wObjectID < 10000) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
				else sOwnerH = NULL;
			}
			if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
				_ClearExchangeStatus(iClientH);
			}
			else {
				if ((m_pClientList[sOwnerH]->m_bIsExchangeMode == TRUE) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
					(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
					_ClearExchangeStatus(iClientH);
				}
				else {
					m_pClientList[iClientH]->m_bIsExchangeMode = TRUE;
					m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
					strcpy_secure(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);

					//Clear items in the list
					m_pClientList[iClientH]->iExchangeCount = 0;
					m_pClientList[sOwnerH]->iExchangeCount = 0;
					for (int i = 0; i < 20; i++) {
						//Clear the trader
						ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
						//Clear the guy we're trading with
						ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeItemName[i], sizeof(m_pClientList[sOwnerH]->m_cExchangeItemName[i]));
						m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
					}

					m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount] = (char)sItemIndex;
					m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

					memcpy_secure(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);

					m_pClientList[sOwnerH]->m_bIsExchangeMode = TRUE;
					m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
					ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
					strcpy_secure(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

					m_pClientList[iClientH]->iExchangeCount++;
					SendNotifyMsg(sOwnerH, iClientH, CLIENT_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 + 100,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute, FALSE, (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3);

					SendNotifyMsg(iClientH, sOwnerH, CLIENT_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 + 100,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute, FALSE, (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3);

					iWeightLeft = CalcWeightExchange(iClientH, sOwnerH);
					if (iWeightLeft < 100) Error = 1;

					if (Error == -1) {
						iWeightLeft = CalcWeightExchange(sOwnerH, iClientH);
						if (iWeightLeft < 100) Error = 2;
					}

					if (Error == -1) {
						if (CalcTotalBagExchange(sOwnerH, iClientH) == TRUE) Error = 3;
						else if (CalcTotalBagExchange(sOwnerH, iClientH) == TRUE) Error = 4;
					}

					if (Error != -1) {
						switch (Error) {
							case 1:
								SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 2, NULL, NULL, NULL);
								SendNotifyMsg(iClientH, sOwnerH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 1, NULL, NULL, NULL);
								break;
							case 2:
								SendNotifyMsg(sOwnerH, sOwnerH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 1, NULL, NULL, NULL);
								SendNotifyMsg(sOwnerH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 2, NULL, NULL, NULL);
								break;
							case 3:
								SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 4, NULL, NULL, NULL);
								SendNotifyMsg(iClientH, sOwnerH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 3, NULL, NULL, NULL);
								break;
							case 4:
								SendNotifyMsg(sOwnerH, sOwnerH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 3, NULL, NULL, NULL);
								SendNotifyMsg(sOwnerH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 4, NULL, NULL, NULL);
								break;
							default:
								break;
						}
					}
					else {
						SendNotifyMsg(sOwnerH, sOwnerH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 0, NULL, NULL, NULL);
						SendNotifyMsg(sOwnerH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 0, NULL, NULL, NULL);
					}
				}
			}
		}
		else {
			_ClearExchangeStatus(iClientH);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ExchangeItemHandler");
	}
#endif
}

void CMapServer::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{

#ifdef DEF_DEBUG
	try {
#endif
		int iExH;
		int iWeightLeft;
		char Error;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
		if (m_pClientList[iClientH]->iExchangeCount > 20) return;	//only 4 items trade

		//no admin trade
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) {
			_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
			_ClearExchangeStatus(iClientH);
		}

		//NADA CON ID
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			ShowClientMsg(iClientH, "Item con ID no puedes Tradearlo!");
			return;
		}

		Error = -1;

		if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			if ((m_pClientList[iExH] == NULL) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0)) {}
			else {
				if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;

				//No Duplicate items
				for (int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
					if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) return;
				}

				if (m_pClientList[iClientH]->iExchangeCount < 20) {
					m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount] = (char)iItemIndex;
					m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

					memcpy_secure(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

					m_pClientList[iClientH]->iExchangeCount++;
					SendNotifyMsg(iClientH, iClientH, CLIENT_NOTIFY_SETEXCHANGEITEM, iItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 + 100,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, FALSE, (char)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3);

					SendNotifyMsg(iClientH, iExH, CLIENT_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 + 100,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, FALSE, (char)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3);
				}
				iWeightLeft = CalcWeightExchange(iClientH, iExH);
				if (iWeightLeft < 100) Error = 1;

				if (Error == -1) {
					iWeightLeft = CalcWeightExchange(iExH, iClientH);
					if (iWeightLeft < 100) Error = 2;
				}

				if (Error == -1) {
					if (CalcTotalBagExchange(iExH, iClientH) == TRUE) Error = 3;
					else if (CalcTotalBagExchange(iExH, iClientH) == TRUE) Error = 4;
				}

				if (Error != -1) {
					switch (Error) {
						case 1:
							SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 2, NULL, NULL, NULL);
							SendNotifyMsg(iClientH, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 1, NULL, NULL, NULL);
							break;
						case 2:
							SendNotifyMsg(iExH, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 1, NULL, NULL, NULL);
							SendNotifyMsg(iExH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 2, NULL, NULL, NULL);
							break;
						case 3:
							SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 4, NULL, NULL, NULL);
							SendNotifyMsg(iClientH, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 3, NULL, NULL, NULL);
							break;
						case 4:
							SendNotifyMsg(iExH, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 3, NULL, NULL, NULL);
							SendNotifyMsg(iExH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 4, NULL, NULL, NULL);
							break;
						default: break;
					}
				}
				else {
					SendNotifyMsg(iClientH, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 0, NULL, NULL, NULL);
					SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 0, NULL, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetExchangeItem");
	}
#endif
}

void CMapServer::ConfirmExchangeItem(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iExH, i;
		int iAmountLeft;
		class CItem * pItemA[20], *pItemB[20], *pItemAcopy[20], *pItemBcopy[20];

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		
		if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;

			if (iClientH == iExH) return;
			if (m_pClientList[iExH] != NULL) {
				if ((memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
					(m_pClientList[iExH]->m_bIsExchangeMode != TRUE) ||
					(memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0)) {

					_ClearExchangeStatus(iClientH);
					_ClearExchangeStatus(iExH);
					return;
				}
				else {
					m_pClientList[iClientH]->m_bIsExchangeConfirm = TRUE;
					if (m_pClientList[iExH]->m_bIsExchangeConfirm == TRUE) {
						for (i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
							if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
								(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
								if (m_pClientList[iClientH]->m_iExchangeItemAmount[i] > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) {
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;
								}

								pItemA[i] = new class CItem;
								_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

								pItemAcopy[i] = new class CItem;
								_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemAcopy[i], pItemA[i]);
								pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							}
							else {
								pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
								pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

								pItemAcopy[i] = new class CItem;
								_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemAcopy[i], pItemA[i]);
								pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							}

							// Saco los items del char
							if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
								(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
								iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
								if (iAmountLeft < 0) iAmountLeft = 0;
								SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
							}
							else {
								ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], TRUE);
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iExH]->m_cCharName);
								m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = NULL;
							}
						}

						for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
							if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
								(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
								if (m_pClientList[iExH]->m_iExchangeItemAmount[i] > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) {
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;
								}
								pItemB[i] = new class CItem;
								_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

								pItemBcopy[i] = new class CItem;
								_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemBcopy[i], pItemB[i]);
								pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
							}
							else {
								pItemB[i] = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
								pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

								pItemBcopy[i] = new class CItem;
								_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemBcopy[i], pItemB[i]);
								pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
							}

							// Saco los items del char
							if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
								(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
								//
								iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
								if (iAmountLeft < 0) iAmountLeft = 0;
								SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
							}
							else {
								ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], TRUE);
								SendNotifyMsg(NULL, iExH, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iClientH]->m_cCharName);
								m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = NULL;
							}
						}

						for (i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
							bAddItem(iExH, pItemA[i], NULL);
							_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
							delete pItemAcopy[i];
							pItemAcopy[i] = NULL;
						}

						for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
							bAddItem(iClientH, pItemB[i], NULL);
							_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
							delete pItemBcopy[i];
							pItemBcopy[i] = NULL;
						}

						m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
						m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
						ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
						m_pClientList[iClientH]->m_iExchangeH = NULL;
						m_pClientList[iClientH]->iExchangeCount = 0;

						m_pClientList[iExH]->m_bIsExchangeMode = FALSE;
						m_pClientList[iExH]->m_bIsExchangeConfirm = FALSE;
						ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
						m_pClientList[iExH]->m_iExchangeH = NULL;
						m_pClientList[iExH]->iExchangeCount = 0;

						for (i = 0; i < 20; i++) {
							m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
							m_pClientList[iExH]->m_cExchangeItemIndex[i] = -1;
						}

						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
						SendNotifyMsg(NULL, iExH, CLIENT_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);

						iCalcTotalWeight(iClientH);
						iCalcTotalWeight(iExH);
						return;
					}
					else SendNotifyMsg(NULL, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, NULL, NULL, NULL, NULL);
				}
			}
			else {
				_ClearExchangeStatus(iClientH);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ConfirmExchangeItem");
	}
#endif
}

int CMapServer::_iGetItemSpaceLeft(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		int i, iTotalItem;

		iTotalItem = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

		return (DEF_MAXITEMS - iTotalItem);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iGetItemSpaceLeft");
	}
#endif
	return 0;
}

BOOL CMapServer::bAddItem(int iClientH, CItem * pItem, char cMode)
{

#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cData[256];
		DWORD * dwp;
		WORD  * wp;
		short * sp;
		int iRet, iEraseReq;

		ZeroMemory(cData, sizeof(cData));
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy_secure(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwCount;	// ������ �Է� 
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
			cp++;

			sp = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

		//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		//	cp++;
			//cambio lalomanu
			sp = (short *)cp;
			*sp = pItem->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;

			if (iEraseReq == 1) {
				delete pItem;
				pItem = NULL;
			}

			//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			//cambio lalomanu
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
			return TRUE;
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			pItem->m_dwTimeDrop = timeGetTime();

			SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);

			return TRUE;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bAddItem");
	}
#endif
	return FALSE;
}

void CMapServer::CancelExchangeItem(int iClientH)
{

#ifdef DEF_DEBUG
	try {
#endif
		int iExH;

		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		mtx.lock();
		bCheckClient[iClientH] = FALSE;
		m_iTotalClients--;
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = NULL;
		RemoveClientShortCut(iClientH);
		mtx.unlock();
		//DeleteClient(iClientH, FALSE, FALSE);
		ErrorList("Crash Evitado en: CancelExchangeItem");
	}
#endif
}

void CMapServer::_ClearExchangeStatus(int iClientH)
{

#ifdef DEF_DEBUG
	try {
#endif
		if ((iClientH <= 0) || (iClientH >= DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == NULL) return;
		int sItemIndex;

		if (m_pClientList[iClientH]->m_cExchangeName != FALSE)
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL, NULL);

		m_pClientList[iClientH]->m_dwInitCCTime = FALSE;
		m_pClientList[iClientH]->m_iExchangeH = NULL;
		m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
		m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;

		// Chequeo si el char posee zem luego del exchange - ZeroEoyPnk
		for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
					case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
						if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
							m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
						}
						break;
				}
			}
		}
		ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
		bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH); //exchange fixed
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _ClearExchangeStatus");
	}
#endif
}

int CMapServer::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iQuest = 0, iEraseReq, Reward = 0, Amount;
		class CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return 0;

		if (m_pClientList[iClientH]->m_bIsQuestCompleted[0] == TRUE) {
			iQuest = m_pClientList[iClientH]->m_iQuest;
			Reward = m_pClientList[iClientH]->m_iQuestRewardType;
			Amount = m_pClientList[iClientH]->m_iQuestRewardAmount;
		}
		else if (m_pClientList[iClientH]->m_bIsQuestCompleted[1] == TRUE) {
			iQuest = m_pClientList[iClientH]->m_iItemQuest;
			Reward = m_pClientList[iClientH]->m_iItemQuestRewardType;
			Amount = 1;
		}
		else if (m_pClientList[iClientH]->m_bIsQuestCompleted[2] == TRUE) {
			iQuest = m_pClientList[iClientH]->m_iStatedQuest;
			Reward = m_pClientList[iClientH]->m_iStatedQuestRewardType;
			Amount = 1;
		}

		if (iQuest != NULL) {
			if (m_pQuestConfigList[iQuest] == NULL) return -4;
			else if (m_pQuestConfigList[iQuest]->m_iFrom == 4) {
				if (Reward == -1) {
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[iQuest]->m_iContribution;
					SendContribution(iClientH);

					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTREWARD, 0, 4, 1, "����ġ", Amount, m_pClientList[iClientH]->m_iContribution);
					_ClearQuestStatus(iClientH, 1);
					return -5;
				}
				else if (Reward == -2) {
					if (_iGetItemSpaceLeft(iClientH) == 0) {
						SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
						return -6;
					}

					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pQuestConfigList[iQuest]->m_iRewardType[1]) == FALSE) {
						delete pItem;
						return -6;
					}
					bAddItem(iClientH, pItem, NULL);
					_ClearQuestStatus(iClientH, 2);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTREWARD, 1, 4, 1, "", 0, 0);
					if (!m_pClientList[iClientH]->Achivements[20].Complete) CheckCompleteAchivement(iClientH, 20, TRUE);
					return -5;
				}
				// Stateds Items
				else if (Reward == -3) {
					if (_iGetItemSpaceLeft(iClientH) == 0) {
						SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
						return -6;
					}

					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pQuestConfigList[iQuest]->m_iRewardType[1]) == FALSE) {
						delete pItem;
						return -6;
					}
					DWORD dwType = 0, dwValue = 0;
					pItem->m_dwAttribute = NULL;

					dwType = m_pQuestConfigList[iQuest]->m_iRewardType[2] << 12;
					dwValue = m_pQuestConfigList[iQuest]->m_iRewardAmount[2] << 8;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					bAddItem(iClientH, pItem, NULL);
					_ClearQuestStatus(iClientH, 3);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTREWARD, 2, 4, 1, "", 0, 0);
					return -5;
				}
				else {
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[iQuest]->m_iContribution;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTREWARD, 0, 4, 1, "", 0, m_pClientList[iClientH]->m_iContribution);
					SendContribution(iClientH);
					_ClearQuestStatus(iClientH, 1);
					return -5;
				}
			}
			return -4;
		}
		if (m_pClientList[iClientH]->m_iIsOnTown == DEF_NONPK) {
			if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;

			iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
			if (iQuest <= 0) return -4;
			return iQuest;
		}
		else return -2;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iTalkToNpcResult_Cityhall");
	}
#endif
	return -4;
}

int CMapServer::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return 0;

		if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
				return 1000;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
				return 1001;
			}
		}
		else {
			if (m_pClientList[iClientH]->m_cSide == DEF_ELVINE) {
				if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
					return 1002;
				}
				else if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
					return 1003;
				}
			}
			else {
				if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
						return 1004;
					}
					else if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
						return 1005;
					}
					else if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
						return 1006;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _iTalkToNpcResult_Guard");
	}
#endif
	return 0;
}

BOOL CMapServer::_bDecodeQuestConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iQuestConfigListIndex = 0;
	class CStrTok * pStrTok;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading QUEST configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								// ����Ʈ ��ȣ 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}

								if (m_pQuestConfigList[atoi(token)] != NULL) {
									// �̹� �Ҵ��� ��ȣ�� �ִ�. �����̴�.
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[atoi(token)] = new class CQuest;
								iQuestConfigListIndex = atoi(token);

								cReadModeB = 2;
								break;

							case 2:
								// ����Ʈ ���̵�  
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
								cReadModeB = 3;
								break;

							case 3:
								// ����Ʈ ����  
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								// TargetType
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								// MaxCount
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
								cReadModeB = 12;
								break;

							case 12:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
								cReadModeB = 13;
								break;

							case 13:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
								cReadModeB = 15;
								break;

							case 15:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
								cReadModeB = 16;
								break;

							case 16:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
								cReadModeB = 17;
								break;

							case 17:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
								cReadModeB = 18;
								break;

							case 18:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
								cReadModeB = 19;
								break;

							case 19:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
								cReadModeB = 20;
								break;

							case 20:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
								cReadModeB = 21;
								break;

							case 21:
								// 
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
								cReadModeB = 22;
								break;

							case 22:
								ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
								strcpy_secure(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
								cReadModeB = 23;
								break;

							case 23:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
								cReadModeB = 24;
								break;

							case 24:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
								cReadModeB = 25;
								break;

							case 25:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
								cReadModeB = 26;
								break;

							case 26:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
								cReadModeB = 27;
								break;

							case 27:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;

						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "quest", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
		PutLogList(cTxt);

		return TRUE;
	}
}

int CMapServer::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

		if (m_pClientList[iClientH] == NULL) return -1;

		iIndex = 0;
		for (i = 0; i < DEF_MAXQUESTTYPE; i++) iQuestList[i] = -1;

		for (i = 1; i < DEF_MAXQUESTTYPE; i++) {
			if (m_pQuestConfigList[i] != NULL) {

				if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
				if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
				if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
				if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
				if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

				if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] <
						m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
				}

				if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP;
				if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP;
				if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

				iQuestList[iIndex] = i;
				iIndex++;

			SFQ_SKIP:;
			}
		}

		if (iIndex == 0) return -1;
		iQuest = (iDice(1, iIndex)) - 1;
		iQuestIndex = iQuestList[iQuest];
		iReward = iDice(1, 3);
		*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// ����Ʈ ���� ���� 
		*pRewardType = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// ����Ʈ ��ǰ ���� 
		*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// ����Ʈ ��ǰ ���� 
		*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// ����Ʈ �ذ��� �ö󰡴� ���嵵 

		strcpy_secure(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// ����Ʈ �� �̸� ���� 
		*pX = m_pQuestConfigList[iQuestIndex]->m_sX;
		*pY = m_pQuestConfigList[iQuestIndex]->m_sY;
		*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

		*pTargetType = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
		*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
		*pQuestType = m_pQuestConfigList[iQuestIndex]->m_iType;

		return iQuestIndex;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: __iSearchForQuest");

	}
#endif
	return -1;
}

void CMapServer::QuestAcceptedHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == NULL) return;

		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
			switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
				case 10:
					_ClearQuestStatus(iClientH, 1);
					RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
						m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
					return;
			}
		}

		if (m_pClientList[iClientH]->m_iAskedQuest < 100) {
			m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
			m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iQuestID;
			m_pClientList[iClientH]->m_iCurQuestCount = 0;
		}
		else if (m_pClientList[iClientH]->m_iAskedQuest < 200) {
			m_pClientList[iClientH]->m_iItemQuest = m_pClientList[iClientH]->m_iAskedQuest;
			m_pClientList[iClientH]->m_iItemQuestID = m_pQuestConfigList[m_pClientList[iClientH]->m_iItemQuest]->m_iQuestID;
			m_pClientList[iClientH]->m_iItemQuestCount = 0;
		}
		else if (m_pClientList[iClientH]->m_iAskedQuest < 500) {
			m_pClientList[iClientH]->m_iStatedQuest = m_pClientList[iClientH]->m_iAskedQuest;
			m_pClientList[iClientH]->m_iStatedQuestID = m_pQuestConfigList[m_pClientList[iClientH]->m_iStatedQuest]->m_iQuestID;
			m_pClientList[iClientH]->m_iStatedQuestCount = 0;
		}

		m_pClientList[iClientH]->m_bIsQuestCompleted[0] = FALSE;
		m_pClientList[iClientH]->m_bIsQuestCompleted[1] = FALSE;
		m_pClientList[iClientH]->m_bIsQuestCompleted[2] = FALSE;

		_CheckQuestEnvironment(iClientH);
		_SendQuestContents(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: QuestAcceptedHandler");
	}
#endif
}

void CMapServer::_SendQuestContents(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iWho, iIndex, iQuestType, iContribution, iTargetType, iX, iY, iRange, iQuestCompleted;
		char cTargetName[21];
		int cQuestRemain;
		unsigned int iTargetCount;

		if (m_pClientList[iClientH] == NULL) return;

		// Contrib Quest
		iIndex = m_pClientList[iClientH]->m_iQuest;
		if (iIndex == NULL) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCONTENTS, 0, NULL, NULL, NULL);
		else {
			iWho = m_pQuestConfigList[iIndex]->m_iFrom;
			iQuestType = m_pQuestConfigList[iIndex]->m_iType - 1;
			iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
			iTargetType = m_pQuestConfigList[iIndex]->m_iTargetType;
			iTargetCount = m_pQuestConfigList[iIndex]->m_iMaxCount;
			iX = m_pQuestConfigList[iIndex]->m_sX;
			iY = m_pQuestConfigList[iIndex]->m_sY;
			iRange = m_pQuestConfigList[iIndex]->m_iRange;
			ZeroMemory(cTargetName, sizeof(cTargetName));
			memcpy_secure(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);

			cQuestRemain = (iTargetCount - m_pClientList[iClientH]->m_iCurQuestCount);
			if (cQuestRemain <= 0) {
				cQuestRemain = 0;
				m_pClientList[iClientH]->m_iCurQuestCount = iTargetCount;
				m_pClientList[iClientH]->m_bIsQuestCompleted[0] = TRUE;
			}

			iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted[0];

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCONTENTS, iQuestType, iWho, iContribution, NULL,
				iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOUNTER, iQuestType, cQuestRemain, NULL, NULL);
		}

		// Item Quest
		iIndex = m_pClientList[iClientH]->m_iItemQuest;
		if (iIndex == NULL) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCONTENTS, 1, NULL, NULL, NULL);
		else {
			iWho = m_pQuestConfigList[iIndex]->m_iFrom;
			iQuestType = m_pQuestConfigList[iIndex]->m_iType - 1;
			iContribution = iIndex;
			iTargetType = m_pQuestConfigList[iIndex]->m_iTargetType;
			iTargetCount = m_pQuestConfigList[iIndex]->m_iMaxCount;
			iX = m_pQuestConfigList[iIndex]->m_sX;
			iY = m_pQuestConfigList[iIndex]->m_sY;
			iRange = m_pQuestConfigList[iIndex]->m_iRange;
			ZeroMemory(cTargetName, sizeof(cTargetName));
			memcpy_secure(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);

			cQuestRemain = (iTargetCount - m_pClientList[iClientH]->m_iItemQuestCount);
			if (cQuestRemain <= 0) {
				cQuestRemain = 0;
				m_pClientList[iClientH]->m_iItemQuestCount = iTargetCount;
				m_pClientList[iClientH]->m_bIsQuestCompleted[1] = TRUE;
			}
			iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted[1];

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCONTENTS, iQuestType, iWho, iContribution, NULL,
				iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOUNTER, iQuestType, cQuestRemain, NULL, NULL);
		}

		// Stated Quest
		iIndex = m_pClientList[iClientH]->m_iStatedQuest;
		if (iIndex == NULL) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCONTENTS, 2, NULL, NULL, NULL);
		else {
			iWho = m_pQuestConfigList[iIndex]->m_iFrom;
			iQuestType = m_pQuestConfigList[iIndex]->m_iType - 1;
			iContribution = iIndex;
			iTargetType = m_pQuestConfigList[iIndex]->m_iTargetType;
			iTargetCount = m_pQuestConfigList[iIndex]->m_iMaxCount;
			iX = m_pQuestConfigList[iIndex]->m_sX;
			iY = m_pQuestConfigList[iIndex]->m_sY;
			iRange = m_pQuestConfigList[iIndex]->m_iRange;
			ZeroMemory(cTargetName, sizeof(cTargetName));
			memcpy_secure(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);

			cQuestRemain = (iTargetCount - m_pClientList[iClientH]->m_iStatedQuestCount);
			if (cQuestRemain <= 0) {
				cQuestRemain = 0;
				m_pClientList[iClientH]->m_iStatedQuestCount = iTargetCount;
				m_pClientList[iClientH]->m_bIsQuestCompleted[2] = TRUE;
			}
			iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted[2];

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCONTENTS, iQuestType, iWho, iContribution, NULL,
				iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOUNTER, iQuestType, cQuestRemain, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _SendQuestContents");
	}
#endif
}

void CMapServer::_ArmarQuestContens(int iClientH, int iIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iWho, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
		char cTargetName[21];

		if (m_pClientList[iClientH] == NULL) return;
		if (iIndex > DEF_MAXQUESTTYPE) return;

		if ((iIndex != NULL) && iIndex < DEF_MAXQUESTTYPE && (m_pQuestConfigList[iIndex] != NULL)) {
			iWho = m_pQuestConfigList[iIndex]->m_iFrom;
			iQuestType = m_pQuestConfigList[iIndex]->m_iType;
			iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
			iTargetType = m_pQuestConfigList[iIndex]->m_iTargetType;
			iTargetCount = m_pQuestConfigList[iIndex]->m_iMaxCount;
			iX = m_pQuestConfigList[iIndex]->m_sX;
			iY = m_pQuestConfigList[iIndex]->m_sY;
			iRange = m_pQuestConfigList[iIndex]->m_iRange;
			ZeroMemory(cTargetName, sizeof(cTargetName));
			memcpy_secure(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
			iQuestCompleted = FALSE;

			// La que necesito
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NPCTALK, 100, iIndex, 1, NULL, iContribution,
				iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _ArmarQuestContens");
	}
#endif
}
void CMapServer::_CheckQuestEnvironment(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iIndex;
		char cTargetName[21];

		if (m_pClientList[iClientH] == NULL) return;

		iIndex = m_pClientList[iClientH]->m_iQuest;
		if (iIndex == NULL) return;

		if (iIndex >= 41 && iIndex <= 46) {
			m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iQuestID = NULL;
			m_pClientList[iClientH]->m_iQuestRewardAmount = m_pClientList[iClientH]->m_iQuestRewardType = NULL;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
			return;
		}

		if (m_pQuestConfigList[iIndex] == NULL) return;
		if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
			m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iQuestID = NULL;
			m_pClientList[iClientH]->m_iQuestRewardAmount = m_pClientList[iClientH]->m_iQuestRewardType = NULL;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
			return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _CheckQuestEnvironment");
	}
#endif
}

BOOL CMapServer::_bCheckIsQuestCompleted(int iClientH, short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iQuestIndex = NULL, Count = 0;

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_bIsQuestCompleted[Type] == TRUE) return FALSE;

		switch (Type) {
			case 0: iQuestIndex = m_pClientList[iClientH]->m_iQuest; break;
			case 1: iQuestIndex = m_pClientList[iClientH]->m_iItemQuest; break;
			case 2: iQuestIndex = m_pClientList[iClientH]->m_iStatedQuest; break;
		}
		if (iQuestIndex == NULL) return FALSE;

		if (m_pQuestConfigList[iQuestIndex] != NULL) {
			switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT_CONTRIB:
				case DEF_QUESTTYPE_MONSTERHUNT_RARE:
				case DEF_QUESTTYPE_MONSTERHUNT_STATED:
					if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pQuestConfigList[iQuestIndex]->m_cTargetName, 10) == 0) {
						switch (Type) {
							case 0:
								if (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) {
									m_pClientList[iClientH]->m_iCurQuestCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
									m_pClientList[iClientH]->m_bIsQuestCompleted[Type] = TRUE;
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOMPLETED, Type, NULL, NULL, NULL);
									return TRUE;
								}
								break;
							case 1:
								if (m_pClientList[iClientH]->m_iItemQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) {
									m_pClientList[iClientH]->m_iItemQuestCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
									m_pClientList[iClientH]->m_bIsQuestCompleted[Type] = TRUE;
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOMPLETED, Type, NULL, NULL, NULL);
									return TRUE;
								}
								break;
							case 2:
								if (m_pClientList[iClientH]->m_iStatedQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) {
									m_pClientList[iClientH]->m_iStatedQuestCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
									m_pClientList[iClientH]->m_bIsQuestCompleted[Type] = TRUE;
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOMPLETED, Type, NULL, NULL, NULL);
									return TRUE;
								}
								break;
						}
					}
					break;

				case DEF_QUESTTYPE_GOPLACE:
					if ((m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && // ���� �°�
						(m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // ��ǥ�� �̳��̸� 
						(m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
						(m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
						(m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange)) {
						m_pClientList[iClientH]->m_bIsQuestCompleted[Type] = TRUE;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTCOMPLETED, Type, NULL, NULL, NULL);
						return TRUE;
					}
					break;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bCheckIsQuestCompleted");
	}
#endif
	return FALSE;
}

void CMapServer::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * cp, cData[512];
		DWORD * dwp;
		WORD  * wp;
		short * sp;
		int   * ip, iRet;

		if (m_pClientList[iClientH] == NULL) return;

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_NOTIFY;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = wMsgType;
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		switch (wMsgType) {
			case CLIENT_NOTIFY_ITEMOBTAINED:
				*cp = 1; // 1�� ȹ���ߴ�. <- ���⼭ 1���� ���� ī��Ʈ�� ���ϴ� ���� �ƴϴ�
				cp++;

				memcpy_secure(cp, pItem->m_cName, 20);
				cp += 20;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
				cp++;

				sp = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;

				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor; // v1.4
				cp++;

				//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				//cp++;
				//cambio lalomanu
				sp = (short *)cp;
				*sp = pItem->m_sItemSpecEffectValue2;
				cp += 2;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;

				//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				//cambio lalomanu
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
				break;

			case CLIENT_NOTIFY_ITEMPURCHASED:
				*cp = 1;
				cp++;

				memcpy_secure(cp, pItem->m_cName, 20);
				cp += 20;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0;
				cp++;

				sp = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;

				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				ip = (int *)cp;
				*ip = iV1; // (iCost - iDiscountCost);
				cp += 4;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
				break;

			case CLIENT_NOTIFY_CANNOTCARRYMOREITEM:
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				break;
		}
		//Agregado Lalo882
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendItemNotifyMsg");
	}
#endif
}

void CMapServer::_ClearQuestStatus(int iClientH, short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (Type >= 1 && Type <= 3) {
			switch (Type) {
				case 1:
					m_pClientList[iClientH]->m_iQuest = NULL;
					m_pClientList[iClientH]->m_iQuestID = NULL;
					m_pClientList[iClientH]->m_iQuestRewardType = NULL;
					m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
					m_pClientList[iClientH]->m_bIsQuestCompleted[1] = FALSE;
					break;
				case 2:
					m_pClientList[iClientH]->m_iItemQuest = NULL;
					m_pClientList[iClientH]->m_iItemQuestID = NULL;
					m_pClientList[iClientH]->m_iItemQuestRewardType = NULL;
					m_pClientList[iClientH]->m_bIsQuestCompleted[2] = FALSE;
					break;
				case 3:
					m_pClientList[iClientH]->m_iStatedQuest = NULL;
					m_pClientList[iClientH]->m_iStatedQuestID = NULL;
					m_pClientList[iClientH]->m_iStatedQuestRewardType = NULL;
					m_pClientList[iClientH]->m_bIsQuestCompleted[3] = FALSE;
					break;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _ClearQuestStatus");
	}
#endif
}

int CMapServer::iGetMaxHP(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet = 0;

		if (m_pClientList[iClientH] == NULL) return 0;

		iRet = m_pClientList[iClientH]->m_iVit * 3 + m_pClientList[iClientH]->m_iLevel * 2 + (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) / 2;

		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
			iRet = iRet - (iRet / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		return iRet;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetMaxHP");
	}
#endif
	return 0;
}

void CMapServer::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iTotalPoint;
		POINT  pList[DEF_MAXINITIALPOINT];

		if (m_pMapList[iMapIndex] == NULL) return;

		iTotalPoint = 0;
		for (i = 0; i < DEF_MAXINITIALPOINT; i++) {
			if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
				pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
				pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
				iTotalPoint++;
			}
		}

		if (iTotalPoint == 0) return;
		if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0))
			i = 0;
		else i = iDice(1, iTotalPoint) - 1;

		*pX = (short)pList[i].x;
		*pY = (short)pList[i].y;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetMapInitialPoint");
	}
#endif
}

void CMapServer::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
#ifdef DEF_DEBUG
	try {
#endif
		UINT iTmp;
		register int iLogSockH, iRet;
		iTmp = (WM_ONLOGSOCKETEVENT + 1);
		iLogSockH = message - iTmp;

		if (m_pSubLogSock[iLogSockH] == NULL) return;

		iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

		switch (iRet) {
			case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
				m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
				m_iSubLogSockActiveCount++;

			case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
				if (m_bIsSubLogSockAvailable[5] == TRUE && !m_bIsLogSockAvailable) bSendMsgToLS(NUCLEO_REQUEST_REGISTERGAMESERVER, NULL);
				break;

			case DEF_XSOCKEVENT_READCOMPLETE:
				OnSubLogRead(iLogSockH);
				break;

			case DEF_XSOCKEVENT_BLOCK:
				wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
				PutLogList(G_cTxt);
				break;

			case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
			case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
				delete m_pSubLogSock[iLogSockH];
				m_pSubLogSock[iLogSockH] = NULL;
				m_bIsSubLogSockAvailable[iLogSockH] = FALSE;

				m_iSubLogSockFailCount++;
				m_iSubLogSockActiveCount--;

				m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
				m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
				m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

				wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
				PutLogList(G_cTxt);

				break;

			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				delete m_pSubLogSock[iLogSockH];
				m_pSubLogSock[iLogSockH] = NULL;
				m_bIsSubLogSockAvailable[iLogSockH] = FALSE;

				m_iSubLogSockFailCount++;
				m_iSubLogSockActiveCount--;

				wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
				PutLogList(G_cTxt);

				m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
				m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
				m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

				wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
				PutLogList(G_cTxt);

				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: OnSubLogSocketEvent");
	}
#endif
}

void CMapServer::OnSubLogRead(int iIndex)
{
#ifdef DEF_DEBUG
	try {
#endif

		DWORD dwMsgSize;
		char * pData, cKey;

		pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

		if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
			ErrorList("@@@@@@ CRITICAL ERROR in MsgQuene 3!!! @@@@@@");
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: OnSubLogRead");
	}
#endif
}

BOOL CMapServer::_bItemLog(int iAction, int iGiveH, int iRecvH, class CItem * pItem, BOOL bForceItemLog)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  cTxt[1024], cTemp1[120], cTemp2[120];
		int iItemCount;

		if (pItem == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

		if (iAction == DEF_ITEMLOG_DUPITEMID) {
			if (m_pClientList[iGiveH] == NULL) return FALSE;
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(G_cTxt, "Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
				pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, m_pClientList[iGiveH]->m_cCharName);

			PutLogItemsList(G_cTxt);
			return TRUE;
		}

		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		ZeroMemory(cTemp2, sizeof(cTemp2));

		switch (iAction) {
			case DEF_ITEMLOG_EXCHANGE:
				if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %d)\t%s(%d %d)\tPC(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
				break;

			case DEF_ITEMLOG_GIVE:
				if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %d)\t%s(%d %d)\tPC(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
				break;

			case DEF_ITEMLOG_DROP:
				wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_GET:
				wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;
			case DEF_ITEMLOG_MAKE:
				wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_DEPLETE:
				wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_BUY:
				iItemCount = iRecvH;
				wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_BUYMARKET:
				iItemCount = iRecvH;
				wsprintf(cTxt, "PC(%s)\tBuy in Market\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_SELL:
				wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_RETRIEVE:
				wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_DEPOSIT:
				wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount,
					pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_UPGRADEFAIL:
				wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;

			case DEF_ITEMLOG_UPGRADESUCCESS:
				wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %d)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
					pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
					m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY);
				break;
			default:
				return FALSE;
		}
		PutLogItemsList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bItemLog");
	}
#endif
	return TRUE;
}

BOOL CMapServer::_bItemLog(int iAction, int iClientH, char * cName, class CItem * pItem, BOOL Save)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (pItem == NULL) return FALSE;
		if (_bCheckGoodItem(pItem) == FALSE) return FALSE;
		if (Save == FALSE) return FALSE;

		if (iAction != DEF_ITEMLOG_NEWGENDROP) {
			if (m_pClientList[iClientH] == NULL) return FALSE;
		}
		char  cTxt[200], cTemp1[120];

		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		if (m_pClientList[iClientH] != NULL) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

		switch (iAction) {
			case DEF_ITEMLOG_NEWGENDROP:
				if (pItem == NULL) return FALSE;
				wsprintf(cTxt, "NPC(%s)\tDrop\t%s", cName, pItem->m_cName);					
				/*wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)", cName, pItem->m_cName, pItem->m_dwCount,
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
				PutLogItemsList(cTxt);*/ //Lalov9 log2dodrop v9
				PutLogDrops(cTxt);
				return false;
				break;
			case DEF_ITEMLOG_SKILLLEARN:
			case DEF_ITEMLOG_MAGICLEARN:
				if (cName == NULL) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName, cName,
					m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
				break;
			case DEF_ITEMLOG_SUMMONMONSTER:
				if (cName == NULL) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName, cName,
					m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
				break;
			case DEF_ITEMLOG_POISONED:
				if (m_pClientList[iClientH] == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName,
					m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
				break;

			case DEF_ITEMLOG_REPAIR:
				if (cName == NULL) return FALSE;
				if (m_pClientList[iClientH] == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iClientH]->m_cCharName, cName,
					m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, cTemp1);
				break;

			default:
				return FALSE;
		}
		PutLogItemsList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bItemLog");
	}
#endif
	return TRUE;
}

BOOL CMapServer::_bCheckGoodItem(class CItem * pItem)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (pItem == NULL) return FALSE;

		if (pItem->m_sIDnum == 90) {
			if (pItem->m_dwCount > 10000) return TRUE;
			else return FALSE;
		}
		switch (pItem->m_sIDnum) {
			case 20: // ���� Į���� 
			case 259:
			case 290:
			case 291:
			case 292:
			case 300:
			case 305:
			case 308:
			case 311:
			case 334:
			case 335:
			case 336:
			case 338:
			case 380:
			case 381:
			case 382:
			case 391:
			case 400:
			case 401:
			case 490:
			case 491:
			case 492:
			case 508:
			case 581:
			case 610:
			case 611:
			case 612:
			case 613:
			case 614:
			case 616:  // ����-�����̾�
			case 618:  // ��ũ����-����
			case 620:
			case 621:
			case 622:
			case 623:
			case 630:
			case 631:
			case 632:
			case 633:
			case 634:
			case 635:
			case 636:
			case 637:
			case 638:
			case 639:
			case 640:
			case 641:
			case 642:
			case 643:
			case 644:
			case 645:
			case 646:
			case 647:
			case 648: //��Ŭ�������긮ġ
			case 650:
			case 651:
			case 652:
			case 653:
			case 654:
			case 655:
			case 656:
			case 657:
			case 700: 	// v2.03 ���� ������ 
			case 701:
			case 702:
			case 703:
			case 704:
			case 705:
			case 706:
			case 707:
			case 708:
			case 709:
			case 710:
			case 711:
			case 712:
			case 713:
			case 714:
			case 715:
			case 716:  // �渶���緹���Ƹ� 
			case 717:  // �������Ƿ����Ǿ�
			case 718:  // �������Ǳ׷���Ʈ�ҵ�
			case 719:  // �渶���罺���ϸ���
			case 720:
			case 721:
			case 722:
			case 723:
			case 724:
			case 725:
			case 726:
			case 727:
			case 728:
			case 729:
			case 730:
			case 731:
			case 732:
			case 733:
			case 734:
			case 735:
			case 736:  // ���ο� ������ ���̾�Ʈ �ҵ�
			case 737:  // ���ο� �������� ���̾�Ʈ �ҵ�
			case 738:  // ���ο� �渶�����Ǹ�������
			case 762:  // ���̾�Ʈ-��Ʋ�ظ�
			case 765:  // 3�ֳ� ���� ����
			case 775:  // �濩�����緹���Ƹ�
			case 776:  // �濩�����罺���ϸ���
				return TRUE;  //Ư���� �������̱� ���� ����...
				break;
			default:
				if ((pItem->m_dwAttribute & 0xF0F0F001) == NULL) return FALSE;
				else if (pItem->m_sIDnum > 30) return TRUE;
				else return FALSE;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bCheckGoodItem");
	}
#endif
}

BOOL CMapServer::_bPKLog(int iAction, int iAttackerH, int iVictumH, char * pNPC, BOOL Blocked)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  cTxt[1024], cTemp1[120], cTemp2[120];

		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		ZeroMemory(cTemp2, sizeof(cTemp2));

		if (m_pClientList[iVictumH] == NULL) return FALSE;

		switch (iAction) {
			case DEF_PKLOG_REDUCECRIMINAL:
				wsprintf(cTxt, "PC(%s [%s])\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_iPKCount,
					m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY);
				break;

			case DEF_PKLOG_BYPLAYER:
				if (m_pClientList[iAttackerH] == NULL) return FALSE;
				if (Blocked)
					wsprintf(cTxt, "PC(%s [%s])\tKilled by PC\t \t%s(%d %d)\tPC(%s [%s] [BLOCKED])", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
						m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress);
				else
					wsprintf(cTxt, "PC(%s [%s])\tKilled by PC\t \t%s(%d %d)\tPC(%s [%s])", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
						m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress);
				break;
			case DEF_PKLOG_BYPK:
				if (m_pClientList[iAttackerH] == NULL) return FALSE;
				if (Blocked)
					wsprintf(cTxt, "PC(%s [%s])\tKilled by PK\tCC(%d)\t%s(%d %d)\tPC(%s [%s] [BLOCKED])", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
						m_pClientList[iAttackerH]->m_iPKCount, m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress);
				else
					wsprintf(cTxt, "PC(%s [%s])\tKilled by PK\tCC(%d)\t%s(%d %d)\tPC(%s [%s])", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
						m_pClientList[iAttackerH]->m_iPKCount, m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress);
				break;
			case DEF_PKLOG_BYENERMY:
				if (m_pClientList[iAttackerH] == NULL) return FALSE;
				if (Blocked)
					wsprintf(cTxt, "PC(%s [%s])\tKilled by EN\t \t%s(%d %d)\tPC(%s [%s] [BLOCKED])", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
						m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress);
				else
					wsprintf(cTxt, "PC(%s [%s])\tKilled by EN\t \t%s(%d %d)\tPC(%s [%s])", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
						m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress);
				break;
			case DEF_PKLOG_BYNPC:
				if (pNPC == NULL) return FALSE;
				wsprintf(cTxt, "PC(%s [%s])\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
					m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, pNPC);
				break;

			case DEF_PKLOG_BYOTHER:
				wsprintf(cTxt, "PC(%s [%s])\tKilled by Other\t \t%s(%d %d)\tUnKnown", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_cIPaddress,
					m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY);
				break;

			default:
				return FALSE;
		}
		PutEkAndPkLogFileList(cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bPKLog");
	}
#endif
	return TRUE;
}

BOOL CMapServer::_bCheckSubLogSocketIndex()
{
#ifdef DEF_DEBUG
	try {
#endif

		int  iCnt;
		BOOL bLoopFlag;

		m_iCurSubLogSockIndex++;
		if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK - 1) m_iCurSubLogSockIndex = 0;

		iCnt = 0;
		bLoopFlag = FALSE;
		while (bLoopFlag == FALSE) {
			if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE))
				bLoopFlag = TRUE;
			else m_iCurSubLogSockIndex++;

			iCnt++;
			if (iCnt >= DEF_MAXSUBLOGSOCK) return FALSE;
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bCheckSubLogSocketIndex");
	}
#endif
	return TRUE;
}

BOOL CMapServer::_bDecodeBuildItemConfigFileContents(char * cFn)
{
	char * pContents, *token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  i, iIndex = 0;
	class CStrTok * pStrTok;
	class CItem * pItem;

	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading BUILD-ITEM configuration file...");
		pContents = new char[dwFileSize + 2];
		ZeroMemory(pContents, dwFileSize + 2);
		fread(pContents, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
								memcpy_secure(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));

								cReadModeB = 2;
								break;

							case 2:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
								cReadModeB = 12;
								break;


							case 12:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
								cReadModeB = 13;
								break;

							case 13:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
								cReadModeB = 15;
								break;

							case 15:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
								cReadModeB = 16;
								break;

							case 16:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
								cReadModeB = 17;
								break;

							case 17:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
								cReadModeB = 18;
								break;


							case 18:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
								cReadModeB = 19;
								break;

							case 19:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
								cReadModeB = 20;
								break;

							case 20:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
								cReadModeB = 21;
								break;

							case 21:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
								cReadModeB = 22;
								break;

							case 22:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
								cReadModeB = 23;
								break;

							case 23:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;

								pItem = new class CItem;
								if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {
									m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;
									for (i = 0; i < 6; i++)
										m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i] * 100);
									iIndex++;
								}
								else {
									wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
									PutLogList(G_cTxt);

									delete m_pBuildItemList[iIndex];
									m_pBuildItemList[iIndex] = NULL;

									delete pContents;
									delete pStrTok;
									return FALSE;
								}
								delete pItem;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "BuildItem", 9) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
					m_pBuildItemList[iIndex] = new class CBuildItem;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]pContents;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
			return FALSE;
		}

		wsprintf(cTxt, "BuildItem(Total:%d) configuration - success!", iIndex);
		PutLogList(cTxt);
		return TRUE;
	}
}

void CMapServer::BuildItemHandler(int iClientH, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cName[21], cElementItemID[6];
		int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
		class  CItem * pItem;
		BOOL   bFlag, bItemFlag[6];
		double dV1, dV2, dV3;
		DWORD  dwTemp, dwTemp2;
		WORD   wTemp;
		short MpLevel, ContribLevel, MaxLevel, UniqLevel, Resultado, MaxPoint;
		DWORD dwType, dwValue, dwValue2;

		if (m_pClientList[iClientH] == NULL) return;
		m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

		cp = (char *)(pData + 11);
		ZeroMemory(cName, sizeof(cName));
		memcpy_secure(cName, cp, 20);
		cp += 20;

		ZeroMemory(cElementItemID, sizeof(cElementItemID));
		cElementItemID[0] = *cp;
		cp++;
		cElementItemID[1] = *cp;
		cp++;
		cElementItemID[2] = *cp;
		cp++;
		cElementItemID[3] = *cp;
		cp++;
		cElementItemID[4] = *cp;
		cp++;
		cElementItemID[5] = *cp;
		cp++;

		bFlag = TRUE;
		while (bFlag == TRUE) {
			bFlag = FALSE;
			for (i = 0; i <= 4; i++) {
				if ((cElementItemID[i] == -1) && (cElementItemID[i + 1] != -1)) {
					cElementItemID[i] = cElementItemID[i + 1];
					cElementItemID[i + 1] = -1;
					bFlag = TRUE;
				}
			}
		}

		for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

		iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
		iResult = iDice(1, 100);

		if (iResult > iPlayerSkillLevel) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
			return;
		}

		for (i = 0; i < 6; i++) {
			if (cElementItemID[i] != -1) {
				if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;
			}
		}

		for (i = 0; i < DEF_MAXBUILDITEMS; i++) {
			if (m_pBuildItemList[i] != NULL) {
				if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
					if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;

					for (x = 0; x < DEF_MAXITEMS; x++) {
						if (m_pClientList[iClientH]->m_pItemList[x] != NULL)
							iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
						else iItemCount[x] = 0;
					}

					iMatch = 0;
					iTotalValue = 0;

					for (x = 0; x < 6; x++) {
						if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
							iMatch++;
						}
						else {
							for (z = 0; z < 6; z++) {
								if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {
									if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
										(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
										(iItemCount[cElementItemID[z]] > 0)) {
										iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
										if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
											iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13]) / 2;
										}

										iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
										iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
										iMatch++;
										bItemFlag[z] = TRUE;

										goto BIH_LOOPBREAK;
									}
								}
							}
						BIH_LOOPBREAK:;
						}
					}

					if (iMatch != 6) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
						return;
					}

					dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
					if (iTotalValue <= 0)
						dV3 = 1.0f;
					else dV3 = (double)iTotalValue;
					dV1 = (double)(dV3 / dV2)*100.0f;
					iTotalValue = (int)dV1;

					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
						delete pItem;
						return;
					}

					// New Manufacture with stats - ZeroEoyPnk
				/*	MpLevel = abs(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft / 100);
					ContribLevel = abs(m_pClientList[iClientH]->m_iContribution / 10000);

					if (MpLevel < ContribLevel) MaxLevel = MpLevel;
					else MaxLevel = ContribLevel;

					if (MaxLevel > 0) {
						if (MaxLevel > DEF_LIMIT_STATSTONE) MaxLevel = DEF_LIMIT_STATSTONE;
						MaxPoint = 0;
						for (i = 1; i <= MaxLevel; i++)
							MaxPoint += (DEF_LIMIT_STATSTONE - i)*MaxLevel + 1;

						dwValue = iDice(1, MaxPoint);
						MaxPoint = 0;
						for (i = 1; i <= MaxLevel; i++) {
							MaxPoint += (DEF_LIMIT_STATSTONE - i)*MaxLevel + 1;
							if (dwValue <= MaxPoint) {
								dwValue = i;
								i = MaxLevel + 1;
							}
						}
						if (dwValue > 15) dwValue = 1;

						dwValue2 = iDice(1, MaxPoint);
						MaxPoint = 0;
						for (i = 1; i <= MaxLevel; i++) {
							MaxPoint += (DEF_LIMIT_STATSTONE - i)*MaxLevel + 1;
							if (dwValue2 <= MaxPoint) {
								dwValue2 = i;
								i = MaxLevel + 1;
							}
						}
						if (dwValue2 > 15) dwValue2 = 1;

						if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
							// Primary Stats
							if (MaxLevel > 5) UniqLevel = 15;
							else UniqLevel = 5;

							switch (iDice(1, UniqLevel)) {
								// Critical
								case 1: dwType = 1; break;
									// Poisoning
									//case 2: dwType = 2; break;
									// Agile
									//case 3: dwType = 5; break;
									// Light 
									//case 4: dwType = 6; break;
									// Strong
								case 2: dwType = 8; break;
									// Ancient
								case 3: dwType = 9; break;
									// Righteous
								case 4: dwType = 3; break;
									// Sharp
								case 5: dwType = 7; break;
								default: dwType = 1; break; // Critical
							}

							pItem->m_dwAttribute = NULL;
							dwType = dwType << 20;
							dwValue = dwValue << 16;
							pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

							// Second Stats
							if (MaxLevel > 5) {
								Resultado = iDice(1, 2000);
								/*if (Resultado >= 1 && Resultado <= 5000)
									dwType = 11; // Experience+%d%%
								else if (Resultado > 5000 && Resultado <= 7500)
									dwType = 12; // Gold +%
								else*//* if (Resultado > 1 && Resultado <= 1200)
									dwType = 10; // Consecutive Attack Damage+%d
								else if (Resultado > 1200 && Resultado <= 1800)
									dwType = 2; // Hitting Probability+%d
								else dwType = 10; // Consecutive Attack Damage+%d
							}
							else {
								switch (iDice(1, 4)) {
									// Experience+%d%%
									///case 1: dwType = 11; break;
									// Gold +%
									//case 2:	dwType = 12; break;
									// Consecutive Attack Damage+%d
									case 3: dwType = 10; break;
										// Hitting Probability+%d
									case 4: dwType = 2; break;
										// Consecutive Attack Damage+%d
									default: dwType = 10; break;
								}
							}

							dwType = dwType << 12;
							dwValue2 = dwValue2 << 8;
							pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue2;
						}
						else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
							// Primary Stat
							switch (iDice(1, 10)) {
								case 1:
									dwType = 10; // Special
									break;
								default:
									dwType = 0;
									break;
							}


							pItem->m_dwAttribute = NULL;
							if (dwType != 0) {
								dwType = dwType << 20;
								dwValue = dwValue << 16;
								pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
							}

							// Second Stats
							if (MaxLevel > 5) {
								Resultado = iDice(1, 10000);
								if (Resultado >= 1 && Resultado <= 5000)
									dwType = 11; // Experience+%d%%
								else if (Resultado > 5000 && Resultado <= 7500)
									dwType = 12; // Gold +%
								else if (Resultado > 7000 && Resultado <= 9500)
									dwType = 10; // Consecutive Attack Damage+%d
								else if (Resultado > 9500 && Resultado <= 9600)
									dwType = 2; // Hitting Probability+%d
								else dwType = 11;
							}
							else {
								switch (iDice(1, 7)) {
									// Experience+%d%%
									case 1: dwType = 11; break;
										// Gold +%
									case 2:	dwType = 12; break;
										// Consecutive Attack Damage+%d
									case 3: dwType = 10; break;
										// Hitting Probability+%d
									case 4: dwType = 2; break;
										// Experience+%d%%
									default: dwType = 11; break;
								}
							}

							dwType = dwType << 12;
							dwValue2 = dwValue2 << 8;
							pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue2;
						}
						else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
							// Primary Stat	
							switch (iDice(1, 5)) {
								// Strong
								case 1: dwType = 8; break;
									// Light
								case 2: dwType = 6; break;
									// Mana Converting
								case 3: dwType = 11; break;
									// Critical
								case 4: dwType = 12; break;
								default: dwType = 0;
							}

							pItem->m_dwAttribute = NULL;
							if (dwType != 0) {
								dwType = dwType << 20;
								dwValue = dwValue << 16;
								pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
							}

							// Second Stats
							if (MaxLevel > 5) {
								Resultado = iDice(1, 5000);
								/*if (Resultado >= 1 && Resultado <= 5000)
									dwType = 1; // Poison Resistance+%d%%
								else if (Resultado > 5000 && Resultado <= 7500)
									dwType = 5;  // SP recovery %d%%
								else*//* if (Resultado > 1 && Resultado <= 200)
									dwType = 4; // HP recovery %d%%
								else if (Resultado > 200 && Resultado <= 400)
									dwType = 6; // MP recovery %d%%
								else {
									Resultado = iDice(1, 800);
									/*if (Resultado >= 1 && Resultado <= 3000)
										dwType = 1; // Poison Resistance+%d%%
									else if (Resultado > 3000 && Resultado <= 5000)
										dwType = 5; // SP recovery %d%%
									else if (Resultado > 1 && Resultado <= 200)
										dwType = 4; // HP recovery %d%%
									else if (Resultado > 200 && Resultado <= 400)
										dwType = 6; // MP recovery %d%%
									else */ /* if (Resultado > 1 && Resultado <= 200)
										dwType = 3; // Defense Ratio+%d
									else if (Resultado > 200 && Resultado <= 400)
										dwType = 7; // Magic Resistance+%d%%
									else if (Resultado > 400 && Resultado <= 600)
										dwType = 8; // Physical Absorption+%d%%
									else if (Resultado > 600 && Resultado <= 800)
										dwType = 9; // Magic Absorption+%d%%
									else dwType = 4; // HP recovery %d%%
								}
							}
							else {
								switch (iDice(1, 5)) {
									// Poison Resistance+%d%%
									//case 1: dwType = 1; break;
									// HP recovery %d%%
									case 2:	dwType = 4; break;
										// SP recovery %d%%
										//case 3: dwType = 5; break;
										// MP recovery %d%%
									case 4: dwType = 6; break;
									default:
										switch (iDice(1, 15)) {
											// Poison Resistance+%d%%
											//case 1: dwType = 1; break;
											// SP recovery %d%%
											//case 2: dwType = 5; break;
											// HP recovery %d%%
											case 3: dwType = 4; break;
												// MP recovery %d%%
											case 4: dwType = 6; break;
												// Defense Ratio+%d
											case 5: dwType = 3; break;
												// Magic Resistance+%d%%
											case 6: dwType = 7; break;
												// Physical Absorption+%d%%
											case 7: dwType = 8; break;
												// Magic Absorption+%d%%
											case 8: dwType = 9; break;
												//  HP recovery %d%%
											default: dwType = 4; break;
										}
										break;
								}
							}

							dwType = dwType << 12;
							dwValue2 = dwValue2 << 8;
							pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue2;

							m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= (MaxLevel * 100);
							m_pClientList[iClientH]->m_iContribution -= (MaxLevel * 10000);

							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
							SendContribution(iClientH);
						}
						else {
							dwTemp = pItem->m_dwAttribute;
							dwTemp = dwTemp & 0xFFFFFFFE;
							dwTemp = dwTemp | 0x00000001;
							pItem->m_dwAttribute = dwTemp;

							dwTemp = pItem->m_dwAttribute;
							dwTemp = dwTemp & 0x0000FFFF;

							dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
							dwTemp2 = dwTemp2 << 16;

							dwTemp = dwTemp | dwTemp2;
							pItem->m_dwAttribute = dwTemp;
						}
					}
					else {
						dwTemp = pItem->m_dwAttribute;
						dwTemp = dwTemp & 0xFFFFFFFE;
						dwTemp = dwTemp | 0x00000001;
						pItem->m_dwAttribute = dwTemp;
					}*/

					dwTemp = pItem->m_dwAttribute;
					dwTemp = dwTemp & 0xFFFFFFFE;
					dwTemp = dwTemp | 0x00000001;
					pItem->m_dwAttribute = dwTemp;

					if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
						iTemp = iDice(1, (iPlayerSkillLevel / 2) + 1) - 1;
						pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel / 2) + iTemp;
						pItem->m_sTouchEffectType = DEF_ITET_ID;
						pItem->m_sTouchEffectValue1 = iDice(1, 100000);

						// Anti Dup System
						SYSTEMTIME SysTime;
						char cTemp[256];
						GetLocalTime(&SysTime);
						ZeroMemory(cTemp, sizeof(cTemp));
						pItem->m_sTouchEffectValue2 = iDice(1, 100000);
						wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
						pItem->m_sTouchEffectValue2 = atoi(cTemp);

						ZeroMemory(cTemp, sizeof(cTemp));
						wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
						pItem->m_sTouchEffectValue3 = atoi(cTemp);

					}
					else {
					//	if (MaxLevel > 0) {
							dwTemp = pItem->m_dwAttribute;
							dwTemp = dwTemp & 0x0000FFFF;

							dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
							dwTemp2 = dwTemp2 << 16;

							dwTemp = dwTemp | dwTemp2;
							pItem->m_dwAttribute = dwTemp;
					//	}

						iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
						if (iResultValue > 0) {
							if (iResultValue > 200) iResultValue = 200;
							dV2 = (double)iResultValue;
							dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
							dV1 = (dV2 / dV3)*100.0f;
							if (dV1 >= 200) dV1 = 200;//agregado
							pItem->m_sItemSpecEffectValue2 = (int)dV1;
						}
						else if (iResultValue <= 0) pItem->m_sItemSpecEffectValue2 = 0;

						dV2 = (double)pItem->m_sItemSpecEffectValue2;
						dV3 = (double)pItem->m_wMaxLifeSpan;
					//	dV1 = (dV2 / 100.0f)*dV3;
						dV1 = (dV2 / 200.0f)*dV3;

						iTemp = (int)pItem->m_wMaxLifeSpan;
						iTemp += (int)dV1;

						pItem->m_sTouchEffectType = DEF_ITET_ID;
						pItem->m_sTouchEffectValue1 = iDice(1, 100000);

						// Anti Dup System
						SYSTEMTIME SysTime;
						char cTemp[256];
						GetLocalTime(&SysTime);
						ZeroMemory(cTemp, sizeof(cTemp));
						pItem->m_sTouchEffectValue2 = iDice(1, 100000);
						wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
						pItem->m_sTouchEffectValue2 = atoi(cTemp);

						ZeroMemory(cTemp, sizeof(cTemp));
						wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
						pItem->m_sTouchEffectValue3 = atoi(cTemp);

						if (iTemp <= 0)
							wTemp = 1;
						else wTemp = (WORD)iTemp;

						if (wTemp <= pItem->m_wMaxLifeSpan * 12) {
							pItem->m_wMaxLifeSpan = wTemp;
							pItem->m_sItemSpecEffectValue1 = (int)wTemp;
							pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
						}
						else pItem->m_sItemSpecEffectValue1 = (int)pItem->m_wMaxLifeSpan;
					/*	else 
						{
							pItem->m_wMaxLifeSpan = (pItem->m_wMaxLifeSpan * 2);
							pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
						}*/

						pItem->m_cItemColor = 2;
					}

				//	wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
					//CharacterLogList(G_cTxt);

					bAddItem(iClientH, pItem, NULL);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer�� �����ϱ� ���� 

					for (x = 0; x < 6; x++)
						if (cElementItemID[x] != -1) {
							if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
								wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
								CharacterLogList(G_cTxt);
							}
							else {
								iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
								if (iCount < 0) iCount = 0;
								SetItemCount(iClientH, cElementItemID[x], iCount);
							}
						}

					if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
						GetExp(iClientH, iDice(2, (m_pBuildItemList[i]->m_iSkillLimit / 4)));
					return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: BuildItemHandler");
	}
#endif
}

void CMapServer::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif

		class  CStrTok * pStrTok;
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], *cp;
		WORD * wp;
		int    iTime;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token == NULL)
				iTime = 0;
			else iTime = atoi(token);

			if (iTime < 0) iTime = 0;

			m_sForceRecallTime = iTime;

			wsprintf(G_cTxt, "Game Server Force Recall Time (%d)min", m_sForceRecallTime);
			PutLogList(G_cTxt);
		}

		delete pStrTok;
		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SetForceRecallTime");
	}
#endif
}

void CMapServer::AdminOrder_UnsummonAll(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (m_pClientList[iClientH] == NULL) return;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				if (m_pNpcList[i]->m_bIsKilled == FALSE) {
					m_pNpcList[i]->m_bIsSummoned = TRUE;
					NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_UnsummonAll");
	}
#endif
}

void CMapServer::AdminOrder_UnsummonBoss(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (m_pClientList[iClientH] == NULL) return;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				if (((m_pNpcList[i]->m_sType == 31) || (m_pNpcList[i]->m_sType == 49) || (m_pNpcList[i]->m_sType == 45) || (m_pNpcList[i]->m_sType == 47) ||
					(m_pNpcList[i]->m_sType == 50) || (m_pNpcList[i]->m_sType == 52) || (m_pNpcList[i]->m_sType == 66) || (m_pNpcList[i]->m_sType == 73) ||
					(m_pNpcList[i]->m_sType == 81)) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
					m_pNpcList[i]->m_bIsSummoned = TRUE;
					NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_UnsummonBoss");
	}
#endif
}

char CMapServer::_cGetSpecialAbility(int iKindSA)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cSA = 0;

		switch (iKindSA) {
			case 1:
				switch (iDice(1, 2)) {
					case 1: cSA = 3; break;
					case 2: cSA = 4; break;
				}
				break;

			case 2:
				switch (iDice(1, 3)) {
					case 1: cSA = 3; break;
					case 2: cSA = 4; break;
					case 3: cSA = 5; break;
				}
				break;

			case 3:
				switch (iDice(1, 4)) {
					case 1: cSA = 3; break;
					case 2: cSA = 4; break;
					case 3: cSA = 5; break;
					case 4: cSA = 6; break;
				}
				break;

			case 4:
				switch (iDice(1, 3)) {
					case 1: cSA = 3; break;
					case 2: cSA = 4; break;
					case 3: cSA = 7; break;
				}
				break;

			case 5:
				switch (iDice(1, 4)) {
					case 1: cSA = 3; break;
					case 2: cSA = 4; break;
					case 3: cSA = 7; break;
					case 4: cSA = 8; break;
				}
				break;

			case 6:
				switch (iDice(1, 3)) {
					case 1: cSA = 3; break;
					case 2: cSA = 4; break;
					case 3: cSA = 5; break;
				}
				break;

			case 7:
				switch (iDice(1, 3)) {
					case 1: cSA = 1; break;
					case 2: cSA = 2; break;
					case 3: cSA = 4; break;
				}
				break;

			case 8:
				switch (iDice(1, 5)) {
					case 1: cSA = 1; break;
					case 2: cSA = 2; break;
					case 3: cSA = 4; break;
					case 4: cSA = 3; break;
					case 5: cSA = 8; break;
				}
				break;

			case 9:
				cSA = iDice(1, 8);
				break;
		}
		return cSA;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _cGetSpecialAbility");
	}
#endif
	return 0;
}

void CMapServer::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA;
		int    pX, pY, j, iNum, iNamingValue;
		class  CStrTok * pStrTok;
		BOOL   bMaster;
		SYSTEMTIME SysTime;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		GetLocalTime(&SysTime);
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token == NULL) {
			delete pStrTok;
			return;
		}

		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy_secure(cNpcName, token);

		token = pStrTok->pGet();

		if (token != NULL)
			iNum = atoi(token);
		else iNum = 1;

		if (iNum <= 0)  iNum = 1;
		if (iNum >= 150)  iNum = 150;

		cSA = 0;
		pX = m_pClientList[iClientH]->m_sX;
		pY = m_pClientList[iClientH]->m_sY;

		wsprintf(G_cTxt, "Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
		CharacterLogList(G_cTxt);

		wsprintf(G_cTxt, "GM Order(%s): Summon NPC(%s)-Count(%d)", m_pClientList[iClientH]->m_cCharName, cNpcName, iNum);
		PutGMLogData(G_cTxt);

		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			ZeroMemory(cName_Master, sizeof(cName_Master));
			wsprintf(cName_Master, "XX%d", iNamingValue);
			cName_Master[0] = '_';
			cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
		}

		for (j = 0; j < (iNum - 1); j++) {
			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				ZeroMemory(cName_Slave, sizeof(cName_Slave));
				wsprintf(cName_Slave, "XX%d", iNamingValue);
				cName_Slave[0] = '_';
				cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
				if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
				else bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Summon");
	}
#endif
}

void CMapServer::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * cp, *token, cName[11], cBuff[256];
		class  CStrTok * pStrTok;
		WORD   * wp;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					if (i == iClientH) {
						delete pStrTok;
						return;
					}
					RequestTeleportHandler(i, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
					delete pStrTok;
					return;
				}
			}
			wsprintf(G_cTxt, "GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cCharName, cName, m_pClientList[iClientH]->m_cMapName);
			PutGMLogData(G_cTxt);
		}

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SummonPlayer");
	}
#endif
}

void CMapServer::AdminOrder_deslogpull(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * cp, *token, cName[11], cBuff[256];
		class  CStrTok * pStrTok;
		WORD   * wp;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					if (i == iClientH) {
						delete pStrTok;
						return;
					}
					if (m_pClientList[i]->NoDelete == TRUE) m_pClientList[i]->NoDelete = FALSE;
					DeleteClient(i, TRUE, TRUE, FALSE);
					delete pStrTok;
					return;
				}
			}
			wsprintf(G_cTxt, "GM Order(%s): PC(%s) deslog to (%s)", m_pClientList[iClientH]->m_cCharName, cName, m_pClientList[iClientH]->m_cMapName);
			PutGMLogData(G_cTxt);
		}

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_deslogpull");
	}
#endif
}

void CMapServer::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	_iForcePlayerDisconect();
}

BOOL CMapServer::bReadDupeConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("Cannot open Dupped file.");
		return FALSE;
	}
	else {
		PutLogList("Reading Dupper List file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								m_pDupItemIDList[iIndex] = new class CItem;
								ZeroMemory(m_pDupItemIDList[iIndex]->m_cName, sizeof(m_pDupItemIDList[iIndex]->m_cName));
								memcpy_secure(m_pDupItemIDList[iIndex]->m_cName, token, 21);
								cReadModeB = 2;
								break;

							case 2:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pDupItemIDList[iIndex]->m_dwCount = atoi(token);
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
								iIndex++;
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "[EOF]", 5) != 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! Dupped configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::_RevertRareItemValue(CItem* pItem)
{
	DWORD dwSWEType, dwSWEValue;
	double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != 0) {
		dwSWEType = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;

		switch (dwSWEType) {
		case 0: break;

		case 5: // Revert speed adjustment
			pItem->m_cSpeed++;
			// No es necesario limitar el valor aquí, ya que se está revirtiendo
			break;

		case 6: // Revert weight adjustment
			dV2 = static_cast<double>(pItem->m_wWeight);
			dV3 = static_cast<double>(dwSWEValue * 4);
			dV1 = (dV3 / 100.0) * dV2;
			pItem->m_wWeight += static_cast<int>(dV1);  // Sumar en lugar de restar para revertir
			break;

		case 8: // Revert lifespan adjustment
		case 9: // Revert lifespan adjustment
			dV2 = static_cast<double>(pItem->m_wMaxLifeSpan);
			dV3 = static_cast<double>(dwSWEValue * 7);
			dV1 = (dV3 / 100.0) * dV2;
			pItem->m_wMaxLifeSpan -= static_cast<int>(dV1);  // Restar en lugar de sumar para revertir
			break;
		}
	}
}

void CMapServer::_AdjustRareItemValue(CItem *pItem) 
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwSWEType, dwSWEValue;
		double dV1, dV2, dV3;

		if ((pItem->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType = (pItem->m_dwAttribute & 0x00F00000) >> 20;
			dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
			switch (dwSWEType) {
				case 0: break;

				case 5: // ��ø�� 
					pItem->m_cSpeed--;
					if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
					break;

				case 6: // ������ 
					dV2 = (double)pItem->m_wWeight;
					dV3 = (double)(dwSWEValue * 4);
					dV1 = (dV3 / 100.0f)*dV2;
					pItem->m_wWeight -= (int)dV1;

					if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
					break;

				case 8: // ��ȭ�� 
				case 9: // ���빮���� 
					dV2 = (double)pItem->m_wMaxLifeSpan;
					dV3 = (double)(dwSWEValue * 7);
					dV1 = (dV3 / 100.0f)*dV2;
					pItem->m_wMaxLifeSpan += (int)dV1;
					break;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _AdjustRareItemValue");
	}
#endif
}

void CMapServer::RequestNoticementHandler(int iClientH, char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cData[120];
		int  * ip, iRet, iClientSize;
		DWORD * dwp;
		WORD  * wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_dwNoticementDataSize < 10) return;

		ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
		iClientSize = *ip;

		if (iClientSize != m_dwNoticementDataSize) {
			cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
			ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
			memcpy_secure((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);

			dwp = (DWORD *)(cp + DEF_INDEX4_MSGID);
			*dwp = CLIENT_RESPONSE_NOTICEMENT;
			wp = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_REJECT;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);

			delete[]cp;
		}
		else {
			ZeroMemory(cData, sizeof(cData));

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_RESPONSE_NOTICEMENT;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = DEF_MSGTYPE_CONFIRM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		}
		//Agregado Lalo882
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestNoticementHandler");
	}
#endif
}

void CMapServer::_bDecodeNoticementFileContents(char * cFn)
{
#ifdef DEF_DEBUG
	try {
#endif

		FILE * pFile;
		HANDLE hFile;
		DWORD dwFileSize;

		hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
		dwFileSize = GetFileSize(hFile, NULL);
		if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

		pFile = fopen(cFn, "rt");
		if (pFile == NULL) return;
		else {
			PutLogList("Reading NOTICEMENT configuration file...");

			m_pNoticementData = new char[dwFileSize + 2];
			ZeroMemory(m_pNoticementData, dwFileSize + 2);
			fread(m_pNoticementData, dwFileSize, 1, pFile);

			m_dwNoticementDataSize = strlen(m_pNoticementData);

			wsprintf(G_cTxt, "Noticement Data Size: %d", m_dwNoticementDataSize);
			PutLogList(G_cTxt);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bDecodeNoticementFileContents");
	}
#endif
}

void CMapServer::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
		short sOwnerH;
		char  cOwnerType;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pMapList[cMapIndex] == NULL) return;

		iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
		iRange = iSkillLevel / 12; // �ִ� ������ 8

		for (iX = dX - iRange; iX <= dX + iRange; iX++) {
			for (iY = dY - iRange; iY <= dY + iRange; iY++) {
				sOwnerH = NULL;
				if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
					m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

				if (sOwnerH != NULL) {
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							// �������� ������ ���� ���鿩�� �������� �����Ѵ�.
							iTamingLevel = 10;
							switch (m_pNpcList[sOwnerH]->m_sType) {
								case 10:							// ������  
								case 16: iTamingLevel = 1; break;	// ����
								case 22: iTamingLevel = 2; break;	// ��
								case 17:							// ����
								case 14: iTamingLevel = 3; break;	// ��ũ
								case 18: iTamingLevel = 4; break;   // ����
								case 11: iTamingLevel = 5; break;	// ���̷���
								case 23:
								case 12: iTamingLevel = 6; break;	// ����
								case 28: iTamingLevel = 7; break;	// Ʈ��
								case 13:							// ����Ŭ�ӽ�
								case 27: iTamingLevel = 8; break;	// ���Ͽ���
								case 29: iTamingLevel = 9; break;	// ������
								case 33: iTamingLevel = 9; break;	// ��������
								case 30: iTamingLevel = 9; break;  // ��ġ
								case 31:
								case 32: iTamingLevel = 10; break;  // ����, ������
							}

							iResult = (iSkillLevel / 10);
							if (iResult < iTamingLevel) break;
							break;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _TamingHandler");
	}
#endif
}

void CMapServer::GetMagicAbilityHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

		m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
		bCheckTotalSkillMasteryPoints(iClientH, 4);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetMagicAbilityHandler");
	}
#endif
}

int CMapServer::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * cp, cDir, cData[3000];
		DWORD * dwp;
		WORD  * wp;
		short * sp, dX, dY;
		int   iRet, iSize;

		if (m_pClientList[iClientH] == NULL) return 0;
		if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

		dX = m_pClientList[iClientH]->m_sX;
		dY = m_pClientList[iClientH]->m_sY;

		cDir = *(pData + DEF_INDEX2_MSGTYPE + 2);

		if ((cDir <= 0) || (cDir > 8)) return 0;

		switch (cDir) {
			case 1:	dY--; break;
			case 2:	dX++; dY--;	break;
			case 3:	dX++; break;
			case 4:	dX++; dY++;	break;
			case 5: dY++; break;
			case 6:	dX--; dY++;	break;
			case 7:	dX--; break;
			case 8:	dX--; dY--;	break;
		}
		//Agregado v13
		if (dX < 1 || dX > m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX ||
			dY < 1 || dY > m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY) {
			return 0;
		}//hasta aca

		m_pClientList[iClientH]->m_sX = dX;
		m_pClientList[iClientH]->m_sY = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_PANNING;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_OBJECTMOVE_CONFIRM;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = (short)(dX - m_pClientList[iClientH]->res_sX);
		cp += 2;

		sp = (short *)cp;
		*sp = (short)(dY - m_pClientList[iClientH]->res_sY);
		cp += 2;

		*cp = cDir;
		cp++;

		iSize = iComposeMoveMapData((short)(dX - m_pClientList[iClientH]->res_sX), (short)(dY - m_pClientList[iClientH]->res_sY), iClientH, cDir, cp);

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 17);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
		}
		return 1;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iRequestPanningMapDataRequest");
	}
#endif
	return 0;
}

void CMapServer::AdminOrder_SetObserverMode(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SetObserverMode");
	}
#endif
}

void CMapServer::RequestRestartHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  cTmpMap[32];

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && m_pClientList[iClientH]->Heredado == TRUE)
				RestoreItems(iClientH);

			strcpy_secure(cTmpMap, m_pClientList[iClientH]->m_cMapName);
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == DEF_NETURAL) {
				if (m_pClientList[iClientH]->Assasain)
				{
					if ((strcmp(cTmpMap, "WorldMap") == 0) && (WorldWarII == TRUE)) {
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8);
					}
					else if ((strcmp(cTmpMap, "evento13") == 0) && (AllEks == TRUE)) {
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "evento13", 8);
					}
					else if ((strcmp(cTmpMap, "evento14") == 0) && (AllDkEks == TRUE)) {
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "evento14", 8);
					}
					else
					{
						strcpy_secure(m_pClientList[iClientH]->m_cMapName, "Whouse");
					}
				}
				else strcpy_secure(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				if (m_pClientList[iClientH]->m_cSide == DEF_ARESDEN) {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 20 * 1;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 20 * 1;
						}
						else {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 20 * 1;
						}
					}

					if ((strcmp(cTmpMap, "elvine") == 0) && (CityVsCity == FALSE)) {
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
						strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 20 * 1;
					}
					else if (m_pClientList[iClientH]->m_iLevel > 40)
						if ((strcmp(cTmpMap, "WorldMap") == 0) && (WorldWarII == TRUE)) {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8);
						}
						else if ((strcmp(cTmpMap, "evento13") == 0) && (AllEks == TRUE)){
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "evento13", 8);
						}
						else if ((strcmp(cTmpMap, "evento14") == 0) && (AllDkEks == TRUE)) {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "evento14", 8);
						}
						else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "gshop_1", 7);
				}
				else {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 20 * 1;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 20 * 1;
						}
						else {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 20 * 1;
						}
					}

					if ((strcmp(cTmpMap, "aresden") == 0) && (CityVsCity == FALSE)) {
						memcpy_secure(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
						strcpy_secure(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 20 * 1;

					}
					else if (m_pClientList[iClientH]->m_iLevel > 40)
						if ((strcmp(cTmpMap, "WorldMap") == 0) && (WorldWarII == TRUE)) {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8);
						}
						else if ((strcmp(cTmpMap, "evento13") == 0) && (AllEks == TRUE)) {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "evento13", 8);
						}
						else if ((strcmp(cTmpMap, "evento14") == 0) && (AllDkEks == TRUE)) {
							memcpy_secure(m_pClientList[iClientH]->m_cMapName, "evento14", 8);
						}
						else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy_secure(m_pClientList[iClientH]->m_cMapName, "gshop_2", 7);
				}
			}

			m_pClientList[iClientH]->m_bIsKilled = FALSE;
			m_pClientList[iClientH]->m_iHP = (3 * m_pClientList[iClientH]->m_iVit) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) / 2);
			m_pClientList[iClientH]->m_iHungerStatus = 100;

			m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);

			ZeroMemory(cTmpMap, sizeof(cTmpMap));
			strcpy_secure(cTmpMap, m_pClientList[iClientH]->m_cMapName);
			RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestRestartHandler");
	}
#endif
}

void CMapServer::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * cp, *token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
		SYSTEMTIME SysTime;
		class  CStrTok * pStrTok;
		class  CItem * pItem;
		short  * sp;
		int    iRet, iTemp, iEraseReq, iValue;
		DWORD * dwp;
		WORD  * wp, wTemp;
		double dV1, dV2, dV3;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cItemName, sizeof(cItemName));
			strcpy_secure(cItemName, token);
		}

		ZeroMemory(cAttribute, sizeof(cAttribute));
		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cAttribute, sizeof(cAttribute));
			strcpy_secure(cAttribute, token);
		}

		ZeroMemory(cValue, sizeof(cValue));
		iValue = 0;
		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cValue, sizeof(cValue));
			strcpy_secure(cValue, token);
			iValue = atoi(cValue);
		}

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			delete pItem;
			return;
		}
		if (strlen(cAttribute) != 0) {
			pItem->m_dwAttribute = atoi(cAttribute);
			if (pItem->m_dwAttribute == 1) {
				if ((iValue >= 1) && (iValue <= 200)) {
					pItem->m_cItemColor = 2;
					pItem->m_sItemSpecEffectValue2 = iValue - 100;

					dV2 = (double)pItem->m_sItemSpecEffectValue2;
					dV3 = (double)pItem->m_wMaxLifeSpan;
					dV1 = (dV2 / 100.0f)*dV3;

					iTemp = (int)pItem->m_wMaxLifeSpan;
					iTemp += (int)dV1;

					if (iTemp <= 0)
						wTemp = 1;
					else wTemp = (WORD)iTemp;

					if (wTemp <= pItem->m_wMaxLifeSpan * 2) {
						pItem->m_wMaxLifeSpan = wTemp;
						pItem->m_sItemSpecEffectValue1 = (int)wTemp;
						pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					}
					else pItem->m_sItemSpecEffectValue1 = (int)pItem->m_wMaxLifeSpan;

				}
				else pItem->m_dwAttribute = NULL;
			}
			else {
				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
						case 6:	pItem->m_cItemColor = 2; break;
						case 8: pItem->m_cItemColor = 3; break;
						case 1:	pItem->m_cItemColor = 5; break;
						case 5:	pItem->m_cItemColor = 1; break;
						case 3:	pItem->m_cItemColor = 7; break;
						case 2:	pItem->m_cItemColor = 4; break;
						case 7:	pItem->m_cItemColor = 6; break;
						case 9:	pItem->m_cItemColor = 8; break;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
						case 10: pItem->m_cItemColor = 5; break;
					}
				}
			}
		}
		switch (pItem->m_sIDnum) {
			case 511: // �����Ƿ���. ��¥�Է�
			case 513:
			case 515:
			case 517:
			case 530:
			case 531:
			case 532:
			case 533:
			case 534:
				GetLocalTime(&SysTime);
				pItem->m_sTouchEffectType = DEF_ITET_DATE;
				pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;

				// Anti Dup System
				ZeroMemory(cTemp, sizeof(cTemp));
				pItem->m_sTouchEffectValue2 = iDice(1, 100000);
				wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue2 = atoi(cTemp);

				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
				break;

			default:
				GetLocalTime(&SysTime);
				pItem->m_sTouchEffectType = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1, 100000);

				// Anti Dup System
				ZeroMemory(cTemp, sizeof(cTemp));
				pItem->m_sTouchEffectValue2 = iDice(1, 100000);
				wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue2 = atoi(cTemp);

				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);
				break;
		}

		ZeroMemory(cData, sizeof(cData));
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy_secure(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwCount;	// ������ �Է� 
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ���� �������̹Ƿ� �������� �ʾҴ�.
			cp++;

			sp = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			//cp++;
			//cambio lalomanu
			sp = (short *)cp;
			*sp = pItem->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char)pItem->m_sItemSpecEffectValue3;
			cp++;

			if (iEraseReq == 1) {
				delete pItem;
				pItem = NULL;
			}

			//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
			//cambio lalomanu
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
			wsprintf(G_cTxt, "GM Order(%s): Create ItemName(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
			PutGMLogData(G_cTxt);

			return;
		}
		else {
			delete pItem;
			return;
		}
		if (pStrTok != NULL) delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CreateItem");
	}
#endif
}

void CMapServer::RequestSellItemListHandler(int iClientH, char * pData)
{

#ifdef DEF_DEBUG
	try {
#endif
		int i, *ip, iAmount;
		char * cp, cIndex;
		struct {
			char cIndex;
			int  iAmount;
		} stTemp[12];

		if (m_pClientList[iClientH] == NULL) return;

		cp = (char *)(pData + 6);
		for (i = 0; i < 12; i++) {
			stTemp[i].cIndex = *cp;
			cp++;

			ip = (int *)cp;
			stTemp[i].iAmount = *ip;
			cp += 4;
		}

		for (i = 0; i < 12; i++) {
			cIndex = stTemp[i].cIndex;
			iAmount = stTemp[i].iAmount;

			if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;

			ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
			if (m_pClientList[iClientH] == NULL) return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestSellItemListHandler");
	}
#endif
}

//ZeroEoyPnk - Soccer Event
BOOL CMapServer::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (Soccer == FALSE) return FALSE;

		if (strcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cName, "fightzone6") == 0) {
			//Point Goal Aresden
			if (((m_pNpcList[iNpcH]->m_sX >= 57) && (m_pNpcList[iNpcH]->m_sX <= 59)) &&
				((m_pNpcList[iNpcH]->m_sY >= 29) && (m_pNpcList[iNpcH]->m_sY <= 31))) {
				GoalPoint(1, sAttackerH);
				return TRUE;
			}
			//Point Goal Elvine
			else if (((m_pNpcList[iNpcH]->m_sX >= 21) && (m_pNpcList[iNpcH]->m_sX <= 23)) &&
				((m_pNpcList[iNpcH]->m_sY >= 29) && (m_pNpcList[iNpcH]->m_sY <= 31))) {
				GoalPoint(2, sAttackerH);
				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckEnergySphereDestination");
	}
#endif
	return FALSE;
}

void CMapServer::GoalPoint(int GoalPoint, short sAttackerH)
{

#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (Soccer == FALSE) return;

		if (GoalPoint == 1) GolesAresden++;
		else if (GoalPoint == 2) GolesElvine++;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)
				&& (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "fightzone6", 10) == 0)) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ENERGYSPHEREGOALIN, GoalPoint, NULL, NULL, m_pClientList[sAttackerH]->m_cCharName, NULL, NULL);

				//Celebrity Light
				// Arco Aresden
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 20, 28, 20, 28, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 20, 32, 20, 32, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 23, 28, 23, 28, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 23, 32, 23, 32, 114, m_pClientList[i]->m_sType);
				// Arco Elvine
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 60, 28, 60, 28, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 60, 32, 60, 32, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 57, 28, 57, 28, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 57, 32, 57, 32, 114, m_pClientList[i]->m_sType);
				// Esquinas
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 23, 19, 23, 19, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 23, 40, 23, 40, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 57, 40, 57, 40, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 57, 19, 57, 19, 114, m_pClientList[i]->m_sType);
				// Medio Campo
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 39, 40, 39, 40, 114, m_pClientList[i]->m_sType);
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 39, 19, 39, 19, 114, m_pClientList[i]->m_sType);

				//Goal! - Aresden
				if (GoalPoint == 1)
					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 54, 30, 58, 30, 208, m_pClientList[i]->m_sType);
				//Goal! - Elvine
				if (GoalPoint == 2)
					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[i]->m_cMapIndex, 22, 30, 22, 30, 207, m_pClientList[i]->m_sType);
			}
		}
		ChequearPartido();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GoalPoint");
	}
#endif
}

void CMapServer::CreateEnergy()
{
#ifdef DEF_DEBUG
	try {
#endif
		int pX, pY, iNamingValue, z, i;
		char cName_Internal[31], cWaypoint[31];

		if (Soccer == FALSE) return;

		pX = 39;
		pY = 30;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));

		for (z = 0; z < DEF_MAXMAPS; z++) {
			if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "fightzone6") == 0)) {
				iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {

					ZeroMemory(cName_Internal, sizeof(cName_Internal));
					wsprintf(cName_Internal, "XX%d", iNamingValue);
					cName_Internal[0] = '_';
					cName_Internal[1] = z + 65;

					if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[z]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
						m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						return;
					}
				}
			}
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete == TRUE)
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ENERGYSPHERECREATED, GolesAresden, GolesElvine, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateEnergy");
	}
#endif
}

void CMapServer::ChequearPartido()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		char cVerMessage[50];

		if (Soccer == FALSE) return;

		if ((GolesElvine >= 10) || (GolesAresden >= 10)) {
			if (GolesElvine >= 10) wsprintf(cVerMessage, "Partido terminado, gano Elvine!");
			if (GolesAresden >= 10) wsprintf(cVerMessage, "Partido terminado, gano Aresden!");

			GolesAresden = -1;
			GolesElvine = -1;

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					ShowClientMsg(i, cVerMessage);
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ENERGYSPHERECREATED, GolesAresden, GolesElvine, 2, NULL, 2, NULL);
				}
			}
			Soccer = FALSE;
		}
		else CreateEnergy();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChequearPartido");
	}
#endif
}

void CMapServer::ActivateSpecialAbilityHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTime = timeGetTime();
		short sTemp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
		if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;
		if (bCheckIfIsFlagCarrier(iClientH) == TRUE) return;

		m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
		m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

		m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF0F;
		switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
				sTemp = sTemp | 0x0010;
				break;
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
				sTemp = sTemp | 0x0020;
				break;
			case 70:
				sTemp = sTemp | 0x0040;
				break;
		}
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActivateSpecialAbilityHandler");
	}
#endif
}

void CMapServer::CancelQuestHandler(int iClientH, short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		_ClearQuestStatus(iClientH, Type);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUESTABORTED, Type - 1, NULL, NULL, NULL);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CancelQuestHandler");
	}
#endif
}
/*

int CMapServer::iGetItemWeight(CItem *pItem, int iCount)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iWeight;
		if (pItem == NULL) return 0;
		iWeight = (pItem->m_wWeight);
		if (iCount < 0) iCount = 1;
		iWeight = iWeight * iCount;
		if (pItem->m_sIDnum == 90 || pItem->m_sIDnum == 3052 || pItem->m_sIDnum == 3053 || pItem->m_sIDnum == 3054 || pItem->m_sIDnum == 3055) iWeight = iWeight / 20;
		if (iWeight <= 0) iWeight = 1;

		return iWeight;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetItemWeight");
	}
#endif
	return 0;
}*/

int CMapServer::iGetItemWeight(CItem *pItem, int iCount)
{
#ifdef DEF_DEBUG
	try {
#endif  // Devuelve directamente 1, ya que todos los ítems tendrán el mismo peso
		return 1;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetItemWeight");
	}
#endif
	return 0;
}


void CMapServer::UpdateMapSectorInfo()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, ix, iy;
		int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {

				iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;
				m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
				m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
				m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

				for (ix = 0; ix < DEF_MAXSECTORS; ix++)
					for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
						if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
							iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
							m_pMapList[i]->m_iMaxNx = ix;
							m_pMapList[i]->m_iMaxNy = iy;
						}

						if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
							iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
							m_pMapList[i]->m_iMaxAx = ix;
							m_pMapList[i]->m_iMaxAy = iy;
						}

						if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
							iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
							m_pMapList[i]->m_iMaxEx = ix;
							m_pMapList[i]->m_iMaxEy = iy;
						}

						if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
							iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
							m_pMapList[i]->m_iMaxMx = ix;
							m_pMapList[i]->m_iMaxMy = iy;
						}

						if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
							iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
							m_pMapList[i]->m_iMaxPx = ix;
							m_pMapList[i]->m_iMaxPy = iy;
						}
					}

				// TempSectorInfo ������.
				m_pMapList[i]->ClearTempSectorInfo();

				// Sector Info�� ����
				if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
				if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
				if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
				if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
				if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UpdateMapSectorInfo");
	}
#endif
}

void CMapServer::AgingMapSectorInfo()
{
#ifdef DEF_DEBUG
	try {
#endif

		int i, ix, iy;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				for (ix = 0; ix < DEF_MAXSECTORS; ix++) {
					for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
						m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
						m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
						m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
						m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
						m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;

						if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
						if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
						if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity = 0;
						if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
						if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity = 0;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AgingMapSectorInfo");
	}
#endif
}

BOOL CMapServer::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iNamingValue, ix, iy, tX, tY;
		char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
		short sOwnerH;

		if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
			return FALSE;
		}

		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {

			for (ix = dX - 3; ix <= dX + 5; ix++) {
				for (iy = dY - 3; iy <= dY + 5; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
				}
			}

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (m_pClientList[iClientH]->m_cSide == 1) {
				switch (iType) {
					case 1: strcpy_secure(cNpcName, "AGT-Aresden"); break;
					case 2: strcpy_secure(cNpcName, "CGT-Aresen"); break;
					case 3: strcpy_secure(cNpcName, "MS-Aresden"); break;
					case 4: strcpy_secure(cNpcName, "DT-Aresden"); break;
				}
			}
			else if (m_pClientList[iClientH]->m_cSide == 2) {
				switch (iType) {
					case 1: strcpy_secure(cNpcName, "AGT-Elvine"); break;
					case 2: strcpy_secure(cNpcName, "CGT-Elvine"); break;
					case 3: strcpy_secure(cNpcName, "MS-Elvine"); break;
					case 4: strcpy_secure(cNpcName, "DT-Elvine"); break;
				}
			}
			else return FALSE;

			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

			tX = (int)dX;
			tY = (int)dY;
			if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, (rand() % 9),
				DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
				PutLogList(G_cTxt);
				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: __bSetConstructionKit");
	}
#endif
	return FALSE;
}

BOOL CMapServer::_bNpcBehavior_ManaCollector(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int dX, dY, iMaxMP, iTotal;
		short sOwnerH;
		char  cOwnerType;
		double dV1, dV2, dV3;
		BOOL bRet;

		if (m_pNpcList[iNpcH] == NULL) return FALSE;
		if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

		bRet = FALSE;
		for (dX = m_pNpcList[iNpcH]->m_sX - 5; dX <= m_pNpcList[iNpcH]->m_sX + 5; dX++) {
			for (dY = m_pNpcList[iNpcH]->m_sY - 5; dY <= m_pNpcList[iNpcH]->m_sY + 5; dY++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				if (sOwnerH != NULL) {
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if ((m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) ||
								(m_pNpcList[iNpcH]->m_cSide == 11 && m_pClientList[sOwnerH]->Assasain == TRUE)) {
								iMaxMP = (2 * (m_pClientList[sOwnerH]->m_iMag + m_pClientList[sOwnerH]->m_sRankAddMag + m_pClientList[sOwnerH]->m_iAngelicMag)) + (2 * m_pClientList[sOwnerH]->m_iLevel) + ((m_pClientList[sOwnerH]->m_iInt + m_pClientList[sOwnerH]->m_sRankAddInt + m_pClientList[sOwnerH]->m_iAngelicInt) / 2); // v1.4
								if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
									iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag + m_pClientList[sOwnerH]->m_sRankAddMag + m_pClientList[sOwnerH]->m_iAngelicMag)); // Mana Point�� 1D(Magic)�� �ö󰣴�.
									if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
										dV2 = (double)iTotal;
										dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
										dV1 = (dV3 / 100.0f)*dV2;
										iTotal += (int)dV1;
									}

									m_pClientList[sOwnerH]->m_iMP += iTotal;

									if (m_pClientList[sOwnerH]->m_iMP > iMaxMP)
										m_pClientList[sOwnerH]->m_iMP = iMaxMP;

									SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MP, NULL, NULL, NULL, NULL);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH]->m_sType == 42) {
								if (m_pNpcList[sOwnerH]->m_iV1 > 0) {
									if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
										if (m_pNpcList[iNpcH]->m_cSide >= 0 && m_pNpcList[iNpcH]->m_cSide <= 3) {
											m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3;
											m_pNpcList[sOwnerH]->m_iV1 -= 3;
											bRet = TRUE;
										}
									}
									else if (m_pNpcList[iNpcH]->m_cSide >= 0 && m_pNpcList[iNpcH]->m_cSide <= 3) {
										m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1;
										m_pNpcList[sOwnerH]->m_iV1 = 0;
										bRet = TRUE;
									}
								}
							}
							else bRet = FALSE;
							break;
					}
				}
			}
		}
		return bRet;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UpdateMapSectorInfo");
	}
#endif
	return FALSE;
}

BOOL CMapServer::_bNpcBehavior_Detector(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif

		int dX, dY;
		short sOwnerH;
		char  cOwnerType, cSide;
		BOOL  bFlag = FALSE;

		if (m_pNpcList[iNpcH] == NULL) return FALSE;
		if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

		for (dX = m_pNpcList[iNpcH]->m_sX - 10; dX <= m_pNpcList[iNpcH]->m_sX + 10; dX++) {
			for (dY = m_pNpcList[iNpcH]->m_sY - 10; dY <= m_pNpcList[iNpcH]->m_sY + 10; dY++) {
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				cSide = 0;
				if (sOwnerH != NULL) {
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							cSide = m_pClientList[sOwnerH]->m_cSide;
							break;

						case DEF_OWNERTYPE_NPC:
							cSide = m_pNpcList[sOwnerH]->m_cSide;
							break;
					}
				}

				if (cSide != m_pNpcList[iNpcH]->m_cSide) {
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
								SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_INVISIBILITY, NULL, NULL, NULL);
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
							}
							break;
					}
					bFlag = TRUE;
				}
			}
		}
		return bFlag;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UpdateMapSectorInfo");
	}
#endif
	return FALSE;
}

void CMapServer::CheckCrusadeResultCalculation(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
			if (m_pClientList[iClientH]->m_iWarContribution > 300000) m_pClientList[iClientH]->m_iWarContribution = 300000;

			if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
				if (m_iCrusadeWinnerSide == 0) {
					m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution / 6);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
				}
				else {
					if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
						if (m_pClientList[iClientH]->m_iLevel <= 80) {
							m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 200;
						}
						else if (m_pClientList[iClientH]->m_iLevel <= 100) {
							m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 100;
						}
						else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 30;

						m_pClientList[iClientH]->m_iExpStock += (int)((m_pClientList[iClientH]->m_iWarContribution)*(1.2));
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					}
					else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
						if (m_pClientList[iClientH]->m_iLevel <= 80) {
							m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 200;
						}
						else if (m_pClientList[iClientH]->m_iLevel <= 100) {
							m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 100;
						}
						else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 30;

						m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution / 5;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1 * m_pClientList[iClientH]->m_iWarContribution, NULL);
					}
				}
			}
			else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);

			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
			m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckCrusadeResultCalculation");
	}
#endif
}

void CMapServer::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
#ifdef DEF_DEBUG
	try {
#endif

		int i;

		if (m_bIsCrusadeMode || ActiveEvent) return;
		DWORD dwTime = timeGetTime();

		ActiveEvent = m_bIsCrusadeMode = TRUE;
		m_iCrusadeWinnerSide = 0;

		dw_CrusadeTime = dwTime - 500;

		m_dwCrusadeGUID = dwCrusadeGUID;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				m_pClientList[i]->m_iCrusadeDuty = 0;
				m_pClientList[i]->m_iConstructionPoint = 0;
				m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
			}
		}

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				m_pMapList[i]->RestoreStrikePoints();
				if (memcmp(m_pMapList[i]->m_cName, "middleland", 10) == 0) m_pMapList[i]->m_iMaximumObject = 0;
			}
		}

		for (i = 0; i < DEF_MAXGUILDS; i++) {
			m_pGuildTeleportLoc[i].m_iNumSummonNpc = 0;
			m_pGuildTeleportLoc[i].m_iV2 = 0;
		}

		CreateCrusadeStructures();
		PutLogList("Crusade Mode ON.");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalStartCrusadeMode");
	}
#endif
}

void CMapServer::LocalEndCrusadeMode(int iWinnerSide)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		if (m_bIsCrusadeMode == FALSE) return;
		m_bIsCrusadeMode = ActiveEvent = FALSE;

		PutLogList("Crusade Mode OFF.");
		RemoveCrusadeStructures();
		KillCrusadeObjects();
		m_iWinnerSide = m_iCrusadeWinnerSide = iWinnerSide;  //v2.19 2002-11-15

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				m_pClientList[i]->m_iCrusadeDuty = 0;
				m_pClientList[i]->m_iConstructionPoint = 0;
				m_pClientList[i]->TotalStructuresKilled = 0;
				if (!m_pClientList[i]->Achivements[10].Complete)
					CheckCompleteAchivement(i, 10, TRUE);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_SADE, EventCount[DEF_SADE].AresdenWin, EventCount[DEF_SADE].ElvineWin, NULL, EventCount[DEF_SADE].Draw, EventCount[DEF_SADE].LastWin);
			}
		}
		RecallHunterPlayer();

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				m_pMapList[i]->m_iTotalCrusadeStructures = 0;
				if (memcmp(m_pMapList[i]->m_cName, "middleland", 10) == 0) m_pMapList[i]->m_iMaximumObject = 800;
			}
		}
		//	InitTowerDefence();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalEndCrusadeMode");
	}
#endif
}

void CMapServer::CreateCrusadeStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue, iTotalMS, iMSIndex[100], iMSSelected[DEF_MAXCRUSADESTRUCTURES], iMSLeft;
		char cName[6], cNpcName[21], cNpcWayPoint[11];
		BOOL bFlag;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

		for (i = 0; i < 100; i++) iMSIndex[i] = -1;

		iTotalMS = 0;
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			if (m_stCrusadeStructures[i].cType == 42) {
				iMSIndex[iTotalMS] = i;
				iTotalMS++;
				iMSSelected[i] = -1;
			}
		}

		if (iTotalMS <= 3) {
			iMSSelected[iMSIndex[0]] = 1;
			iMSSelected[iMSIndex[1]] = 1;
			iMSSelected[iMSIndex[2]] = 1;
		}
		else {
			iMSLeft = 3;
			bFlag = FALSE;
			while (bFlag == FALSE) {
				i = iDice(1, iTotalMS) - 1;
				if (iMSIndex[i] != -1) {
					iMSSelected[iMSIndex[i]] = 1;
					iMSIndex[i] = -1;
					iMSLeft--;
					if (iMSLeft <= 0) bFlag = TRUE;
				}
			}
		}
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			if (m_stCrusadeStructures[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue == -1) {
						}
						else {
							ZeroMemory(cName, sizeof(cName));
							ZeroMemory(cNpcName, sizeof(cNpcName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							switch (m_stCrusadeStructures[i].cType) {
								case 36:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
										strcpy_secure(cNpcName, "AGT-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
										strcpy_secure(cNpcName, "AGT-Elvine");
									break;

								case 37:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
										strcpy_secure(cNpcName, "CGT-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
										strcpy_secure(cNpcName, "CGT-Elvine");
									break;

								case 40:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
										strcpy_secure(cNpcName, "ESG-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
										strcpy_secure(cNpcName, "ESG-Elvine");
									break;

								case 41:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
										strcpy_secure(cNpcName, "GMG-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
										strcpy_secure(cNpcName, "GMG-Elvine");
									break;

								case 42:
									// v2.05
									if (iMSSelected[i] == 1) strcpy_secure(cNpcName, "ManaStone");
									break;

								case 64:
									strcpy_secure(cNpcName, "Crops");
									break;

								default:
									strcpy_secure(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName);
									break;
							}

							tX = (int)m_stCrusadeStructures[i].dX;
							tY = (int)m_stCrusadeStructures[i].dY;
							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
								&tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								wsprintf(G_cTxt, "Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
								PutLogList(G_cTxt);
							}
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateCrusadeStructures");
	}
#endif
}

void CMapServer::SendCollectedMana()
{
#ifdef DEF_DEBUG
	try {
#endif

		char * cp, cData[120];
		WORD * wp;

		if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

		wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
		PutLogList(G_cTxt);

		CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);
		m_iCollectedMana[0] = m_iCollectedMana[1] = m_iCollectedMana[2] = 0;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendCollectedMana");
	}
#endif
}

void CMapServer::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_iAresdenMapIndex != -1) {
			m_iAresdenMana += wAresdenMana;
			if (wAresdenMana > 0) {
				wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
				PutLogList(G_cTxt);
			}
		}

		if (m_iElvineMapIndex != -1) {
			m_iElvineMana += wElvineMana;
			if (wElvineMana > 0) {
				wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
				PutLogList(G_cTxt);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CollectedManaHandler");
	}
#endif
}

void CMapServer::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (m_pNpcList[iNpcH]->m_cSide) {
			case 1:
				if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
					m_iAresdenMana = 0;
					m_pNpcList[iNpcH]->m_iManaStock++;
					if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
						MeteorStrikeMsgHandler(1);
						m_pNpcList[iNpcH]->m_iManaStock = 0;
						m_iAresdenMana = 0;
					}
					wsprintf(G_cTxt, "Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
					PutLogList(G_cTxt);
				}
				break;

			case 2:
				if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
					m_iElvineMana = 0;
					m_pNpcList[iNpcH]->m_iManaStock++;
					if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
						MeteorStrikeMsgHandler(2);
						m_pNpcList[iNpcH]->m_iManaStock = 0;
						m_iElvineMana = 0;
					}
					wsprintf(G_cTxt, "Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
					PutLogList(G_cTxt);
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _NpcBehavior_GrandMagicGenerator");
	}
#endif
}

void CMapServer::MeteorStrikeMsgHandler(char cAttackerSide)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		DWORD dwTime = timeGetTime();

		switch (cAttackerSide) {
			case 1:
				if (m_iElvineMapIndex != -1) {
					for (i = 1; i < DEF_MAXCLIENTS; i++) {
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
							if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvine") == 0)
								SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
							else SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
						}
					}
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000 * 5, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
				}
				else {
					for (i = 1; i < DEF_MAXCLIENTS; i++) {
						if (m_pClientList[i] != NULL) {
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
						}
					}
				}
				break;

			case 2:
				if (m_iAresdenMapIndex != -1) {
					for (i = 1; i < DEF_MAXCLIENTS; i++) {
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
							if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aresden") == 0)
								SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
							else SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
						}
					}
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000 * 5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
				}
				else {
					for (i = 1; i < DEF_MAXCLIENTS; i++) {
						if (m_pClientList[i] != NULL) {
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
						}
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MeteorStrikeMsgHandler");
	}
#endif
}

void CMapServer::_LinkStrikePointMapIndex()
{
#ifdef DEF_DEBUG
	try {
#endif

		int i, z, x;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
				for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) {
					if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
						for (x = 0; x < DEF_MAXMAPS; x++) {
							if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
								m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
								goto LSPMI_LOOPBREAK;
							}
						}
					LSPMI_LOOPBREAK:;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _LinkStrikePointMapIndex");
	}
#endif
}

void CMapServer::MeteorStrikeHandler(int iMapIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
		int iTargetArray[DEF_MAXSTRIKEPOINTS];
		short sOwnerH;
		char  cOwnerType;
		DWORD dwTime = timeGetTime();

		PutLogList("Beginning Meteor Strike Procedure...");

		if (iMapIndex == -1) {
			PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
			return;
		}

		if (m_pMapList[iMapIndex] == NULL) {
			PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
			return;
		}

		if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
			PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
			return;
		}

		for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

		iIndex = 0;
		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
			if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
				iTargetArray[iIndex] = i; // ��Ʈ����ũ ����Ʈ�� �ε����� �ִ´�.
				iIndex++;
			}
		}

		wsprintf(G_cTxt, "Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
		PutLogList(G_cTxt);
		m_stMeteorStrikeResult.iCasualties = 0;
		m_stMeteorStrikeResult.iCrashedStructureNum = 0;
		m_stMeteorStrikeResult.iStructureDamageAmount = 0;

		if (iIndex == 0) {
			PutLogList("No strike points!");
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex))
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
			}

			for (i = 0; i < iIndex; i++) {
				iTargetIndex = iTargetArray[i];

				if (iTargetIndex == -1) {
					PutLogList("(X) Strike Point MapIndex: -1!");
					goto MSH_SKIP_STRIKE;
				}

				dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
				dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

				iTotalESG = 0;
				for (ix = dX - 10; ix <= dX + 10; ix++) {
					for (iy = dY - 10; iy <= dY + 10; iy++) {
						m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
							iTotalESG++;
						}
					}
				}
				wsprintf(G_cTxt, "Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
				PutLogList(G_cTxt);

				if (iTotalESG < 2) {
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
					if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
						m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
						m_stMeteorStrikeResult.iCrashedStructureNum++;
					}
					else {
						m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
						iEffect = iDice(1, 5) - 1;
						iAddDynamicObjectList(NULL, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex,
							m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] + (iDice(1, 3) - 2),
							m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] + (iDice(1, 3) - 2), 60 * 1000 * 50);
					}
				}
			MSH_SKIP_STRIKE:;
			}

			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MeteorStrikeHandler");
	}
#endif
}

void CMapServer::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cData[120];
		register int i;
		int *ip, iIndex;
		DWORD dwTemp, dwTime;

		if (m_pClientList[iClientH] == NULL) return;
		if (dY < 100) dY = 100;
		if (dY > 600) dY = 600;

		dwTime = timeGetTime();
		//wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
		//CharacterLogList(G_cTxt);

		for (i = 0; i < DEF_MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
				if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					return;
				}
				else {
					m_pGuildTeleportLoc[i].m_sDestX = dX;
					m_pGuildTeleportLoc[i].m_sDestY = dY;
					ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
					strcpy_secure(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					return;
				}
			}
		}

		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < DEF_MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy_secure(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
					iIndex = i;
				}
			}
		}

		if (iIndex == -1) return;
		CharacterLogList("(X) No more GuildTeleportLoc Space! Replaced.");
		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX = dX;
		m_pGuildTeleportLoc[i].m_sDestY = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
		strcpy_secure(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime = dwTime;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestSetGuildTeleportLocHandler");
	}
#endif
}

void CMapServer::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cData[120];
		register int i;
		int *ip, iIndex;
		DWORD dwTemp, dwTime;

		if (m_pClientList[iClientH] == NULL) return;

		dwTime = timeGetTime();
		//wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
		//CharacterLogList(G_cTxt);

		for (i = 0; i < DEF_MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
				if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
					m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
					return;
				}
				else {
					m_pGuildTeleportLoc[i].m_sDestX2 = dX;
					m_pGuildTeleportLoc[i].m_sDestY2 = dY;
					ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
					strcpy_secure(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
					m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
					return;
				}
			}
		}

		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < DEF_MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {

				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy_secure(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
					iIndex = i;
				}
			}
		}
		if (iIndex == -1) return;

		CharacterLogList("(X) No more GuildConstructLoc Space! Replaced.");
		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX2 = dX;
		m_pGuildTeleportLoc[i].m_sDestY2 = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
		strcpy_secure(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestSetGuildConstructLocHandler");
	}
#endif
}

void CMapServer::RequestGuildTeleportHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		char cMapName[11];

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
			return;
		}
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "middleland", 10) == 0) return;

		if (m_bIsCrusadeMode != TRUE) {
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
		if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		for (i = 0; i < DEF_MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
				ZeroMemory(cMapName, sizeof(cMapName));
				strcpy_secure(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);
				//wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
				//CharacterLogList(G_cTxt);
				RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestGuildTeleportHandler");
	}
#endif
}

void CMapServer::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
		register int i, x;
		int iNamingValue, tX, tY, ix, iy;
		BOOL bRet;
		short sOwnerH;
		DWORD dwTime = timeGetTime();

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland", 10) != 0)
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden", 7) != 0)
			&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine", 6) != 0))
			return;

		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cMapName, sizeof(cMapName));

		if (cType < 0) return;
		if (cType >= DEF_MAXNPCTYPES) return;
		if (cNum > 10) return;
		if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;

		cNum = 1;
		for (x = 1; x <= cNum; x++) {
			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				ZeroMemory(cName, sizeof(cName));
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

				switch (cType) {
					case 43: // Light War Beetle
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: strcpy_secure(cNpcName, "LWB-Assasain"); break;
							case 1: strcpy_secure(cNpcName, "LWB-Aresden"); break;
							case 2: strcpy_secure(cNpcName, "LWB-Elvine"); break;
						}
						break;

					case 36: // Arrow Guard Tower
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: strcpy_secure(cNpcName, "AGT-Assasain"); break;
							case 1: strcpy_secure(cNpcName, "AGT-Aresden"); break;
							case 2: strcpy_secure(cNpcName, "AGT-Elvine"); break;
						}
						break;

					case 37: // Cannon Guard Tower
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: strcpy_secure(cNpcName, "CGT-Assasain"); break;
							case 1: strcpy_secure(cNpcName, "CGT-Aresden"); break;
							case 2: strcpy_secure(cNpcName, "CGT-Elvine"); break;
						}
						break;

					case 38: // Mana Collector
						switch (m_pClientList[iClientH]->m_cSide) {
							case 1: strcpy_secure(cNpcName, "MS-Aresden"); break;
							case 2: strcpy_secure(cNpcName, "MS-Elvine"); break;
						}
						break;

					case 39: // Detector
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: strcpy_secure(cNpcName, "DT-Assasain"); break;
							case 1: strcpy_secure(cNpcName, "DT-Aresden"); break;
							case 2: strcpy_secure(cNpcName, "DT-Elvine"); break;
						}
						break;

					case 51: // Catapult
						switch (m_pClientList[iClientH]->m_cSide) {
							case 0: strcpy_secure(cNpcName, "CP-Assasain"); break;
							case 1: strcpy_secure(cNpcName, "CP-Aresden"); break;
							case 2: strcpy_secure(cNpcName, "CP-Elvine"); break;
						}
						break;

					case 44: strcpy_secure(cNpcName, "GHK"); break;
					case 45: strcpy_secure(cNpcName, "GHKABS"); break;
					case 46: strcpy_secure(cNpcName, "TK"); break;
					case 47: strcpy_secure(cNpcName, "BG"); break;
				}

				wsprintf(G_cTxt, "Request Summon War Unit (%d) (%s)", cType, cNpcName);
				CharacterLogList(G_cTxt);

				tX = (int)dX;
				tY = (int)dY;

				bRet = FALSE;
				switch (cType) {
					case 36:
					case 37:
					case 38:
					case 39:
						if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
						if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
						if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

						if (bRet == TRUE) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
							return;
						}
						for (i = 0; i < DEF_MAXGUILDS; i++) {
							if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
								m_pGuildTeleportLoc[i].m_dwTime = dwTime;
								if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
									SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
									return;
								}
								else {
									m_pGuildTeleportLoc[i].m_iV2++;
									goto RSWU_LOOPBREAK;
								}
							}
						}
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
						return;
						break;

					case 43:
					case 44:
					case 45:
					case 46:
					case 47:
					case 51:
						for (i = 0; i < DEF_MAXGUILDS; i++) {
							if (m_pGuildTeleportLoc[i].m_iNumSummonNpc >= DEF_MAX_CRUSADESUMMONMOB) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTCONSTRUCT, 4, NULL, NULL, NULL);
								return;
							}
							else {
								m_pGuildTeleportLoc[i].m_iNumSummonNpc++;
								goto RSWU_LOOPBREAK;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
						return;
						break;

				}

			RSWU_LOOPBREAK:;
				bRet = FALSE;
				switch (cType) {
					case 36:
					case 37:
						for (ix = tX - 2; ix <= tX + 2; ix++) {
							for (iy = tY - 2; iy <= tY + 2; iy++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
									switch (m_pNpcList[sOwnerH]->m_sType) {
										case 36:
										case 37:
											bRet = TRUE;
											break;
									}
								}
							}
						}
						if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
						break;
				}

				if (bRet == TRUE) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
					return;
				}
				if (cMode == NULL) {
					if (m_pClientList[iClientH]->Assasain)
						bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, 11, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
					else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
					bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
				}
				else {
					if (m_pClientList[iClientH]->Assasain)
						bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, 11, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
					else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				}

				if (bRet == FALSE) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
				else {
					m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
					if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestSummonWarUnitHandler");
	}
#endif
}

void CMapServer::CheckConnectionHandler(int iClientH, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp;
		DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

		if (m_pClientList[iClientH] == NULL) return;

		dwTime = timeGetTime();
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		dwp = (DWORD *)cp;
		dwTimeRcv = *dwp;

		if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
			m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
			m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
		}
		else {
			dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
			dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);

			if (dwTimeGapClient < dwTimeGapServer) return;
			if ((abs((int)(dwTimeGapClient - dwTimeGapServer))) >= (DEF_CLIENTTIMEOUT)) {
				//if (m_pClientList[iClientH]->NoClear == FALSE /*&& m_pClientList[iClientH]->NoDelete == FALSE*/) {
				if (m_pClientList[iClientH]->NoClear == FALSE && m_pClientList[iClientH]->NoDelete == FALSE) {
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckConnectionHandler");
	}
#endif
}

void CMapServer::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

		if ((3 - m_iWinnerSide) == m_pClientList[iClientH]->m_cSide) {
			if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
				if (3 == iDuty) m_pClientList[iClientH]->m_iConstructionPoint = 3000;
			}
		}

		m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SelectCrusadeDutyHandler");
	}
#endif
}

void CMapServer::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		if (m_pClientList[iClientH] == NULL) return;

		switch (iMode) {
			case 1:
				if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

				for (i = 0; i < DEF_MAXGUILDS; i++) {
					if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
							NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
							NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);
						ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
						memcpy_secure(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
						m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
						m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
						return;
					}
				}
				break;

			case 3:
				for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
				}
				m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

				if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
					for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
						if (m_pClientList[iClientH]->m_iCrusadeDuty == 3) {
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
						}
						else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) {
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
							m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
						}
					}
					memcpy_secure(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
				}
				else {
					if (strcmp(pMapName, "middleland") == 0) {
						for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
							if (m_pClientList[iClientH]->m_iCrusadeDuty == 3) {
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_stMiddleCrusadeStructureInfo[i].sX;
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_stMiddleCrusadeStructureInfo[i].sY;
							}
							else if (m_stMiddleCrusadeStructureInfo[i].cType == 42) {
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_stMiddleCrusadeStructureInfo[i].sX;
								m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_stMiddleCrusadeStructureInfo[i].sY;
							}
						}
						strcpy_secure(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
					}
				}
				_SendMapStatus(iClientH);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MapStatusHandler");
	}
#endif
}

void CMapServer::_SendMapStatus(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i, iDataSize;
		char *cp, cData[DEF_MAXCRUSADESTRUCTURES * 6];
		short * sp;

		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);

		memcpy_secure(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
		cp += 10;

		sp = (short *)cp;
		*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
		cp += 2;

		cp++;

		if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
			m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

		iDataSize = 0;
		for (i = 0; i < 100; i++) {
			if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
			if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
			if ((m_pClientList[iClientH]->m_iCSIsendPoint >= 3) && (m_pClientList[iClientH]->m_iCrusadeDuty != 3))  goto SMS_ENDOFDATA;

			*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
			cp++;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
			cp += 2;
			*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
			cp++;

			iDataSize += 6;
			m_pClientList[iClientH]->m_iCSIsendPoint++;
		}

		cp = (char *)(cData + 12);
		*cp = (iDataSize / 6);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAPSTATUSNEXT, iDataSize + 13, NULL, NULL, cData);
		return;

	SMS_ENDOFDATA:;

		cp = (char *)(cData + 12);
		*cp = (iDataSize / 6);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAPSTATUSLAST, iDataSize + 13, NULL, NULL, cData);
		m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

		return;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _SendMapStatus");
	}
#endif
}

void CMapServer::RemoveCrusadeStructures()
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 36:
					case 37:
					case 38:
					case 39:
					case 40:
					case 41:
					case 42:
					case 64:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveCrusadeStructures");
	}
#endif
}

void CMapServer::RecallHunterPlayer()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsWarLocation) && (m_pClientList[i]->m_bIsHunter) && (m_pClientList[i]->m_bIsInitComplete))
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RecallHunterPlayer");
	}
#endif
}

void CMapServer::DoMeteorStrikeDamageHandler(int iMapIndex)
{

#ifdef DEF_DEBUG
	try {
#endif
		int i, iDamage;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0 || m_pClientList[i]->Assasain == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
				if (m_pClientList[i]->m_iLevel < 80)
					iDamage = m_pClientList[i]->m_iLevel + iDice(1, 10);
				else iDamage = m_pClientList[i]->m_iLevel * 2 + iDice(1, 10);

				iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
				if (iDamage > 255) iDamage = 255;

				if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) iDamage = iDamage / 2;
				if (m_pClientList[i]->m_iAdminUserLevel > 0) iDamage = 0;

				m_pClientList[i]->m_iHP -= iDamage;
				if (m_pClientList[i]->m_iHP <= 0) {
					ClientKilledHandler(i, NULL, NULL, iDamage);
					m_stMeteorStrikeResult.iCasualties++;
				}
				else {
					if (iDamage > 0) {
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

						if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
							m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
							m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						}

						if (m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0) {
							// 1: Hold-Person 
							// 2: Paralize
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT], NULL, NULL);

							m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] = NULL;
							bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DoMeteorStrikeDamageHandler");
	}
#endif
}

void CMapServer::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS];
		char * cp, *cp2, cData[120], cWinnerSide, cTempData[120];
		WORD * wp;

		if (m_bIsCrusadeMode == FALSE) return;

		for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++)
			iStructureHP[i] = 0;

		iActiveStructure = 0;
		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
			if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
				iActiveStructure++;
				iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP;
			}
		}

		wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
		PutLogList(G_cTxt);

		if (iActiveStructure == 0) {
			if (iMapIndex == m_iAresdenMapIndex) {
				cWinnerSide = 2;
				LocalEndCrusadeMode(2); // �̱� ���� ������
			}
			else if (iMapIndex == m_iElvineMapIndex) {
				cWinnerSide = 1;
				LocalEndCrusadeMode(1); // �̱� ���� �Ʒ�����
			}
			else {
				cWinnerSide = 0;
				LocalEndCrusadeMode(0);
			}
			CreateEventResults(cWinnerSide, DEF_SADE);
		}
		else {
			ZeroMemory(cTempData, sizeof(cTempData));
			cp2 = (char *)(cTempData);

			wp = (WORD *)cp2;
			*wp = (WORD)m_pMapList[iMapIndex]->m_iTotalStrikePoints;
			cp2 += 2;

			for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
				wp = (WORD *)cp2;
				*wp = (WORD)iStructureHP[i];
				cp2 += 2;
			}
			GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure, m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);

			//Genero Mercenarios
			if (iMapIndex == m_iAresdenMapIndex) CallMercenary(1);
			else if (iMapIndex == m_iElvineMapIndex) CallMercenary(2);
		}
		m_stMeteorStrikeResult.iCasualties = 0;
		m_stMeteorStrikeResult.iCrashedStructureNum = 0;
		m_stMeteorStrikeResult.iStructureDamageAmount = 0;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalcMeteorStrikeEffectHandler");
	}
#endif
}

void CMapServer::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iSTcount, char * pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, 0, 0, 0, 0, iSTcount, pData);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GrandMagicResultHandler");
	}
#endif
}

void CMapServer::SyncMiddlelandMapInfo()
{
#ifdef DEF_DEBUG
	try {
#endif

		int i;
		char * cp;
		short * sp;

		if (m_iMiddlelandMapIndex != -1) {
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY = NULL;
			}
			m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SyncMiddlelandMapInfo");
	}
#endif
}

void CMapServer::CheckCommanderConstructionPoint(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cData[120];
		int  * ip, i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_bIsCrusadeMode == FALSE) return;
		if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

		switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
			case 1: // 
			case 2: // 
				for (i = 0; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
						(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
						m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
						m_pClientList[i]->m_iWarContribution += (m_pClientList[iClientH]->m_iConstructionPoint / 6);

						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT)
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						m_pClientList[iClientH]->m_iConstructionPoint = 0;
						return;
					}
				}
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				break;

			case 3: break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckCommanderConstructionPoint");
	}
#endif
}

BOOL CMapServer::bAddClientShortCut(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_iClientShortCut[i] == iClientH) return FALSE;
		}

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_iClientShortCut[i] == 0) {
				m_iClientShortCut[i] = iClientH;
				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bAddClientShortCut");
	}
#endif
	return FALSE;
}

void CMapServer::RemoveClientShortCut(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		for (i = 0; i < DEF_MAXCLIENTS + 1; i++) {
			if (m_iClientShortCut[i] == iClientH) {
				m_iClientShortCut[i] = 0;
				goto RCSC_LOOPBREAK;
			}
		}

	RCSC_LOOPBREAK:;
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i + 1] != 0)) {
				m_iClientShortCut[i] = m_iClientShortCut[i + 1];
				m_iClientShortCut[i + 1] = 0;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveClientShortCut");
	}
#endif
}

void CMapServer::ManualEndCrusadeMode(int iWinnerSide)
{
#ifdef DEF_DEBUG
	try {
#endif

		char * cp, cData[256];
		WORD * wp;

		if (m_bIsCrusadeMode == FALSE) return;

		LocalEndCrusadeMode(iWinnerSide);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ManualEndCrusadeMode");
	}
#endif
}

int CMapServer::iGetMapLocationSide(char *pMapName)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (strcmp(pMapName, "aresden") == 0) return 3;
		if (strcmp(pMapName, "elvine") == 0)  return 4;
		if (memcmp(pMapName, "arebrk11", 8) == 0) return 3;
		if (memcmp(pMapName, "elvbrk11", 8) == 0) return 4;

		if (memcmp(pMapName, "cityhall_1", 10) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "cityhall_2", 10) == 0)  return DEF_ELVINE;

		if (memcmp(pMapName, "cath_1", 6) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "cath_2", 6) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "gshop_1", 7) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "gshop_2", 7) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "bsmith_1", 8) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "bsmith_2", 8) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "wrhus_1", 7) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "wrhus_2", 7) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "gldhall_1", 9) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "gldhall_2", 9) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "wzdtwr_1", 8) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "wzdtwr_2", 8) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "arefarm", 7) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "elvfarm", 7) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "arewrhus", 8) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "elvwrhus", 8) == 0) return DEF_ELVINE;

		if (memcmp(pMapName, "CmdHall_1", 9) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "CmdHall_2", 9) == 0)  return DEF_ELVINE;

		if (memcmp(pMapName, "ABarracks", 9) == 0) return DEF_ARESDEN;
		if (memcmp(pMapName, "EBarracks", 9) == 0)  return DEF_ELVINE;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iGetMapLocationSide");
	}
#endif
	return 0;
}

BOOL CMapServer::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (pOriginal == NULL) return FALSE;
		if (pCopy == NULL) return FALSE;

		pCopy->m_sIDnum = pOriginal->m_sIDnum;
		pCopy->m_cItemType = pOriginal->m_cItemType;
		pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
		pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;
		pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
		pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
		pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3;
		pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
		pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
		pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6;
		pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
		pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
		pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
		pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2;
		pCopy->m_sSprite = pOriginal->m_sSprite;
		pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;
		pCopy->m_cApprValue = pOriginal->m_cApprValue;
		pCopy->m_cSpeed = pOriginal->m_cSpeed;
		pCopy->m_wPrice = pOriginal->m_wPrice;
		pCopy->m_wWeight = pOriginal->m_wWeight;
		pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;
		pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;
		pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
		pCopy->m_cCategory = pOriginal->m_cCategory;
		pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
		pCopy->m_dwCount = pOriginal->m_dwCount;
		pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
		pCopy->m_sTouchEffectValue1 = pOriginal->m_sTouchEffectValue1;
		pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
		pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
		pCopy->m_cItemColor = pOriginal->m_cItemColor;
		pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
		pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
		pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
		pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
		pCopy->m_dwAttribute = pOriginal->m_dwAttribute;

		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCopyItemContents");
	}
#endif
}

void CMapServer::KillCrusadeObjects()
{
#ifdef DEF_DEBUG
	try {
#endif

		int i;
		for (i = 1; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 43:
					case 44:
					case 45:
					case 46:
					case 47:
					case 51:
						NpcKilledHandler(NULL, NULL, i, 0);
						break;
				}
			}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: KillCrusadeObjects");
	}
#endif
}

void CMapServer::AdminOrder_GetFightzoneTicket(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iReserveTime, iFightzoneTN, iFightzoneN;
		char cTemp[21];
		SYSTEMTIME SysTime;

		if (m_pClientList[iClientH] == NULL) return;
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {

			iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth * 10000 + SysTime.wDay * 100 + (SysTime.wHour + 3);
			ZeroMemory(cTemp, sizeof(cTemp));
			strcpy_secure(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName + 9));
			iFightzoneN = m_pClientList[iClientH]->m_iFightzoneNumber;
			iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
			m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);
			GetFightzoneTicketHandler(iClientH);
			GetFightzoneTicketHandler(iClientH);
			GetFightzoneTicketHandler(iClientH);
			m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
			m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
		}
		else {
			iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth * 10000 + SysTime.wDay * 100 + (SysTime.wHour + 2);
			ZeroMemory(cTemp, sizeof(cTemp));
			strcpy_secure(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName + 9));
			iFightzoneN = m_pClientList[iClientH]->m_iFightzoneNumber;
			iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
			m_pClientList[iClientH]->m_iFightzoneNumber = 1;
			GetFightzoneTicketHandler(iClientH);
			GetFightzoneTicketHandler(iClientH);
			GetFightzoneTicketHandler(iClientH);
			m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
			m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_GetFightzoneTicket");
	}
#endif
}

void CMapServer::ResurrectPlayer(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		PutLogList("(*) Resurrect Player!");
		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
		m_pClientList[iClientH]->m_iMP = (2 * (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) + (2 * m_pClientList[iClientH]->m_iLevel) + ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2);
		m_pClientList[iClientH]->m_iSP = (2 * m_pClientList[iClientH]->m_iStr) + (2 * m_pClientList[iClientH]->m_iLevel);
		m_pClientList[iClientH]->m_bIsKilled = FALSE;

		RequestInitDataHandler(iClientH, NULL, NULL, TRUE);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ResurrectPlayer");
	}
#endif
}

BOOL CMapServer::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return FALSE;

		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 4:  // �ܰ� +1
			case 9:  // ��Ʈ �ҵ� +1
			case 13: // ������ +1
			case 16: // �׶����콺 +1
			case 18: // �ռҵ� +1
			case 19: // �ռҵ� +2
			case 21: // ����Į���� +1
			case 24: // ���̹� +1
			case 26: // �ù�Ÿ +1
			case 27: // �ù�Ÿ +2
			case 29: // ��ġ�� +1
			case 30: // ��ġ�� +2
			case 32: // ������ũ +1
			case 33: // ������ũ +2
			case 35: // �����Ǿ� +1
			case 36: // �����Ǿ� +2
			case 39: // ���ε� �ҵ� +1
			case 40: // ���ε� �ҵ� +2
			case 43: // �ٽ�Ÿ�� �ҵ� +1
			case 44: // �ٽ�Ÿ�� �ҵ� +2
			case 47: // Ŭ���̸��� +1
			case 48: // Ŭ���̸��� +2
			case 51: // �׷���Ʈ �ҵ� +1
			case 52: // �׷���Ʈ �ҵ� +2
			case 55: // �÷����� +1
			case 56: // �÷����� +2
			case 60: // ����Ʈ �׽� +1
			case 61: // ����Ʈ �׽� +2
			case 63: // �丶ȣũ +1
			case 64: // �丶ȣũ +2
			case 66: // �����׽� +1
			case 67: // �����׽� +2
			case 69: // �����׽� +1
			case 70: // �����׽� +2
			case 72: // ���׽� +1
			case 73: // ���׽� +2
			case 580: // ��Ʋ�׽� +1
			case 581: // ��Ʋ�׽� +2
			case 582: // ���̹� +2
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckAndConvertPlusWeaponItem");
	}
#endif
	return TRUE;
}

void CMapServer::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
#ifdef DEF_DEBUG
	try {
#endif
		double dV1, dV2, dV3;
		int i, iH, iUnitValue;
		DWORD dwTime = timeGetTime();
		int iTotalPartyMembers;
		int iStruckLevel;
		int PartyID = 0;

		if (m_pClientList[iClientH] == NULL) return;
		if (iExp <= 0) return;

		if (m_pClientList[iClientH]->m_iLevel <= 80) {
			dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
			dV2 = dV1 * 0.025f;
			dV3 = (double)iExp;
			dV1 = (dV2 + 1.025f)*dV3;
			iExp = (int)dV1;
		}

		//nose pasa de lvl 
		iStruckLevel = m_pClientList[iClientH]->m_iLevel - DEF_PLAYERMAXLEVEL; // By Mkintosh
		if ((m_pClientList[iClientH]->m_iLevel > DEF_PLAYERMAXLEVEL) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
			m_pClientList[iClientH]->m_iLevel = DEF_PLAYERMAXLEVEL;
			m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (iStruckLevel * 3);
		}
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			//Only divide exp if > 1 person and exp > 10
			PartyID = m_pClientList[iClientH]->m_iPartyID;
			if (iExp >= 10 && m_pPartyManager[PartyID]->iTotalMembers > 0) {

				//Figure out how much exp a player gets
				dV1 = (double)iExp;
				switch (m_pPartyManager[PartyID]->iTotalMembers) {
					case 1: dV2 = dV1; break;
					case 2: dV2 = (dV1 + (dV1 * 2.0e-2)) / 2.0; break;
					case 3: dV2 = (dV1 + (dV1 * 5.0e-2)) / 3.0; break;
					case 4: dV2 = (dV1 + (dV1 * 7.000000000000001e-2)) / 4.0; break;
					case 5: dV2 = (dV1 + (dV1 * 1.0e-1)) / 5.0; break;
					case 6: dV2 = (dV1 + (dV1 * 1.4e-1)) / 6.0; break;
					case 7: dV2 = (dV1 + (dV1 * 1.7e-1)) / 7.0; break;
					case 8: dV2 = (dV1 + (dV1 * 2.0e-1)) / 8.0; break;
					default: dV2 = (dV1 + (dV1 * 2.0e-1)) / 9.0; break;
				}

				dV3 = dV2 + 5.0e-1;
				iUnitValue = (int)dV3;

				//Divide exp among party members
				for (i = 0; i <= m_pPartyManager[PartyID]->iTotalMembers; i++) {
					iH = m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH;
					//Player who kills monster gets more exp
					if (iH == iClientH) {
						if (m_pClientList[iH] != NULL) { // Is player alive ??
							//heaton prevent lammers quest and exp
							if (m_pClientList[iH]->m_sRebirthStatus == 1) continue;
							if (m_pClientList[iH]->m_iCheckCount > 39) continue;
							//Exp gain based on lvl
							if ((m_pClientList[iH]->m_iStatus & 0x10000) != 0) iUnitValue *= 3;
							MultiplicadorExp(iH, iUnitValue);
						}
					}
					else {
						//Other players get normal exp :P
						if ((m_pClientList[iH] != NULL) && m_pClientList[iH]->m_iHP > 0) {
							//heaton prevent lammers quest and exp
							if (m_pClientList[iH]->m_sRebirthStatus == 1) continue;
							if (m_pClientList[iH]->m_iCheckCount > 39) continue;
							if (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) {
								//Only players on same map get exp
								if (m_pClientList[iH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
									MultiplicadorExp(iH, iUnitValue);
							}
						}
					}
				}
				if (bIsAttackerOwn == TRUE) {
					if (m_pPartyManager[PartyID]->iTotalMembers > 1)
						m_pClientList[iClientH]->m_iExpStock += (iUnitValue / 10);
				}
			}
			else {
				if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) iExp *= 3;
				MultiplicadorExp(iClientH, iExp);
			}
		}
		else {
			if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) iExp *= 3;
			MultiplicadorExp(iClientH, iExp);
		}
		if (m_pClientList[iClientH]->m_iLevel >= DEF_PLAYERMAXLEVEL && m_pClientList[iClientH]->m_iExp < m_iLevelExpTable[DEF_PLAYERMAXLEVEL]) {
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[DEF_PLAYERMAXLEVEL];
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetExp");
	}
#endif
}

void CMapServer::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iItemX, iItemY, iSoM, iSoX, iSomH, iSoxH, iCheckHeroCape, iValue1, iValue2, ItemID = 0; // v2.172
		DWORD *dwp, dwTemp, dwSWEType, iValue;
		double dV1, dV2, dV3;
		short *sp, sItemUpgrade = 2;
		WORD *wp;
		char cData[512], *cp;
		BOOL ItemChange = FALSE;

		if (m_pClientList[iClientH] == NULL) return;
		if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
		if ((!VerificarItem(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum)) &&
			(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum < 4000 ||
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum > 4017) &&
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum < 4932 ||
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum > 4955)) {

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}

			iCheckHeroCape = iUpgradeHeroCapeRequirements(iClientH, iItemIndex);
			if (iCheckHeroCape == 1) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_UPGRADEHEROCAPE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
				return;
			}
			else if (iCheckHeroCape == -1) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, -1, m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);
				return;
			}
		}

		iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 717) && (iValue >= 7) && (iValue < 0)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
			return;
		}

		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
			case 46: // Pendants are category 46
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; // Pendants are type 1
				}
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; // Pendants are left finger or more
				}
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return; // Pendants are EffectType 14
				}
				switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
					default: // Other items are not upgradable
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
						return; // Pendants are EffectType 14
					case 16: // AngelicPandent(STR)
					case 17: // AngelicPandent(DEX)
					case 18: // AngelicPandent(INT)
					case 19: // AngelicPandent(MAG)
						if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						if ((iValue + m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3) >= 20) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						iValue2 = iValue + m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3;
						switch (iValue2) {
							case 0: sItemUpgrade = 10; break;
							case 1: sItemUpgrade = 11; break;
							case 2: sItemUpgrade = 13; break;
							case 3: sItemUpgrade = 16; break;
							case 4: sItemUpgrade = 20; break;
							case 5: sItemUpgrade = 25; break;
							case 6: sItemUpgrade = 31; break;
							case 7: sItemUpgrade = 38; break;
							case 8: sItemUpgrade = 46; break;
							case 9: sItemUpgrade = 55; break;
							case 10: sItemUpgrade = 57; break;
							case 11: sItemUpgrade = 59; break;
							case 12: sItemUpgrade = 61; break;
							case 13: sItemUpgrade = 63; break;
							case 14: sItemUpgrade = 65; break;
							case 15: sItemUpgrade = 67; break;
							case 16: sItemUpgrade = 69; break;
							case 17: sItemUpgrade = 71; break;
							case 18: sItemUpgrade = 73; break;
							case 19: sItemUpgrade = 75; break;
							default:
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
								return;
								break;
						}
						if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						int iDicePTA = iDice(1, 100);
						if (iDicePTA <= 70) {
							m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
							iValue1 = (iValue + m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3);
							iValue1++;
							if (iValue1 <= 15) {
								dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
								dwTemp = dwTemp & 0x0FFFFFFF;
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue1 << 28);
							}
							else if (iValue1 <= 20) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3++;
							ZeroMemory(cData, sizeof(cData));
							dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = CLIENT_NOTIFY;
							wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp = CLIENT_NOTIFY_ITEMATTRIBUTECHANGEANGEL;

							cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

							sp = (short *)cp;
							*sp = (short)iItemIndex;
							cp += 2;

							dwp = (DWORD *)cp;
							*dwp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							cp += 4;

							sp = (short *)cp;
							*sp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3;
							cp += 2;
							//Agregado Lalo882
							//m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 14);
							int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 14);
							switch (iRet) {
							case DEF_XSOCKEVENT_QUENEFULL:
							case DEF_XSOCKEVENT_SOCKETERROR:
							case DEF_XSOCKEVENT_CRITICALERROR:
							case DEF_XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, TRUE, TRUE);
								break;
							}

							_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						}
						else {
							m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
						}
						return;
						break;
				}
				break;
		}
		if (iValue >= 15 || iValue < 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
			return;
		}

		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
			case 1:
			case 3:
			case 8:
				switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
					case 703: // SangAhFlameberge
					case 709: // DarkKnightFlameberge
					case 718: // DarkKnightGreatSword
					case 727: // DarkKnightFlamebergW
					case 736: // SangAhGiantSword
					case 737: // DarkKnightGiantSword
					case 745: // BlackKnightTemple
						if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType != 0) {
							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
								(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
								(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
								return;
							}
						}
						sItemUpgrade = (short)((iValue*(iValue + 6) / 8) + 2);
						if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703)) { // SangAhFlameberge 
							ItemID = 736;
							ItemChange = TRUE;
							break;
						}
						else if ((iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 727))) { // DarkKnightFlameberge DarkKnightFlamebergW
							ItemID = 737;
							ItemChange = TRUE;
							break;
						}
						else if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 737)) { // DarkKnightGiantSword
							ItemID = 745;
							ItemChange = TRUE;
							break;
						}
						else if ((iValue >= 12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 745)) { // BlackKnightTemple 				
							ItemID = 745;
							ItemChange = TRUE;
							break;
						}
						else {
							iValue += 2;
							if (iValue > 15) iValue = 15;
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);

							_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						}
						break;

					case 2011: // DarkKnightHammer			
					case 2012: // DarkKnightBHammer			
					case 2013: // DarkKnightBBHammer			
						if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}

						sItemUpgrade = (short)((iValue*(iValue + 6) / 8) + 2);

						if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);

						if ((iValue >= 2) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 2011)) { // DarkKnightFlameberge
							ItemID = 2012;
							ItemChange = TRUE;
							break;
						}
						else if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 2012)) { // DarkKnightGiantSword
							ItemID = 2013;
							ItemChange = TRUE;
							break;
						}
						else if ((iValue >= 14) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 2013)) { // BlackKnightTemple 
							ItemID = 2013;
							ItemChange = TRUE;
							break;
						}
						else {
							iValue += 2;
							if (iValue > 15) iValue = 15;
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						}
						break;

					case 291: // MagicWand(MS30-LLF) 
					case 714: // DarkMageMagicStaff 
					case 732: // DarkMageMagicStaffW 
					case 738: // DarkMageMagicWand
					case 746: // BlackMageTemple
						if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
							(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
							(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
							return;
						}
						if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						sItemUpgrade = (short)((iValue*(iValue + 6) / 8) + 2);
						if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						if (iValue == 0) {
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
						}
						if ((iValue >= 4) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 732))) {
							ItemID = 738;
							ItemChange = TRUE;
							break;
						}
						if ((iValue >= 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738)) {
							ItemID = 746;
							ItemChange = TRUE;
							break;
						}
						if ((iValue >= 12) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 746)) {
							ItemID = 746;
							ItemChange = TRUE;
							break;
						}
						else {
							iValue += 2;
							if (iValue > 15) iValue = 15;
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; // ºñÆ® Å¬¸®¾î 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // ¾÷±×·¹ÀÌµåµÈ ºñÆ®°ª ÀÔ·Â
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						}
						break;

					case 717: // DarkKnightRapier
						if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						sItemUpgrade = (short)((iValue*(iValue + 6) / 8) + 2);
						if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
							(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
							(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
							return;
						}
						if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
							return;
						}
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						iValue++;
						//if (iValue > 7) iValue = 7;
						//laloivalue
						if (iValue > 10) iValue = 10;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break;

					default:
						//Agregado Tope Xel y Mer Stones
						iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
						if (iValue >= 10) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
							return;
						}
						if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
							if (dwSWEType == 9) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
								return;
							}
						}
						iSoX = iSoM = 0;
						for (i = 0; i < DEF_MAXITEMS; i++) {
							if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
								switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
									case 656: iSoX++; iSoxH = i; break;
									case 657: iSoM++; iSomH = i; break;
								}
							}
						}
						if (iSoX > 0) {
							if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
								iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
								if (iValue >= 10)
									ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
								ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
								return;
							}
							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
								iValue++;
								if (iValue > 15) iValue = 15;
								else {
									dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
									dwTemp = dwTemp & 0x0FFFFFFF;
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
									ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
								}
							}
							else {
								iValue++;
								if (iValue > 15) iValue = 15;
								else {
									dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
									dwTemp = dwTemp & 0x0FFFFFFF;
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
									ItemDepleteHandler(iClientH, iSoxH, FALSE, TRUE);
								}
							}
						}
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						break;
				}
				break;

			case 5:
			case 6:
			case 15:
				switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
					case 621: // MerienPlateMailM
					case 622: // MerienPlateMailW 
					case 623:
					case 700: // SangAhHauberk 
					case 701: // SangAhFullHel
					case 702: // SangAhLeggings 
					case 703:
					case 704: // SangAhPlateMail 
					case 706: // DarkKnightHauberk
					case 707: // DarkKnightFullHelm 
					case 708: // DarkKnightLeggings  
					case 710: // DarkKnightPlateMail 
					case 711: // DarkMageHauberk 
					case 712: // DarkMageChainMail
					case 713: // DarkMageLeggings  
					case 716: // DarkMageLedderArmor
					case 719: // DarkMageScaleMail
					case 724: // DarkKnightHauberkW
					case 725: // DarkKnightFullHelmW 
					case 726: // DarkKnightLeggingsW 
					case 728: // DarkKnightPlateMailW 
					case 729: // DarkMageHauberkW 
					case 730: // DarkMageChainMailW 
					case 731: // DarkMageLeggingsW 
					case 403: //Hero
					case 404: //Hero
					case 405: //Hero
					case 406: //Hero
					case 407: //Hero
					case 408: //Hero
					case 409: //Hero
					case 410: //Hero
					case 411: //Hero
					case 412: //Hero
					case 413: //Hero
					case 414: //Hero
					case 415: //Hero
					case 416: //Hero
					case 417: //Hero
					case 418: //Hero
					case 419: //Hero
					case 420: //Hero
					case 421: //Hero
					case 422: //Hero
					case 423: //Hero
					case 424: //Hero
					case 425: //Hero
					case 426: //Hero
					case 427: //Hero
					case 428: //Hero
					case 3213: //MAresHeroCape + 1
					case 3227: //MElvHeroCape + 1
					case 4020: //PowerAresHeroCape + 1
					case 4021: //PowerElvHeroCape + 1
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
						return;
					default:
						//Agregado Tope Xel y Mer Stones
						iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
						if (iValue >= 10) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
							return;
						}

						if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
							dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
							if (dwSWEType == 8) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
								return;
							}
						}
						iSoX = iSoM = 0;
						for (i = 0; i < DEF_MAXITEMS; i++) {
							if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
								switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
									case 656: iSoX++; iSoxH = i; break;
									case 657: iSoM++; iSomH = i; break;
								}
							}
						}
						if (iSoM > 0) {
							if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
								iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
								if (iValue >= 10)
									ItemDepleteHandler(iClientH, iItemIndex, FALSE, TRUE);
								ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);
								return;
							}
							iValue++;
							if (iValue > 15) iValue = 15;
							else {
								dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
								dwTemp = dwTemp & 0x0FFFFFFF;
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
								if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
									dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
									dV2 = (dV1 * 20) / 100;
									dV3 = dV1 + dV2;
								}
								else { 
									dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
									dV2 = (dV1 * 15) / 100;
									dV3 = dV1 + dV2;
								}
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (int)dV3;
								if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan += (int)dV2;
								ItemDepleteHandler(iClientH, iSomH, FALSE, TRUE);
							}
						}
						break;
				}
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
				break;

			default:
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				break;
		}

		if (ItemChange && ItemID != 0) {
			iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
			iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;
			delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
			m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
			m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
			m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
			if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], ItemID) == FALSE) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				return;
			}

			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			iValue += 2;
			if (iValue > 15) iValue = 15;
			if (iValue == 15) m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = 9;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp & 0x0FFFFFFF;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestItemUpgradeHandler");
	}
#endif
}

BOOL CMapServer::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, BOOL bBonus)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iValue, iProb, iResult;

		if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;
		iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

		//cambiar
		switch (iValue) {
			case 0: iProb = 99; break;  // +1 :99   
			case 1: iProb = 99; break;  // +2 :99
			case 2: iProb = 99; break;  // +3 :99
			case 3: iProb = 99; break;  // +4 35
			case 4: iProb = 70; break;  // +5 30
			case 5: iProb = 60; break;  // +6 20
			case 6: iProb = 50; break;  // +7 10
			case 7: iProb = 40; break;  // +8 5
			case 8: iProb = 30; break;  // +9 3
			case 9: iProb = 20; break;  // +10 2
			default: iProb = 1; break;
				//Original
		/*	case 0: iProb = 99; break;  // +1 :99   
			case 1: iProb = 99; break;  // +2 :99
			case 2: iProb = 99; break;  // +3 :99
			case 3: iProb = 70; break;  // +4 35
			case 4: iProb = 60; break;  // +5 30
			case 5: iProb = 50; break;  // +6 20
			case 6: iProb = 40; break;  // +7 10
			case 7: iProb = 30; break;  // +8 5
			case 8: iProb = 20; break;  // +9 3
			case 9: iProb = 10; break;  // +10 2
			default: iProb = 1; break;*/
				//editar facil +10
			/*case 0: iProb = 99; break;  // +1 :99   
			case 1: iProb = 99; break;  // +2 :99
			case 2: iProb = 99; break;  // +3 :99
			case 3: iProb = 99; break;  // +4 35
			case 4: iProb = 99; break;  // +5 30
			case 5: iProb = 99; break;  // +6 20
			case 6: iProb = 99; break;  // +7 10
			case 7: iProb = 99; break;  // +8 5
			case 8: iProb = 99; break;  // +9 3
			case 9: iProb = 99; break;  // +10 2
			default: iProb = 99; break;*/
		}

		if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {
			if (iProb > 20) iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
			else if (iProb > 7) iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
			else iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
		}
		if (bBonus == TRUE) iProb *= 2;

		iProb *= 100;
		iResult = iDice(1, 10000);

		if (iProb >= iResult) {
			_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			return TRUE;
		}
		_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckIsItemUpgradeSuccess");
	}
#endif
	return FALSE;
}

//ArmorBreak
void CMapServer::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iTemp;

		if (m_pClientList[iAttackerH] == NULL) return;

		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[iTargetH] == NULL) return;
				break;

			default:
				return;
		}

		if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return;

		//Armor break fix - Con PFA :P - Para lalito, que lo mira por pc :P
		if ((m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2) ||
			(m_pClientList[iTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5)) return;

		switch (iDice(1, 13)) {
			case 1:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
							}
						}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 2:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 3:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 4:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
						//Omitir Hauberk Reflex
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4982) return;
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4983) return;

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 5:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 6:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}

				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 7:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}

				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 8:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}

				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
						//Omitir Hauberk Reflex
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4982) return;
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4983) return;

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 9:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
						//Omitir Hauberk Reflex
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4982) return;
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4983) return;

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 10:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
						//Omitir Hauberk Reflex
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4982) return;
						if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_sIDnum == 4983) return;

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}

				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 11:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}

				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 12:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;

			case 13:
				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}

				iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
				if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
					if ((m_pClientList[iTargetH]->m_cSide != 0 || m_pClientList[iTargetH]->Assasain == TRUE) &&
						(m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {

						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= 100;
						switch (iDice(1, 3)) {
						case 1: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 2: ReleaseItemHandler(iTargetH, iTemp, TRUE);
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						case 3: return;
						}
					}
					if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
						m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
						SendNotifyMsg(NULL, iTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
						ReleaseItemHandler(iTargetH, iTemp, TRUE);
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ArmorLifeDecrement");
	}
#endif
}

void CMapServer::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

		if (m_pClientList[iObjectID] != NULL)
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestGuildNameHandler");
	}
#endif
}

BOOL CMapServer::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTimeGap;
		short cTxt;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL)
			m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
		else {
			dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
			m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
			//SPEED HACK.//< 250
			if (dwTimeGap < 400) {//400
				wsprintf(G_cTxt, "Speed Attack(%s), %d", m_pClientList[iClientH]->m_cCharName, dwTimeGap);
				PutLogHacksFileList(G_cTxt);
				DeleteClient(iClientH, TRUE, TRUE);
				return FALSE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckClientAttackFrequency");
	}
#endif
	return FALSE;
}

//Nuevo Codigo Anti Hack Magias
BOOL CMapServer::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTimeGap;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		if (m_pClientList[iClientH]->m_dwMagicFreqTime == NULL)
			m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
		else {
			dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
			m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
			//SPEED HACK.//< 250
			if (dwTimeGap < 400) {//400
				wsprintf(G_cTxt, "Speed Magic(%s), %d", m_pClientList[iClientH]->m_cCharName, dwTimeGap);
				PutLogHacksFileList(G_cTxt);
				DeleteClient(iClientH, TRUE, TRUE);
				return FALSE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckClientMagicFrequency");
	}
#endif
	return FALSE;
}

/*

BOOL CMapServer::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTimeGap;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		if (m_pClientList[iClientH]->m_sNoCheckSpeed)
		{
			m_pClientList[iClientH]->m_sNoCheckSpeed = false;
			return true;
		}

		if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL)
			m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
		else {
			if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
				m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
				m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
				return FALSE;
			}

			if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
				m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
				m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
				return FALSE;
			}

		/ *	if (m_pClientList[iClientH]->m_sNoCheckSpeed == TRUE) {
				m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
				m_pClientList[iClientH]->m_sNoCheckSpeed = FALSE;
				return FALSE;
			}* /

			dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
			m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
			//SPEED HACK < 250 
			//OLD CODE
			/ *if (dwTimeGap < 250) { //240
				wsprintf(G_cTxt, "Speed Move(%s), %d", m_pClientList[iClientH]->m_cCharName, dwTimeGap);
				PutLogHacksFileList(G_cTxt);
				DeleteClient(iClientH, TRUE, TRUE);
				return FALSE;
			}* /
			//new code
			if (dwTimeGap < 270) {  // 240
				m_pClientList[iClientH]->m_iFailedAttempts++;

				if (m_pClientList[iClientH]->m_iFailedAttempts >= 3 && m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					wsprintf(G_cTxt, "Speed Move(%s), %d", m_pClientList[iClientH]->m_cCharName, dwTimeGap);
					PutLogHacksFileList(G_cTxt);
					DeleteClient(iClientH, TRUE, TRUE);
					return FALSE;
				}
				/ *wsprintf(G_cTxt, "Intento fallido %d de %s",
					m_pClientList[iClientH]->m_iFailedAttempts,
					m_pClientList[iClientH]->m_cCharName);
				PutLogHacksFileList(G_cTxt);* /
			}
			else {
				// Reiniciar el contador si pasa un movimiento válido.
				m_pClientList[iClientH]->m_iFailedAttempts = 0;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckClientMoveFrequency");
	}
#endif
	return FALSE;
}*//*
void CMapServer::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTimeGap;

		// Verificar si el cliente existe
		if (m_pClientList[iClientH] == NULL) return;

		// Inicialización de tiempo si es la primera vez
		if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
		}
		else {
			// Manejar bloqueos de movimiento
			if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
				m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
				m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
				return;
			}

			// Manejar cambios de modo de ataque
			if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
				m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
				m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
				return;
			}

			// Calcular el tiempo entre movimientos
			dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
			m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;

			// Validación de valores negativos en el cálculo
			if (dwTimeGap < 0) {
				dwTimeGap = 0; // Evitar errores
			}

			// Comprobación de velocidad sospechosa
			if (dwTimeGap < 270) {
				// Incrementar el contador de intentos fallidos
				m_pClientList[iClientH]->m_iFailedAttempts++;

				// Bloquear si supera el límite de intentos fallidos
				if (m_pClientList[iClientH]->m_iFailedAttempts >= 3 && m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					wsprintf(G_cTxt, "Speed Move(%s), %d", m_pClientList[iClientH]->m_cCharName, dwTimeGap);
					PutLogHacksFileList(G_cTxt);
					DeleteClient(iClientH, TRUE, TRUE); // Desconectar al cliente
					return; // Finalizar la función después de la desconexión
				}

				// Registrar intentos fallidos para depuración
				wsprintf(G_cTxt, "Intento fallido %d de %s (TimeGap: %d)",
					m_pClientList[iClientH]->m_iFailedAttempts,
					m_pClientList[iClientH]->m_cCharName,
					dwTimeGap);
				PutLogHacksFileList(G_cTxt);
			}
			else {
				// Reiniciar el contador de intentos fallidos si el movimiento es válido
				m_pClientList[iClientH]->m_iFailedAttempts = 0;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckClientMoveFrequency");
	}
#endif
	return;
}
*/

//chequeo lvl y stats Lalov9
BOOL CMapServer::bCheckClientStatLvl(int iClientH)
{
	return FALSE;
#ifdef DEF_DEBUG
	try {
#endif
				
		short cStr, cVit, cDex, cInt, cMag, cChar;
		int iTotalSetting = 0;
		//m_iAdminUserLevel
		if (m_pClientList[iClientH]->m_sRebirthEnabled == 1) return FALSE;

		if (m_pClientList[iClientH] == NULL) return FALSE;
	//	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 1) return FALSE;
		
		iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
			m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	//	if (iTotalSetting > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70)) {
		if ((iTotalSetting > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70)) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			wsprintf(G_cTxt, "HACK-STATS-MOVE - Character(%s)!", m_pClientList[iClientH]->m_cCharName);
			PutLogHacksFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return FALSE;
		}

	//	if ((m_pClientList[iClientH]->m_iLevel) > 200){
		if (((m_pClientList[iClientH]->m_iLevel) > m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
			wsprintf(G_cTxt, "HACK-LEVEL-MOVE - Character(%s)!", m_pClientList[iClientH]->m_cCharName);
			PutLogHacksFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return FALSE;
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckClientStatLvl");
	}
#endif
	return FALSE;
}

void CMapServer::SetForceRecallTime(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iTL_ = 0;
		SYSTEMTIME SysTime;

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {

			if (m_sForceRecallTime > 0) {
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sForceRecallTime;
			}
			else {
				GetLocalTime(&SysTime);
				switch (SysTime.wDayOfWeek) {
					case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 3; break;  //������  1 2002-09-10 #1
					case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 3; break;  //ȭ����  1 
					case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 3; break;  //������  1 
					case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 3; break;  //������  1�� 
					case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 15; break; //�ݿ��� 15��
					case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 45; break; //������ 45�� 
					case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 60; break; //�Ͽ��� 60��
				}
			}
		}
		else {
			if (m_sForceRecallTime > 0) {
				iTL_ = 20 * m_sForceRecallTime;
			}
			else {
				GetLocalTime(&SysTime);
				switch (SysTime.wDayOfWeek) {
					case 1:	iTL_ = 20 * 1; break;  //������  1�� 2002-09-10 #1
					case 2:	iTL_ = 20 * 1; break;  //ȭ����  1��
					case 3:	iTL_ = 20 * 1; break;  //������  1��
					case 4:	iTL_ = 20 * 1; break;  //������  1��
					case 5:	iTL_ = 20 * 15; break; //�ݿ��� 15��
					case 6:	iTL_ = 20 * 45; break; //������ 45�� 
					case 0:	iTL_ = 20 * 60; break; //�Ͽ��� 60��
				}
			}
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_)
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetForceRecallTime");
	}
#endif
}

void CMapServer::RequestHuntmode(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iPKCount > 0) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall", 8) != 0) return;
		if ((m_pClientList[iClientH]->m_iLevel > DEF_LIMITHUNTERLEVEL) && (m_pClientList[iClientH]->m_bIsHunter == FALSE)) return;

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0)
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, "arehunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, "elvhunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, "aresden");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, "elvine");

		if (m_pClientList[iClientH]->m_bIsHunter == TRUE)
			m_pClientList[iClientH]->m_bIsHunter = FALSE;
		else m_pClientList[iClientH]->m_bIsHunter = TRUE;

		m_pClientList[iClientH]->m_bIsNeutral = FALSE;
		bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestHuntmode");
	}
#endif
}

void CMapServer::SetNoHunterMode(int iClientH, BOOL bSendMsg)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, "aresden");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
			strcpy_secure(m_pClientList[iClientH]->m_cLocation, "elvine");

		if (m_pClientList[iClientH]->m_bIsHunter == TRUE)
			m_pClientList[iClientH]->m_bIsHunter = FALSE;

		m_pClientList[iClientH]->m_bIsNeutral = FALSE;

		bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);

		if (bSendMsg == TRUE) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetNoHunterMode");
	}
#endif
}

int CMapServer::iSetSide(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return -1;

		char cLocationName[12], cMapLocationName[12];

		ZeroMemory(cLocationName, sizeof(cLocationName));
		ZeroMemory(cMapLocationName, sizeof(cMapLocationName));

		memcpy_secure(cLocationName, m_pClientList[iClientH]->m_cLocation, 10);
		memcpy_secure(cMapLocationName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
		m_pClientList[iClientH]->m_cSide = DEF_NETURAL; // v2.172
		m_pClientList[iClientH]->m_iIsOnTown = DEF_PK;
		m_pClientList[iClientH]->m_bIsHunter = FALSE;
		m_pClientList[iClientH]->m_bIsNeutral = FALSE;

		if (memcmp(cLocationName, cMapLocationName, 3) == 0)
			m_pClientList[iClientH]->m_iIsOnTown = DEF_NONPK;

		if (memcmp(cLocationName, "are", 3) == 0)
			m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;
		else if (memcmp(cLocationName, "elv", 3) == 0)
			m_pClientList[iClientH]->m_cSide = DEF_ELVINE;
		else {
			if ((strcmp(cMapLocationName, "elvine") == 0) || (strcmp(cMapLocationName, "aresden") == 0))
				m_pClientList[iClientH]->m_iIsOnTown = DEF_NONPK;

			if (m_pClientList[iClientH]->Assasain) m_pClientList[iClientH]->m_bIsNeutral = FALSE;
			else m_pClientList[iClientH]->m_bIsNeutral = TRUE;
		}

		if ((memcmp(cLocationName, "arehunter", 9) == 0) || (memcmp(cLocationName, "elvhunter", 9) == 0)) {
			m_pClientList[iClientH]->m_bIsHunter = TRUE;
		}

		if ((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "Whouse", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "VipMap1", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "evento13", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "evento14", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)) {
			m_pClientList[iClientH]->m_bIsOnShop = TRUE;
		}
		else m_pClientList[iClientH]->m_bIsOnShop = FALSE;

		if ((memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0)
			|| (memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0)
			|| (memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
			|| (memcmp(m_pClientList[iClientH]->m_cMapName, "ArGEvent", 8) == 0)) {
			m_pClientList[iClientH]->m_bIsOnWarehouse = TRUE;
		}
		else m_pClientList[iClientH]->m_bIsOnWarehouse = TRUE;

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0
			|| (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0)) {
			m_pClientList[iClientH]->m_bIsOnTower = TRUE;
		}
		else m_pClientList[iClientH]->m_bIsOnTower = TRUE;

		if ((memcmp(m_pClientList[iClientH]->m_cMapName, "2ndmiddle", 9) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "abaddon", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "aresdend", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "areuni", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "druncncity", 10) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "elvined", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "elvuni", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "huntzone", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "icebound", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "infernia", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "maze", 4) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "middle", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "procella", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "toh", 3) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "DesertMap", 9) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "Extreme", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "ArGOffice", 9) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "ArGMagic", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "ArGEvent", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "evento13", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "evento14", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, DEF_PRICE_EVENT_CITYVSCITY, 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "MBarracks", 9) == 0)) {
			m_pClientList[iClientH]->m_bIsOnCombatantZone = TRUE;
		}
		else m_pClientList[iClientH]->m_bIsOnCombatantZone = FALSE;

		return m_pClientList[iClientH]->m_cSide;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iSetSide");

	}
#endif
	return -1;
}

BOOL CMapServer::__bSetAgricultureItem(int iMapIndex, int dX, int dY, int iType, int iSsn, int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iNamingValue, tX, tY;
		char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
		short sOwnerH;
		BOOL	iRet;

		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= DEF_MAXAGRICULTURE) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
			return FALSE;
		}

		if (iSsn > m_pClientList[iClientH]->m_cSkillMastery[2]) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);  //??
			return FALSE;
		}
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
				return FALSE;
			}
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == FALSE) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
				return FALSE;
			}
			ZeroMemory(cNpcName, sizeof(cNpcName));
			strcpy_secure(cNpcName, "Crops");

			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

			tX = (int)dX;
			tY = (int)dY;

			iRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0,
				DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, FALSE, 0, FALSE, TRUE);

			if (iRet == FALSE) m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			else {
				if (m_pNpcList[iRet] == NULL) return FALSE;
				m_pNpcList[iRet]->m_iNpcCrops = iType;
				switch (iType) {
					case 1: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //WaterMelon
					case 2: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Pumpkin
					case 3: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Garlic
					case 4: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Barley
					case 5: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Carrot
					case 6: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Radish
					case 7: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Corn
					case 8: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //CBellflower
					case 9: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Melone
					case 10: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Tommato
					case 11: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Grapes
					case 12: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //BlueGrapes
					case 13: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Mushroom
					case 14: m_pNpcList[iRet]->m_iCropsSkillLV = iSsn; break; //Ginseng
					default: m_pNpcList[iRet]->m_iCropsSkillLV = 100; break;
				}

				m_pNpcList[iRet]->m_sAppr2 = iType << 8 | 1;
				SendEventToNearClient_TypeA(iRet, DEF_OWNERTYPE_NPC, CLIENT_COMMON_COMMAND_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
				wsprintf(G_cTxt, "plant(%s) Agriculture begin(%d,%d) sum(%d)!", cNpcName, tX, tY,
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				PutLogList(G_cTxt);
				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: __bSetAgricultureItem");
	}
#endif
	return FALSE;
}

BOOL CMapServer::bCropsItemDrop(int iClientH, short iTargetH, BOOL bMobDropPos)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		int	  iItemID = 0;
		int	  iSeedID = 0;

		iSeedID = m_pNpcList[iTargetH]->m_iNpcCrops;

		switch (iSeedID) {
			case 1: iItemID = 820; GetExp(iClientH, iDice(3, 10)); break; //WaterMelon
			case 2: iItemID = 821; GetExp(iClientH, iDice(3, 10)); break; //Pumpkin
			case 3: iItemID = 822; GetExp(iClientH, iDice(4, 10)); break; //Garlic
			case 4: iItemID = 823; GetExp(iClientH, iDice(4, 10)); break; //Barley
			case 5: iItemID = 824; GetExp(iClientH, iDice(5, 10)); break; //Carrot
			case 6: iItemID = 825; GetExp(iClientH, iDice(5, 10)); break; //Radish
			case 7: iItemID = 826; GetExp(iClientH, iDice(6, 10)); break; //Corn
			case 8: iItemID = 827; GetExp(iClientH, iDice(6, 10)); break; //CBellflower
			case 9: iItemID = 828; GetExp(iClientH, iDice(7, 10)); break; //Melone
			case 10: iItemID = 829; GetExp(iClientH, iDice(7, 10)); break; //Tommato
			case 11: iItemID = 830; GetExp(iClientH, iDice(8, 10)); break; //Grapes
			case 12: iItemID = 831; GetExp(iClientH, iDice(8, 10)); break; //BlueGrapes
			case 13: iItemID = 832; GetExp(iClientH, iDice(9, 10)); break; //Mushroom
			case 14: iItemID = 721; GetExp(iClientH, iDice(10, 10)); break; //Ginseng
			default: iItemID = 0; break;
		}

		if (iItemID == 0) return FALSE;

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			delete pItem;
			return FALSE;
		}
		else {
			if (bMobDropPos == FALSE) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
				pItem->m_dwTimeDrop = timeGetTime();

				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
			}
			else {
				m_pMapList[m_pNpcList[iTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[iTargetH]->m_sX, m_pNpcList[iTargetH]->m_sY, pItem);
				pItem->m_dwTimeDrop = timeGetTime();

				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pNpcList[iTargetH]->m_cMapIndex,
					m_pNpcList[iTargetH]->m_sX, m_pNpcList[iTargetH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCropsItemDrop");
	}
#endif
	return TRUE;
}

int SKILLCROPSTABLE[9][9] =
// 20  30  40  50  60  70  80  90 100
{
   42, 34, 27, 21, 16, 12,  9,  7,  6,  //20
   43, 40, 33, 27, 22, 18, 15, 13, 10,	//30
   44, 41, 38, 32, 27, 23, 20, 18, 13,  //40
   45, 42, 39, 36, 31, 27, 24, 22, 15,  //50
   46, 43, 40, 37, 34, 30, 27, 25, 16,  //60
   47, 44, 41, 38, 35, 32, 29, 27, 20,  //70
   48, 45, 42, 39, 36, 33, 30, 28, 23,  //80
   49, 46, 43, 40, 37, 34, 31, 28, 25,  //90
   50, 47, 44, 41, 38, 35, 32, 29, 26  //100
};

int CROPSDROPTABLE[9][9] =
// 20  30  40  50  60  70  80  90 100
{
   40,  0,  0,  0,  0,  0,  0,  0,  0,  //20
   41, 38,  0,  0,  0,  0,  0,  0,  0,	//30
   43, 40, 36,  0,  0,  0,  0,  0,  0,  //40
   46, 42, 38, 35,  0,  0,  0,  0,  0,  //50
   50, 45, 41, 37, 33,  0,  0,  0,  0,  //60
   55, 49, 44, 40, 35, 31,  0,  0,  0,  //70
   61, 54, 48, 43, 38, 33, 30,  0,  0,  //80
   68, 60, 53, 47, 42, 37, 32, 28,  0,  //90
   76, 67, 59, 52, 46, 41, 35, 29, 24  //100
};
/////////////////////////////////////////////////////////////////////////////////
int CMapServer::bProbabilityTable(int x, int y, int iTable)
{
#ifdef DEF_DEBUG
	try {
#endif

		int iProb;
		int iX, iY;

		iX = (x - 20) / 10;
		iY = (y - 20) / 10;

		if (iX < 0 || iX > 8) return 0;
		if (iY < 0 || iY > 8) return 0;

		iProb = iDice(1, 100);

		if (iTable == 1) {
			if (SKILLCROPSTABLE[iX][iY] >= iProb) return SKILLCROPSTABLE[iX][iY];
			else return 0;
		}
		else if (iTable == 2) {
			if (CROPSDROPTABLE[iX][iY] >= iProb) return CROPSDROPTABLE[iX][iY];
			else return 0;
		}
		else return 0;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bProbabilityTable");
	}
#endif
	return 0;
}

int CMapServer::CheckHeroItemEquipHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sLeggings, sHauberk, sHelm, sArmor, sCape, Bonus;

		if (m_pClientList[iClientH] == NULL) return 0;

		sLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
		sHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
		sArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
		sHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
		sCape = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BACK];
		Bonus = 0;

		if ((sLeggings < 0) || (sHauberk < 0) || (sArmor < 0) || (sHelm < 0)) return 0;

		if (m_pClientList[iClientH]->m_pItemList[sLeggings] == NULL) return 0;
		if (m_pClientList[iClientH]->m_pItemList[sHauberk] == NULL) return 0;
		if (m_pClientList[iClientH]->m_pItemList[sArmor] == NULL) return 0;
		if (m_pClientList[iClientH]->m_pItemList[sHelm] == NULL) return 0;
		//HeroComun
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 403) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 411) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 419) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 423)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 407) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 415) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 419) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 423)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 404) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 412) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 420) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 424)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 408) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 416) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 420) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 424)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 405) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 413) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 421) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 425)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 409) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 417) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 421) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 425)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 406) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 414) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 422) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 426)) return 1;

		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 410) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 418) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 422) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 426)) return 1;
		//Lalo PowerHeroBonus
		//Power Hero ares War M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4932) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4940) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4948) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4952)) Bonus = 2;
		//Power Hero ares Mage M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4936) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4944) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4948) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4952)) Bonus = 2;
		//Power Hero ares War W	
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4933) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4941) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4949) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4953)) Bonus = 2;
		//Power Hero ares Mage W	
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4937) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4945) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4949) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4953)) Bonus = 2;
		//Power Hero Elvin War M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4934) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4942) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4950) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4954)) Bonus = 2;
		//Power Hero Elvin Mage M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4938) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4946) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4950) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4954)) Bonus = 2;
		//Power Hero Elvin War W
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4935) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4943) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4951) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4955)) Bonus = 2;
		//Power Hero Elvin Mage W
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4939) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4947) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4951) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4955)) Bonus = 2;

		//Lalo Master Hero Bonus
		//aresden
		//Master Hero ares War M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3201) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3205) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3209) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3211)) Bonus = 11;
		//Master Hero ares Mage M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3203) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3207) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3209) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3211)) Bonus = 11;
		//Master Hero ares War W	
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3202) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3206) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3210) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3212)) Bonus = 11;
		//Master Hero ares Mage W	
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3204) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3208) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3210) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3212)) Bonus = 11;
		//Elvine
		//Master Hero Elvin War M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3215) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3219) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3223) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3225)) Bonus = 12;
		//Master Hero Elvin Mage M
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3217) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3221) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3223) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3225)) Bonus = 12;
		//Master Hero Elvin War W
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3216) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3220) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3224) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3226)) Bonus = 12;
		//Master Hero Elvin Mage W
		if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 3218) &&
			(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 3222) &&
			(m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 3224) &&
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 3226)) Bonus = 12;
		
		//Assasain Hero Bonus
		//Assasain M
		if ((m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4109) && // Hauberk M
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4111)) { // Leggs M

			if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4101) && // Helm M
				(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4105)) // Armor M
				Bonus = 5;

			else if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4103) && // Cap M
				(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4107)) // Robe M
				Bonus = 6;
		}

		//Assasain W
		if ((m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum == 4110) && // Hauberk W
			(m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum == 4112)) { // Leggs W

			if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4102) && // Helm M
				(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4106)) // Armor M
				Bonus = 5;

			else if ((m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum == 4104) && // Cap M
				(m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum == 4108)) // Robe M
				Bonus = 6;
		}

		switch (Bonus) {
		case 2:
			if (sCape > 0) {
				if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 4018) // PowerAresHeroCape
					Bonus += 1;
				else if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 4019) // PowerElvHeroCape
					Bonus += 1;
				else if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 4020) // PowerAresHeroCape+1
					Bonus += 2;
				else if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 4021) // PowerElvHeroCape+1
					Bonus += 2;
			}
			break;
			case 5:
			case 6:
				if (sCape > 0) {
					if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 4100) // Cape
						Bonus += 2;
					else if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 4113) // Cape+1
						Bonus += 4;
				}
				break;
			case 11:
				if (sCape > 0) {
					if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 3200) // MasterAresHeroCape
						Bonus += 2;
					else if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 3213) // MasterAresHeroCape+1
						Bonus += 3;
				}
				break;
			case 12:
				if (sCape > 0) {
					if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 3214) // MasterElvHeroCape
						Bonus += 1;
					else if (m_pClientList[iClientH]->m_pItemList[sCape]->m_sIDnum == 3227) // MasterElvHeroCape+1
						Bonus += 2;
				}
				break;
			default:
				break;
		}
		return Bonus;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckHeroItemEquipHandler");
	}
#endif
	return 0;
}


void CMapServer::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cStateChange1, cStateChange2, cStateChange3;
		char cStr, cVit, cDex, cInt, cMag, cChar;
		int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
		int iRestHP;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

		cStr = cVit = cDex = cInt = cMag = cChar = 0;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		cStateChange1 = *cp;
		cp++;

		cStateChange2 = *cp;
		cp++;

		cStateChange3 = *cp;
		cp++;

		iOldStr = m_pClientList[iClientH]->m_iStr;
		iOldVit = m_pClientList[iClientH]->m_iVit;
		iOldDex = m_pClientList[iClientH]->m_iDex;
		iOldInt = m_pClientList[iClientH]->m_iInt;
		iOldMag = m_pClientList[iClientH]->m_iMag;
		iOldChar = m_pClientList[iClientH]->m_iCharisma;

		if (!bChangeState(cStateChange1, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
		if (!bChangeState(cStateChange2, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
		if (!bChangeState(cStateChange3, &cStr, &cVit, &cDex, &cInt, &cMag, &cChar)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if (m_pClientList[iClientH]->m_iGuildRank == 0) {
			if (m_pClientList[iClientH]->m_iCharisma - cChar < 10) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
				return;
			}
		}

		/*if (iOldStr + iOldVit + iOldDex + iOldInt + iOldMag + iOldChar != ((DEF_PLAYERMAXLEVEL - 1) * 3 + 70)) {
			return;
		}*/

		int maxstats = ((m_pClientList[iClientH]->m_iLevel - 1) * 3) + 70;
		maxstats = maxstats + m_pClientList[iClientH]->getRebirthStats();

		if (iOldStr + iOldVit + iOldDex + iOldInt + iOldMag + iOldChar != maxstats) {
			return;
		}

		if ((cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0) ||
			(cStr + cVit + cDex + cInt + cMag + cChar != 3)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT)
			|| (m_pClientList[iClientH]->m_iStr - cStr < 10)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT)
			|| (m_pClientList[iClientH]->m_iDex - cDex < 10)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT)
			|| (m_pClientList[iClientH]->m_iInt - cInt < 10)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT)
			|| (m_pClientList[iClientH]->m_iVit - cVit < 10)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT)
			|| (m_pClientList[iClientH]->m_iMag - cMag < 10)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
			|| (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}

		m_pClientList[iClientH]->m_iLU_Pool += 3;

		if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;


		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

		m_pClientList[iClientH]->m_iStr -= cStr;
		m_pClientList[iClientH]->m_iVit -= cVit;
		m_pClientList[iClientH]->m_iDex -= cDex;
		m_pClientList[iClientH]->m_iInt -= cInt;
		m_pClientList[iClientH]->m_iMag -= cMag;
		m_pClientList[iClientH]->m_iCharisma -= cChar;
		AutoSkill(iClientH);

		if (cInt > 0) bCheckMagicInt(iClientH);

		if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) {
			iRestHP = m_pClientList[iClientH]->m_iHP - iGetMaxHP(iClientH);
			m_pClientList[iClientH]->m_iHP -= iRestHP;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StateChangeHandler");
	}
#endif
}

BOOL CMapServer::bCheckMagicInt(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		for (int i = 0; i < DEF_MAXMAGICTYPE; i++) {
			if (m_pMagicConfigList[i] != NULL) {
				if (m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->m_iInt)
					m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
			}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckMagicInt");
	}
#endif
	return TRUE;
}

BOOL CMapServer::bChangeState(char cStateChange, char *cStr, char *cVit, char *cDex, char *cInt, char *cMag, char *cChar)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (cStateChange == DEF_STR) *cStr += 1;
		else if (cStateChange == DEF_VIT) *cVit += 1;
		else if (cStateChange == DEF_DEX) *cDex += 1;
		else if (cStateChange == DEF_INT) *cInt += 1;
		else if (cStateChange == DEF_MAG) *cMag += 1;
		else if (cStateChange == DEF_CHR) *cChar += 1;
		else return 0;

		return cStateChange;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bChangeState");
		return 0;
	}
#endif
}

int CMapServer::iUpgradeHeroCapeRequirements(int iClientH, int iItemIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iViejoItemID, iNuevoItemID, iRequiredEnemyKills, iRequiredContribution, iStoneNumber, i;

		iViejoItemID = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;
		switch (iViejoItemID) {
			case 400:
				iNuevoItemID = 427;
				iRequiredEnemyKills = 30;
				iRequiredContribution = 50;
				iStoneNumber = 657;
				break;
			case 401:
				iNuevoItemID = 428;
				iRequiredEnemyKills = 30;
				iRequiredContribution = 50;
				iStoneNumber = 657;
				break;
			case 4018:
				iNuevoItemID = 4020;
				iRequiredEnemyKills = 500;
				iRequiredContribution = 5000;
				iStoneNumber = 657;
				break;
			case 4019:
				iNuevoItemID = 4021;
				iRequiredEnemyKills = 500;
				iRequiredContribution = 5000;
				iStoneNumber = 657;
				break;
			case 4100:
				iNuevoItemID = 4113;
				iRequiredEnemyKills = 1000;
				iRequiredContribution = 500;
				iStoneNumber = 657;
				break;
			case 3200:
				iNuevoItemID = 3213;
				iRequiredEnemyKills = 5000;
				iRequiredContribution = 20000;
				iStoneNumber = 657;
				break;
			case 3214:
				iNuevoItemID = 3227;
				iRequiredEnemyKills = 5000;
				iRequiredContribution = 20000;
				iStoneNumber = 657;
				break;
			default:
				return 2; // No es cape
				break;
		}

		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)m_pClientList[iClientH]->m_pItemList[iItemIndex], FALSE);

		if (iNuevoItemID != 4113) {
			if ((m_pClientList[iClientH]->m_iEnemyKillCount < iRequiredEnemyKills) || (m_pClientList[iClientH]->m_iContribution < iRequiredContribution)) return -1;
		}
		else {
			if ((m_pClientList[iClientH]->m_iPKCount < iRequiredEnemyKills) || (m_pClientList[iClientH]->m_iContribution < iRequiredContribution)) return -1;
		}

		for (i = 0; i < DEF_MAXITEMS; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == iStoneNumber)) break;

		if (i == 50) return -1;
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], iNuevoItemID) == FALSE) return -1;
		else {
			if (iNuevoItemID != 4113) m_pClientList[iClientH]->m_iEnemyKillCount -= iRequiredEnemyKills;
			else m_pClientList[iClientH]->m_iPKCount -= iRequiredEnemyKills;

			m_pClientList[iClientH]->m_iContribution -= iRequiredContribution;
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
				ItemDepleteHandler(iClientH, i, FALSE, TRUE);
			return 1;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iUpgradeHeroCapeRequirements");
	}
#endif
	return -1;
}

void CMapServer::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
				else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetIllusionFlag");
	}
#endif
}

void CMapServer::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				if (bStatus == TRUE) m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
				else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;

				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetIllusionFlag");
	}
#endif
}

void CMapServer::RequestResurrectPlayer(int iClientH, BOOL bResurrect)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sX, sY;
		char buff[100];

		if (m_pClientList[iClientH] == NULL) return;

		sX = m_pClientList[iClientH]->m_sX;
		sY = m_pClientList[iClientH]->m_sY;

		if (bResurrect == FALSE) {
			m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
			return;
		}

		if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) {
			wsprintf(buff, "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
			DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
			return;
		}

		wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
		CharacterLogList(buff);

		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH) / 2;
		m_pClientList[iClientH]->m_iMP = (((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) * 2) + (m_pClientList[iClientH]->m_iLevel / 2)) + (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) / 2;
		m_pClientList[iClientH]->m_iSP = ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) * 2) + (m_pClientList[iClientH]->m_iLevel / 2);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
		RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		if (m_pClientList[iClientH] != NULL) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL, 9) == 0) && (AllVsAll == TRUE)) {
				if (!m_pClientList[iClientH]->Achivements[19].Complete)
					CheckCompleteAchivement(iClientH, 19, TRUE);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestResurrectPlayer");
	}
#endif
}

void CMapServer::ReqCreateSlateHandler(int iClientH, char* pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iRet;
		short *sp;
		char cItemID[4], ctr[4];
		char *cp, cSlateColour = 0, cData[120];
		BOOL bIsSlatePresent = FALSE;
		CItem * pItem;
		int iSlateType = 0, iEraseReq = 0;
		DWORD *dwp;
		WORD *wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

		for (i = 0; i < 4; i++) {
			cItemID[i] = 0;
			ctr[i] = 0;
		}

		cp = (char *)pData;
		cp += 11;

		// 14% chance of creating slates
		if (iDice(1, 100) <= 40) bIsSlatePresent = TRUE;

		// make sure slates really exist
		for (i = 0; i < 4; i++) {
			cItemID[i] = *cp;
			cp++;

			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] == NULL || cItemID[i] > DEF_MAXITEMS) {
				bIsSlatePresent = FALSE;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			if (cItemID[i] < DEF_MAXITEMS) {
				//No duping
				if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
					ctr[0] = 1;
				else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
					ctr[1] = 1;
				else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
					ctr[2] = 1;
				else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
					ctr[3] = 1;
			}
		}

		// Are all 4 slates present ??
		if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
			bIsSlatePresent = FALSE;
			return;
		}

		if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = TRUE;

		// if we failed, kill everything
		if (!bIsSlatePresent) {
			for (i = 0; i < 4; i++) {
				if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
					ItemDepleteHandler(iClientH, cItemID[i], FALSE, FALSE);
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);
			return;
		}

		// make the slates
		for (i = 0; i < 4; i++) {
			if (cItemID[i] < DEF_MAXITEMS) {
				if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
					ItemDepleteHandler(iClientH, cItemID[i], FALSE, FALSE);
				}
			}
		}
		pItem = new class CItem;

		i = iDice(1, 1000);

		if (i < 10) { // Hp slate
			iSlateType = 1;
			cSlateColour = 32;
		}
		else if (i < 80) { // Mana slate
			iSlateType = 3;
			cSlateColour = 37;
		}
		else if (i < 300) { // Bezerk slate
			iSlateType = 2;
			cSlateColour = 3;
		}
		else if (i < 1001) { // Exp slate
			iSlateType = 4;
			cSlateColour = 32;
		}

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);
		ZeroMemory(cData, sizeof(cData));

		// Create slates
		if (_bInitItemAttr(pItem, 867) == FALSE) {
			delete pItem;
			return;
		}
		else {
			pItem->m_sTouchEffectType = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1, 100000);

			// Anti Dup System
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			pItem->m_sTouchEffectValue2 = iDice(1, 100000);
			wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue2 = atoi(cTemp);

			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

			pItem->m_sItemSpecEffectValue2 = iSlateType;
			pItem->m_cItemColor = cSlateColour;
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_ITEMOBTAINED;

				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;

				memcpy_secure(cp, pItem->m_cName, 20);
				cp += 20;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;

				*cp = pItem->m_cItemType;
				cp++;

				*cp = pItem->m_cEquipPos;
				cp++;

				*cp = (char)0; // �??�|?????e��??�??
				cp++;

				sp = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;

				*cp = pItem->m_cGenderLimit;
				cp++;

				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;

				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;

				sp = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				//*cp = (char)pItem->m_sItemSpecEffectValue2;
				//cp++;
				//cambio lalomanu
				sp = (short *)cp;
				*sp = pItem->m_sItemSpecEffectValue2;
				cp += 2;

				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;

				*cp = (char)pItem->m_sItemSpecEffectValue3;
				cp++;

				if (iEraseReq == 1) delete pItem;

				//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				//cambio lalomanu
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
				}
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
				pItem->m_dwTimeDrop = timeGetTime();
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		//Crash Hacker Caught
		wsprintf(G_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutLogHacksFileList(G_cTxt);

		ErrorList("Crash Evitado en: ReqCreateSlateHandler");
		return;
	}
#endif
}

void CMapServer::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (sType == CLIENT_NOTIFY_SLATECLEAR) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
			m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
			m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
			return;
		}

		if (bFlag == TRUE) {
			if (sType == 1) m_pClientList[iClientH]->m_iStatus |= 0x400000; // Invincible slate
			else if (sType == 3) m_pClientList[iClientH]->m_iStatus |= 0x800000; // Mana slate
			else if (sType == 4) m_pClientList[iClientH]->m_iStatus |= 0x10000; // Exp slate
		}
		else {
			if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) {
				m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
			}
			else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
				m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
			}
			else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) {
				m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
			}
		}
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetSlateFlag");
	}
#endif
}

void CMapServer::Desbug(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token;
		CStrTok * pStrTok;
		char cBuff[256], cName[11], cTargetName[11], cFileNamex[255], cFileName[255], cDir[63];
		ZeroMemory(cTargetName, sizeof(cTargetName));

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, token);
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, "null");
		}

		if (token == NULL) { token = "null"; }
		if (cName != NULL) {
			token = cName;

			if (strlen(token) > 10)
				memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			ZeroMemory(cFileName, sizeof(cFileName));
			ZeroMemory(cDir, sizeof(cDir));
			wsprintf(cDir, "..\\..\\Character\\AscII%d\\%s.bak", *cTargetName, cTargetName);
			strcat(cFileName, cDir);

			ZeroMemory(cFileNamex, sizeof(cFileNamex));
			ZeroMemory(cDir, sizeof(cDir));
			wsprintf(cDir, "..\\..\\Character\\AscII%d\\%s.txt", *cTargetName, cTargetName);
			strcat(cFileNamex, cDir);

			DeleteFile(cFileNamex);
			CopyFile(cFileName, cFileNamex, FALSE);

			delete pStrTok;
			return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Desbug");
	}
#endif
}

void CMapServer::AdminOrder_banjail(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cName[11], cTargetName[11];
		CStrTok * pStrTok;
		register int tiempo = 0;
		register int i;
		BOOL   bFlag;

		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, token);
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, "null");
		}

		token = pStrTok->pGet();
		if (token != NULL) tiempo = atoi(token);

		if (token == NULL) { token = "null"; }
		if (cName != NULL) {
			token = cName;

			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					bFlag = TRUE;
					//Defines I as Max clients
					if (bFlag == TRUE) tiempo = (tiempo * 60);

					if (m_pClientList[i]->m_cSide == 1) {
						ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
						strcpy_secure(m_pClientList[i]->m_cLockedMapName, "arejail");
						m_pClientList[i]->m_iLockedMapTime = tiempo;
						RequestTeleportHandler(i, "2   ", "arejail", -1, -1);
					}
					else {
						ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
						strcpy_secure(m_pClientList[i]->m_cLockedMapName, "elvjail");
						m_pClientList[i]->m_iLockedMapTime = tiempo;
						RequestTeleportHandler(i, "2   ", "elvjail", -1, -1);
					}

					DeleteClient(i, TRUE, TRUE);
					delete pStrTok;
					return;
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_banjail");
	}
#endif
}

void CMapServer::AdminOrder_ban(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cName[11], cTargetName[11];
		CStrTok * pStrTok;
		register int dia = 1, mes = 1, year = 2050;
		register int i;
		BOOL   bFlag;

		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));

		dia = mes = 00;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, token);
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, "null");
		}

		token = pStrTok->pGet();
		if (token != NULL) year = atoi(token);

		token = pStrTok->pGet();
		if (token != NULL) mes = atoi(token);

		token = pStrTok->pGet();
		if (token != NULL) dia = atoi(token);

		if (token == NULL) { token = "null"; }
		if (cName != NULL) {
			token = cName;

			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					bFlag = TRUE;
					//Defines I as Max clients
					if (bFlag == TRUE) {
						m_pClientList[i]->m_iPenaltyBlockYear = year;
						m_pClientList[i]->m_iPenaltyBlockMonth = mes;
						m_pClientList[i]->m_iPenaltyBlockDay = dia;
						//Antipull
						m_pClientList[i]->NoDelete = FALSE;

						m_pClientList[i]->m_bForceDisconnect = true;
						DeleteClient(i, TRUE, TRUE);
						delete pStrTok;
						return;
					}
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_ban");
	}
#endif
}

void CMapServer::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iMaxHP, iMaxMP, iMaxSP;
		if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
		if (m_pClientList[sOwnerH] == NULL) return;

		switch (iStatus) {
			case 1: // STR Angel
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00001000;
				break;
			case 2: // DEX Angel
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00002000;
				break;
			case 3: // INT Angel
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00004000;
				bAddMagicAngelInt(sOwnerH);
				SendNotifyMsg(NULL, sOwnerH, CLIENT_NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
				break;
			case 4: // MAG Angel
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00008000;
				break;
			default:
			case 0: // Remove all Angels
				m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF0FFF;
				iMaxHP = iGetMaxHP(sOwnerH);
				iMaxMP = (2 * m_pClientList[sOwnerH]->m_iMag) + (2 * m_pClientList[sOwnerH]->m_iLevel) + (m_pClientList[sOwnerH]->m_iInt / 2);
				iMaxSP = (2 * m_pClientList[sOwnerH]->m_iStr) + (2 * m_pClientList[sOwnerH]->m_iLevel);

				if (m_pClientList[sOwnerH]->m_iHP > iMaxHP) m_pClientList[sOwnerH]->m_iHP = iMaxHP;
				if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) m_pClientList[sOwnerH]->m_iMP = iMaxMP;
				if (m_pClientList[sOwnerH]->m_iSP > iMaxSP) m_pClientList[sOwnerH]->m_iSP = iMaxSP;
				break;
		}

		iTemp -= 5;
		if (iTemp > 9) {
			int iAngelicStars = (iTemp / 3)*(iTemp / 5);
			m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | (iAngelicStars << 8);
		}
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetAngelFlag");
	}
#endif
}

void CMapServer::GetAngelHandler(int iClientH, char * pData, DWORD dwMsgSize)
{

#ifdef DEF_DEBUG
	try {
#endif
		char  *cp, cData[256], cTmpName[21];
		int   iAngel;
		class CItem * pItem;
		int   iRet, iEraseReq, iRequiredMagesty;
		char  cItemName[21];
		short * sp;
		WORD  * wp;
		int   * ip;
		DWORD * dwp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (_iGetItemSpaceLeft(iClientH) == 0) {
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, cp);
		cp += 20;
		ip = (int *)cp;
		iAngel = (int)*ip;
		cp += 2;
		switch (iAngel) {
			case 1:
				wsprintf(cItemName, "AngelicPandent(STR)");
				iRequiredMagesty = 5;
				break;
			case 2:
				wsprintf(cItemName, "AngelicPandent(DEX)");
				iRequiredMagesty = 5;
				break;
			case 3:
				wsprintf(cItemName, "AngelicPandent(INT)");
				iRequiredMagesty = 5;
				break;
			case 4:
				wsprintf(cItemName, "AngelicPandent(MAG)");
				iRequiredMagesty = 5;
				break;
			default:
				PutLogList("Gail asked to create a wrong item!");
				break;
		}

		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;
		if ((_bInitItemAttr(pItem, cItemName) == TRUE)) {
			pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
			pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
			pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
			pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_ITEMOBTAINED;
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp = 1;
				cp++;
				memcpy_secure(cp, pItem->m_cName, 20);
				cp += 20;
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				*cp = pItem->m_cItemType;
				cp++;
				*cp = pItem->m_cEquipPos;
				cp++;
				*cp = (char)0;
				cp++;
				sp = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				*cp = pItem->m_cGenderLimit;
				cp++;
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				sp = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				sp = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;
				*cp = pItem->m_cItemColor;
				cp++;
				//*cp = (char)pItem->m_sItemSpecEffectValue2;
				//cp++;
				//cambio lalomanu
				sp = (short *)cp;
				*sp = pItem->m_sItemSpecEffectValue2;
				cp += 2;

				if (iEraseReq == 1) delete pItem;
				//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
				//cambio lalomanu
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						break;
				}
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= iRequiredMagesty;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
				pItem->m_dwTimeDrop = timeGetTime();
				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = CLIENT_NOTIFY;
				wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						break;
				}
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetAngelHandler");
	}
#endif
}

void CMapServer::ReqCreateCraftingHandler(int iClientH, char *pData)
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD * dwp;
		WORD  * wp;
		char  * cp, cI[6], cCraftingName[21], cData[120];
		int    iRet, i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
		short * sp, sTemp;
		short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
		BOOL   bDup, bFlag, bNeedLog;
		class  CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;
		m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

		for (i = 0; i < 6; i++) {
			cI[i] = -1;
			sItemIndex[i] = -1;
			sItemNumber[i] = 0;
			sItemPurity[i] = -1;
		}
		cp = (char *)(pData + 11);
		cp += 20;
		cI[0] = *cp;
		cp++;
		cI[1] = *cp;
		cp++;
		cI[2] = *cp;
		cp++;
		cI[3] = *cp;
		cp++;
		cI[4] = *cp;
		cp++;
		cI[5] = *cp;
		cp++;

		for (i = 0; i < 6; i++) {
			if (cI[i] >= DEF_MAXITEMS) return;
			if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
		}

		for (i = 0; i < 6; i++) {
			if (cI[i] >= 0) {
				bDup = FALSE;
				for (j = 0; j < 6; j++) {
					if (sItemIndex[j] == cI[i]) {
						sItemNumber[j]++;
						bDup = TRUE;
					}
				}
				if (bDup == FALSE) {
					for (j = 0; j < 6; j++) {
						if (sItemIndex[j] == -1) {
							sItemIndex[j] = cI[i];
							sItemNumber[j]++;
							goto RCPH_LOOPBREAK;
						}
					}
				RCPH_LOOPBREAK:;
				}
			}
		}

		for (i = 0; i < 6; i++) {
			if (sItemIndex[i] != -1) {
				if (sItemIndex[i] < 0) return;
				if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;

				sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum == 657)
					sItemPurity[i] = 100; // Merien stones considered 100% purity.
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
					sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity

				if (sItemNumber[i] > 1) sItemPurity[i] = -1; // No purity for stacked items

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == DEF_EQUIPPOS_NECK)) {
					iNeededContrib = 10; // Necks Crafting requires 10 contrib
				}
			}
		}

		// Bubble Sort
		bFlag = TRUE;
		while (bFlag == TRUE) {
			bFlag = FALSE;
			for (i = 0; i < 5; i++) {
				if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1)) {
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum)) {
						sTemp = sItemIndex[i + 1];
						sItemIndex[i + 1] = sItemIndex[i];
						sItemIndex[i] = sTemp;
						sTemp = sItemPurity[i + 1];
						sItemPurity[i + 1] = sItemPurity[i];
						sItemPurity[i] = sTemp;
						sTemp = sItemNumber[i + 1];
						sItemNumber[i + 1] = sItemNumber[i];
						sItemNumber[i] = sTemp;
						bFlag = TRUE;
					}
				}
			}
		}

		j = 0;
		for (i = 0; i < 6; i++) {
			if (sItemIndex[i] != -1) sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
			else sItemArray[j] = sItemIndex[i];

			sItemArray[j + 1] = sItemNumber[i];
			j += 2;
		}

		// Search Crafting you wanna build
		ZeroMemory(cCraftingName, sizeof(cCraftingName));
		for (i = 0; i < DEF_MAXPORTIONTYPES; i++) {
			if (m_pCraftingConfigList[i] != NULL) {
				bFlag = FALSE;
				for (j = 0; j < 12; j++) {
					if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE; // one item mismatch	
				}
				if (bFlag == FALSE) { // good Crafting receipe
					ZeroMemory(cCraftingName, sizeof(cCraftingName));
					memcpy_secure(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
					iRiskLevel = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
					iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
				}
			}
		}

		// Check if recipe is OK
		if (strlen(cCraftingName) == 0) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRAFTING_FAIL, 1, NULL, NULL, NULL); // "There is not enough material"
			return;
		}
		// Check for Contribution
		if (m_pClientList[iClientH]->m_iContribution < iNeededContrib) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRAFTING_FAIL, 2, NULL, NULL, NULL); // "There is not enough Contribution Point"	
			return;
		}
		// Check possible Failure
		if (iDice(1, 100) > iDifficulty) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRAFTING_FAIL, 3, NULL, NULL, NULL); // "Crafting failed"

			// Remove parts...
			pItem = NULL;
			pItem = new class CItem;
			if (pItem == NULL) return;
			for (i = 0; i < 6; i++) {
				if (sItemIndex[i] != -1) {	// Deplete any Merien Stone
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_NONE)
						&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
						&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129)) {
						ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
					}
					else {
						// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
						if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_EQUIP)
							|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_MATERIAL)) {
							if (iDice(1, 100) < iRiskLevel) {
								ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
							}
						}
					}
				}
			}
			return;
		}

		// Purity
		int iPurity, iTot = 0, iCount = 0;
		for (i = 0; i < 6; i++) {
			if (sItemIndex[i] != -1) {
				if (sItemPurity[i] != -1) {
					iTot += sItemPurity[i];
					iCount++;
				}
			}
		}

		if (iCount == 0) {
		//	iPurity = 20 + iDice(1, 80);			// Wares have random purity (20%..100%)
			iPurity = 40 + iDice(1, 60);
			bNeedLog = FALSE;
		}
		else {
			iPurity = iTot / iCount;
			iTot = (iPurity * 4) / 5;
			iCount = iPurity - iTot;
			iPurity = iTot + iDice(1, iCount);	// Jewel completion depends off Wares purity
			bNeedLog = TRUE;
		}

		if (iNeededContrib != 0) {
			iPurity = 0;						// Necks require contribution but no purity/completion
			bNeedLog = TRUE;
		}

		if (strlen(cCraftingName) != 0) {
			pItem = NULL;
			pItem = new class CItem;
			if (pItem == NULL) return;
			for (i = 0; i < 6; i++) {
				if (sItemIndex[i] != -1) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) {
						SetItemCount(iClientH, sItemIndex[i], m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
					}
					else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE, FALSE);
				}
			}

			if (iNeededContrib != 0) m_pClientList[iClientH]->m_iContribution -= iNeededContrib;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRAFTING_SUCCESS, NULL, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iExpStock += iDice(2, 100);
			SendContribution(iClientH);

			if ((_bInitItemAttr(pItem, cCraftingName) == TRUE)) {
				if (iPurity != 0) {
					pItem->m_sItemSpecEffectValue1 = 300;
					pItem->m_sItemSpecEffectValue2 = iPurity;
					pItem->m_dwAttribute = 1;
				}
				pItem->m_sTouchEffectType = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1, 100000);

				pItem->m_wMaxLifeSpan = 300;

				// Anti Dup System
				SYSTEMTIME SysTime;
				char cTemp[256];
				GetLocalTime(&SysTime);
				ZeroMemory(cTemp, sizeof(cTemp));
				pItem->m_sTouchEffectValue2 = iDice(1, 100000);
				wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
				pItem->m_sTouchEffectValue2 = atoi(cTemp);

				ZeroMemory(cTemp, sizeof(cTemp));
				wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
				pItem->m_sTouchEffectValue3 = atoi(cTemp);

				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					ZeroMemory(cData, sizeof(cData));
					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMOBTAINED;
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;
					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;
					*cp = pItem->m_cItemType;
					cp++;
					*cp = pItem->m_cEquipPos;
					cp++;
					*cp = (char)0;
					cp++;
					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
					*cp = pItem->m_cGenderLimit;
					cp++;
					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;
					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;
					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;
					*cp = pItem->m_cItemColor;
					cp++;

					//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					//cp++;
					//cambio lalomanu
					sp = (short *)cp;
					*sp = pItem->m_sItemSpecEffectValue2;
					cp += 2;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;

					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;
					if (iEraseReq == 1) delete pItem;
				//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
					//cambio lalomanu
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							break;
					}
				}
				else {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					pItem->m_dwTimeDrop = timeGetTime();
					SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							break;
					}
				}
			}
			else {
				delete pItem;
				pItem = NULL;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqCreateCraftingHandler");
	}
#endif
}

void CMapServer::AdminOrder_SetStatus(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, *token2, cBuff[256];
		int    iPass;
		class  CStrTok * pStrTok;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token2 = pStrTok->pGet();

		iPass = (int)token;
		if (token != NULL) {
			if (token[0] == '0') {
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			}
			if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '2') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '3') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '4') SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '5') SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '6') SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '7') SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '8') SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '9') SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '1' && token[1] == '0') SetInhibitionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			if (token[0] == '1' && token[1] == '1') SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SetStatus");
	}
#endif
}

void CMapServer::SetInhibitionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) return;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) return;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetInhibitionFlag");
	}
#endif
}

void CMapServer::ShowVersion(int iClientH)
{
	char cVerMessage[256];

	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cVerMessage, sizeof(cVerMessage));
	wsprintf(cVerMessage, "Helbreath Cursed");
	ShowClientMsg(iClientH, cVerMessage);
}

void CMapServer::ShowClientMsg(int iClientH, char* pMsg)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cTemp[256];
		DWORD * dwp, dwMsgSize;
		WORD * wp;
		short * sp;

		ZeroMemory(cTemp, sizeof(cTemp));

		dwp = (DWORD *)cTemp;
		*dwp = CLIENT_REQUEST_COMMAND_CHATMSG;

		wp = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
		*wp = NULL;

		cp = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
		sp = (short *)cp;
		*sp = NULL;
		cp += 2;

		sp = (short *)cp;
		*sp = NULL;
		cp += 2;

		memcpy_secure(cp, "MapServer", 9);
		cp += 10;

		*cp = 10;
		cp++;

		dwMsgSize = strlen(pMsg);
		if (dwMsgSize > 100) dwMsgSize = 100;
		memcpy_secure(cp, pMsg, dwMsgSize);
		cp += dwMsgSize;
		//Agregado Lalo882
		//m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
		int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ShowClientMsg");
	}
#endif
}

void CMapServer::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		CStrTok * pStrTok;
		char   * token, cMapName[11], cBuff[256];
		BOOL bFlag = FALSE;	//Used to check if we are on the map we wanna clear
		int i;
		CItem *pItem;
		short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
		char cRemainItemColor, len;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cMapName, sizeof(cMapName));
			memcpy_secure(cMapName, token, 10);

			for (i = 0; i < DEF_MAXMAPS; i++) { //Enum all maps
				if (m_pMapList[i] != NULL) {	//Is allocated map
					if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
						bFlag = TRUE; //Set flag
						//Get X and Y coords
						int m_x = m_pMapList[i]->m_sSizeX;
						int m_y = m_pMapList[i]->m_sSizeY;
						for (int j = 1; j < m_x; j++) {
							for (int k = 1; k < m_y; k++) {
								do {	//Delete all items on current tile
									pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
									if (pItem != NULL) {
										delete pItem;	//Delete item;
									}
								} while (pItem != NULL);
							}
						}
						break;	//Break outo f loop
					}
				}
			}
		}

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CleanMap");
	}
#endif
}

void CMapServer::RemoveOccupyFlags(int iMapIndex)
{
#ifdef DEF_DEBUG
	try {
#endif

		DWORD dwTime = timeGetTime();
		register int i;
		short dX, dY;
		int iDynamicObjectIndex;
		class CTile * pTile;
		int iy, ix;

		if (m_pMapList[iMapIndex] == NULL) return;

		for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) {
			if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] == NULL) continue;

			dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;

			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) continue;
			SendEventToNearClient_TypeB(CLIENT_COMMON_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, iMapIndex, dX, dY, m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
			m_pMapList[iMapIndex]->SetDynamicObject(NULL, NULL, dX, dY, dwTime);

			if (m_pDynamicObjectList[iDynamicObjectIndex] == NULL) {
				for (ix = dX - 2; ix <= dX + 2; ix++) {
					for (iy = dY - 2; iy <= dY + 2; iy++) {
						pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + ix + iy*m_pMapList[iMapIndex]->m_sSizeY);
						pTile->m_sOwner = NULL;
					}
				}
			}
			register int j;
			for (i = 0; i < m_pMapList[iMapIndex]->m_sSizeX; i++) { // Then remove all m_iOccupyStatus
				for (j = 0; j < m_pMapList[iMapIndex]->m_sSizeY; j++) {
					pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + i + j*m_pMapList[iMapIndex]->m_sSizeY);
					pTile->m_iOccupyStatus = 0;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveOccupyFlags");
	}
#endif
}

BOOL CMapServer::bDecodeTeleportList(char *pFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;
	int  iIndex;
	int iTeleportConfigListIndex = 0;

	for (int i = 0; i < DEF_MAXTELEPORTLIST; i++) {
		if (m_pTeleportConfigList[i] != NULL) {
			delete m_pTeleportConfigList[i];
			m_pTeleportConfigList[i] = NULL;
		}
	}

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;
	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		PutLogList("Cannot open Teleport.cfg file.");
		return FALSE;
	}
	else {
		PutLogList("Reading TeleportList.cfg...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1: // Teleport n�
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
									delete pStrTok;
									delete cp;
									return FALSE;
								}
								iTeleportConfigListIndex = atoi(token);
								if ((iTeleportConfigListIndex < 0) || (iTeleportConfigListIndex >= DEF_MAXTELEPORTLIST)) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong TeleportList number.");
									return FALSE;
								}
								if (m_pTeleportConfigList[iTeleportConfigListIndex] != NULL) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Duplicate TeleportList number.");
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex] = new class CTeleport;
								cReadModeB = 2;
								break;

							case 2: // NPC name
								memcpy_secure(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cNpcName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3: // SOURCE MAP
								memcpy_secure(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cSourceMap, token, strlen(token));
								cReadModeB = 4;
								break;
							case 4: // TARGET MAP
								memcpy_secure(m_pTeleportConfigList[iTeleportConfigListIndex]->m_cTargetMap, token, strlen(token));
								cReadModeB = 5;
								break;
							case 5: // TARGET MAP X
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - X - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex]->m_iX = atoi(token);
								cReadModeB = 6;
								break;

							case 6: // TARGET MAP Y
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Y - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex]->m_iY = atoi(token);
								cReadModeB = 7;
								break;
							case 7: // COST
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Cost - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex]->m_iCost = atoi(token);
								cReadModeB = 8;
								break;
							case 8: // Minimum Level
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - MinLvl - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMinLvl = atoi(token);
								cReadModeB = 9;
								break;
							case 9: // Maximum Level
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - MaxLvl- Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex]->m_iMaxLvl = atoi(token);
								cReadModeB = 10;
								break;

							case 10: // Side (aresden, elvein)
								if (memcmp(token, "aresden", 7) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 1;
								else if (memcmp(token, "elvine", 6) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 2;
								else if (memcmp(token, "assasain", 4) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 124;
								else if (memcmp(token, "evil", 4) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 4;
								else if (memcmp(token, "all", 3) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 12;
								else if (memcmp(token, "heldenian", 9) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_iSide = 66;
								else {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Side - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 11;
								break;

							case 11: // HuntMode (0,1)
								if (_bGetIsStringIsNumber(token) == FALSE) {
									PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Hunter - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								if (memcmp(token, "0", 1) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = FALSE;
								else if (memcmp(token, "1", 1) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_bHunter = TRUE;
								else {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Hunter - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 12;
								break;

							case 12: // Netural (0,1)
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Neutral - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								if (memcmp(token, "0", 1) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = FALSE;
								else if (memcmp(token, "1", 1) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_bNetural = TRUE;
								else {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Neutral - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 13;
								break;

							case 13: // Criminal (0,1)
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}

								if (memcmp(token, "0", 1) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = FALSE;
								else if (memcmp(token, "1", 1) == 0)
									m_pTeleportConfigList[iTeleportConfigListIndex]->m_bCriminal = TRUE;
								else {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 14;
								break;

							case 14:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Crim - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pTeleportConfigList[iTeleportConfigListIndex]->m_iEvent = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "teleport", 8) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				else if (memcmp(token, "[END]", 5) == 0) {
					cReadModeA = 0;
					cReadModeB = 0;
					break; // Stop While Loop
				}
			}
			token = pStrTok->pGet();
		} // while

		delete pStrTok;
		delete[]cp;
		if ((cReadModeA != 0) || (cReadModeB != 0) || (iTeleportConfigListIndex < 0) || (iTeleportConfigListIndex >= DEF_MAXTELEPORTLIST)) {
			ErrorList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
			return FALSE;
		}
		if (pFile != NULL) fclose(pFile);

		wsprintf(G_cTxt, "TELEPORT-LIST(Total:%d) configuration - success!", iTeleportConfigListIndex);
		PutLogList(G_cTxt);
		return TRUE;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Funcion demasiado garcha 'continue', 'goto', etc... es demasiado pajero, es un braker malisimo, cambio mejor **
** Por una puta variable boolean, va a quedar mejor estetica y funcionalmente                                   **
** Esto es para el HB-Argentina v3.82																			**
** ZeroEoyPnk - 12 / 03 / 2013 - 21:06 PM																		**
////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
void CMapServer::RequestTeleportListHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
		if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
			return;
		}

		char *cp, cData[512];
		int  iRet;
		DWORD *dwp;
		WORD *wp;
		int  *listCount;
		char cNpcName[21];
		int  *ip;
		BOOL Confirm, Event, TPEvent;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ZeroMemory(cNpcName, sizeof(cNpcName));
		memcpy_secure(cNpcName, cp, 20);
		cp += 20;

		ZeroMemory(cData, sizeof(cData));
		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_TELEPORT_LIST;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;
		cp = cData + 6;

		listCount = (int*)cp;
		*listCount = 0;
		cp += 4; // sizeof(int)

		int  index;
		for (index = 0; index < DEF_MAXTELEPORTLIST; index++) {
			if (m_pTeleportConfigList[index] != NULL) {
				Confirm = TRUE;
				Event = FALSE;
				TPEvent = FALSE;

				if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pTeleportConfigList[index]->m_cSourceMap) != 0) && (Confirm))
					Confirm = FALSE;
				if ((strcmp(m_pTeleportConfigList[index]->m_cNpcName, cNpcName) != 0) && (Confirm))
					Confirm = FALSE;
				if (((m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel) || (m_pTeleportConfigList[index]->m_iMaxLvl <= m_pClientList[iClientH]->m_iLevel)) && (Confirm))
					Confirm = FALSE;
				if ((m_pTeleportConfigList[index]->m_bHunter == FALSE) && (m_pClientList[iClientH]->m_bIsHunter) && (Confirm))
					Confirm = FALSE;
				if ((m_pTeleportConfigList[index]->m_bNetural == FALSE) && (m_pClientList[iClientH]->m_cSide == 0) && (Confirm))
					Confirm = FALSE;
				if ((m_pTeleportConfigList[index]->m_bCriminal == FALSE) && (m_pClientList[iClientH]->m_iPKCount > 0) && (Confirm))
					Confirm = FALSE;
				if ((m_pClientList[iClientH]->Assasain) && (Confirm == FALSE))
					Confirm = TRUE;

				if (Confirm) {
					switch (m_pTeleportConfigList[index]->m_iSide) {
						case 1: // Aresden
							if (m_pClientList[iClientH]->m_cSide != 1) Confirm = FALSE;
							break;
						case 2: // Elvine
							if (m_pClientList[iClientH]->m_cSide != 2) Confirm = FALSE;
							break;
						case 4: // Evil oO!???
							if (m_pClientList[iClientH]->m_cSide != 4) Confirm = FALSE;
							break;
						case 12: // All
							if (m_pClientList[iClientH]->m_cSide == 4) Confirm = FALSE;
							break;
						case 124: // Assasain
							if ((m_pClientList[iClientH]->m_cSide != 0) || (!m_pClientList[iClientH]->Assasain)) Confirm = FALSE;
							break;
						default:
							break;
					}
				}

				//Events - New //Agregar Mapas premio eventos
				if (Confirm) {
					switch (m_pTeleportConfigList[index]->m_iEvent) {
						case 1: // Crusada
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_SADE].LastWin)
								Confirm = FALSE;
							Event = TRUE;
							break;
						case 2: // Capture the flag //Agregar mapa de premio
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_CTF].LastWin)
								Confirm = FALSE;
							Event = TRUE;  //Agregar mapa de premio
							break;
						case 3: // Rush //Agregar mapa de premio
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_RUSH].LastWin)
								Confirm = FALSE;
							Event = TRUE;
							break; 
						case 4: // TowerDefense
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_TD].LastWin)
								Confirm = FALSE;
							Event = TRUE;
							break;

						case 5: // City Vs City -> Sin sentido...
							/*if (m_pClientList[iClientH]->m_cSide != LastCVCWinnerSide)
								Confirm = FALSE;
							else if (PriceEvent == FALSE)
								Confirm = FALSE;
							Event = TRUE;*/
							break;

						case 8:
							if (TowerDefense == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 10:
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_CVC].LastWin)
								Confirm = FALSE;
							if (PriceEvent == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 11:
							if (AllVsAllPortals == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 12:
							if (AbaddonEvent == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 13:
							if (RunSummonEvent == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 14:
							if (RunSummonEvent2 == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 15:
							if (HellOfDeath == FALSE)
								Confirm = FALSE;
							TPEvent = TRUE;
							break;
						case 16:
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_HOD].LastWin)
								Confirm = FALSE;

							if (PriceHODEvent == FALSE) Confirm = FALSE;
							Event = TRUE;
							break;
						case 17:
							if (RunSummonEvent3 == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 18:
							if (VipMap == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 19:
							if (Masacre == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 20:
							if (FinalFight == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 21:
							if (DKEvent == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 22:
							if (TowerHell == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 23:
							if (WorldWar == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 24:
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_WW].LastWin)
								Confirm = FALSE;
							if (WWPriceEvent == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 25://LaloMarket
							if (MarketEnabled == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 26:
							if (WorldWarII == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 27:
							if (m_pClientList[iClientH]->m_cSide != EventCount[DEF_WWII].LastWin)
								Confirm = FALSE;
							if (WWIIPriceEvent == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 28:
							if (AllEks == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 29:
							if (AllDkEks == FALSE) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						case 30:
							if (!g_ev.Is(EventID::Deathmatch)) Confirm = FALSE;
							TPEvent = TRUE;
							break;

						default:
							Event = FALSE;
							TPEvent = FALSE;
							break;
					}
				}

				// Si todo est� OK, armo el array con la data
				if (Confirm) {
					ip = (int*)cp;
					*ip = index;
					cp += 4;
					memcpy_secure(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
					cp += 10;
					ip = (int*)cp;
					*ip = m_pTeleportConfigList[index]->m_iX;
					cp += 4;
					ip = (int*)cp;
					*ip = m_pTeleportConfigList[index]->m_iY;
					cp += 4;
					ip = (int*)cp;
					*ip = m_pTeleportConfigList[index]->m_iCost;
					cp += 4;
					*cp = Event;
					cp++;
					*cp = TPEvent;
					cp++;
					(*listCount)++;
				}
			}
		}

		if ((*listCount) == 0)*wp = DEF_MSGTYPE_REJECT;
		// Teleport List
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 28);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestTeleportListHandler");
	}
#endif
}

void CMapServer::RequestChargedTeleportHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char *cp, cData[64];
		int  iRet;
		DWORD *dwp;
		WORD *wp;
		int  index;
		WORD wConfirm = DEF_MSGTYPE_CONFIRM;
		short sError = 0;
		short TempsX, TempsY;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;

		// CHARGED_TELEPORT index
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		index = (int)(*cp);
		cp += 4;

		if ((index < 0) || (index >= DEF_MAXTELEPORTLIST)) return;
		if (m_pTeleportConfigList[index] == NULL)  return;
		if (strncmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0) return;
		if ((m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel)
			|| (m_pTeleportConfigList[index]->m_iMaxLvl <= m_pClientList[iClientH]->m_iLevel)) {
			wConfirm = DEF_MSGTYPE_REJECT;
			sError = 1;
		}

		if ((wConfirm == DEF_MSGTYPE_CONFIRM) && (m_pTeleportConfigList[index]->m_bHunter == FALSE) && (m_pClientList[iClientH]->m_bIsHunter == TRUE)) {
			wConfirm = DEF_MSGTYPE_REJECT;
			sError = 2;
		}

		if ((wConfirm == DEF_MSGTYPE_CONFIRM) && (m_pTeleportConfigList[index]->m_bNetural == FALSE) && (m_pClientList[iClientH]->m_cSide == 0)) {
			if (m_pClientList[iClientH]->Assasain == FALSE) {
				wConfirm = DEF_MSGTYPE_REJECT;
				sError = 3;
			}
		}

		if ((wConfirm == DEF_MSGTYPE_CONFIRM) && (m_pTeleportConfigList[index]->m_bCriminal == FALSE) && (m_pClientList[iClientH]->m_iPKCount > 0) &&
			(m_pClientList[iClientH]->Assasain == FALSE)) {
			if (m_pClientList[iClientH]->Assasain) {
				wConfirm = DEF_MSGTYPE_REJECT;
				sError = 4;
			}
		}

		if (wConfirm == DEF_MSGTYPE_CONFIRM) {
			switch (m_pTeleportConfigList[index]->m_iSide) {
				default:
					break;
				case 1:
				case 2:
				case 4:
					if (m_pClientList[iClientH]->m_cSide != m_pTeleportConfigList[index]->m_iSide) {
						wConfirm = DEF_MSGTYPE_REJECT;
						sError = 5;
					}
					break;
				case 12:
					if (m_pClientList[iClientH]->m_cSide > 2) {
						wConfirm = DEF_MSGTYPE_REJECT;
						sError = 5;
					}
					break;
				case 124:// Everybody
					break;
			}
		}

		if (wConfirm == DEF_MSGTYPE_CONFIRM) {
			DWORD dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if (dwGoldCount >= m_pTeleportConfigList[index]->m_iCost) {
				int iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - m_pTeleportConfigList[index]->m_iCost);
				iCalcTotalWeight(iClientH);
				if (m_pClientList[iClientH]->m_cSide == 1 || m_pClientList[iClientH]->m_cSide == 2) {
					m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += m_pTeleportConfigList[index]->m_iCost;
				}
			}
			else {
				wConfirm = DEF_MSGTYPE_REJECT;
				sError = 6;
			}
		}
		// Invalid Charged-teleport
		if (wConfirm == DEF_MSGTYPE_REJECT) {
			ZeroMemory(cData, sizeof(cData));
			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_RESPONSE_CHARGED_TELEPORT;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = wConfirm;
			cp = cData + DEF_INDEX2_MSGTYPE + 2;
			short *sp;
			sp = (short*)cp;
			*sp = sError;
			cp += 2;
			// Teleport List
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6 + 2);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
			return;
		}
		// teleport
		if (strcmp(m_pTeleportConfigList[index]->m_cTargetMap, DEF_EVENTMAP_ALLVSALL) == 0) {
			TempsX = Random(65, 84);
			TempsY = Random(74, 85);
		}
		else if (strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "dm") == 0) {
			c_dm->join_event(iClientH);
			return;
		}
		else {
			TempsX = m_pTeleportConfigList[index]->m_iX;
			TempsY = m_pTeleportConfigList[index]->m_iY;
		}
		RequestTeleportHandler(iClientH, "2   ", m_pTeleportConfigList[index]->m_cTargetMap, TempsX, TempsY);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestChargedTeleportHandler");
	}
#endif
}

void CMapServer::AdminOrder_Kill(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
		class  CStrTok * pStrTok;
		register int i;
		int sAttackerWeapon, sDamage, iExH;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			memcpy_secure(cName, token, 10);
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, "null");
		}

		token = pStrTok->pGet();
		if (token != NULL) sDamage = atoi(token);
		else sDamage = 1;

		if (token == NULL) token = "null";
		if (cName != NULL) {
			token = cName;
			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					m_pClientList[i]->m_iHP = 0;
					m_pClientList[i]->m_bIsKilled = TRUE;

					if (m_pClientList[i]->m_bIsExchangeMode == TRUE) {
						iExH = m_pClientList[i]->m_iExchangeH;
						_ClearExchangeStatus(iExH);
						_ClearExchangeStatus(i);
					}

					RemoveFromTarget(i, DEF_OWNERTYPE_PLAYER);
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_KILLED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
					sAttackerWeapon = 1;
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(12, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

					delete pStrTok;
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Kill");
	}
#endif
}

void CMapServer::AdminOrder_Revive(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
		class  CStrTok * pStrTok;
		register int i;
		int sAttackerWeapon, sDamage, sHP;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);

		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			memcpy_secure(cName, token, 10);
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, "null");
		}

		token = pStrTok->pGet();
		if (token != NULL) sDamage = atoi(token);
		else sDamage = 1;

		token = pStrTok->pGet();
		if (token != NULL) sHP = atoi(token);
		else sHP = 1;

		token = cName;
		if (cName != NULL) {
			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					m_pClientList[i]->m_iHP = sHP;
					if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
					m_pClientList[i]->m_bIsKilled = FALSE;
					m_pClientList[i]->m_iLastDamage = sDamage;
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
					sAttackerWeapon = 1;
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTDAMAGE, sDamage, sAttackerWeapon, NULL);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

					delete pStrTok;
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Revive");
	}
#endif
}

void CMapServer::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cPlayerName[11], cMapName[32];
		class  CStrTok * pStrTok;
		char *cp;
		WORD *wp;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token == NULL) {
			delete pStrTok;
			return;
		}

		if (strlen(token) > 10) memcpy_secure(cPlayerName, token, 10);
		else memcpy_secure(cPlayerName, token, strlen(token));

		for (int i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (memcmp(cPlayerName, m_pClientList[i]->m_cCharName, 10) == 0) {
					if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
						//Agregado anticrash lalo
						if (m_pClientList[i] == NULL) return;
						if (m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1) {
							wsprintf(cBuff, "GM Order(%s): GoTo MapName(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cMapName);
						}
						else {
							wsprintf(cBuff, "GM Order(%s): GoTo MapName(%s)(%d %d)", m_pClientList[iClientH]->m_cCharName,
								m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						}
						ZeroMemory(cMapName, sizeof(cMapName));
						strcpy_secure(cMapName, m_pClientList[i]->m_cMapName);
						RequestTeleportHandler(iClientH, "2   ", cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					delete pStrTok;
					return;
				}
			}
		}
		m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_GoTo");
	}
#endif
}
//LaloRamos Multiplicador Experience EXPACA
void CMapServer::MultiplicadorExp(WORD Client, DWORD Exp)
{
	auto p = m_pClientList[Client];
	if (!p) return;
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[Client]->m_iLevel <= 20)			Exp *= 600;//50 medium
		else if (m_pClientList[Client]->m_iLevel <= 60)		Exp *= 600;//30
		else if (m_pClientList[Client]->m_iLevel <= 100)	Exp *= 600;//50
		else if (m_pClientList[Client]->m_iLevel <= 140)	Exp *= 600;//50
		else if (m_pClientList[Client]->m_iLevel <= 160)	Exp *= 600;//50
		else if (m_pClientList[Client]->m_iLevel <= DEF_PLAYERMAXLEVEL)	Exp *= 600;
		else if (m_pClientList[Client]->m_iLevel >= DEF_PLAYERMAXLEVEL) 	Exp *= 600;

		if (p->m_sRebirthStatus == 1 && p->m_iLevel != DEF_PLAYERMAXLEVEL && p->m_iRebirthLevel != 0)
		{
			float rebirthMultiplier = 1.0f;
			if (p->m_iRebirthLevel > 0 && p->m_iRebirthLevel <= 20) {
				rebirthMultiplier = pow(0.85f, p->m_iRebirthLevel);
			}

			Exp *= rebirthMultiplier;
		}
		
		p->m_iExpStock += Exp;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: MultiplicadorExp");
	}
#endif
}

void CMapServer::AdminOrder_SetZerk(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '1') {
				SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)m_pMagicConfigList[32]->m_sValue4;
			}
			else if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SetZerk");
	}
#endif
}

void CMapServer::Anuncios()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, a, MSG = 35;//25

		if (Actualizar == FALSE) return;
		if (strlen(m_cMsg[0]) == 0) return;

		for (i = 0; i < 35; i++) {//25
			if (strlen(m_cMsg[i]) == 0) MSG = i;
			i = 35;//25
		}

		MSG = iDice(1, MSG);
		MSG--;

		if (strlen(m_cMsg[MSG]) == 0) return;

		for (a = 0; a < 100; a++)
			if (m_cMsg[MSG][a] == '_') m_cMsg[MSG][a] = ' ';

		for (i = 0; i < DEF_MAXCLIENTS; i++)
			SendNotifyMsg(NULL, i, CLIENT_NOTIFY_NOTICEMSG, NULL, NULL, NULL, m_cMsg[MSG]);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Anuncios");
	}
#endif
}

void CMapServer::AdminOrder_MonsterCount(int iClientH, char* pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iMonsterCount;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		iMonsterCount = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
		SendNotifyMsg(0, iClientH, CLIENT_NOTIFY_MONSTERCOUNT, iMonsterCount, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_MonsterCount");
	}
#endif
}

// New Clear Map - ZeroEoyPnk
void CMapServer::AutoClearMap()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, k, j;
		short sItemSprite, sItemSpriteFrame;
		char cItemColor;
		DWORD dwTime = timeGetTime();

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				int m_x = m_pMapList[i]->m_sSizeX - 20;
				int m_y = m_pMapList[i]->m_sSizeY - 20;
				for (j = 20; j <= m_x; j++) {
					for (k = 20; k <= m_y; k++) {
						if (m_pMapList[i]->bGetIsMoveAllowedTile(j, k) != FALSE)
							m_pMapList[i]->pGetItem2(j, k, &sItemSprite, &sItemSpriteFrame, &cItemColor, dwTime); // v1.4
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AutoClearMap");
	}
#endif
}

int CMapServer::iCheckLugar(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if ((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall", 8) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)) return 1;
		else if ((m_bIsCrusadeMode == FALSE) && (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0)) return 1;

		if ((memcmp(m_pClientList[iClientH]->m_cMapName, "GodH", 4) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cMapName, "HRampart", 8) == 0))return 3;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: iCheckLugar");
	}
#endif
	return 0;
}

void CMapServer::GetDkHandler(int iClientH, int iOpcion)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   i, iNum, iRet, iEraseReq, iItemID;
		char  * cp, cData[256], cItemName[21];
		class CItem * pItem;
		DWORD * dwp;
		short * sp;
		WORD  * wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iLevel < DEF_PLAYERMAXLEVEL) return;
		if ((m_pClientList[iClientH]->m_cSide == DEF_NETURAL) && (!m_pClientList[iClientH]->Assasain)) return;

		if (_iGetItemSpaceLeft(iClientH) == 0) {
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}
		switch (iOpcion) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr >= 130) {//dk sword
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 709;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 727;
				}
				else if (m_pClientList[iClientH]->m_iStr >= 39) { //dk rapier
					iItemID = 717;
				}
				else return;
				break;

			case 2://dk wand
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 714;
				else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 732;
				break;

			case 3:
				if (m_pClientList[iClientH]->m_iStr >= 85) { //dk helm
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 707;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 725;
				}
				else if (m_pClientList[iClientH]->m_iMag >= 130) { //dk hat
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 703;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 702;
				}
				else return;
				break;

			case 4:
				if (m_pClientList[iClientH]->m_iStr >= 100) {//dk armor
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 710;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 728;
				}
				else if (m_pClientList[iClientH]->m_iStr >= 30) { //dk chain mail
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 712;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 730;
				}
				else return;
				break;

			case 5:
				if (m_pClientList[iClientH]->m_iMag >= 100) {//dm robe
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 715;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 733;
				}
				else return;
				break;

			case 6:
				if (m_pClientList[iClientH]->m_iStr >= 15) {//dk hauberk
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 706;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 724;
				}
				else return;
				break;

			case 7:
				if (m_pClientList[iClientH]->m_iStr >= 20) {//dk leggings
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 708;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 731;
				}
				else return;
				break;

			case 8:
				if (m_pClientList[iClientH]->m_iStr >= 200) {//dk hammer
					if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 2011;
					else if (m_pClientList[iClientH]->m_cSex == 2) iItemID = 2011;
				}
				else return;
				break;

			default:
				return;
				break;
		}

		iNum = 1;
		for (i = 1; i <= iNum; i++) {

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				pItem = NULL;
			}
			else {
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

					ZeroMemory(cItemName, sizeof(cItemName));
					memcpy_secure(cItemName, pItem->m_cName, 20);

					pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMOBTAINED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0;
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					//cp++;
					//cambio lalomanu
					sp = (short *)cp;
					*sp = pItem->m_sItemSpecEffectValue2;
					cp += 2;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;

					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;

					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

					if (iEraseReq == 1) {
						delete pItem;
						pItem = NULL;
					}

					//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
					//cambio lalomanu
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

					iCalcTotalWeight(iClientH);

					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
				else {
					delete pItem;
					pItem = NULL;

					iCalcTotalWeight(iClientH);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetDkHandler");
	}
#endif
}

void CMapServer::SetAccountMsg(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		FILE * pFile;
		char cFile[256], cTxt[96], cData[101];
		char   seps[] = "= \t\n";
		char   * token;
		CStrTok * pStrTok;
		char cBuff[256];

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cFile, sizeof(cFile));
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cFile, "Anuncios.cfg");

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();


		if (token != NULL) {
			ZeroMemory(cData, sizeof(cData));
			strcpy_secure(cData, token);
			m_bAnunciosActivo = TRUE;
		}
		else m_bAnunciosActivo = FALSE;

		pFile = fopen(cFile, "wt");
		if (pFile != NULL) {
			if (m_bAnunciosActivo == TRUE) wsprintf(cTxt, "msg-1 = %s", cData);
			else if (m_bAnunciosActivo == FALSE) wsprintf(cTxt, "");

			fwrite(cTxt, 1, strlen(cTxt), pFile);
			fclose(pFile);
		}
		else m_bAnunciosActivo = FALSE;

		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetAccountMsg");
	}
#endif
}

void CMapServer::SetAfkFlag(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char *cp;
		int *ip, iStatus = 0;
		DWORD dwTime;
		dwTime = timeGetTime();

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->OpenSell) return;
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL, 9) == 0) return;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		ip = (int *)cp;
		iStatus = (int)*ip;

		if (iStatus == 1) {
			m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000008;
			if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) ||
				(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0)) {
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 0x00000006) != 0)
					m_pClientList[iClientH]->KilledClientAFK = dwTime;
			}
		}
		else {
			m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus & 0xFFFFFFF7;
			m_pClientList[iClientH]->KilledClientAFK = -1;
		}
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetAfkFlag");
	}
#endif
}

void CMapServer::AdminOrder_Time(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		int i;

		if ((dwMsgSize) <= 0) return;
		if (m_pClientList[iClientH] == NULL) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '2') m_cDayOrNight = 2;
			else if (token[0] == '1') m_cDayOrNight = 1;
			else if (token[0] == '3') m_cDayOrNight = 3;
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					if ((m_pClientList[i]->m_cMapIndex >= 0) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
						(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Time");
	}
#endif
}

void CMapServer::AdminOrder_Weather(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		char cPrevMode;
		int i, j, sType, sTime;
		DWORD dwTime;

		dwTime = timeGetTime();

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token == NULL) {
			delete pStrTok;
			return;
		}

		sType = atoi(token);
		token = pStrTok->pGet();

		if (token == NULL) {
			delete pStrTok;
			return;
		}

		sTime = atoi(token);
		delete pStrTok;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {
				cPrevMode = m_pMapList[i]->m_cWhetherStatus;
				if (m_pMapList[i]->m_cWhetherStatus != NULL) {
					if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime)
						m_pMapList[i]->m_cWhetherStatus = NULL;
				}
				else {
					sTime *= 1000;
					m_pMapList[i]->m_cWhetherStatus = sType;
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime = sTime;
				}
				if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
					for (j = 1; j < DEF_MAXCLIENTS; j++) {
						if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i))
							SendNotifyMsg(NULL, j, CLIENT_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Weather");
	}
#endif
}

void CMapServer::AdminOrder_ChangeCity(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cBuff[256];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					if (memcmp(m_pClientList[i]->m_cLocation, "aresden", 7) == 0) {
						memcpy_secure(m_pClientList[i]->m_cLocation, "elvine", 10);
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
						break;
					}
					if (memcmp(m_pClientList[i]->m_cLocation, "elvine", 6) == 0) {
						memcpy_secure(m_pClientList[i]->m_cLocation, "aresden", 10);
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
						break;
					}
				}
			}

			if (m_pClientList[iClientH] != NULL) {
				wsprintf(G_cTxt, "GM Order(%s): Change City PC(%s)", m_pClientList[iClientH]->m_cCharName, cName);
				PutGMLogData(G_cTxt);
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_ChangeCity");
	}
#endif
}

BOOL CMapServer::bGetEmptyArea(short sOwnerH, char cMapIndex, short pX, short pY, char cArea)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sAreaSquared;
		register int i;

		if ((cArea > 5) || (cArea < 2)) return FALSE;
		sAreaSquared = cArea*cArea;
		for (i = 0; i < sAreaSquared; i++) {
			if (m_pMapList[cMapIndex]->bGetMoveableArea(sOwnerH, pX + _tmp_cEmptyPosX[i], pY + _tmp_cEmptyPosY[i]) == FALSE) return FALSE;
			if (m_pMapList[cMapIndex]->bGetIsTeleport(pX + _tmp_cEmptyPosX[i], pY + _tmp_cEmptyPosY[i]) == TRUE) return FALSE;
		}
		return TRUE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bGetEmptyArea");

	}
#endif
	return FALSE;
}

BOOL CMapServer::bGetNpcMovementArea(short sOwnerH, short pX, short pY, char cMapIndex, char cArea)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sAreaSquared, sPositionY, sPositionX, sX, sY;
		register int i;

		sAreaSquared = cArea*cArea;
		if ((cArea > 5) || (cArea < 2)) return FALSE;
		if (m_pNpcList[sOwnerH]->m_sType == 91) return TRUE;
		for (i = 1; i < sAreaSquared; i++) {
			if (_tmp_cEmptyPosX[i] > 0) sPositionX = 2;
			else if (_tmp_cEmptyPosX[i] < 0) sPositionX = -2;
			else sPositionX = 0;

			if (_tmp_cEmptyPosY[i] > 0)	sPositionY = 2;
			else if (_tmp_cEmptyPosY[i] < 0) sPositionY = -2;
			else sPositionY = 0;

			if (bGetEmptyArea(sOwnerH, cMapIndex, pX + sPositionX, pY + sPositionY, cArea) != FALSE) {
				sX = pX + sPositionX;
				sY = pY + sPositionY;
				pX = sX;
				pY = sY;
				return TRUE;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bGetNpcMovementArea");
	}
#endif
	return FALSE;
}

//skills 100%
void CMapServer::AutoSkill(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		// Str Points m_pClientList[iClientH]->m_sRankAddStr
		if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr) * 2 >= 100) {
			m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
			m_pClientList[iClientH]->m_cSkillMastery[0] = 100;
			m_pClientList[iClientH]->m_cSkillMastery[13] = 100;
		}
		else {
			m_pClientList[iClientH]->m_cSkillMastery[5] = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr) * 2;	//m_pClientList[iClientH]->m_iStr * 2;
			m_pClientList[iClientH]->m_cSkillMastery[0] = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr) * 2;	// m_pClientList[iClientH]->m_iStr * 2;
			m_pClientList[iClientH]->m_cSkillMastery[13] = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr) * 2;	// m_pClientList[iClientH]->m_iStr * 2;
		}

		// Dex Points
		if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex) * 2 >= 100) {
	//	if (m_pClientList[iClientH]->m_iDex * 2 >= 100) {
			m_pClientList[iClientH]->m_cSkillMastery[1] = m_pClientList[iClientH]->m_cSkillMastery[6] =
				m_pClientList[iClientH]->m_cSkillMastery[7] = m_pClientList[iClientH]->m_cSkillMastery[8] =
				m_pClientList[iClientH]->m_cSkillMastery[9] = m_pClientList[iClientH]->m_cSkillMastery[10] =
				m_pClientList[iClientH]->m_cSkillMastery[11] = m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
		}
		else {
			m_pClientList[iClientH]->m_cSkillMastery[1] = m_pClientList[iClientH]->m_cSkillMastery[6] =
				m_pClientList[iClientH]->m_cSkillMastery[7] = m_pClientList[iClientH]->m_cSkillMastery[8] =
				m_pClientList[iClientH]->m_cSkillMastery[9] = m_pClientList[iClientH]->m_cSkillMastery[10] =
				m_pClientList[iClientH]->m_cSkillMastery[11] = m_pClientList[iClientH]->m_cSkillMastery[14] = (m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex) * 2;// m_pClientList[iClientH]->m_iDex * 2;
		}

		// Int Points
		//if (m_pClientList[iClientH]->m_iInt * 2 >= 100) {
		if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt) * 2 >= 100) {
			m_pClientList[iClientH]->m_cSkillMastery[2] = 100;
			m_pClientList[iClientH]->m_cSkillMastery[12] = 100;
		}
		else {
			m_pClientList[iClientH]->m_cSkillMastery[2] = (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt) * 2;// m_pClientList[iClientH]->m_iInt * 2;
			m_pClientList[iClientH]->m_cSkillMastery[12] = (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt) * 2;// m_pClientList[iClientH]->m_iInt * 2;
		}

		// Mag Points
	//	if (m_pClientList[iClientH]->m_iMag * 2 >= 100) {
		if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag) * 2 >= 100) {
			m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
			m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
		}
		else {
			m_pClientList[iClientH]->m_cSkillMastery[4] = (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag) * 2;// m_pClientList[iClientH]->m_iMag * 2;
			m_pClientList[iClientH]->m_cSkillMastery[21] = (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag) * 2;// m_pClientList[iClientH]->m_iMag * 2;
		}

		if (m_pClientList[iClientH]->m_cSkillMastery[23] < 20) m_pClientList[iClientH]->m_cSkillMastery[23] = 20;

		for (short i = 0; i <= 23; i++)
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, i, m_pClientList[iClientH]->m_cSkillMastery[i], 1, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AutoSkill");
	}
#endif
}

void CMapServer::PlayerCommandCheckAdmins(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cNotifyMessage[256], cNotifyMessage2[256], cGMName[11];
		int i;
		char * cp, cTemp[120], cBuff[256];
		WORD * wp;

		ZeroMemory(cGMName, sizeof(cGMName));
		ZeroMemory(cNotifyMessage, sizeof(cNotifyMessage));
		ZeroMemory(cNotifyMessage2, sizeof(cNotifyMessage2));

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear && m_pClientList[i]->m_iAdminUserLevel > 0)
			{
				wsprintf(cNotifyMessage, "Admins: %s", m_pClientList[i]->m_cCharName);
				ShowClientMsg(iClientH, cNotifyMessage);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: PlayerCommandCheckAdmins");
	}
#endif
}
void CMapServer::AdminOrder_CheckRep(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		class  CStrTok * pStrTok;
		short m_iRating;
		char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
		register int i;

		if (m_pClientList[iClientH] == NULL) return;

		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cRepMessage, sizeof(cRepMessage));
		if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
			wsprintf(cRepMessage, " You have %d reputation points.", m_pClientList[iClientH]->m_iRating);
			ShowClientMsg(iClientH, cRepMessage);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_CheckRep");
	}
#endif
}

void CMapServer::AdminOrder_ClearNpc(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		for (int i = 1; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
				switch (m_pNpcList[i]->m_sType) {
					case 15:
					case 19:
					case 20:
					case 24:
					case 25:
					case 26:
					case 38:
					case 67:
					case 68:
					case 69:
					case 90:
					case 91:
					case 111:
						break;

					default:
						m_pNpcList[i]->m_bIsUnsummoned = TRUE;
						NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_ClearNpc");
	}
#endif
}

void CMapServer::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256], cMapName[11], cName[11], cTargetName[11];
		class  CStrTok * pStrTok;
		register int dX, dY;
		register int i;
		BOOL   bFlag;

		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));

		dX = dY = -1;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, token);
		}
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, "null");
		}
		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cMapName, sizeof(cMapName));
			strcpy_secure(cMapName, token);
		}

		token = pStrTok->pGet();
		if (token != NULL) dX = atoi(token);

		token = pStrTok->pGet();
		if (token != NULL) dY = atoi(token);

		if (token == NULL) { token = "null"; }
		if (cName != NULL) {
			token = cName;

			if (strlen(token) > 10) memcpy_secure(cTargetName, token, 10);
			else memcpy_secure(cTargetName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
					bFlag = FALSE;
					// ZeroEoyPnk - Chequeo mapas activos.
					bFlag = CheckActiveMaps(cMapName);
					//Defines I as Max clients
					if (bFlag == TRUE) {
						//Reqeust the Push/Teleport
						RequestTeleportHandler(i, "2   ", cMapName, dX, dY);
						wsprintf(G_cTxt, "(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)", m_pClientList[iClientH]->m_cIPaddress,
							m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
						PutGMLogData(G_cTxt);
					}
					else RequestTeleportHandler(i, "1   ");
					delete pStrTok;
					return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Pushplayer");
	}
#endif
}

void CMapServer::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * cBuff[256], cLocation[11];
		int    pX, pY, i;
		char buff[100];

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pX = m_pClientList[iClientH]->m_sX;
		pY = m_pClientList[iClientH]->m_sY;

		memcpy_secure(cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);
		//wsprintf(buff, "Summon-Guild: %s (%s) %s %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName, cLocation, pX, pY);
		//CharacterLogList(buff);

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName) == 0) && (i != iClientH)) {
				//if ((bCheckIfIsFlagCarrier(i) == FALSE) && (m_pClientList[i]->m_bRecall == TRUE) && (m_pClientList[i]->m_iStatus & 0x00000008) == 0
				//	&& m_pClientList[i]->OpenSell != TRUE) {
					//laloSummonguild no AFK
				if ((bCheckIfIsFlagCarrier(i) == FALSE) && (m_pClientList[i]->m_bRecall == TRUE) && ((m_pClientList[i]->m_iStatus & 0x00000008) == 0)
					&& (m_pClientList[i]->OpenSell != TRUE)) {

					if ((HellOfDeath || PriceHODEvent || SummonLaunched)) {
						if (m_pClientList[i]->m_iPKCount == 0)
							RequestTeleportHandler(i, "2   ", cLocation, pX, pY);
					}
					else RequestTeleportHandler(i, "2   ", cLocation, pX, pY);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SummonGuild");
	}
#endif
}

void CMapServer::ManualStartHappyHour(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cBuff[256], *token, seps[] = "= \t\n";
		class CStrTok * pStrTok;
		int i;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '1') LocalStarHappyHour(true);
			else if (token[0] == '0') LocalStarHappyHour(false);
		}

		delete pStrTok;
		wsprintf(G_cTxt, "Admin Order(%s): begin Happy-Hour", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ManualStartHappyHour");
	}
#endif
}

void CMapServer::ManualStartHappyDay(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char cBuff[256], *token, seps[] = "= \t\n";
		class CStrTok * pStrTok;
		int i;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '1') LocalStarHappyDay(true);
			else if (token[0] == '0') LocalStarHappyDay(false);
		}

		delete pStrTok;
		wsprintf(G_cTxt, "Admin Order(%s): begin Happy-DaY", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ManualStartHappyDay");
	}
#endif
}

void CMapServer::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		int    i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL) {
			if (token[0] == '1') {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled = TRUE;
				for (i = 1; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex))
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled, NULL, NULL, NULL);
				}
			}
			else if (token[0] == '0') {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled = FALSE;
				for (i = 1; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex))
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled, NULL, NULL, NULL);
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_SetAttackMode");
	}
#endif
}
/*

void CMapServer::NetBoxLotery(int iClientH, int ItemType)
{
#ifdef DEF_DEBUG
	try {
#endif
		int sX, sY, iResult;

		if (m_pClientList[iClientH] == NULL) return;

		sX = m_pClientList[iClientH]->m_sX;
		sY = m_pClientList[iClientH]->m_sY;
		SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[iClientH]->m_cMapIndex
			, sX, sY, sX, sY, 114, m_pClientList[iClientH]->m_sType);

		iResult = iDice(1, 10000);
		switch (ItemType) {
			case 1: Resultado1(iClientH, ItemType); break;
			case 2: Resultado1(iClientH, ItemType); break;
			case 3: Resultado1(iClientH, ItemType); break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NetBoxLotery");
	}
#endif
}
//Item comun 50% de probabilidades!
void CMapServer::Resultado1(int iClientH, int ItemType)
{
#ifdef DEF_DEBUG
	try {
#endif
		class  CItem * pItem;
		int iItemID, iResult, iEraseReq;

		if (m_pClientList[iClientH] == NULL) return;

		switch (ItemType) {
			case 1://Pandora Box Big
				iResult = iDice(1, 9);
				switch (iResult) {
					case 1: Resultado2(iClientH, ItemType); break;
					case 2: iItemID = 274; break; // SexChangePotion
					case 3: iItemID = 650; break; // ZemstoneofSacrifice 
					case 4: iItemID = 895; break; //895	MagicNecklace(MS18)
					case 5: Resultado2(iClientH, ItemType); break;
					case 6: iItemID = 903; break; //903	MagicNecklace(DF+30)
					case 7: iItemID = 899; break; //899	MagicNecklace(DM+5)
					case 8: iItemID = 907; break; //907	MagicNecklace(RM30)
					case 9: Resultado2(iClientH, ItemType); break;
				}
				break;
			case 2://Pandora Box Medium
				iResult = iDice(1, 9);
				switch (iResult) {
					case 1: Resultado2(iClientH, ItemType); break;
					case 2: iItemID = 274; break; // SexChangePotion
					case 3: iItemID = 650; break; // ZemstoneofSacrifice 
					case 4: iItemID = 894; break; //894	MagicNecklace(MS16)
					case 5: Resultado2(iClientH, ItemType); break;
					case 6: iItemID = 902; break; //902	MagicNecklace(DF+25)
					case 7: iItemID = 898; break; //898	MagicNecklace(DM+4)
					case 8: iItemID = 906; break; //906	MagicNecklace(RM25)
					case 9: Resultado2(iClientH, ItemType); break;
				}
				break;
			case 3: //Pandora Box Small
				iResult = iDice(1, 11);
				switch (iResult) {
					case 1: Resultado2(iClientH, ItemType); break;
					case 2: iItemID = 272; break; // SkinColorPotion
					case 3: iItemID = 650; break; // ZemstoneofSacrifice 
					case 4: iItemID = 656; break; // StoneOfXelima
					case 5: iItemID = 657; break; // StoneOfMerien 
					case 6: Resultado2(iClientH, ItemType); break;
					case 7: iItemID = 905; break; //905	MagicNecklace(RM20)
					case 8: iItemID = 897; break; //897	MagicNecklace(DM+3)
					case 9: iItemID = 893; break; //893	MagicNecklace(MS14)
					case 10: iItemID = 901; break; //901	MagicNecklace(DF+20)
					case 11: Resultado2(iClientH, ItemType); break;
				}
				break;
		}

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) delete pItem;
		else {
			_bAddClientItemList(iClientH, pItem, &iEraseReq);
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_ITEMOBTAINED, pItem, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Resultado1");
	}
#endif
}

//Item basico 24% de probabilidades!
void CMapServer::Resultado2(int iClientH, int ItemType)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iResult;
		char cMsg[120];

		if (m_pClientList[iClientH] == NULL) return;

		switch (ItemType) {
			//Pandora Box Big
			case 1:
				iResult = iDice(1, 4);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iEnemyKillCount += 100;//50
						wsprintf(cMsg, "You got 100 Enemy Kill Points");
						ShowClientMsg(iClientH, cMsg);
						SendEnemyKills(iClientH);
						break;
					case 2:
						m_pClientList[iClientH]->m_iRating += 100;//50
						wsprintf(cMsg, "You got 100 Reputation Points");
						if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
						break;

			//		case 3: Resultado1(iClientH, ItemType); break;
					case 3: Resultado3(iClientH, ItemType); break;
					case 4: Resultado4(iClientH, ItemType); break;
				}
				break;
				//Pandora Box Medium
			case 2:
				iResult = iDice(1, 4);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iEnemyKillCount += 50;//20
						wsprintf(cMsg, "You got 50 Enemy Kill Points");
						ShowClientMsg(iClientH, cMsg);
						SendEnemyKills(iClientH);
						break;
					case 2:
						m_pClientList[iClientH]->m_iRating += 50;//20
						wsprintf(cMsg, "You got 50 Reputation Points");
						if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
						break;
				//	case 3: Resultado1(iClientH, ItemType); break;
				//	case 4: Resultado3(iClientH, ItemType); break;
					case 3: Resultado3(iClientH, ItemType); break;
					case 4: Resultado4(iClientH, ItemType); break;
				}
				break;
				//Pandora Box Small
			case 3:
				iResult = iDice(1, 4);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iEnemyKillCount += 20;//10
						wsprintf(cMsg, "You got 20 Enemy Kill Points");
						ShowClientMsg(iClientH, cMsg);
						SendEnemyKills(iClientH);
						break;
					case 2:
						m_pClientList[iClientH]->m_iRating += 20;//10
						wsprintf(cMsg, "You got 20 Reputation Points");
						if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
						break;

				//	case 3: Resultado1(iClientH, ItemType); break;
				//	case 4: Resultado3(iClientH, ItemType); break;
					case 3: Resultado3(iClientH, ItemType); break;
					case 4: Resultado4(iClientH, ItemType); break;
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Resultado2");
	}
#endif
}
//Item basico 20% de probabilidades!
void CMapServer::Resultado3(int iClientH, int ItemType)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iResult;
		char cMsg[120];

		if (m_pClientList[iClientH] == NULL) return;

		switch (ItemType) {
			case 1:
				iResult = iDice(1, 3);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft +=500;//20
						wsprintf(cMsg, "You got 500 Majestics Points");
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						break;

				//	case 2: Resultado2(iClientH, ItemType); break;
				//	case 3: Resultado4(iClientH, ItemType); break;
					case 2: Resultado4(iClientH, ItemType); break;
					case 3: Resultado5(iClientH, ItemType); break;
				}
				break;
			case 2:
				iResult = iDice(1, 3);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 250;//10
						wsprintf(cMsg, "You got 250 Majestics Points");
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						break;

				//	case 2: Resultado2(iClientH, ItemType); break;
				//	case 3: Resultado4(iClientH, ItemType); break;
					case 2: Resultado4(iClientH, ItemType); break;
					case 3: Resultado5(iClientH, ItemType); break;
				}
				break;
			case 3:
				iResult = iDice(1, 3);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 100;//5
						wsprintf(cMsg, "You got 100 Majestics Points");
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						break;

				//	case 2: Resultado2(iClientH, ItemType); break;
				//	case 3: Resultado4(iClientH, ItemType); break;
					case 2: Resultado4(iClientH, ItemType); break;
					case 3: Resultado5(iClientH, ItemType); break;
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Resultado3");
	}
#endif
}
//Item basico 5% de probabilidades!
void CMapServer::Resultado4(int iClientH, int ItemType)
{
#ifdef DEF_DEBUG
	try {
#endif
		class  CItem * pItem;
		int iItemID = 0, iResult, iEraseReq;
		char cMsg[120];
		if (m_pClientList[iClientH] == NULL) return;

		switch (ItemType) {
			case 1:
				iResult = iDice(1, 7);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iEnemyKillCount += 120;//20
						wsprintf(cMsg, "You got 120 Enemy Kill Points");
						ShowClientMsg(iClientH, cMsg);
						SendEnemyKills(iClientH);
						break;
					case 2:
						m_pClientList[iClientH]->m_iRating += 120;
						wsprintf(cMsg, "You got 120 Reputation Points");//20
						if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
						break;

					case 3: iItemID = 734; break; // 734	RingofArcmage
					case 4: iItemID = 631; break; // 631	RingoftheAbaddon 
					case 5: iItemID = 858; break; // 858	NecklaceOfMerien 
					case 6: iItemID = 860; break; // 860	NecklaceOfXelima				
					case 7: Resultado5(iClientH, ItemType); break;
				//	case 7: Resultado3(iClientH, ItemType); break;
				}
				break;
			case 2:
				iResult = iDice(1, 6);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iEnemyKillCount += 60;//10
						wsprintf(cMsg, "You got 60 Enemy Kill Points");
						ShowClientMsg(iClientH, cMsg);
						SendEnemyKills(iClientH);
						break;
					case 2:
						m_pClientList[iClientH]->m_iRating += 60;
						wsprintf(cMsg, "You got 60 Reputation Points");
						if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
						break;

					case 3: iItemID = 3078; break; //3078	ContribBall(+10000)
					case 4:
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 250;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						wsprintf(cMsg, "You got 250 Majestics Points");
						ShowClientMsg(iClientH, cMsg);
						break;

					case 5: iItemID = 4909; break; // 4909	WhiteMWand(MS.60)
					case 6: Resultado5(iClientH, ItemType); break;
				//	case 6: Resultado3(iClientH, ItemType); break;
				}
				break;
			case 3:
				iResult = iDice(1, 6);
				switch (iResult) {
					case 1:
						m_pClientList[iClientH]->m_iEnemyKillCount += 30;
						wsprintf(cMsg, "You got 30 Enemy Kill Points");
						ShowClientMsg(iClientH, cMsg);
						SendEnemyKills(iClientH);
						break;
					case 2:
						m_pClientList[iClientH]->m_iRating += 30;
						wsprintf(cMsg, "You got 30 Reputation Points");
						if (m_pClientList[iClientH]->m_iRating > (DEF_LIMIT_REP * 1000))  m_pClientList[iClientH]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[iClientH]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[iClientH]->m_iRating = -(DEF_LIMIT_REP * 1000);
						ShowClientMsg(iClientH, cMsg);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
						break;

					case 3: iItemID = 3087; break; //3087	RepPotion(+100)

					case 4:
						m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += 100;//10
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						wsprintf(cMsg, "You got 100 Majestics Points");
						ShowClientMsg(iClientH, cMsg);
						break;

					case 5: iItemID = 3025; break; // 3025	ContribBall(+5000)
					case 6: Resultado5(iClientH, ItemType); break;
				//	case 6: Resultado3(iClientH, ItemType); break;
				}
				break;
		}

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) delete pItem;
		else {
			_bAddClientItemList(iClientH, pItem, &iEraseReq);
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_ITEMOBTAINED, pItem, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Resultado5");
	}
#endif
}

void CMapServer::Resultado5(int iClientH, int ItemType)
{
#ifdef DEF_DEBUG
	try {
#endif
		class  CItem * pItem;
		int iItemID, iResult, iEraseReq;

		if (m_pClientList[iClientH] == NULL) return;

		switch (ItemType) {
			case 1:
				iResult = iDice(1, 6);
				switch (iResult) {
					case 1: iItemID = 3079; break; //3079	ContribBall(+20000)
					case 2: iItemID = 3106; break; //3106	Coins(+500)
					case 3: iItemID = 3086; break; //3086	CriticalBall(+1000)
					case 4: iItemID = 3087; break; //3087	RepPotion(+100)
					case 5: iItemID = 3089; break; //3089	TintaMagica
				//	case 6: iItemID = 3083; break; //3083	PowerBarbarian
					case 6: iItemID = 2124; break; //2124	TintaCapa(Azul)
				//	case 8: iItemID = 611; break; //611	XelimaAxe
				/ *	case 5: Resultado4(iClientH, ItemType); break;
					case 6: Resultado3(iClientH, ItemType); break;
					case 7: Resultado2(iClientH, ItemType); break;
					case 8: Resultado1(iClientH, ItemType); break;* /
				}
				break;
			case 2:
				iResult = iDice(1, 6);
				switch (iResult) {
					case 1: iItemID = 3078; break; //3078	ContribBall(+10000)
					case 2: iItemID = 3105; break; //3105	Coins(+200)
					case 3: iItemID = 3085; break; //3085	CriticalBall(+100)
					case 4: iItemID = 3087; break; //3087	RepPotion(+100)
					case 5: iItemID = 3090; break; // 3090	TintaMagicaRoja
					//case 6: iItemID = 3084; break; //3084	PowerRapier
					case 6: iItemID = 2125; break; //2125	TintaCapa(Roja)
					//case 8: iItemID = 610; break; //610	XelimaBlade
				/ *	case 4: Resultado4(iClientH, ItemType); break;
					case 5: Resultado3(iClientH, ItemType); break;
					case 6: Resultado2(iClientH, ItemType); break;
					case 7: Resultado1(iClientH, ItemType); break;* /
				}
				break;
			case 3:
				iResult = iDice(1, 7);
				switch (iResult) {
					case 1: iItemID = 3025; break; //3025	ContribBall(+5000)
					case 2: iItemID = 3104; break; //3104	Coins(+100)
					case 3: iItemID = 3085; break; //3085	CriticalBall(+100)
					case 4: iItemID = 3087; break; //3087	RepPotion(+100)
					case 5: iItemID = 3746; break; //3746	Tinta Verde
					case 6: iItemID = 3761; break; //3761	TintaCapaVerde
					case 7: iItemID = 612; break; //612	XelimaRapier
				/ *	case 4: Resultado4(iClientH, ItemType); break;
					case 5: Resultado3(iClientH, ItemType); break;
					case 6: Resultado2(iClientH, ItemType); break;
					case 7: Resultado1(iClientH, ItemType); break;* /
				}
				break;
		}

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, iItemID) == FALSE) delete pItem;
		else {
			_bAddClientItemList(iClientH, pItem, &iEraseReq);
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_ITEMOBTAINED, pItem, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: Resultado5");
	}
#endif
}*/


int CMapServer::RollDice(int min, int max)
{
	auto roll = rand() % (max - min + 1) + min;
	return roll;
}

void CMapServer::PandoraBox(int client, short type)
{
	auto p = m_pClientList[client];
	if (!p) return;

	short sX = p->m_sX;
	short sY = p->m_sY;

	SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, p->m_cMapIndex, sX, sY, sX, sY, 114, p->m_sType);

	// Rango de recompensas por tipo de Pandora
	struct RewardRange
	{
		int minMajestic;
		int maxMajestic;
		int minReputation;
		int maxReputation;
		int minContribution;
		int maxContribution;
	};

	RewardRange rewardRanges[] = {
		{ 50, 175, 1, 5, 10, 100 },    // PANDORA_SMALL
		{ 200, 325, 15, 25, 50, 130 }, // PANDORA_MEDIUM
		{ 400, 575, 20, 40, 200, 300 } // PANDORA_BIG
	};

	if (type < PANDORA_SMALL || type > PANDORA_BIG) return;

	auto reward = rewardRanges[type];

	auto dado = iDice(1, 3);
	switch (dado)
	{
	case 1: {
		auto rew = RollDice(reward.minMajestic, reward.maxMajestic);
		p->m_iGizonItemUpgradeLeft += rew;
		SendCommand(client, "/majs", p->m_iGizonItemUpgradeLeft);
		wsprintf(G_cTxt, "You received %d majestics from the Pandora Box", rew);
		SendAlertMsg(client, G_cTxt);
		break;
	}

	case 2: {
		auto rew = RollDice(reward.minReputation, reward.maxReputation);
		p->m_iRating += rew;
		SendCommand(client, "/rep", p->m_iRating);
		wsprintf(G_cTxt, "You received %d reputation from the Pandora Box", rew);
		SendAlertMsg(client, G_cTxt);
		break;
	}

	case 3: {
		auto rew = RollDice(reward.minContribution, reward.maxContribution);
		p->m_iContribution += rew;
		SendCommand(client, "/contrib", p->m_iContribution);
		wsprintf(G_cTxt, "You received %d contribution from the Pandora Box", rew);
		SendAlertMsg(client, G_cTxt);
		break;
	}
	default: break;
	}
}


/*

void CMapServer::PandoraBox(int client, short type)
{
	auto p = m_pClientList[client];
	if (!p) return;

	enum Pandoras
	{
		PANDORA_SMALL,
		PANDORA_MEDIUM,
		PANDORA_BIG,
	};

	switch (type)
	{
	case PANDORA_SMALL:
	{
		auto dado = iDice(1, 3);
		switch (dado)
		{
		case 1: {
			auto rew = RollDice(10, 30);
			p->m_iGizonItemUpgradeLeft += rew;
			SendCommand(client, "/majestic", p->m_iGizonItemUpgradeLeft);
			wsprintf(G_cTxt, "You received %d majestics from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}

		case 2: {
			auto rew = RollDice(1, 5);
			p->m_iRating += rew;
			SendCommand(client, "/rep", p->m_iRating);
			wsprintf(G_cTxt, "You received %d reputation from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}

		case 3: {
			auto rew = RollDice(10, 100);
			p->m_iContribution += rew;
			SendCommand(client, "/contrib", p->m_iContribution);
			wsprintf(G_cTxt, "You received %d contribution from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}
		default: break;
		}
		break;
	}

	case PANDORA_MEDIUM:
	{
		auto dado = iDice(1, 3);
		switch (dado)
		{
		case 1: {
			auto rew = RollDice(50, 150);
			p->m_iGizonItemUpgradeLeft += rew;
			SendCommand(client, "/majestic", p->m_iGizonItemUpgradeLeft);
			wsprintf(G_cTxt, "You received %d majestics from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}

		case 2: {
			auto rew = RollDice(15, 25);
			p->m_iRating += rew;
			SendCommand(client, "/rep", p->m_iRating);
			wsprintf(G_cTxt, "You received %d reputation from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}

		case 3: {
			auto rew = RollDice(50, 130);
			p->m_iContribution += rew;
			SendCommand(client, "/contrib", p->m_iContribution);
			wsprintf(G_cTxt, "You received %d contribution from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}
		default: break;
		}
		break;
	}

	case PANDORA_BIG:
	{
		auto dado = iDice(1, 3);
		switch (dado)
		{
		case 1: {
			auto rew = RollDice(150, 250);
			p->m_iGizonItemUpgradeLeft += rew;
			SendCommand(client, "/majestic", p->m_iGizonItemUpgradeLeft);
			wsprintf(G_cTxt, "You received %d majestics from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}

		case 2: {
			auto rew = RollDice(20, 40);
			p->m_iRating += rew;
			SendCommand(client, "/rep", p->m_iRating);
			wsprintf(G_cTxt, "You received %d reputation from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}

		case 3: {
			auto rew = RollDice(200, 300);
			p->m_iContribution += rew;
			SendCommand(client, "/contrib", p->m_iContribution);
			wsprintf(G_cTxt, "You received %d contribution from the Pandora Box", rew);
			SendAlertMsg(client, G_cTxt);
			break;
		}
		default: break;
		}
		break;
	}
	default: break;
	}
	
}
*/

void CMapServer::AdminOrder_Portal(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		BOOL   bFlag;
		DWORD dwTime = timeGetTime();
		int PortalNum;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		if (PortalAbility[DEF_MAXPORTALS - 1] == TRUE) PortalNum = 0;
		else {
			// Bucle inverso, para buscar el portal no habilitado con el ID mas bajo :3
			for (int i = DEF_MAXPORTALS - 1; i > 0; i--) {
				if (PortalAbility[i] != TRUE) PortalNum = i;
			}
		}

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		//Indico el nombre del mapa
		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(Portal_MapName[PortalNum], sizeof(Portal_MapName[PortalNum]));
			strcpy_secure(Portal_MapName[PortalNum], token);
		}

		//Indico las coords de destino
		token = pStrTok->pGet();
		if (token != NULL) dest_dx_portal[PortalNum] = atoi(token);
		else dest_dx_portal[PortalNum] = NULL;

		token = pStrTok->pGet();
		if (token != NULL) dest_dy_portal[PortalNum] = atoi(token);
		else dest_dy_portal[PortalNum] = NULL;

		//Indico El tiempo de apertura del portal
		token = pStrTok->pGet();
		if (token != NULL) {
			dw_TimeOpenPortal[PortalNum] = atoi(token);
			if (dw_TimeOpenPortal[PortalNum] < 60) dw_TimeOpenPortal[PortalNum] *= 60000;
			else dw_TimeOpenPortal[PortalNum] *= 1000;
		}
		else dw_TimeOpenPortal[PortalNum] = 1000000;

		//Indico el nivel max del portal
		token = pStrTok->pGet();
		if (token != NULL) LevelLimit_portal[PortalNum] = atoi(token);
		else LevelLimit_portal[PortalNum] = 999;

		//Indico la cantidad maxima de players
		token = pStrTok->pGet();
		if (token != NULL) MaxPlayer_portal[PortalNum] = atoi(token);
		else MaxPlayer_portal[PortalNum] = -1;

		bFlag = FALSE;
		bFlag = CheckActiveMaps(Portal_MapName[PortalNum]);

		//si el mapa es correcto
		if (bFlag == TRUE) {
			if ((dest_dx_portal[PortalNum] != NULL) && (dest_dy_portal[PortalNum] != NULL)) {
				LastPortal = PortalNum;

				//Verifico las coords del GM y le agrego +2 de la posicion X, para que quede al lado
				ini_dx_portal[PortalNum] = m_pClientList[iClientH]->m_sX + 2;
				ini_dy_portal[PortalNum] = m_pClientList[iClientH]->m_sY;
				ZeroMemory(Portal_Init[PortalNum], sizeof(Portal_Init[PortalNum]));
				strcpy_secure(Portal_Init[PortalNum], m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
				PortalPlayers[PortalNum] = 0;

				dw_TimePortal[PortalNum] = dwTime - 500;
				PortalAbility[PortalNum] = TRUE;
				char cMsg[40];

				wsprintf(cMsg, "Portal N� %d abierto", PortalNum);
				ShowClientMsg(iClientH, cMsg);
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Portal");
	}
#endif
}
void CMapServer::ClosePortal(int PortalNum)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		PortalAbility[PortalNum] = FALSE;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (i >= 0 && i < DEF_MAXCLIENTS && m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear)
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_APOCGATECLOSE, PortalNum, ini_dx_portal[PortalNum], ini_dy_portal[PortalNum], m_pClientList[i]->m_cMapName);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClosePortal");
	}
#endif
}

void CMapServer::LocalStartRushNetMode()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (m_bIsRushNetMode || ActiveEvent) return;
		m_bIsRushNetMode = ActiveEvent = TRUE;

		DWORD dwTime = timeGetTime();
		dw_RushTime = dwTime - 100;

		m_iTowerElvine = m_iTowerAresden = ReliquiaAresden = ReliquiaElvine = EventCount[DEF_RUSH].LastWin = 0;
		AttackElvine = AttackAresden = FALSE;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_RUSH, 10, NULL, NULL, NULL, NULL);
		}

		CreateRushStructures();
		PutLogList("Rush Net Mode ON.");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalStartRushNetMode");
	}
#endif
}

void CMapServer::LocalEndRushNetMode(int Loser)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		SYSTEMTIME SystemTime;
		GetLocalTime(&SystemTime);

		if (m_bIsRushNetMode == FALSE) return;
		m_bIsRushNetMode = ActiveEvent = FALSE;

		PutLogList("Rush Mode OFF.");

		RemoveRushNetStructures();
		m_iTowerAresden = m_iTowerElvine = -1;
		UpdateRushNet(0);

		switch (Loser) {
			case 1: CreateEventResults(2, 2); break;
			case 2: CreateEventResults(1, 2); break;
			default: CreateEventResults(0, 2); break;
		}

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
					m_pMapList[i]->m_iMaximumObject = 900;
				if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
					m_pMapList[i]->m_iMaximumObject = 900;
			}
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				m_pClientList[i]->TotalStructuresKilled = 0;
				if (!m_pClientList[i]->Achivements[10].Complete)
					CheckCompleteAchivement(i, 10, TRUE);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_RUSH, Loser, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_RUSH, EventCount[DEF_RUSH].AresdenWin, EventCount[DEF_RUSH].ElvineWin, NULL, EventCount[DEF_RUSH].Draw, EventCount[DEF_RUSH].LastWin);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalEndRushNetMode");
	}
#endif
}

void CMapServer::UpdateRushNet(int Structure, bool Send)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z = 0;

		if (Structure == 1) {
			z = 3;
			AttackAresden = TRUE;
			CallMercenary(Structure);
		}
		else if (Structure == 2) {
			z = 4;
			AttackElvine = TRUE;
			CallMercenary(Structure);
		}

		if (Structure != 0) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_RUSH, z, NULL, NULL, NULL, NULL);
			}
		}
		SendHPStructures(1);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UpdateRushNet");
	}
#endif
}

void CMapServer::RemoveRushNetStructures()
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 35:
					case 38:
					case 39:
					case 87:
					case 89:
					case 92:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveRushNetStructures");
	}
#endif
}

BOOL CMapServer::bReadRushStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading rush configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  rush configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);

								if (m_stRushStructures[iIndex].cType != NULL) {
									ErrorList("(!!!) CRITICAL ERROR!  rush configuration file error - Duplicate potion number.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stRushStructures[iIndex].cMapName, sizeof(m_stRushStructures[iIndex].cMapName));
								memcpy_secure(m_stRushStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  rush configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stRushStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  rush configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stRushStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  rush configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stRushStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "rush-structure", 14) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! Rush Structure configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::CreateRushStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];
		char cOwnerType;
		short sOwner;
		bool Send = false;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

		for (i = 0; i < MAX_RUSHSTRUCTURES; i++) {
			if (m_stRushStructures[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stRushStructures[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							switch (m_stRushStructures[i].cType) {
								case 38:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0) strcpy_secure(cNpcName, "MS-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0) strcpy_secure(cNpcName, "MS-Elvine");
									break;

								case 39:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0) strcpy_secure(cNpcName, "DT-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0) strcpy_secure(cNpcName, "DT-Elvine");
									break;

								case 87:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0) strcpy_secure(cNpcName, "CT-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0) strcpy_secure(cNpcName, "CT-Elvine");
									break;

								case 89:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0) strcpy_secure(cNpcName, "AGC-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0) strcpy_secure(cNpcName, "AGC-Elvine");
									break;

								case 92:
									if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0) strcpy_secure(cNpcName, "Reliquia-a");
									else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0) strcpy_secure(cNpcName, "Reliquia-e");
									break;

								default:
									strcpy_secure(cNpcName, m_pNpcConfigList[m_stRushStructures[i].cType]->m_cNpcName);
									break;
							}

							tX = (int)m_stRushStructures[i].dX;
							tY = (int)m_stRushStructures[i].dY;

							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								if ((memcmp(cNpcName, "AGC-Aresden", 11) == 0) || (memcmp(cNpcName, "CT-Aresden", 10) == 0) || (memcmp(cNpcName, "MS-Aresden", 10) == 0) || (memcmp(cNpcName, "DT-Aresden", 10) == 0))
									m_iTowerAresden += 1;
								else if ((memcmp(cNpcName, "AGC-Elvine", 10) == 0) || (memcmp(cNpcName, "CT-Elvine", 9) == 0) || (memcmp(cNpcName, "MS-Elvine", 9) == 0) || (memcmp(cNpcName, "DT-Elvine", 9) == 0))
									m_iTowerElvine += 1;

								Send = true;
								wsprintf(G_cTxt, "Creating Rush Structure(%s) at %s(%d, %d)", cNpcName, m_stRushStructures[i].cMapName, tX, tY);
								PutLogList(G_cTxt);
							}
						}
					}
				}
			}
		}
		UpdateRushNet(0, Send);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateRushStructures");
	}
#endif
}

void CMapServer::GoldPorLevel(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet, iEraseReq, iWeightLeft;
		DWORD * dwp;
		WORD  * wp;
		char  * cp, cData[100], cItemName[21];
		class CItem * pItem;
		short * sp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

		if (iWeightLeft <= 0) return;
		iWeightLeft = iWeightLeft / 2;
		if (iWeightLeft <= 0) return;

		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		wsprintf(cItemName, "Gold");
		_bInitItemAttr(pItem, cItemName);
		if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= 300) {
			pItem->m_dwCount = 300;
		}

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy_secure(cp, pItem->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0;
			cp++;

			sp = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			//cp++;
			//cambio lalomanu
			sp = (short *)cp;
			*sp = pItem->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			//lalomanu
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);


			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMOBTAINED, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GoldPorLevel");
	}
#endif
}

void CMapServer::GetMajesticsItemsHandler(int iClientH, int iItemID, char * pString)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   i, iNum, iRet, iEraseReq;
		char  * cp, cData[256], cItemName[21];
		class CItem * pItem;
		DWORD * dwp;
		short * sp;
		WORD  * wp;
		BOOL AddID = FALSE;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->Assasain == FALSE) {
			if (m_pClientList[iClientH]->m_cSide == 0 && m_pClientList[iClientH]->Assasain == FALSE) return;
		}
		if (_iGetItemSpaceLeft(iClientH) == 0) {
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}

		//Prevents a crash if item dosent exist
		if (m_pItemConfigList[iItemID] == NULL)  return;

		switch (iItemID) {
			//Angelics
			case 911:	//AngelicPandent(STR)
			case 912:	//AngelicPandent(DEX)
			case 913:	//AngelicPandent(INT)
			case 914:	//AngelicPandent(MAG)
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5) return;
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
				AddID = TRUE;
				break;

			case 2600: //NetBox(Big)
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 500) return;
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 500;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
				break;

			case 2601: //NetBox(Medium)
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 250) return;
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 250;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
				break;

			case 2602: //NetBox(Small)
				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 100) return;
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 100;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
				break;

			default:
				return;
				break;
		}

		if (m_pClientList[iClientH] == NULL) return;
		ZeroMemory(cItemName, sizeof(cItemName));
		memcpy_secure(cItemName, m_pItemConfigList[iItemID]->m_cName, 20);

		iNum = 1;
		for (i = 1; i <= iNum; i++) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) delete pItem;
			else {
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0)
						m_pClientList[iClientH]->m_iCurWeightLoad = 0;
	//				wsprintf(G_cTxt, "(*)Trade Mjs: Char(%s) EK(%d) Item(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, cItemName);
	//				CharacterLogList(G_cTxt);

					if (AddID) {
						pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
					}
					else {
						pItem->m_sTouchEffectType = DEF_ITET_ID;
						pItem->m_sTouchEffectValue1 = iDice(1, 100000);

						// Anti Dup System
						SYSTEMTIME SysTime;
						char cTemp[256];
						GetLocalTime(&SysTime);
						ZeroMemory(cTemp, sizeof(cTemp));
						pItem->m_sTouchEffectValue2 = iDice(1, 100000);
						wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
						pItem->m_sTouchEffectValue2 = atoi(cTemp);

						ZeroMemory(cTemp, sizeof(cTemp));
						wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
						pItem->m_sTouchEffectValue3 = atoi(cTemp);
					}

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMOBTAINED;
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0;
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

				//	*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				//	cp++;
					//cambio lalomanu
					sp = (short *)cp;
					*sp = pItem->m_sItemSpecEffectValue2;
					cp += 2;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;

					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;

					if (iEraseReq == 1) delete pItem;

					//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
					//lalomanu
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);

					iCalcTotalWeight(iClientH);

					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
				else {
					delete pItem;

					iCalcTotalWeight(iClientH);
					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetMajesticsItemsHandler");
	}
#endif
}

void CMapServer::ZerkMe(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char ErrorText[64];

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < ZERK_ME_MAJESTICS) {
			wsprintf(ErrorText, "Necesitas %d para conseguir el efecto", ZERK_ME_MAJESTICS);
			ShowClientMsg(iClientH, ErrorText);
			return;
		}

		m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = (char)1;
		SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);

		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK,
			timeGetTime() + ZERK_ME_DURATION * 1000, iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);

		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= ZERK_ME_MAJESTICS;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);

		ShowClientMsg(iClientH, "Te sientes un guerrero heroico!");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ZerkMe");
	}
#endif
}

void CMapServer::ManaMe(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char ErrorText[64];

		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < MANA_ME_MAJESTICS) {
			wsprintf(ErrorText, "Necesitas %d para conseguir el efecto", MANA_ME_MAJESTICS);
			ShowClientMsg(iClientH, ErrorText);
			return;
		}

		m_pClientList[iClientH]->m_bManaMe = TRUE;
		m_pClientList[iClientH]->m_dwManaMe = timeGetTime();

		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= MANA_ME_MAJESTICS;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);

		SetSlateFlag(iClientH, 3, TRUE);
		ShowClientMsg(iClientH, "Te sientes un experto en magia!");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ManaMe");
	}
#endif
}

void CMapServer::PlayerOrder_ChangeCity(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		int iAres = 0, iElv = 0;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iLevel < DEF_PLAYERMAXLEVEL) return;
		if (AllVsAll == TRUE) {
			ShowClientMsg(iClientH, "Durante el Evento, no podras cambiar de ciudad");
			return;
		}
		//Capture The Flag
		if (m_bIsCTFMode == TRUE) {
			ShowClientMsg(iClientH, "Durante el Evento, no podras cambiar de ciudad");
			return;
		}
		if (m_pClientList[iClientH]->Assasain == TRUE) {
			ShowClientMsg(iClientH, "Eres Assassin, no podras cambiar de ciudad");
			return;
		}
		if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "MBarracks", 9) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "EventMap", 8) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ABarracks", 9) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "EBarracks", 9) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "market", 6) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "default", 7) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "bisle", 5) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "NewEvent", 8) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ESAresden", 9) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ESAssasain", 10) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "ESElvine", 8) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "BtField", 7) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "Counter", 7) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "areuni", 6) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "WorldMap", 8) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "evento13", 8) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "evento14", 8) == 0) ||
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "FightMap", 8) == 0))	{
			ShowClientMsg(iClientH, "En este mapa, no podras cambiar de ciudad");
			return;
		}


		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if ((m_pClientList[i]->m_iStatus & 0x00000008) == 0)
				{
					if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (m_pClientList[i]->NoClear == FALSE)) iAres++;
					else if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (m_pClientList[i]->NoClear == FALSE)) iElv++;
				}
			}
		}

		if ((iAres - iElv) > 5) { // Si es elvine, e intenta hacerse aresden
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
				ShowClientMsg(iClientH, "Hay demasiados aresden, no podras cambiar de ciudad");
				return;
			}
		}

		if ((iElv - iAres) > 5) { // Si es aresden, e intenta hacerse elvine
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
				ShowClientMsg(iClientH, "Hay demasiados elvine, no podras cambiar de ciudad");
				return;
			}
		}
		
		/*if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft >= 1000) && (m_pClientList[iClientH]->m_iEnemyKillCount >= 1000) &&
			(m_pClientList[iClientH]->m_iCoins >= 1000)) {
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 1000;
			m_pClientList[iClientH]->m_iEnemyKillCount -= 1000;
			m_pClientList[iClientH]->m_iCoins -= 1000;*/
		if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft >= 300) {
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 300;

			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);

			if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
				strcpy_secure(m_pClientList[iClientH]->m_cLocation, "elvine");
				m_pClientList[iClientH]->m_cSide = 2;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
				strcpy_secure(m_pClientList[iClientH]->m_cLocation, "aresden");
				m_pClientList[iClientH]->m_cSide = 1;
			}
			ChangeHeroSide(iClientH);
			//Agregado deleted guild
			if (m_pClientList[iClientH]->m_iGuildRank != -1) {
				if (m_pClientList[iClientH]->m_iGuildRank == 0) {
					bSendMsgToLS(NUCLEO_REQUEST_DISBANDGUILD, iClientH);
				}
				else
				{
					RemoveFromGuild(iClientH);
				/*	m_pClientList[iClientH]->m_iGuildRank = -1;
					m_pClientList[iClientH]->m_iGuildGUID = -1;
					strcpy_secure(m_pClientList[iClientH]->m_cGuildName, "NONE");*/
				}
			}


			bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
			ShowClientMsg(iClientH, "Te has vendido, te recordaran como un traidor!");
			wsprintf(G_cTxt, "Player(%s) Request ChangeCity", m_pClientList[iClientH]->m_cCharName);
			PutLogList(G_cTxt);
			//Antipull
			m_pClientList[iClientH]->NoDelete = FALSE;

			m_pClientList[iClientH]->m_bForceDisconnect = true;
			//Aca agregar lalo
			DeleteClient(iClientH, true, true);
		}
		else ShowClientMsg(iClientH, "Necesitas 200 Magesticks!");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: PlayerOrder_ChangeCity");
	}
#endif
}

/*void CGame::DropItemID(int iClientH, short ItemPos, int iItemID, int iX, int iY, int dwType, int dwValue, int cColor, int Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		pItem = new class CItem;
		short Value1, Value2;
		int Value3, EffectValue2;
		int iEraseReq;
	//	int EffectValue1;

		Value1 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectValue1;
		Value2 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectValue2;
		Value3 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectValue3;

		EffectValue2 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sItemSpecEffectValue2;
		//EffectValue1 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sItemSpecEffectValue1;

		if (_bInitItemAttr(pItem, iItemID) == FALSE) delete pItem;
		else {
			ItemDepleteHandler(iClientH, ItemPos, FALSE, FALSE);
			if (Type == 1) {
				pItem->m_dwAttribute = NULL;
				dwType = dwType << 20;
				dwValue = dwValue << 16;
				pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
			}
			else if (Type == 2) {
				dwType = dwType << 12;
				dwValue = dwValue << 8;
				pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
			}

			pItem->m_sTouchEffectValue1 = Value1;
			pItem->m_sTouchEffectValue2 = Value2;
			pItem->m_sTouchEffectValue3 = Value3;
			pItem->m_sItemSpecEffectValue2 = EffectValue2;

			/*switch (iItemID) {
				case 620: //MerienShield
				case 621: //MerienPlateM
					break;
				default:
			//		pItem->m_cItemColor = cColor;
					break;
			}*//*
			//agregado
			pItem->m_cItemColor = cColor;
			//pItem->m_sItemSpecEffectValue1 = EffectValue1;

			_bAddClientItemList(iClientH, pItem, &iEraseReq);
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_ITEMOBTAINED, pItem, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DropItemID");
	}
#endif
}*/

void CMapServer::DropItemID(int iClientH, short ItemPos, int iItemID, int iX, int iY, int dwType, int dwValue, int cColor, int Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		pItem = new class CItem;
		// Gaby - Agrego las variables que quiero mantener 
		short TouchEffectType, TouchEffectValue1, TouchEffectValue2;
		int TouchEffectValue3, ItemSpecEffectValue1, ItemSpecEffectValue2, ItemSpecEffectValue3;
		//int iEraseReq;
		int iEraseReq, iValue;
		int  CurLifeSpan, MaxLifeSpan;
		//DWORD Attribute;
		DWORD Attribute, dwTemp;

		if (m_pClientList[iClientH] == NULL) return;

		// Gaby - Guardo los datos del item original
		TouchEffectType = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectType;
		TouchEffectValue1 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectValue1;
		TouchEffectValue2 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectValue2;
		TouchEffectValue3 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sTouchEffectValue3;
		ItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sItemSpecEffectValue1;
		ItemSpecEffectValue2 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sItemSpecEffectValue2;
		ItemSpecEffectValue3 = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_sItemSpecEffectValue3;
		MaxLifeSpan = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_wMaxLifeSpan;
		CurLifeSpan = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_wCurLifeSpan;
		Attribute = m_pClientList[iClientH]->m_pItemList[ItemPos]->m_dwAttribute;

		// Gaby - Elimino el atributo anterior de cada dato
		// Con esto elimino todos los atributos anteriores.
		Attribute = Attribute & 0xFF0FFFFF; // pos 20
		Attribute = Attribute & 0xFFF0FFFF; // pos 16 
		Attribute = Attribute & 0xFFFF0FFF; // pos 8 ESTO ES LIGHT OSEA NO JUSTO ESTO, PERO SON LOS STATS VARIOS PORQUE LA STONE SOLO MANTIEENE 1 A LA VEZ
		Attribute = Attribute & 0xFFFFF0FF; // pos 6
		Attribute = Attribute & 0xFFFFFFFE; //agregado lalo sacar completion estimo que esta linea saca ese atributo +1 q te mostraba en el txt


		if (_bInitItemAttr(pItem, iItemID) == FALSE) delete pItem;
		else {
			ItemDepleteHandler(iClientH, ItemPos, FALSE, FALSE);

			if (Type == 1) {
				/* Gaby - Le saca el +10 a los items */
				if (dwType == 9) { // ancient es 9, si es ancient le saca las +10 
					Attribute = (Attribute & 0xF0000000) >> 28;
					Attribute = Attribute & 0xFFFFFFFE; //agregado lalo sacar completion
					dwTemp = Attribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					pItem->m_dwAttribute = dwTemp | (Attribute << 28);
				}
					// Si lo dejo activo, podrian sumarse los stats ( Sharp + Hitting )
					//Attribute = Attribute & 0xFF0FFFFF;
					//Attribute = Attribute & 0xFFF0FFFF;

					dwType = dwType << 20;
					dwValue = dwValue << 16;
					// Gaby - Le asigno los nuevos atributos a los items
					pItem->m_dwAttribute = Attribute | dwType | dwValue;

			}
			else if (Type == 2) {
				// Gaby - Elimino el atributo anterior de cada datonono el tipe 2 q seria cad o hit
				
				// Si lo dejo activo, podrian sumarse los stats ( Sharp + Hitting )
				//Attribute = Attribute & 0xFFFF0FFF;
				//Attribute = Attribute & 0xFFFFF0FF;

				dwType = dwType << 12;
				dwValue = dwValue << 8;
				// Gaby - Le asigno los nuevos atributos a los items
				pItem->m_dwAttribute = Attribute | dwType | dwValue;
			}


			// Gaby - Asigno los datos del item original al nuevo item
			/* Gaby - Si el item tenia endu y se lo saque, hay que sacarselo. */
			/*if (dwType == 9) { // No se cual es sharp, ancient, o el que te da endu jaja
				pItem->m_wCurLifeSpan = CurLifeSpan;
				pItem->m_wMaxLifeSpan = MaxLifeSpan;
			}*/
			pItem->m_wCurLifeSpan = CurLifeSpan;
			pItem->m_wMaxLifeSpan = MaxLifeSpan;
			pItem->m_sTouchEffectType = TouchEffectType;
			pItem->m_sTouchEffectValue1 = TouchEffectValue1;
			pItem->m_sTouchEffectValue2 = TouchEffectValue2;
			pItem->m_sTouchEffectValue3 = TouchEffectValue3;
			pItem->m_sItemSpecEffectValue1 = ItemSpecEffectValue1;
			pItem->m_sItemSpecEffectValue2 = ItemSpecEffectValue2;
			pItem->m_sItemSpecEffectValue3 = ItemSpecEffectValue3;


			/*switch (iItemID) {
			case 620:
			case 621:
			case 622:
			case 2090:
			case 4972:
			case 4973:
			case 4974:
			case 4975:
			case 4976:
			case 4977:
				break;
			default:
				pItem->m_cItemColor = cColor;
				break;
			}*/
			pItem->m_cItemColor = cColor;
			_bAddClientItemList(iClientH, pItem, &iEraseReq);
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_ITEMOBTAINED, pItem, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DropItemID");
	}
#endif
}

void CMapServer::SummonCelebrate(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char seps[] = "= \t\n";
		char cOwnerType;
		short sOwnerH, sType;
		int	dX1, dY1, dX2, dX3, dY2, dY3;
		int ix, iy;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

		sType = 14;

		dX1 = m_pClientList[iClientH]->m_sX;
		dX2 = m_pClientList[iClientH]->m_sX - 1;
		dX3 = m_pClientList[iClientH]->m_sX + 1;

		dY1 = m_pClientList[iClientH]->m_sY;
		dY2 = m_pClientList[iClientH]->m_sY - 1;
		dY3 = m_pClientList[iClientH]->m_sY + 1;

		switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_HPUP_SPOT:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX1, dY1);
				Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);

				SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX1, dY1, (sType + 100), m_pClientList[iClientH]->m_sType);

				break;
			case DEF_MAGICTYPE_SPDOWN_AREA:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX1, dY1);

				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, 95) == FALSE) {
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
				}

				for (iy = (dY1 - m_pMagicConfigList[sType]->m_sValue3); iy <= (dY1 + m_pMagicConfigList[sType]->m_sValue3); iy++) {
					for (ix = (dX1 - m_pMagicConfigList[sType]->m_sValue2); ix <= (dX1 + m_pMagicConfigList[sType]->m_sValue2); ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);

						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, 95) == FALSE) {
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
						SendEventToNearClient_TypeB(CLIENT_COMMON_EVENT, CLIENT_COMMON_MAGIC, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX1, dY1, (sType + 100), m_pClientList[iClientH]->m_sType);
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SummonCelebrate");
	}
#endif
}

// Plant The Flag Capture The Flag
void CMapServer::StartCaptureTheFlag()
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_bIsCTFMode || ActiveEvent) return;

		DWORD dwTime = timeGetTime();
		dw_CaptureTime = dwTime - 500;

		ActiveEvent = m_bIsCTFMode = true;
		m_sElvineFlagCount = m_sAresdenFlagCount = 0;
		m_bIsElvineFlagCaptured = m_bIsAresdenFlagCaptured = false;

		ActualizarCountFlag(1);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartCaptureTheFlag");
	}
#endif
}

void CMapServer::RequestCheckFlag(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!m_bIsCTFMode) return;
		if (m_pClientList[iClientH] == NULL) return;
		//Check LaloFlag
		if (m_pClientList[iClientH]->m_iHP <= 0) return;

		if ((m_pClientList[iClientH]->m_sX == 151) && (m_pClientList[iClientH]->m_sY == 132) &&
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)) { //Elvine Flag Cords
			if (m_pClientList[iClientH]->m_iLevel >= 100) {
				if (m_pClientList[iClientH]->m_cSide == 1) { //Aresden Side
					if ((!m_bIsAresdenFlagCaptured) && (!m_bIsElvineFlagCaptured)) //Aresden Capture Elvine Flag
						SetFlagCarrierFlag(iClientH, true);
				}
				else { //Elvine Side
					if ((m_bIsAresdenFlagCaptured) && (!m_bIsElvineFlagCaptured)) {
						if (bCheckIfIsFlagCarrier(iClientH)) {
							m_pClientList[iClientH]->m_iEnemyKillCount += 20;//20
							SendEnemyKills(iClientH);
							m_sElvineFlagCount++;
							m_bIsAresdenFlagCaptured = false;

							//Agregado - ZeroEoyPnk
							SetFlagCarrierFlag(iClientH, false);
							ActualizarCountFlag(6);

							if (m_sElvineFlagCount == 10) EndCaptureTheFlag(2);
						}
					}
				}
			}
			else RequestTeleportHandler(iClientH, "2   ", "elvine", -1, -1);
		}
		else if ((m_pClientList[iClientH]->m_sX == 151) && (m_pClientList[iClientH]->m_sY == 128) &&
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 6) == 0)) { //Aresden Flag Cords
			if (m_pClientList[iClientH]->m_iLevel >= 100) {
				if (m_pClientList[iClientH]->m_cSide == 2) { //Elvine Side
					if ((!m_bIsAresdenFlagCaptured) && (!m_bIsElvineFlagCaptured)) //Elvine Capture Aresden Flag
						SetFlagCarrierFlag(iClientH, true);
				}
				else { //Aresden Side
					if ((m_bIsElvineFlagCaptured) && (!m_bIsAresdenFlagCaptured)) {
						if (bCheckIfIsFlagCarrier(iClientH)) {
							m_pClientList[iClientH]->m_iEnemyKillCount += 20;//20
							SendEnemyKills(iClientH);
							m_sAresdenFlagCount++;
							m_bIsElvineFlagCaptured = false;

							//Agregado - ZeroEoyPnk
							SetFlagCarrierFlag(iClientH, false);
							ActualizarCountFlag(7);

							if (m_sAresdenFlagCount == 10) EndCaptureTheFlag(1);
						}
					}
				}
			}
			else RequestTeleportHandler(iClientH, "2   ", "aresden", -1, -1);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestCheckFlag");
	}
#endif
}

BOOL CMapServer::bCheckIfIsFlagCarrier(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (!m_bIsCTFMode) return false;
		if (m_iFlagCarrierIndex == -1) return false;
		if (m_pClientList[iClientH] == NULL) return false;

		if (iClientH == m_iFlagCarrierIndex) return true;
		else return false;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bCheckIfIsFlagCarrier");
	}
#endif
	return false;
}

void CMapServer::SetFlagCarrierFlag(int iClientH, BOOL bFlagMode)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!m_bIsCTFMode) return;
		if (m_pClientList[iClientH] == NULL) return;

		if (bFlagMode) {
			PutLogList("Capture The Flag: New Flag Carrier!");
			m_iFlagCarrierIndex = iClientH;
			if (m_pClientList[iClientH]->m_cSide == 1) {
				m_bIsElvineFlagCaptured = true;
				ActualizarCountFlag(2);
			}
			else {
				m_bIsAresdenFlagCaptured = true;
				ActualizarCountFlag(3);
			}
			if (m_pClientList[iClientH]->m_cSide == 1) m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x40000; //Elvine Flag - New Status ZeroEoyPnk
			else if (m_pClientList[iClientH]->m_cSide == 2) m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x80000; //Aresden Flag - New Status ZeroEoyPnk

			m_pClientList[iClientH]->TimeFlagCarrier = timeGetTime();
		}
		else {
			m_iFlagCarrierIndex = -1;
			if (m_pClientList[iClientH]->m_cSide == 1) {
				m_bIsElvineFlagCaptured = false;
				ActualizarCountFlag(4);
			}
			else {
				m_bIsAresdenFlagCaptured = false;
				ActualizarCountFlag(5);
			}

			SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
			if ((m_pClientList[iClientH]->m_iStatus & 0x40000) != 0) m_pClientList[iClientH]->m_iStatus &= 0xFFFBFFFF; // New Reset Status ZeroEoyPnk 
			else if ((m_pClientList[iClientH]->m_iStatus & 0x80000) != 0) m_pClientList[iClientH]->m_iStatus &= 0xFFF7FFFF; // New Reset Status ZeroEoyPnk 

			m_pClientList[iClientH]->TimeFlagCarrier = -1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetFlagCarrierFlag");
	}
#endif
}
void CMapServer::EndCaptureTheFlag(short Winner)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!m_bIsCTFMode) return;

		switch (Winner) {
			case 0://Finished by GM
				CreateEventResults(0, 1);
				ActualizarCountFlag(0);
				break;
			case 1://Aresden Win
				CreateEventResults(1, 1);
				ActualizarCountFlag(9);
				break;
			case 2://Elvine Win
				CreateEventResults(2, 1);
				ActualizarCountFlag(8);
				break;
		}

		ActiveEvent = m_bIsCTFMode = m_bIsElvineFlagCaptured = m_bIsAresdenFlagCaptured = false;
		m_sElvineFlagCount = m_sAresdenFlagCount = 0;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndCaptureTheFlag");
	}
#endif
}

void CMapServer::ActualizarCountFlag(short Flag, BOOL Client)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (Client == FALSE) {
			for (int i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CAPTURETHEFLAG, Flag, NULL, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_FLAGCOUNTER, m_sAresdenFlagCount, m_sElvineFlagCount, m_bIsElvineFlagCaptured, NULL, m_bIsAresdenFlagCaptured, NULL);
					if (Flag == 0 || Flag == 8 || Flag == 9)
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_CTF, EventCount[DEF_CTF].AresdenWin, EventCount[DEF_CTF].ElvineWin, NULL, EventCount[DEF_CTF].Draw, EventCount[DEF_CTF].LastWin);
				}
			}
		}
		else if (m_pClientList[Flag] != NULL) {
			SendNotifyMsg(NULL, Flag, CLIENT_NOTIFY_CAPTURETHEFLAG, 1, NULL, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, Flag, CLIENT_NOTIFY_FLAGCOUNTER, m_sAresdenFlagCount, m_sElvineFlagCount, m_bIsElvineFlagCaptured, NULL, m_bIsAresdenFlagCaptured, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActualizarCountFlag");
	}
#endif
}

void CMapServer::InitTowerDefence()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (TowerDefense || ActiveEvent) return;
		DWORD dwTime = timeGetTime();

		TowerDefense = ActiveEvent = TRUE;
		FlagElvine = FlagAresden = FALSE;
		dw_TowerTime = dwTime - 100;

		m_iTowerDefenceElvine = m_iTowerDefenceAresden = 0;

		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOWERDEFENCE, 10, NULL, NULL, NULL, NULL);
		}

		CreateTowerAresden();
		CreateTowerElvine();
		PutLogList("Tower Defence Mode ON.");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitTowerDefence");
	}
#endif
}

void CMapServer::EndTowerDefenceMode(int Loser)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (TowerDefense == FALSE) return;
		TowerDefense = FlagElvine = FlagAresden = ActiveEvent = FALSE;

		PutLogList("Tower Defence Mode OFF.");
		RemoveTowerStructures();

		m_iTowerDefenceAresden = m_iTowerDefenceElvine = -1;
		UpdateTowerDefence(0);

		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				m_pClientList[i]->TotalStructuresKilled = 0;
				if (!m_pClientList[i]->Achivements[10].Complete) CheckCompleteAchivement(i, 10, TRUE);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOWERDEFENCE, Loser, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_TD, EventCount[DEF_TD].AresdenWin, EventCount[DEF_TD].ElvineWin, NULL, EventCount[DEF_TD].Draw, EventCount[DEF_TD].LastWin);
			}
		}

		EndTowerDefenseTime();
		CreateEventResults(Loser, 3);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndTowerDefenceMode");
	}
#endif
}

void CMapServer::UpdateTowerDefence(int Structure)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (Structure != 0) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOWERDEFENCE, Structure, NULL, NULL, NULL, NULL);
			}
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TD_STRUCTURES, m_iTowerDefenceAresden, m_iTowerDefenceElvine, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UpdateTowerDefence");
	}
#endif
}

void CMapServer::RemoveTowerStructures()
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 87:
					case 89:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveTowerStructures");
	}
#endif
}

void CMapServer::CreateTowerAresden()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

		for (i = 0; i < MAX_DEFENCESTRUCTURES; i++) {
			if (m_stDefenceStructures[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stDefenceStructures[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							switch (m_stDefenceStructures[i].cType) {
								case 87: if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_TOWERDEFENSE) == 0) strcpy_secure(cNpcName, "CT-Aresden"); break;
								case 89: if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_TOWERDEFENSE) == 0) strcpy_secure(cNpcName, "AGC-Aresden"); break;
								default: strcpy_secure(cNpcName, m_pNpcConfigList[m_stDefenceStructures[i].cType]->m_cNpcName);  break;
							}

							tX = (int)m_stDefenceStructures[i].dX;
							tY = (int)m_stDefenceStructures[i].dY;
							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								if ((memcmp(cNpcName, "AGC-Aresden", 10) == 0) || (memcmp(cNpcName, "CT-Aresden", 9) == 0)) m_iTowerDefenceAresden += 1;

								wsprintf(G_cTxt, "Creating Structure(%d - Aresden) at %s(%d, %d)", m_stDefenceStructures[i].cType, m_stDefenceStructures[i].cMapName, tX, tY);
								PutLogList(G_cTxt);
							}
						}
					}
				}
			}
		}
		UpdateTowerDefence(0);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateTowerAresden");
	}
#endif
}

void CMapServer::CreateTowerElvine()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

		for (i = 0; i < MAX_DEFENCESTRUCTURES; i++) {
			if (m_stDefenceStructuresx[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stDefenceStructuresx[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							switch (m_stDefenceStructuresx[i].cType) {
								case 87: if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_TOWERDEFENSE) == 0) strcpy_secure(cNpcName, "CT-Elvine"); break;
								case 89: if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_TOWERDEFENSE) == 0) strcpy_secure(cNpcName, "AGC-Elvine"); break;

								default: strcpy_secure(cNpcName, m_pNpcConfigList[m_stDefenceStructuresx[i].cType]->m_cNpcName); break;
							}

							tX = (int)m_stDefenceStructuresx[i].dX;
							tY = (int)m_stDefenceStructuresx[i].dY;
							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								if ((memcmp(cNpcName, "AGC-Elvine", 10) == 0) || (memcmp(cNpcName, "CT-Elvine", 9) == 0)) m_iTowerDefenceElvine += 1;

								wsprintf(G_cTxt, "Creating Structure(%d - Elvine) at %s(%d, %d)", m_stDefenceStructuresx[i].cType, m_stDefenceStructuresx[i].cMapName, tX, tY);
								PutLogList(G_cTxt);
							}
						}
					}
				}
			}
		}
		UpdateTowerDefence(0);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateTowerElvine");
	}
#endif
}

BOOL CMapServer::bReadTDStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		ErrorList("Cannot open Tower Defence configuration file.");
		return FALSE;
	}
	else {
		PutLogList("Reading Tower Defense configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Tower Defence configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stDefenceStructures[iIndex].cMapName, sizeof(m_stDefenceStructures[iIndex].cMapName));
								memcpy_secure(m_stDefenceStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stDefenceStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stDefenceStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stDefenceStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;
					case 2:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stDefenceStructuresx[iIndex].cMapName, sizeof(m_stDefenceStructuresx[iIndex].cMapName));
								memcpy_secure(m_stDefenceStructuresx[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stDefenceStructuresx[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stDefenceStructuresx[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Heldenian configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stDefenceStructuresx[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "structure", 9) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "structurs", 9) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! Tower Defence Structure configuration file contents error!");
			return FALSE;
		}
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CMapServer::CheckActiveMaps(char * pMapName)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  cTmpName[11];
		int i = 0;
		BOOL Respuesta = FALSE;

		ZeroMemory(cTmpName, sizeof(cTmpName));
		strcpy_secure(cTmpName, pMapName);

		if (strlen(cTmpName) > 10) return FALSE;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (MapList[i] != NULL) {
				if (memcmp(MapList[i], cTmpName, 10) == 0)
					Respuesta = TRUE;
			}
		}
		return Respuesta;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckActiveMaps");
	}
#endif
	return FALSE;
}

void CMapServer::ParseCommand(char* pMsg)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (pMsg == NULL) return;

		char   seps[] = "= \t\n";
		char   * token, *token2;
		class  CStrTok * pStrTok;
		char * cName[11];
		char buff[256];
		BOOL bFlag;
		int i;

		pStrTok = new class CStrTok(pMsg, seps);
		token = pStrTok->pGet();
		token2 = pStrTok->pGet();
		bFlag = false;

		ZeroMemory(cName, sizeof(cName));

		if (memcmp(pMsg, "/ascii ", 7) == 0) {
			bFlag = TRUE;
			char znak[1];
			memcpy_secure(znak, token, 1);
			wsprintf(buff, "AscII%d/%s.txt", znak[0], token);
			PutLogList(buff);
		}

		if (memcmp(pMsg, "/say ", 5) == 0) {
			bFlag = TRUE;
			char ss[256];
			ZeroMemory(ss, 256);
			memcpy_secure(ss, pMsg, strlen(pMsg));
			ss[0] = ' ';
			ss[1] = ' ';
			ss[2] = ' ';
			ss[3] = ' ';
			int i;
			char*p = ss;
			while (isspace(*p) && (*p))p++;
			memmove(ss, p, strlen(p) + 1);
			wsprintf(ss, "%s", ss);
			int do_ilu;
			do_ilu = 0;
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {
					ShowClientMsg(i, ss);
					do_ilu++;
				}
			}

			char buff[256];
			wsprintf(buff, "Server: %s", ss);
			ChatLogs(buff);
		}

		if (memcmp(pMsg, "/user+", 6) == 0) {
			bFlag = TRUE;
			m_iAddUser += 3;
			wsprintf(G_cTxt, "Added: 3 -> Total Added: %d", m_iAddUser);
			PutLogList(G_cTxt);
		}

		if (memcmp(pMsg, "/user-", 6) == 0) {
			bFlag = TRUE;
			m_iAddUser -= 3;
			wsprintf(G_cTxt, "Discount: 3 -> Total Added: %d", m_iAddUser);
			PutLogList(G_cTxt);
		}

		if (memcmp(pMsg, "/happyday", 9) == 0) {
			LocalStarHappyDay(true);
			PutLogList("Happy Day On!");
		}

		if ((!bFlag) && (pMsg != NULL)) {
			wsprintf(buff, "(!!!) %s - Comando Invalido", pMsg);
			PutLogList(buff);
		}

		if (memcmp(pMsg, "/check ", 6) == 0) {
			bFlag = true;

			if (token2 != NULL) {
				ZeroMemory(cName, sizeof(cName));
				memcpy_secure(cName, token2, 11);
			}

			if (cName != NULL) {
				for (i = 1; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
						ZeroMemory(buff, sizeof(buff));
						wsprintf(buff, "%s :    Str:%d  Dex:%d  Vit:%d  Int:%d  Mag:%d  Chr:%d    Map:%s - %i , %i", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_iStr, m_pClientList[i]->m_iDex, m_pClientList[i]->m_iVit, m_pClientList[i]->m_iInt, m_pClientList[i]->m_iMag, m_pClientList[i]->m_iCharisma, m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						PutLogList(buff);
						return;
					}
				}
			}
		}

		if (memcmp(pMsg, "crusade start", 13) == 0) {
			bFlag = true;
			LocalStartCrusadeMode(timeGetTime());
		}

		if (memcmp(pMsg, "crusade end", 11) == 0) {
			bFlag = true;
			ManualEndCrusadeMode(0);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ParseCommand");
	}
#endif
}

void CMapServer::EndTowerDefenseTime()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] == NULL) return;
			m_pClientList[i]->m_iTimeLeft_ForceRecall = 90;
			m_pClientList[i]->m_b5MinutosFinales = TRUE;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndTowerDefenseTime");
	}
#endif
}

void CMapServer::InitAllVsAll()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		if (AllVsAll || AllVsAllPortals || ActiveEvent) return;
		DWORD dwTime = timeGetTime();

		dwTimeTP = dwTime - 100;
		ActiveEvent = AllVsAll = AllVsAllPortals = TRUE;

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (strcmp(m_pMapList[i]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)
					m_pMapList[i]->m_bIsAttackEnabled = FALSE;
			}
		}

		TotalCompetidores = TotalPrice = 0;
		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_OPENPORTALS, NULL, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitAllVsAll");
	}
#endif
}

void CMapServer::IniciarAllVsAll()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (AllVsAllPortals == FALSE) return;
		AllVsAllPortals = FALSE;

		PutLogList("Evento comenzado");

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (strcmp(m_pMapList[i]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)
					m_pMapList[i]->m_bIsAttackEnabled = TRUE;
			}
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_INITALLVSALL, NULL, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: IniciarAllVsAll");
	}
#endif
}

void CMapServer::EndAllVsAll(int Char)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (AllVsAll == FALSE) return;

		AllVsAll = AllVsAllPortals = ActiveEvent = FALSE;
		dwTimeTP = 0;

		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(Char, i, CLIENT_NOTIFY_ENDALLVSALL, NULL, NULL, NULL, NULL, NULL);
				SetIllusionFlag(i, DEF_OWNERTYPE_PLAYER, FALSE);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
				m_pClientList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
				m_pClientList[i]->ActiveAvA = -1;
			}
		}
		TotalCompetidores = 0;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndAllVsAll");
	}
#endif
}

void CMapServer::ChequearAllVsAll()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, Char = -1;
		int Total;

		Total = 0;
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
				if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL, 9) == 0) {
					if ((m_pClientList[i]->m_iHP != 0) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
						Total++;
						Char = i;
					}
				}
			}
		}

		if (Total < 2) {
			if (Char != -1) {
				m_pClientList[Char]->m_iCoins += 5;
				SendNotifyMsg(Char, NULL, CLIENT_NOTIFY_COINS, m_pClientList[Char]->m_iCoins, NULL, NULL, NULL);
				if (!m_pClientList[Char]->Achivements[12].Complete) CheckCompleteAchivement(Char, 12, TRUE);
				if (!m_pClientList[Char]->Achivements[15].Complete) CheckCompleteAchivement(Char, 15, TRUE);
				EndAllVsAll(Char);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChequearAllVsAll");
	}
#endif
}

void CMapServer::DeleteEnergy()
{
#ifdef DEF_DEBUG
	try {
#endif

		register int i;
		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 35:
						NpcBehavior_Dead(i);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DeleteEnergy");
	}
#endif
}

BOOL CMapServer::VerificarItem(int iItemID)
{
#ifdef DEF_DEBUG
	try {
#endif
		BOOL Create;
		class CItem * pItem;
		pItem = new class CItem;

		if (_bInitItemAttr(pItem, iItemID) == FALSE) {
			delete pItem;
			return FALSE;
		}
		else {
			switch (iItemID) {
				case 400:
				case 401:
				case 403:
				case 404:
				case 405:
				case 406:
				case 407:
				case 408:
				case 409:
				case 410:
				case 411:
				case 412:
				case 413:
				case 414:
				case 415:
				case 416:
				case 417:
				case 418:
				case 419:
				case 420:
				case 421:
				case 422:
				case 423:
				case 424:
				case 425:
				case 426:
				case 427:
				case 428:
				case 613: //Agregado SwordofMedusa
				case 641: //Agregado KnecklaceOfMedusa
				case 702:
				case 703:
				case 706:
				case 707:
				case 708:
				case 709:
				case 710:
				case 711:
				case 712:
				case 713:
				case 714:
				case 715:
				case 716:
				case 717:
				case 718:
				case 719:
				case 724:
				case 725:
				case 726:
				case 727:
				case 728:
				case 730:
				case 731:
				case 732:
				case 733:
				case 737:
				case 738:
				case 745:
				case 746:
				case 925:
				case 926:
				case 2001:
				case 2002:
				case 2003:
				case 2011:
				case 2012:
				case 2013:
				case 3200:
				case 3201:
				case 3202:
				case 3203:				
				case 3204:
				case 3205:
				case 3206:
				case 3207:
				case 3208:
				case 3209:
				case 3210:
				case 3211:
				case 3212:
				case 3213:
				case 3214:
				case 3215:
				case 3216:
				case 3217:
				case 3218:
				case 3219:
				case 3220:
				case 3221:
				case 3222:
				case 3223:
				case 3224:
				case 3225:
				case 3226:
				case 3227:
				case 4000:
				case 4001:
				case 4002:
				case 4003:
				case 4004:
				case 4005:
				case 4006:
				case 4007:
				case 4008:
				case 4009:
				case 4010:
				case 4011:
				case 4012:
				case 4013:
				case 4014:
				case 4015:
				case 4016:
				case 4017:
				case 4018:
				case 4019:
				case 4020:
				case 4021:
				case 4032:
				case 4033:
				case 4034:
				case 4035:
				case 4036:
				case 4037:
				case 4038:
				case 4039:
				case 4040:
				case 4041:
				case 4042:
				case 4043:
				case 4044:
				case 4045:
				case 4046:
				case 4047:
				case 4048:
				case 4049:
				case 4050:
				case 4051:
				case 4052:
				case 4053:
				case 4054:
				case 4055:
				case 4100:
				case 4101:
				case 4102:
				case 4103:
				case 4104:
				case 4105:
				case 4106:
				case 4107:
				case 4108:
				case 4109:
				case 4110:
				case 4111:
				case 4112:
				case 4113:
				case 4114:
				case 4932:
				case 4933:
				case 4934:
				case 4935:
				case 4936:
				case 4937:
				case 4938:
				case 4939:
				case 4940:
				case 4941:
				case 4942:
				case 4943:
				case 4944:
				case 4945:
				case 4946:
				case 4947:
				case 4948:
				case 4949:
				case 4950:
				case 4951:
				case 4952:
				case 4953:
				case 4954:
				case 4955:
					Create = FALSE;
					break;
				default: Create = TRUE; break;
			}
		}
		return Create;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: VerificarItem");
	}
#endif
	return FALSE;
}

void CMapServer::SendEventData(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] != NULL) {
			for (int i = 0; i < 10; i++) {
				if (EventCount[i].AresdenWin != -1)
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EVENTDATA, i, EventCount[i].AresdenWin, EventCount[i].ElvineWin, NULL, EventCount[i].Draw, EventCount[i].LastWin);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEventData");
	}
#endif
}

void CMapServer::EventosAutomaticos()
{
	Event_Crusada();  //ta
	Event_Rush();  //ta
	Event_CatptureTheFlag();  //ta
	//Event_AllVsAll(); 
	Event_Abbadon();  //ta
	Event_CloseAbbadon(); //ta
	Event_CityVsCity();  //ta
	Event_Hod();  //ta
	Event_Summon();  //ta
	//Event_FinalFight();
	//Close_FinalFight();
	//Event_EK40();
	//EndEvent_EK40();
	//Event_EK100();
	//EndEvent_EK100();
	Event_WorldWar();  ///ta
	Event_WorldWarII(); //ta
	Event_TowerDefense();  //ta
	//Event_Masacre();
	//EndEvent_Masacre();
	//Event_TowerHell();
	//EndEvent_TowerHell();
	//Event_HuntMap();
	//EndEvent_HuntMap();
	Event_Questx2();
	EndEvent_Questx2();
	//Event_Questx3();
	//EndEvent_Questx3();
	//EventAllEks();
	//EventAllDkEks();
	EventDM();
}



void CMapServer::Event_Crusada()
{
	SYSTEMTIME SysTime;
	int CrusadeDay[4], CrusadeHour[4], CrusadeMinute[4];
	short Max = 4, i;
	
	/*//Miercoles
	CrusadeDay[0] = 3;
	CrusadeHour[0] = 20;
	CrusadeMinute[0] = 00;

	//Viernes
	CrusadeDay[1] = 5;
	CrusadeHour[1] = 19;
	CrusadeMinute[1] = 00;

	//Sabado
	CrusadeDay[2] = 6;
	CrusadeHour[2] = 18;
	CrusadeMinute[2] = 00;

	//Domingo
	CrusadeDay[3] = 0;
	CrusadeHour[3] = 20;
	CrusadeMinute[3] = 00;*/

	// Crusada
	// Miércoles
	CrusadeDay[0] = 3;
	CrusadeHour[0] = 21;
	CrusadeMinute[0] = 00;

	// Viernes
	CrusadeDay[1] = 5;
	CrusadeHour[1] = 20;
	CrusadeMinute[1] = 00;

	// Sábado
	CrusadeDay[2] = 6;
	CrusadeHour[2] = 20;
	CrusadeMinute[2] = 00;

	// Domingo
	CrusadeDay[3] = 0;
	CrusadeHour[3] = 20;
	CrusadeMinute[3] = 00;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((CrusadeDay[i] == SysTime.wDayOfWeek) && (CrusadeHour[i] == SysTime.wHour) && (CrusadeMinute[i] == SysTime.wMinute)) {
			LocalStartCrusadeMode(timeGetTime());
			return;
		}
	}
}

void CMapServer::Event_TowerDefense()
{
	SYSTEMTIME SysTime;
	int TDDay[2], TDHour[2], TDMinute[2];
	short Max = 2, i;

	//Martes
	TDDay[0] = 2;
	TDHour[0] = 21;
	TDMinute[0] = 0;

	//Jueves
	TDDay[1] = 4;
	TDHour[1] = 18;
	TDMinute[1] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((TDDay[i] == SysTime.wDayOfWeek) && (TDHour[i] == SysTime.wHour) && (TDMinute[i] == SysTime.wMinute)) {
			InitTowerDefence();
			return;
		}
	}
}

void CMapServer::Event_Rush()
{
	SYSTEMTIME SysTime;
	int RushDay[3], RushHour[3], RushMinute[3];//3
	short Max = 3, i;

	/*//Martes
	RushDay[0] = 2;
	RushHour[0] = 16;
	RushMinute[0] = 0;

	//Sabado
	RushDay[1] = 6;
	RushHour[1] = 16;
	RushMinute[1] = 0;*/
	

	// Rush
	// Lunes
	RushDay[0] = 1;
	RushHour[0] = 20;
	RushMinute[0] = 00;

	// miercoles
	RushDay[1] = 3;
	RushHour[1] = 18;
	RushMinute[1] = 00;

	// viernes
	RushDay[2] = 5;
	RushHour[2] = 18;
	RushMinute[2] = 00;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((RushDay[i] == SysTime.wDayOfWeek) && (RushHour[i] == SysTime.wHour) && (RushMinute[i] == SysTime.wMinute)) {
			LocalStartRushNetMode();
			return;
		}
	}
}

void CMapServer::Event_CatptureTheFlag()
{
	SYSTEMTIME SysTime;
	int CTFDay[4], CTFHour[4], CTFMinute[4];
	short Max = 4, i;

	//Lunes
	CTFDay[0] = 1;
	CTFHour[0] = 19;
	CTFMinute[0] = 0;

	//Miercoles
	CTFDay[1] = 3;
	CTFHour[1] = 17;
	CTFMinute[1] = 0;
	
	//Viernes
	CTFDay[2] = 5;
	CTFHour[2] = 16;
	CTFMinute[2] = 0;

	//Domingo
	CTFDay[3] = 0;
	CTFHour[3] = 14;
	CTFMinute[3] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((CTFDay[i] == SysTime.wDayOfWeek) && (CTFHour[i] == SysTime.wHour) && (CTFMinute[i] == SysTime.wMinute)) {
			StartCaptureTheFlag();
			return;
		}
	}
}

void CMapServer::Event_EK40()
{
	SYSTEMTIME SysTime;
	int HappyHourDay[7], HappyHourHour[7], HappyHourMinute[7];
	short Max = 7, i;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado

	// Domingo
	HappyHourDay[0] = 0;
	HappyHourHour[0] = 8;
	HappyHourMinute[0] = 0;

	// Lunes
	HappyHourDay[1] = 1;
	HappyHourHour[1] = 8;
	HappyHourMinute[1] = 0;

	// Martes
	HappyHourDay[2] = 2;
	HappyHourHour[2] = 8;
	HappyHourMinute[2] = 0;

	// Miercoles
	HappyHourDay[3] = 3;
	HappyHourHour[3] = 8;
	HappyHourMinute[3] = 0;

	// Jueves
	HappyHourDay[4] = 4;
	HappyHourHour[4] = 8;
	HappyHourMinute[4] = 0;

	// Viernes
	HappyHourDay[5] = 5;
	HappyHourHour[5] = 8;
	HappyHourMinute[5] = 0;

	// Sabado
	HappyHourDay[6] = 6;
	HappyHourHour[6] = 8;
	HappyHourMinute[6] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((HappyHourDay[i] == SysTime.wDayOfWeek) && (HappyHourHour[i] == SysTime.wHour) && (HappyHourMinute[i] == SysTime.wMinute)) {
			LocalStarHappyHour(true);
			PutLogList("Ek40 ON");
			return;
		}
	}
}
void CMapServer::EndEvent_EK40()
{
	SYSTEMTIME SysTime;
	int HappyHourDay[7], HappyHourHour[7], HappyHourMinute[7];
	short Max = 7, i;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado
	
	// Domingo
	HappyHourDay[0] = 0;
	HappyHourHour[0] = 2;
	HappyHourMinute[0] = 59;

	// Lunes
	HappyHourDay[1] = 1;
	HappyHourHour[1] = 2;
	HappyHourMinute[1] = 59;

	// Martes
	HappyHourDay[2] = 2;
	HappyHourHour[2] = 2;
	HappyHourMinute[2] = 59;

	// Miercoles
	HappyHourDay[3] = 3;
	HappyHourHour[3] = 2;
	HappyHourMinute[3] = 59;

	// Jueves
	HappyHourDay[4] = 4;
	HappyHourHour[4] = 2;
	HappyHourMinute[4] = 59;

	// Viernes
	HappyHourDay[5] = 5;
	HappyHourHour[5] = 2;
	HappyHourMinute[5] = 59;

	// Sabado
	HappyHourDay[6] = 6;
	HappyHourHour[6] = 2;
	HappyHourMinute[6] = 59;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((HappyHourDay[i] == SysTime.wDayOfWeek) && (HappyHourHour[i] == SysTime.wHour) && (HappyHourMinute[i] == SysTime.wMinute)) {
			LocalStarHappyHour(false);
			PutLogList("Ek40 OFF");
			return;
		}
	}
}
void CMapServer::Event_EK100()
{
	SYSTEMTIME SysTime;
	int DayHappyDay[7], DayHappyHour[7], DayHappyMinute[7];
	short Max = 7, i;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado

	// Domingo
	DayHappyDay[0] = 0;
	DayHappyHour[0] = 18;
	DayHappyMinute[0] = 0;

	// Lunes
	DayHappyDay[1] = 1;
	DayHappyHour[1] = 18;
	DayHappyMinute[1] = 0;

	// Martes
	DayHappyDay[2] = 2;
	DayHappyHour[2] = 18;
	DayHappyMinute[2] = 0;

	// Miercoles
	DayHappyDay[3] = 3;
	DayHappyHour[3] = 18;
	DayHappyMinute[3] = 0;

	// Jueves
	DayHappyDay[4] = 4;
	DayHappyHour[4] = 18;
	DayHappyMinute[4] = 0;

	// Viernes
	DayHappyDay[5] = 5;
	DayHappyHour[5] = 18;
	DayHappyMinute[5] = 0;

	// Sabado
	DayHappyDay[6] = 6;
	DayHappyHour[6] = 18;
	DayHappyMinute[6] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((DayHappyDay[i] == SysTime.wDayOfWeek) && (DayHappyHour[i] == SysTime.wHour) && (DayHappyMinute[i] == SysTime.wMinute)) {
			LocalStarHappyHour(false);
			PutLogList("Ek40 OFF");
			LocalStarHappyDay(true);
			PutLogList("Ek100 ON");
			return;
		}
	}
}

void CMapServer::EndEvent_EK100()
{
	SYSTEMTIME SysTime;
	int DayHappyDay[7], DayHappyHour[7], DayHappyMinute[7];
	short Max = 7, i;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado

	// Domingo
	DayHappyDay[0] = 0;
	DayHappyHour[0] = 23;
	DayHappyMinute[0] = 59;

	// Lunes
	DayHappyDay[1] = 1;
	DayHappyHour[1] = 23;
	DayHappyMinute[1] = 59;

	// Martes
	DayHappyDay[2] = 2;
	DayHappyHour[2] = 23;
	DayHappyMinute[2] = 59;

	// Miercoles
	DayHappyDay[3] = 3;
	DayHappyHour[3] = 23;
	DayHappyMinute[3] = 59;

	// Jueves
	DayHappyDay[4] = 4;
	DayHappyHour[4] = 23;
	DayHappyMinute[4] = 59;

	// Viernes
	DayHappyDay[5] = 5;
	DayHappyHour[5] = 23;
	DayHappyMinute[5] = 59;

	// Sabado
	DayHappyDay[6] = 6;
	DayHappyHour[6] = 23;
	DayHappyMinute[6] = 59;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((DayHappyDay[i] == SysTime.wDayOfWeek) && (DayHappyHour[i] == SysTime.wHour) && (DayHappyMinute[i] == SysTime.wMinute)) {
			LocalStarHappyDay(false);
			PutLogList("Ek100 OFF");
			LocalStarHappyHour(true);
			PutLogList("Ek40 ON");
			return;
		}
	}
}

void CMapServer::Event_Masacre()
{
	SYSTEMTIME SysTime;
	int MasacreHourDay[1], MasacreHourHour[1], MasacreHourMinute[1];
	short Max = 1, i;
	int iClientH;
	
	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado
	// Lunes
	MasacreHourDay[0] = 2;
	MasacreHourHour[0] = 22;
	MasacreHourMinute[0] = 0;
	// Viernes
	//MasacreHourDay[1] = 5;
	//MasacreHourHour[1] = 21;
	//MasacreHourMinute[1] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((MasacreHourDay[i] == SysTime.wDayOfWeek) && (MasacreHourHour[i] == SysTime.wHour) && (MasacreHourMinute[i] == SysTime.wMinute)) {
			Masacre = TRUE;
			PutLogList("Extreme ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXTRNOW, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

void CMapServer::EndEvent_Masacre()
{
	SYSTEMTIME SysTime;
	int MasacreHourDay[1], MasacreHourHour[1], MasacreHourMinute[1];
	short Max = 1, i;
	int iClientH;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado
	// Lunes
	MasacreHourDay[0] = 2;
	MasacreHourHour[0] = 23;
	MasacreHourMinute[0] = 0;
	// Sabado
	//MasacreHourDay[1] = 5;
	//MasacreHourHour[1] = 22;
	//MasacreHourMinute[1] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((MasacreHourDay[i] == SysTime.wDayOfWeek) && (MasacreHourHour[i] == SysTime.wHour) && (MasacreHourMinute[i] == SysTime.wMinute)) {
			Masacre = FALSE;
			PutLogList("Extreme OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXTREND, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}



//Lalo Questx2
void CMapServer::Event_Questx2()
{
	SYSTEMTIME SysTime;
	int Questx2HourDay[12], Questx2HourHour[12], Questx2HourMinute[12];
	short Max = 12, i;
	int iClientH;
	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	

	// Lunes
	Questx2HourDay[0] = 1; // Lunes
	Questx2HourHour[0] = 1; // 01:00
	Questx2HourMinute[0] = 0;
	
	// Martes
	Questx2HourDay[1] = 2; // Martes
	Questx2HourHour[1] = 3; // 03:00
	Questx2HourMinute[1] = 0;

	Questx2HourDay[2] = 2; // Martes
	Questx2HourHour[2] = 18; // 18:00
	Questx2HourMinute[2] = 0;

	// Miércoles
	Questx2HourDay[3] = 3; // Miércoles
	Questx2HourHour[3] = 2; // 02:00
	Questx2HourMinute[3] = 0;

	Questx2HourDay[4] = 3; // Miércoles
	Questx2HourHour[4] = 15; // 15:00
	Questx2HourMinute[4] = 0;

	// Jueves
	Questx2HourDay[5] = 4; // Jueves
	Questx2HourHour[5] = 0; // 00:30
	Questx2HourMinute[5] = 30;

	// Viernes
	Questx2HourDay[6] = 5; // Viernes
	Questx2HourHour[6] = 3; // 03:00
	Questx2HourMinute[6] = 0;

	Questx2HourDay[7] = 5; // Viernes
	Questx2HourHour[7] = 14; // 14:00
	Questx2HourMinute[7] = 0;

	// Sábado
	Questx2HourDay[8] = 6; // Sábado
	Questx2HourHour[8] = 2; // 02:30
	Questx2HourMinute[8] = 0;

	Questx2HourDay[9] = 6; // Sábado
	Questx2HourHour[9] = 23; // 23:00
	Questx2HourMinute[9] = 0;

	// Domingo
	Questx2HourDay[10] = 0; // Domingo
	Questx2HourHour[10] = 1; // 01:30
	Questx2HourMinute[10] = 30;

	Questx2HourDay[11] = 0; // Domingo
	Questx2HourHour[11] = 19; // 19:00
	Questx2HourMinute[11] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((Questx2HourDay[i] == SysTime.wDayOfWeek) && (Questx2HourHour[i] == SysTime.wHour) && (Questx2HourMinute[i] == SysTime.wMinute)) {
			Questx2 = TRUE;
			PutLogList("Quest x 2 ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		/*	Questx3 = TRUE;
			PutLogList("Quest x 3 ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;*/
		}
	}
}

//Lalo Questx2
void CMapServer::EndEvent_Questx2()
{
	SYSTEMTIME SysTime;
	int Questx2HourDay[12], Questx2HourHour[12], Questx2HourMinute[12];
	short Max = 12, i;
	int iClientH;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	
	
	// Lunes
	Questx2HourDay[0] = 1; // Lunes
	Questx2HourHour[0] = 2; // 01:00
	Questx2HourMinute[0] = 0;

	// Martes
	Questx2HourDay[1] = 2; // Martes
	Questx2HourHour[1] = 4; // 03:00
	Questx2HourMinute[1] = 0;

	Questx2HourDay[2] = 2; // Martes
	Questx2HourHour[2] = 19; // 18:00
	Questx2HourMinute[2] = 0;

	// Miércoles
	Questx2HourDay[3] = 3; // Miércoles
	Questx2HourHour[3] = 3; // 02:00
	Questx2HourMinute[3] = 0;

	Questx2HourDay[4] = 3; // Miércoles
	Questx2HourHour[4] = 16; // 15:00
	Questx2HourMinute[4] = 0;

	// Jueves
	Questx2HourDay[5] = 4; // Jueves
	Questx2HourHour[5] = 1; // 00:30
	Questx2HourMinute[5] = 30;

	// Viernes
	Questx2HourDay[6] = 5; // Viernes
	Questx2HourHour[6] = 4; // 03:00
	Questx2HourMinute[6] = 0;

	Questx2HourDay[7] = 5; // Viernes
	Questx2HourHour[7] = 15; // 14:00
	Questx2HourMinute[7] = 0;

	// Sábado
	Questx2HourDay[8] = 6; // Sábado
	Questx2HourHour[8] = 3; // 02:30
	Questx2HourMinute[8] = 0;

	Questx2HourDay[9] = 6; // Sábado
	Questx2HourHour[9] = 23; // 23:00
	Questx2HourMinute[9] = 59;

	// Domingo
	Questx2HourDay[10] = 0; // Domingo
	Questx2HourHour[10] = 2; // 01:30
	Questx2HourMinute[10] = 30;

	Questx2HourDay[11] = 0; // Domingo
	Questx2HourHour[11] = 20; // 19:00
	Questx2HourMinute[11] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((Questx2HourDay[i] == SysTime.wDayOfWeek) && (Questx2HourHour[i] == SysTime.wHour) && (Questx2HourMinute[i] == SysTime.wMinute)) {
			Questx2 = FALSE;
			PutLogList("Quest x 2 OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2OFF, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
			/*	Questx3 = FALSE;
			PutLogList("Quest x 3 OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3OFF, 10, NULL, NULL, NULL, NULL);
				}
			}*/
		}
	}
}

void CMapServer::Event_Questx3()
{
	SYSTEMTIME SysTime;
	int Questx3HourDay[7], Questx3HourHour[7], Questx3HourMinute[7];
	short Max = 7, i;
	int iClientH;
	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	

	//Domingo
	Questx3HourDay[0] = 0;
	Questx3HourHour[0] = 16;
	Questx3HourMinute[0] = 2;

	//Lunes
	Questx3HourDay[1] = 1;
	Questx3HourHour[1] = 16;
	Questx3HourMinute[1] = 2;

	//Martes
	Questx3HourDay[2] = 2;
	Questx3HourHour[2] = 16;
	Questx3HourMinute[2] = 2;

	//Miercoles
	Questx3HourDay[3] = 3;
	Questx3HourHour[3] = 16;
	Questx3HourMinute[3] = 2;

	//Jueves
	Questx3HourDay[4] = 4;
	Questx3HourHour[4] = 16;
	Questx3HourMinute[4] = 2;

	//Viernes
	Questx3HourDay[5] = 5;
	Questx3HourHour[5] = 16;
	Questx3HourMinute[5] = 2;

	//Sabado
	Questx3HourDay[6] = 6;
	Questx3HourHour[6] = 16;
	Questx3HourMinute[6] = 2;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((Questx3HourDay[i] == SysTime.wDayOfWeek) && (Questx3HourHour[i] == SysTime.wHour) && (Questx3HourMinute[i] == SysTime.wMinute)) {
			Questx2 = FALSE;
			PutLogList("Quest x 2 OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2OFF, 10, NULL, NULL, NULL, NULL);
				}
			}
			Questx3 = TRUE;
			PutLogList("Quest x 3 ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

//Lalo Questx2
void CMapServer::EndEvent_Questx3()
{
	SYSTEMTIME SysTime;
	int Questx3HourDay[7], Questx3HourHour[7], Questx3HourMinute[7];
	short Max = 7, i;
	int iClientH;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	

	//Domingo
	Questx3HourDay[0] = 0;
	Questx3HourHour[0] = 20;
	Questx3HourMinute[0] = 0;

	//Lunes
	Questx3HourDay[1] = 1;
	Questx3HourHour[1] = 20;
	Questx3HourMinute[1] = 0;

	//Martes
	Questx3HourDay[2] = 2;
	Questx3HourHour[2] = 20;
	Questx3HourMinute[2] = 0;

	//Miercoles
	Questx3HourDay[3] = 3;
	Questx3HourHour[3] = 20;
	Questx3HourMinute[3] = 0;

	//Jueves
	Questx3HourDay[4] = 4;
	Questx3HourHour[4] = 20;
	Questx3HourMinute[4] = 0;

	//Viernes
	Questx3HourDay[5] = 5;
	Questx3HourHour[5] = 20;
	Questx3HourMinute[5] = 0;

	//Sabado
	Questx3HourDay[6] = 6;
	Questx3HourHour[6] = 20;
	Questx3HourMinute[6] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((Questx3HourDay[i] == SysTime.wDayOfWeek) && (Questx3HourHour[i] == SysTime.wHour) && (Questx3HourMinute[i] == SysTime.wMinute)) {
			Questx3 = FALSE;
			PutLogList("Quest x 3 OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3OFF, 10, NULL, NULL, NULL, NULL);
				}
			}
			Questx2 = TRUE;
			PutLogList("Quest x 2 ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3OFF, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

//lALO hUNTmAP OPENVIP
void CMapServer::Event_HuntMap()
{
	SYSTEMTIME SysTime;
	int HuntMapHourDay[3], HuntMapHourHour[3], HuntMapHourMinute[3];
	short Max = 3, i;
	int iClientH;
	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	

	//Domingo
	HuntMapHourDay[0] = 0;
	HuntMapHourHour[0] = 8;
	HuntMapHourMinute[0] = 0;

	//Martes
	HuntMapHourDay[1] = 2;
	HuntMapHourHour[1] = 8;
	HuntMapHourMinute[1] = 0;

	//Jueves
	HuntMapHourDay[2] = 4;
	HuntMapHourHour[2] = 8;
	HuntMapHourMinute[2] = 0;

	//Miercoles
	/*HuntMapHourDay[3] = 3;
	HuntMapHourHour[3] = 23;
	HuntMapHourMinute[3] = 2;

	//Jueves
	HuntMapHourDay[4] = 4;
	HuntMapHourHour[4] = 23;
	HuntMapHourMinute[4] = 2;

	//Viernes
	HuntMapHourDay[5] = 5;
	HuntMapHourHour[5] = 23;
	HuntMapHourMinute[5] = 2;

	//Sabado
	HuntMapHourDay[6] = 6;
	HuntMapHourHour[6] = 23;
	HuntMapHourMinute[6] = 2;*/

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((HuntMapHourDay[i] == SysTime.wDayOfWeek) && (HuntMapHourHour[i] == SysTime.wHour) && (HuntMapHourMinute[i] == SysTime.wMinute)) {
			VipMap = TRUE;
			PutLogList("HuntMap ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HUNTON, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

void CMapServer::EndEvent_HuntMap()
{
	SYSTEMTIME SysTime;
	int HuntMapHourDay[3], HuntMapHourHour[3], HuntMapHourMinute[3];
	short Max = 3, i;
	int iClientH;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	

	//Domingo
	HuntMapHourDay[0] = 0;
	HuntMapHourHour[0] = 23;
	HuntMapHourMinute[0] = 58;

	//Martes
	HuntMapHourDay[1] = 2;
	HuntMapHourHour[1] = 23;
	HuntMapHourMinute[1] = 58;

	//Jueves
	HuntMapHourDay[2] = 4;
	HuntMapHourHour[2] = 23;
	HuntMapHourMinute[2] = 58;

	//Miercoles
/*	HuntMapHourDay[3] = 3;
	HuntMapHourHour[3] = 1;
	HuntMapHourMinute[3] = 2;

	//Jueves
	HuntMapHourDay[4] = 4;
	HuntMapHourHour[4] = 1;
	HuntMapHourMinute[4] = 2;

	//Viernes
	HuntMapHourDay[5] = 5;
	HuntMapHourHour[5] = 1;
	HuntMapHourMinute[5] = 2;

	//Sabado
	HuntMapHourDay[6] = 6;
	HuntMapHourHour[6] = 1;
	HuntMapHourMinute[6] = 2;*/

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((HuntMapHourDay[i] == SysTime.wDayOfWeek) && (HuntMapHourHour[i] == SysTime.wHour) && (HuntMapHourMinute[i] == SysTime.wMinute)) {
			VipMap = FALSE;
			PutLogList("HuntMap OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HUNTOFF, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

void CMapServer::Event_TowerHell()
{
	SYSTEMTIME SysTime;
	int TowerHellHourDay[4], TowerHellHourHour[4], TowerHellHourMinute[4];
	short Max = 4, i;
	int iClientH;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	
	// Lunes
	TowerHellHourDay[0] = 1;
	TowerHellHourHour[0] = 8;
	TowerHellHourMinute[0] = 0;

	// Miercoles
	TowerHellHourDay[1] = 3;
	TowerHellHourHour[1] = 8;
	TowerHellHourMinute[1] = 0;

	// Viernes
	TowerHellHourDay[2] = 5;
	TowerHellHourHour[2] = 8;
	TowerHellHourMinute[2] = 0;
	
	// Sabado
	TowerHellHourDay[3] = 6;
	TowerHellHourHour[3] = 8;
	TowerHellHourMinute[3] = 0;

	// Viernes
/*	TowerHellHourDay[4] = 5;
	TowerHellHourHour[4] = 14;
	TowerHellHourMinute[4] = 1;

	// Sabado
	TowerHellHourDay[5] = 6;
	TowerHellHourHour[5] = 14;
	TowerHellHourMinute[5] = 1;

	// Domingo
	TowerHellHourDay[6] = 0;
	TowerHellHourHour[6] = 14;
	TowerHellHourMinute[6] = 1;*/

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((TowerHellHourDay[i] == SysTime.wDayOfWeek) && (TowerHellHourHour[i] == SysTime.wHour) && (TowerHellHourMinute[i] == SysTime.wMinute)) {
			TowerHell = TRUE;
			PutLogList("TowerHell ON");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TOHNOW, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

void CMapServer::EndEvent_TowerHell()
{
	SYSTEMTIME SysTime;
	int TowerHellHourDay[4], TowerHellHourHour[4], TowerHellHourMinute[4];
	short Max = 4, i;
	int iClientH;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado	
	// Lunes
	TowerHellHourDay[0] = 1;
	TowerHellHourHour[0] = 23;
	TowerHellHourMinute[0] = 59;

	// Miercoles
	TowerHellHourDay[1] = 3;
	TowerHellHourHour[1] = 23;
	TowerHellHourMinute[1] = 59;

	// Viernes
	TowerHellHourDay[2] = 5;
	TowerHellHourHour[2] = 23;
	TowerHellHourMinute[2] = 59;

	// Sabado
	TowerHellHourDay[3] = 6;
	TowerHellHourHour[3] = 23;
	TowerHellHourMinute[3] = 59;

	// Viernes
/*	TowerHellHourDay[4] = 5;
	TowerHellHourHour[4] = 18;
	TowerHellHourMinute[4] = 1;

	// Sabado
	TowerHellHourDay[5] = 6;
	TowerHellHourHour[5] = 18;
	TowerHellHourMinute[5] = 1;

	// Domingo
	TowerHellHourDay[6] = 0;
	TowerHellHourHour[6] = 18;
	TowerHellHourMinute[6] = 1;*/

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((TowerHellHourDay[i] == SysTime.wDayOfWeek) && (TowerHellHourHour[i] == SysTime.wHour) && (TowerHellHourMinute[i] == SysTime.wMinute)) {
			TowerHell = FALSE;
			PutLogList("TowerHell OFF");
			for (iClientH = 0; iClientH < DEF_MAXCLIENTS; iClientH++)
			{
				if (m_pClientList[iClientH] != NULL)
				{
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TOHEND, 10, NULL, NULL, NULL, NULL);
				}
			}
			return;
		}
	}
}

void CMapServer::Event_AllVsAll()
{
	SYSTEMTIME SysTime;
	int AllVsAllDay[1], AllVsAllHour[1], AllVsAllMinute[1];
	short Max = 1, i;

	// Jueves
	AllVsAllDay[0] = 4;
	AllVsAllHour[0] = 18;
	AllVsAllMinute[0] = 0;

	// Domingo
//	AllVsAllDay[1] = 0;
//	AllVsAllHour[1] = 15;
//	AllVsAllMinute[1] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((AllVsAllDay[i] == SysTime.wDayOfWeek) && (AllVsAllHour[i] == SysTime.wHour) && (AllVsAllMinute[i] == SysTime.wMinute)) {
			InitAllVsAll();
			return;
		}
	}
}


void CMapServer::EventAllEks()
{
	SYSTEMTIME SysTime;
	int AllEksDay[7], AllEksHour[7], AllEksMinute[7];
	short Max = 7, i;

	// Domingo
	AllEksDay[0] = 0;
	AllEksHour[0] = 12;
	AllEksMinute[0] = 0;

	// Lunes
	AllEksDay[1] = 1;
	AllEksHour[1] = 17;
	AllEksMinute[1] = 0;

	// Martes
	AllEksDay[2] = 2;
	AllEksHour[2] = 23;
	AllEksMinute[2] = 30;

	// Miercoles
	AllEksDay[3] = 3;
	AllEksHour[3] = 22;
	AllEksMinute[3] = 0;

	// Jueves
	AllEksDay[4] = 4;
	AllEksHour[4] = 18;
	AllEksMinute[4] = 0;

	// Viernes
	AllEksDay[5] = 5;
	AllEksHour[5] = 18;
	AllEksMinute[5] = 0;

	// Sabado
	AllEksDay[6] = 6;
	AllEksHour[6] = 23;
	AllEksMinute[6] = 58;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((AllEksDay[i] == SysTime.wDayOfWeek) && (AllEksHour[i] == SysTime.wHour) && (AllEksMinute[i] == SysTime.wMinute)) {
			StartAllEks();
			return;
		}
	}
}

void CMapServer::EventAllDkEks()
{
	SYSTEMTIME SysTime;
	int AllDkEksDay[1], AllDkEksHour[1], AllDkEksMinute[1];
	short Max = 1, i;

	// Jueves
	AllDkEksDay[0] = 4;
	AllDkEksHour[0] = 23;
	AllDkEksMinute[0] = 59;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((AllDkEksDay[i] == SysTime.wDayOfWeek) && (AllDkEksHour[i] == SysTime.wHour) && (AllDkEksMinute[i] == SysTime.wMinute)) {
			StartAllDkEks();
			return;
		}
	}
}

void CMapServer::Event_Abbadon()
{
	SYSTEMTIME SysTime;
	int AbbyDay, AbbyHour, AbbyMinute;

	// Viernes 23 Hs Open Abby Map
	AbbyDay = 5;
	AbbyHour = 23;
	AbbyMinute = 0;

	GetLocalTime(&SysTime);
	if (AbbyDay == SysTime.wDayOfWeek && AbbyHour == SysTime.wHour && AbbyMinute == SysTime.wMinute) InitAbaddonEvent();
}

void CMapServer::Event_CloseAbbadon()
{
	SYSTEMTIME SysTime;
	int AbbyDay, AbbyHour, AbbyMinute;

	// Domingo 22 Hs Close Abby Map
	AbbyDay = 0;
	AbbyHour = 23;
	AbbyMinute = 0;

	GetLocalTime(&SysTime);
	if (AbbyDay == SysTime.wDayOfWeek && AbbyHour == SysTime.wHour && AbbyMinute == SysTime.wMinute) CloseAbaddonEvent();
}

///VER EVENTO ABADDON LALORAMOS
void CMapServer::InitAbaddonEvent()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_bIsApocalypseMode == TRUE) return;
		AbaddonEvent = TRUE;
		dw_abaddon_nospawn = -1;

		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL)) SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ABADDONMAP, NULL, NULL, NULL, NULL);
		}

		for (short j = 0; j < DEF_MAXMAPS; j++) {
			if (m_pMapList[j] != NULL) {
				if (strcmp(m_pMapList[j]->m_cName, "abaddon") == 0) {
					m_pMapList[j]->m_bIsApocalypseMobSpawn = 0;
					m_bIsApocalypseMode = TRUE;
					m_pMapList[j]->m_bIsAttackEnabled = TRUE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitAbaddonEvent");
	}
#endif
}

void CMapServer::CloseAbaddonEvent()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_bIsApocalypseMode == FALSE) return;
		if (AbaddonEvent == FALSE) return;

		AbaddonEvent = FALSE;

		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL)) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 90;
				m_pClientList[i]->m_b5MinutosFinales = TRUE;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ABADDONMAPCLOSE, NULL, NULL, NULL, NULL);
			}
		}

		for (short j = 0; j < DEF_MAXMAPS; j++) {
			if (m_pMapList[j] != NULL) {
				if (strcmp(m_pMapList[j]->m_cName, "abaddon") == 0) {
					m_pMapList[j]->m_bIsApocalypseMobSpawn = 0;
					dw_abaddon_nospawn = timeGetTime() - 30;
					m_pMapList[j]->m_bIsAttackEnabled = FALSE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CloseAbaddonEvent");
	}
#endif
}

void CMapServer::Event_CityVsCity()
{
	SYSTEMTIME SysTime;
	int CityVsCityDay[2], CityVsCityHour[2], CityVsCityMinute[2];
	short Max = 2, i;
	
	//Jueves
	CityVsCityDay[0] = 4;
	CityVsCityHour[0] = 20;
	CityVsCityMinute[0] = 0;

	//Domingo
	CityVsCityDay[1] = 0;
	CityVsCityHour[1] = 22;
	CityVsCityMinute[1] = 30;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((CityVsCityDay[i] == SysTime.wDayOfWeek) && (CityVsCityHour[i] == SysTime.wHour) && (CityVsCityMinute[i] == SysTime.wMinute)) {
			StartCityVsCity();
			return;
		}
	}
}

//WorldWar Automatico
void CMapServer::Event_WorldWar()
{
	SYSTEMTIME SysTime;
	int WorldWarDay[1], WorldWarHour[1], WorldWarMinute[1];
	short Max = 1, i;

	//Lunes
	WorldWarDay[0] = 1;
	WorldWarHour[0] = 22;
	WorldWarMinute[0] = 0;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((WorldWarDay[i] == SysTime.wDayOfWeek) && (WorldWarHour[i] == SysTime.wHour) && (WorldWarMinute[i] == SysTime.wMinute)) {
			StartWorldWar();
			return;
		}
	}
}

void CMapServer::Event_WorldWarII()
{
	SYSTEMTIME SysTime;
	int WorldWar2Day[1], WorldWar2Hour[1], WorldWar2Minute[1];
	short Max = 1, i;

	//Sabado
	WorldWar2Day[0] = 6;
	WorldWar2Hour[0] = 22;
	WorldWar2Minute[0] = 0;

	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((WorldWar2Day[i] == SysTime.wDayOfWeek) && (WorldWar2Hour[i] == SysTime.wHour) && (WorldWar2Minute[i] == SysTime.wMinute)) {
			StartWorldWarII();
			return;
		}
	}
}

void CMapServer::EventDM()
{
	SYSTEMTIME SysTime;
	int EventDMDay[10], EventDMHour[10], EventDMMinute[10];
	short Max = 2, i;

	// Lunes
	EventDMDay[0] = 1; // Lunes
	EventDMHour[0] = 16; // 16:00
	EventDMMinute[0] = 0;

	EventDMDay[1] = 1; // Lunes
	EventDMHour[1] = 21; // 21:00
	EventDMMinute[1] = 0;

	// Martes
	EventDMDay[2] = 2; // Martes
	EventDMHour[2] = 16; // 16:00
	EventDMMinute[2] = 0;

	EventDMDay[3] = 2; // Martes
	EventDMHour[3] = 19; // 19:00
	EventDMMinute[3] = 0;

	// Miércoles
	EventDMDay[4] = 3; // Miércoles
	EventDMHour[4] = 23; // 23:00
	EventDMMinute[4] = 0;

	// Jueves

	EventDMDay[5] = 4; // Jueves
	EventDMHour[5] = 17; // 19:00
	EventDMMinute[5] = 0;

	EventDMDay[6] = 4; // Jueves
	EventDMHour[6] = 19; // 19:00
	EventDMMinute[6] = 0;

	// Viernes
	EventDMDay[7] = 5; // Viernes
	EventDMHour[7] = 22; // 22:00
	EventDMMinute[7] = 0;

	// Sábado
	EventDMDay[8] = 6; // Sábado
	EventDMHour[8] = 18; // 18:00
	EventDMMinute[8] = 0;

	// Domingo
	EventDMDay[9] = 0; // Domingo
	EventDMHour[9] = 18; // 18:00
	EventDMMinute[9] = 0;


	// 0 Domingo //  1 Lunes // 2 Martes // 3 Miercoles // 4 jueves // 5 Viernes // 6 Sabado

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((EventDMDay[i] == SysTime.wDayOfWeek) && (EventDMHour[i] == SysTime.wHour) && (EventDMMinute[i] == SysTime.wMinute)) {
			if (!g_ev.Is(EventID::Deathmatch)) g_ev.Activate(EventID::Deathmatch);
			return;
		}
	}
}

void CMapServer::Event_Hod()
{
	SYSTEMTIME SysTime;
	int HodDay[1], HodHour[1], HodMinute[1];
	short Max = 1, i;

	// Domingo
	HodDay[0] = 0;
	HodHour[0] = 16;
	HodMinute[0] = 00;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((HodDay[i] == SysTime.wDayOfWeek) && (HodHour[i] == SysTime.wHour) && (HodMinute[i] == SysTime.wMinute)) {
			InitHellOfDeath();
			return;
		}
	}
}

void CMapServer::Event_Summon()
{
	SYSTEMTIME SysTime;
	int SummonDay[7], SummonHour[7], SummonMinute[7];
	short Max = 7, i;
	
	// Domingo
	SummonDay[0] = 0;
	SummonHour[0] = 12;
	SummonMinute[0] = 0;

	// Lunes
	SummonDay[1] = 1;
	SummonHour[1] = 10;
	SummonMinute[1] = 0;

	//Martes
	SummonDay[2] = 2;
	SummonHour[2] = 12;
	SummonMinute[2] = 0;

	// Miercoles
	SummonDay[3] = 3;
	SummonHour[3] = 14;
	SummonMinute[3] = 0;

	// Jueves
	SummonDay[4] = 4;
	SummonHour[4] = 16;
	SummonMinute[4] = 0;

	//Viernes
	SummonDay[5] = 5;
	SummonHour[5] = 12;
	SummonMinute[5] = 0;

	// Sabado
	SummonDay[6] = 6;
	SummonHour[6] = 14;
	SummonMinute[6] = 1;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((SummonDay[i] == SysTime.wDayOfWeek) && (SummonHour[i] == SysTime.wHour) && (SummonMinute[i] == SysTime.wMinute)) {
			LaunchSummonEvent();
			return;
		}
	}
}

void CMapServer::PlayerReceivedCoords(int iClientH, int CoordX, int CoordY)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		DWORD dwTime = timeGetTime();

		m_pClientList[iClientH]->RecallCoordX = CoordX;
		m_pClientList[iClientH]->RecallCoordY = CoordY;
		m_pClientList[iClientH]->TimeCoord = dwTime;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STRINGMSG, NULL, NULL, NULL, "Recall point designed");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: PlayerReceivedCoords");
	}
#endif
}

void CMapServer::DefineWHPage(int iClientH, short iV1)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return;
		m_pClientList[iClientH]->WHPage = iV1;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DefineWHPage");
	}
#endif
}

BOOL CMapServer::bReadCVCStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) return FALSE;
	else {
		PutLogList("Reading rush configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  City Vs City configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);

								if (m_stCVCStructures[iIndex].cType != NULL) {
									ErrorList("(!!!) CRITICAL ERROR!  City Vs City configuration file error - Duplicate potion number.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stCVCStructures[iIndex].cMapName, sizeof(m_stCVCStructures[iIndex].cMapName));
								memcpy_secure(m_stCVCStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;


							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  City Vs City configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCVCStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  City Vs City configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCVCStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  City Vs City configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stCVCStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "CityVsCity-structure", 20) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! City Vs City Structure configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::CreateCVCStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

		for (i = 0; i < MAX_CVCSTRUCTURES; i++) {
			if (m_stCVCStructures[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCVCStructures[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							switch (m_stCVCStructures[i].cType) {
								case 42:
									strcpy_secure(cNpcName, "ManaStone");
									break;

								default:
									strcpy_secure(cNpcName, m_pNpcConfigList[m_stCVCStructures[i].cType]->m_cNpcName);
									break;
							}

							tX = (int)m_stCVCStructures[i].dX;
							tY = (int)m_stCVCStructures[i].dY;
							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
								wsprintf(G_cTxt, "Creating Structure Error in Structure(%d) at %s(%d, %d)", i, m_stCVCStructures[i].cMapName, tX, tY);
								ErrorList(G_cTxt);
							}
							else {
								wsprintf(G_cTxt, "Creating CityVsCity Structure(%d) at %s(%d, %d)", i, m_stCVCStructures[i].cMapName, tX, tY);
								PutLogList(G_cTxt);
							}
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateCVCStructures");
	}
#endif
}

void CMapServer::AbrirPortales(short Event)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i = 0;

		DWORD dwTime = timeGetTime();
		switch (Event) {
			case 1:
				for (i = 0; i < 10; i++) {
					ZeroMemory(Portal_Init[i], sizeof(Portal_Init[i]));
					ZeroMemory(Portal_MapName[i], sizeof(Portal_MapName[i]));
					switch (i) {
						case 0: // Aresden Left Button
							ini_dx_portal[i] = 33;
							ini_dy_portal[i] = 266;
							strcpy_secure(Portal_Init[i], "aresden");
							dest_dx_portal[i] = 208;
							dest_dy_portal[i] = 32;
							strcpy_secure(Portal_MapName[i], "elvine");
							break;
						case 1: // Aresden right Button
							ini_dx_portal[i] = 273;
							ini_dy_portal[i] = 204;
							strcpy_secure(Portal_Init[i], "aresden");
							dest_dx_portal[i] = 269;
							dest_dy_portal[i] = 196;
							strcpy_secure(Portal_MapName[i], "elvine");
							break;
						case 2: // Aresden right Top 
							ini_dx_portal[i] = 255;
							ini_dy_portal[i] = 26;
							strcpy_secure(Portal_Init[i], "aresden");
							dest_dx_portal[i] = 251;
							dest_dy_portal[i] = 265;
							strcpy_secure(Portal_MapName[i], "elvine");
							break;
						case 3: // Aresden Left Top 
							ini_dx_portal[i] = 29;
							ini_dy_portal[i] = 27;
							strcpy_secure(Portal_Init[i], "aresden");
							dest_dx_portal[i] = 32;
							dest_dy_portal[i] = 270;
							strcpy_secure(Portal_MapName[i], "elvine");
							break;
						case 4: // Elvine Left Button 
							ini_dx_portal[i] = 28;
							ini_dy_portal[i] = 271;
							strcpy_secure(Portal_Init[i], "elvine");
							dest_dx_portal[i] = 25;
							dest_dy_portal[i] = 28;
							strcpy_secure(Portal_MapName[i], "aresden");
							break;
						case 5: // Elvine right Button 
							ini_dx_portal[i] = 272;
							ini_dy_portal[i] = 197;
							strcpy_secure(Portal_Init[i], "elvine");
							dest_dx_portal[i] = 270;
							dest_dy_portal[i] = 203;
							strcpy_secure(Portal_MapName[i], "aresden");
							break;
						case 6: // Elvine right Top 
							ini_dx_portal[i] = 211;
							ini_dy_portal[i] = 34;
							strcpy_secure(Portal_Init[i], "elvine");
							dest_dx_portal[i] = 29;
							dest_dy_portal[i] = 266;
							strcpy_secure(Portal_MapName[i], "aresden");
							break;
						case 7: // Elvine Left Top 
							ini_dx_portal[i] = 254;
							ini_dy_portal[i] = 264;
							strcpy_secure(Portal_Init[i], "elvine");
							dest_dx_portal[i] = 249;
							dest_dy_portal[i] = 29;
							strcpy_secure(Portal_MapName[i], "aresden");
							break;
							//habilitados 8 y 9
						/*case 8: // Elvine d1
							ini_dx_portal[i] = 254;
							ini_dy_portal[i] = 77;
							strcpy_secure(Portal_Init[i], "elvine");
							dest_dx_portal[i] = 72;
							dest_dy_portal[i] = 208;
							strcpy_secure(Portal_MapName[i], "aresden");
							break;
						case 9: // Aresden d1 
							ini_dx_portal[i] = 78;
							ini_dy_portal[i] = 204;
							strcpy_secure(Portal_Init[i], "aresden");
							dest_dx_portal[i] = 258;
							dest_dy_portal[i] = 76;
							strcpy_secure(Portal_MapName[i], "elvine");
							break;*/
						default:
							break;
					}
					LevelLimit_portal[i] = 999;
					MaxPlayer_portal[i] = -1;

					PortalPlayers[i] = 0;
					PortalAbility[i] = TRUE;
				}
				break;
			case 2: // Summon Event Aresden
				ZeroMemory(Portal_Init[5], sizeof(Portal_Init[5]));
				ZeroMemory(Portal_MapName[5], sizeof(Portal_MapName[5]));
				ZeroMemory(Portal_Init[6], sizeof(Portal_Init[6]));
				ZeroMemory(Portal_MapName[6], sizeof(Portal_MapName[6]));

				ini_dx_portal[5] = 58;
				ini_dy_portal[5] = 37;
				strcpy_secure(Portal_Init[5], "ESAresden");
				dest_dx_portal[5] = -1;
				dest_dy_portal[5] = -1;
				strcpy_secure(Portal_MapName[5], "aresden");
				LevelLimit_portal[5] = 999;
				MaxPlayer_portal[5] = -1;

				PortalPlayers[5] = 0;
				dw_TimeOpenPortal[5] = 900000;
				dw_TimePortal[5] = dwTime - 500;
				PortalAbility[5] = TRUE;

				ini_dx_portal[6] = 31;
				ini_dy_portal[6] = 40;
				strcpy_secure(Portal_Init[6], "ESAresden");
				dest_dx_portal[6] = -1;
				dest_dy_portal[6] = -1;
				strcpy_secure(Portal_MapName[6], "aresden");
				LevelLimit_portal[6] = 999;
				MaxPlayer_portal[6] = -1;

				PortalPlayers[6] = 0;
				dw_TimeOpenPortal[6] = 900000;
				dw_TimePortal[6] = dwTime - 500;
				PortalAbility[6] = TRUE;
				break;
			case 3: // Summon Event Elvine
				ZeroMemory(Portal_Init[7], sizeof(Portal_Init[7]));
				ZeroMemory(Portal_MapName[7], sizeof(Portal_MapName[7]));
				ZeroMemory(Portal_Init[8], sizeof(Portal_Init[8]));
				ZeroMemory(Portal_MapName[8], sizeof(Portal_MapName[8]));

				ini_dx_portal[7] = 58;
				ini_dy_portal[7] = 37;
				strcpy_secure(Portal_Init[7], "ESElvine");
				dest_dx_portal[7] = -1;
				dest_dy_portal[7] = -1;
				strcpy_secure(Portal_MapName[7], "elvine");
				LevelLimit_portal[7] = 999;
				MaxPlayer_portal[7] = -1;

				PortalPlayers[7] = 0;
				dw_TimeOpenPortal[7] = 900000;
				dw_TimePortal[7] = dwTime - 500;
				PortalAbility[7] = TRUE;

				ini_dx_portal[8] = 31;
				ini_dy_portal[8] = 40;
				strcpy_secure(Portal_Init[8], "ESElvine");
				dest_dx_portal[8] = -1;
				dest_dy_portal[8] = -1;
				strcpy_secure(Portal_MapName[8], "elvine");
				LevelLimit_portal[8] = 999;
				MaxPlayer_portal[8] = -1;

				PortalPlayers[8] = 0;
				dw_TimeOpenPortal[8] = 900000;
				dw_TimePortal[8] = dwTime - 500;
				PortalAbility[8] = TRUE;
				break;

			case 4: // Summon Event Assasain
				ZeroMemory(Portal_Init[3], sizeof(Portal_Init[3]));
				ZeroMemory(Portal_MapName[3], sizeof(Portal_MapName[3]));
				ZeroMemory(Portal_Init[4], sizeof(Portal_Init[4]));
				ZeroMemory(Portal_MapName[4], sizeof(Portal_MapName[4]));

				ini_dx_portal[3] = 58;
				ini_dy_portal[3] = 37;
				strcpy_secure(Portal_Init[3], "ESAssasain");
				dest_dx_portal[3] = -1;
				dest_dy_portal[3] = -1;
				strcpy_secure(Portal_MapName[3], "Whouse");
				LevelLimit_portal[3] = 999;
				MaxPlayer_portal[3] = -1;

				PortalPlayers[3] = 0;
				dw_TimeOpenPortal[3] = 900000;
				dw_TimePortal[3] = dwTime - 500;
				PortalAbility[3] = TRUE;

				ini_dx_portal[4] = 31;
				ini_dy_portal[4] = 40;
				strcpy_secure(Portal_Init[8], "ESAssasain");
				dest_dx_portal[4] = -1;
				dest_dy_portal[4] = -1;
				strcpy_secure(Portal_MapName[4], "Whouse");
				LevelLimit_portal[4] = 999;
				MaxPlayer_portal[4] = -1;

				PortalPlayers[4] = 0;
				dw_TimeOpenPortal[4] = 900000;
				dw_TimePortal[4] = dwTime - 500;
				PortalAbility[4] = TRUE;
				break;

			case 5:
				ZeroMemory(Portal_Init[3], sizeof(Portal_Init[3]));
				ZeroMemory(Portal_MapName[3], sizeof(Portal_MapName[3]));
				ZeroMemory(Portal_Init[4], sizeof(Portal_Init[4]));
				ZeroMemory(Portal_MapName[4], sizeof(Portal_MapName[4]));
				ZeroMemory(Portal_Init[5], sizeof(Portal_Init[5]));
				ZeroMemory(Portal_MapName[5], sizeof(Portal_MapName[5]));
				ZeroMemory(Portal_Init[6], sizeof(Portal_Init[6]));
				ZeroMemory(Portal_MapName[6], sizeof(Portal_MapName[6]));

				if (EventCount[DEF_CVC].LastWin == 1) {
					strcpy_secure(Portal_MapName[3], "aresden");
					strcpy_secure(Portal_MapName[4], "aresden");
					strcpy_secure(Portal_MapName[5], "aresden");
					strcpy_secure(Portal_MapName[6], "aresden");
				}
				else if (EventCount[DEF_CVC].LastWin == 2) {
					strcpy_secure(Portal_MapName[3], "elvine");
					strcpy_secure(Portal_MapName[4], "elvine");
					strcpy_secure(Portal_MapName[5], "elvine");
					strcpy_secure(Portal_MapName[6], "elvine");
				}
				else {
					strcpy_secure(Portal_MapName[3], "Whouse");
					strcpy_secure(Portal_MapName[4], "Whouse");
					strcpy_secure(Portal_MapName[5], "Whouse");
					strcpy_secure(Portal_MapName[6], "Whouse");
				}
				ini_dx_portal[3] = 123;
				ini_dy_portal[3] = 65;
				strcpy_secure(Portal_Init[3], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[3] = -1;
				dest_dy_portal[3] = -1;
				LevelLimit_portal[3] = 999;
				MaxPlayer_portal[3] = -1;

				PortalPlayers[3] = 0;
				dw_TimeOpenPortal[3] = 900000;
				dw_TimePortal[3] = dwTime - 500;
				PortalAbility[3] = TRUE;

				ini_dx_portal[4] = 80;
				ini_dy_portal[4] = 94;
				strcpy_secure(Portal_Init[4], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[4] = -1;
				dest_dy_portal[4] = -1;
				LevelLimit_portal[4] = 999;
				MaxPlayer_portal[4] = -1;

				PortalPlayers[4] = 0;
				dw_TimeOpenPortal[4] = 900000;
				dw_TimePortal[4] = dwTime - 500;
				PortalAbility[4] = TRUE;

				ini_dx_portal[5] = 79;
				ini_dy_portal[5] = 35;
				strcpy_secure(Portal_Init[5], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[5] = -1;
				dest_dy_portal[5] = -1;
				LevelLimit_portal[5] = 999;
				MaxPlayer_portal[5] = -1;

				PortalPlayers[5] = 0;
				dw_TimeOpenPortal[5] = 900000;
				dw_TimePortal[5] = dwTime - 500;
				PortalAbility[5] = TRUE;

				ini_dx_portal[6] = 38;
				ini_dy_portal[6] = 65;
				strcpy_secure(Portal_Init[6], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[6] = -1;
				dest_dy_portal[6] = -1;
				LevelLimit_portal[6] = 999;
				MaxPlayer_portal[6] = -1;

				PortalPlayers[6] = 0;
				dw_TimeOpenPortal[6] = 900000;
				dw_TimePortal[6] = dwTime - 500;
				PortalAbility[6] = TRUE;
				break;

				//WorldWar LaloRamos Portales
			case 6:
				ZeroMemory(Portal_Init[3], sizeof(Portal_Init[3]));
				ZeroMemory(Portal_MapName[3], sizeof(Portal_MapName[3]));
				ZeroMemory(Portal_Init[4], sizeof(Portal_Init[4]));
				ZeroMemory(Portal_MapName[4], sizeof(Portal_MapName[4]));
				ZeroMemory(Portal_Init[5], sizeof(Portal_Init[5]));
				ZeroMemory(Portal_MapName[5], sizeof(Portal_MapName[5]));
				ZeroMemory(Portal_Init[6], sizeof(Portal_Init[6]));
				ZeroMemory(Portal_MapName[6], sizeof(Portal_MapName[6]));

				ini_dx_portal[3] = 123;
				ini_dy_portal[3] = 65;
				strcpy_secure(Portal_Init[3], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[3] = -1;
				dest_dy_portal[3] = -1;
				strcpy_secure(Portal_MapName[3], "Whouse");
				LevelLimit_portal[3] = 999;
				MaxPlayer_portal[3] = -1;

				PortalPlayers[3] = 0;
				dw_TimeOpenPortal[3] = 900000;
				dw_TimePortal[3] = dwTime - 500;
				PortalAbility[3] = TRUE;

				ini_dx_portal[4] = 80;
				ini_dy_portal[4] = 94;
				strcpy_secure(Portal_Init[4], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[4] = -1;
				dest_dy_portal[4] = -1;
				strcpy_secure(Portal_MapName[4], "Whouse");
				LevelLimit_portal[4] = 999;
				MaxPlayer_portal[4] = -1;

				PortalPlayers[4] = 0;
				dw_TimeOpenPortal[4] = 900000;
				dw_TimePortal[4] = dwTime - 500;
				PortalAbility[4] = TRUE;

				ini_dx_portal[5] = 79;
				ini_dy_portal[5] = 35;
				strcpy_secure(Portal_Init[5], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[5] = -1;
				dest_dy_portal[5] = -1;
				strcpy_secure(Portal_MapName[5], "Whouse");
				LevelLimit_portal[5] = 999;
				MaxPlayer_portal[5] = -1;

				PortalPlayers[5] = 0;
				dw_TimeOpenPortal[5] = 900000;
				dw_TimePortal[5] = dwTime - 500;
				PortalAbility[5] = TRUE;

				ini_dx_portal[6] = 38;
				ini_dy_portal[6] = 65;
				strcpy_secure(Portal_Init[6], DEF_PRICE_EVENT_CITYVSCITY);
				dest_dx_portal[6] = -1;
				dest_dy_portal[6] = -1;
				strcpy_secure(Portal_MapName[6], "Whouse");
				LevelLimit_portal[6] = 999;
				MaxPlayer_portal[6] = -1;

				PortalPlayers[6] = 0;
				dw_TimeOpenPortal[6] = 900000;
				dw_TimePortal[6] = dwTime - 500;
				PortalAbility[6] = TRUE;
				break;
			case 7: //WorldWar Portales
				for (i = 0; i < 4; i++) {
					ZeroMemory(Portal_Init[i], sizeof(Portal_Init[i]));
					ZeroMemory(Portal_MapName[i], sizeof(Portal_MapName[i]));
					switch (i) {
						case 0: //gshop_1
							ini_dx_portal[i] = 42;
							ini_dy_portal[i] = 41;
							strcpy_secure(Portal_Init[i], "gshop_1");
							dest_dx_portal[i] = -1;
							dest_dy_portal[i] = -1;
							strcpy_secure(Portal_MapName[i], "FightMap");
							break;
						case 1: //gshop_2
							ini_dx_portal[i] = 42;
							ini_dy_portal[i] = 41;
							strcpy_secure(Portal_Init[i], "gshop_2");
							dest_dx_portal[i] = -1;
							dest_dy_portal[i] = -1;
							strcpy_secure(Portal_MapName[i], "FightMap");
							break;
						case 2: //Whouse
							ini_dx_portal[i] = 40;
							ini_dy_portal[i] = 54;
							strcpy_secure(Portal_Init[i], "Whouse");
							dest_dx_portal[i] = -1;
							dest_dy_portal[i] = -1;
							strcpy_secure(Portal_MapName[i], "FightMap");
							break;
						case 3: //Whouse
							ini_dx_portal[i] = 58;
							ini_dy_portal[i] = 44;
							strcpy_secure(Portal_Init[i], "Whouse");
							dest_dx_portal[i] = -1;
							dest_dy_portal[i] = -1;
							strcpy_secure(Portal_MapName[i], "FightMap");
							break;
						default:
							break;
					}
					LevelLimit_portal[i] = 999;
					MaxPlayer_portal[i] = -1;

					PortalPlayers[i] = 0;
					PortalAbility[i] = TRUE;
				}
				break;

			case 8: //WorldWar II Portales
				for (i = 0; i < 4; i++) {
					ZeroMemory(Portal_Init[i], sizeof(Portal_Init[i]));
					ZeroMemory(Portal_MapName[i], sizeof(Portal_MapName[i]));
					switch (i) {
					case 0: //gshop_1
						ini_dx_portal[i] = 42;
						ini_dy_portal[i] = 41;
						strcpy_secure(Portal_Init[i], "gshop_1");
						dest_dx_portal[i] = -1;
						dest_dy_portal[i] = -1;
						strcpy_secure(Portal_MapName[i], "WorldMap");
						break;
					case 1: //gshop_2
						ini_dx_portal[i] = 42;
						ini_dy_portal[i] = 41;
						strcpy_secure(Portal_Init[i], "gshop_2");
						dest_dx_portal[i] = -1;
						dest_dy_portal[i] = -1;
						strcpy_secure(Portal_MapName[i], "WorldMap");
						break;
					case 2: //Whouse
						ini_dx_portal[i] = 40;
						ini_dy_portal[i] = 54;
						strcpy_secure(Portal_Init[i], "Whouse");
						dest_dx_portal[i] = -1;
						dest_dy_portal[i] = -1;
						strcpy_secure(Portal_MapName[i], "WorldMap");
						break;
					case 3: //Whouse
						ini_dx_portal[i] = 58;
						ini_dy_portal[i] = 44;
						strcpy_secure(Portal_Init[i], "Whouse");
						dest_dx_portal[i] = -1;
						dest_dy_portal[i] = -1;
						strcpy_secure(Portal_MapName[i], "WorldMap");
						break;
					default:
						break;
					}
					LevelLimit_portal[i] = 999;
					MaxPlayer_portal[i] = -1;

					PortalPlayers[i] = 0;
					PortalAbility[i] = TRUE;
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AbrirPortales");
	}
#endif
}

void CMapServer::AllClosePortals()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, PortalNum;

		for (PortalNum = 0; PortalNum < DEF_MAXPORTALS; PortalNum++) {
			PortalAbility[PortalNum] = FALSE;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL)
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_APOCGATECLOSE, PortalNum, ini_dx_portal[PortalNum], ini_dy_portal[PortalNum], m_pClientList[i]->m_cMapName);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AllClosePortals");
	}
#endif
}

//WorldWar LaloRamos
void CMapServer::StartWorldWar()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent || WorldWar) return;
		DWORD dwTime = timeGetTime();
		WorldWarTime = dwTime - 30;
		WWPriceTime = 0;
		WorldWar = ActiveEvent = true;
		WWPriceEvent = false;

		WWContadorElvine = WWContadorAresden = WWContadorAssesino = WWLastContElv = WWLastContAres = WWSideWinner = 0;

		AbrirPortales(7);
		ActualizarWWContador();
		PutLogList("WorldWar Map Open");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartWorldWar");
	}
#endif
}

//WorldWar LaloRamos
void CMapServer::EndWorldWar()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!WorldWar) return;
		if (WWPriceEvent) return;
		DWORD dwTime = timeGetTime();
		PutLogList("WorldWar Map Closed");

		int pX, pY, iNamingValue, z, i;
		char cName_Internal[31], cWaypoint[31];

		WorldWar = ActiveEvent = false;

		if (WWContadorElvine > WWContadorAresden && WWContadorElvine > WWContadorAssesino) WWSideWinner = 2;
		else if (WWContadorAresden > WWContadorElvine && WWContadorAresden > WWContadorAssesino) WWSideWinner = 1;
		else WWSideWinner = 0;

		CreateEventResults(WWSideWinner, 6);
		WWContadorAresden = WWContadorElvine = WWContadorAssesino = -1;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear) {
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_WWEND, WWSideWinner, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_WW, EventCount[DEF_WW].AresdenWin, EventCount[DEF_WW].ElvineWin, NULL, EventCount[DEF_WW].Draw, EventCount[DEF_WW].LastWin);
				if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_EVENTMAP_WORLDWAR, 8) == 0) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
				}
			}
		}

		AllClosePortals();

		if (WWSideWinner > 0) {
			ActiveEvent = WWPriceEvent = true;
			WWPriceTime = dwTime - 100;
			AbrirPortales(6); //5

			pX = 80;
			pY = 63;
			ZeroMemory(cWaypoint, sizeof(cWaypoint));

			for (z = 0; z < DEF_MAXMAPS; z++) {
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) {
					iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
					if (iNamingValue != -1) {
						ZeroMemory(cName_Internal, sizeof(cName_Internal));
						wsprintf(cName_Internal, "XX%d", iNamingValue);
						cName_Internal[0] = '_';
						cName_Internal[1] = z + 65;

						if ((bCreateNewNpc("HellAbaddon", cName_Internal, m_pMapList[z]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE)
							m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						m_pMapList[z]->m_bIsAttackEnabled = TRUE;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndWorldWar");
	}
#endif
}

//WorldWar II LaloRamos
void CMapServer::StartWorldWarII()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent || WorldWarII) return;
		DWORD dwTime = timeGetTime();
		WorldWarTimeII = dwTime - 30;
		WWIIPriceTime = 0;
		WorldWarII = ActiveEvent = true;
		WWIIPriceEvent = false;

		WWIIContadorElvine = WWIIContadorAresden = WWIIContadorAssesino = WWIILastContElv = WWIILastContAres = WWIISideWinner = 0;

		AbrirPortales(8);
		ActualizarWWIIContador();
		PutLogList("WorldWar II Map Open");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartWorldWar II");
	}
#endif
}

//WorldWar LaloRamos
void CMapServer::EndWorldWarII()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!WorldWarII) return;
		if (WWIIPriceEvent) return;
		DWORD dwTime = timeGetTime();
		PutLogList("WorldWar II Map Closed");

		int pX, pY, iNamingValue, z, i;
		char cName_Internal[31], cWaypoint[31];

		WorldWarII = ActiveEvent = false;

		if (WWIIContadorElvine > WWIIContadorAresden && WWIIContadorElvine > WWIIContadorAssesino) WWIISideWinner = 2;
		else if (WWIIContadorAresden > WWIIContadorElvine && WWIIContadorAresden > WWIIContadorAssesino) WWIISideWinner = 1;
		else WWIISideWinner = 0;

		CreateEventResults(WWIISideWinner, 7);
		WWIIContadorAresden = WWIIContadorElvine = WWIIContadorAssesino = -1;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear) {
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_WWENDII, WWIISideWinner, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_WWII, EventCount[DEF_WWII].AresdenWin, EventCount[DEF_WWII].ElvineWin, NULL, EventCount[DEF_WWII].Draw, EventCount[DEF_WWII].LastWin);
				if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_EVENTMAP_WORLDWARII, 8) == 0) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
				}
			}
		}

		AllClosePortals();

		if (WWIISideWinner > 0) {
			ActiveEvent = WWIIPriceEvent = true;
			WWIIPriceTime = dwTime - 100;
			AbrirPortales(6); //5

			pX = 80;
			pY = 63;
			ZeroMemory(cWaypoint, sizeof(cWaypoint));

			for (z = 0; z < DEF_MAXMAPS; z++) {
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) {
					iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
					if (iNamingValue != -1) {
						ZeroMemory(cName_Internal, sizeof(cName_Internal));
						wsprintf(cName_Internal, "XX%d", iNamingValue);
						cName_Internal[0] = '_';
						cName_Internal[1] = z + 65;

						if ((bCreateNewNpc("BlackWyvern", cName_Internal, m_pMapList[z]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE)
							m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						m_pMapList[z]->m_bIsAttackEnabled = TRUE;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndWorldWar II");
	}
#endif
}

//WorldWar II
void CMapServer::CloseWWEventMapII()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (WWIIPriceEvent == FALSE) return;
		int i;

		PutLogList("WW II evento cerrado");

		WWIIPriceEvent = FALSE;
		ActiveEvent = FALSE;

		AllClosePortals();

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear
				&& (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_PRICE_EVENT_CITYVSCITY, 8) == 0)) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, "1   ");
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_PRICECLOSE, NULL, NULL, NULL, NULL);
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
			}
		}

		for (i = 0; i < DEF_MAXMAPS; i++) { // No atack luego de matar al abby
			if ((m_pMapList[i] != NULL) && (strcmp(m_pMapList[i]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0))
				m_pMapList[i]->m_bIsAttackEnabled = TRUE;
		}
		//WorldWar - LaloRamos
		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
				case 128:
				case 134:
					NpcBehavior_Dead(i, FALSE);
					break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CloseWWEventMap II");
	}
#endif
}

void CMapServer::StartCityVsCity()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent || CityVsCity) return;
		DWORD dwTime = timeGetTime();

		cvcEventTime = dwTime - 30;
		PriceTime = 0;
		CityVsCity = ActiveEvent = true;
		PriceEvent = false;

		RandomEventID = iDice(1, 100000);

		ContadorElvine = ContadorAresden = ContadorAssesino = LastContElv = LastContAres = SideWinner = 0;

		AbrirPortales(1);
		CreateCVCStructures();
		ActualizarContador();
		PutLogList("City vs City Mode ON.");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartCityVsCity");
	}
#endif
}

void CMapServer::EndCityVsCity()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!CityVsCity) return;
		if (PriceEvent) return;
		DWORD dwTime = timeGetTime();

		int pX, pY, iNamingValue, z, i;
		char cName_Internal[31], cWaypoint[31];

		EventTime = ((((dwTime - cvcEventTime) / 60000) * DEF_EVENT_TIME_PRICE) / 100);

		CityVsCity = ActiveEvent = false;

		if (ContadorElvine > ContadorAresden && ContadorElvine > ContadorAssesino) SideWinner = 2;
		else if (ContadorAresden > ContadorElvine && ContadorAresden > ContadorAssesino) SideWinner = 1;
		else SideWinner = 0;

		CreateEventResults(SideWinner, 4);
		ContadorAresden = ContadorElvine = ContadorAssesino = -1;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear) {
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CVCEND, SideWinner, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_CVC, EventCount[DEF_CVC].AresdenWin, EventCount[DEF_CVC].ElvineWin, NULL, EventCount[DEF_CVC].Draw, EventCount[DEF_CVC].LastWin);
			}
		}

		PutLogList("City vs City Mode OFF.");
		AllClosePortals();

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 42:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}

		if (SideWinner > 0) {
			ActiveEvent = PriceEvent = true;
			PriceTime = dwTime - 100;
			AbrirPortales(5);

			pX = 80;
			pY = 63;
			ZeroMemory(cWaypoint, sizeof(cWaypoint));

			for (z = 0; z < DEF_MAXMAPS; z++) {
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0)) {
					iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
					if (iNamingValue != -1) {
						ZeroMemory(cName_Internal, sizeof(cName_Internal));
						wsprintf(cName_Internal, "XX%d", iNamingValue);
						cName_Internal[0] = '_';
						cName_Internal[1] = z + 65;

						if ((bCreateNewNpc("Abaddon", cName_Internal, m_pMapList[z]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE)
							m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						m_pMapList[z]->m_bIsAttackEnabled = TRUE;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndCityVsCity");
	}
#endif
}

void CMapServer::CloseEventMap()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (PriceEvent == FALSE) return;
		int i;

		PutLogList("evento cerrado");

		PriceEvent = FALSE;
		ActiveEvent = FALSE;

		AllClosePortals();

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear) {
				m_pClientList[i]->RndEventID = 0;
				m_pClientList[i]->EventMinPlaying = 0;

				if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_PRICE_EVENT_CITYVSCITY, 8) == 0) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_PRICECLOSE, NULL, NULL, NULL, NULL);
					m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
				}
			}
		}

		for (i = 0; i < DEF_MAXMAPS; i++) { // No atack luego de matar al abby
			if ((m_pMapList[i] != NULL) && (strcmp(m_pMapList[i]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0))
				m_pMapList[i]->m_bIsAttackEnabled = TRUE;
		}


		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 81:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CloseEventMap");
	}
#endif
}
//WorldWar
void CMapServer::CloseWWEventMap()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (WWPriceEvent == FALSE) return;
		int i;

		PutLogList("WW evento cerrado");

		WWPriceEvent = FALSE;
		ActiveEvent = FALSE;

		AllClosePortals();

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear
				&& (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_PRICE_EVENT_CITYVSCITY, 8) == 0)) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, "1   ");
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_PRICECLOSE, NULL, NULL, NULL, NULL);
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
			}
		}

		for (i = 0; i < DEF_MAXMAPS; i++) { // No atack luego de matar al abby
			if ((m_pMapList[i] != NULL) && (strcmp(m_pMapList[i]->m_cName, DEF_PRICE_EVENT_CITYVSCITY) == 0))
				m_pMapList[i]->m_bIsAttackEnabled = TRUE;
		}
		//WorldWar - LaloRamos
		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 120:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CloseWWEventMap");
	}
#endif
}

void CMapServer::ActualizarContador()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!CityVsCity) return;

		for (short i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear) {
				if (m_pClientList[i]->RndEventID != RandomEventID) m_pClientList[i]->RndEventID = RandomEventID;

				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_CVCNOW, ContadorElvine, ContadorAresden, ContadorAssesino, NULL);
				if (m_pClientList[i] != NULL) m_pClientList[i]->m_bIsSafeAttackMode = TRUE;
			}
		}

		if ((ContadorElvine >= 9999) || (ContadorAresden >= 9999) || (ContadorAssesino >= 9999))
			EndCityVsCity();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActualizarContador");
	}
#endif
}

//WorldWar - LaloRamos
void CMapServer::ActualizarWWContador()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!WorldWar) return;

		for (short i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear)
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_WWNOW, WWContadorElvine, WWContadorAresden, WWContadorAssesino, NULL);
		}

		if ((WWContadorElvine >= 9999) || (WWContadorAresden >= 9999) || (WWContadorAssesino >= 9999))
			EndWorldWar();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActualizarWWContador");
	}
#endif
}

//WorldWar II - LaloRamos
void CMapServer::ActualizarWWIIContador()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!WorldWarII) return;

		for (short i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear)
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_WWNOWII, WWIIContadorElvine, WWIIContadorAresden, WWIIContadorAssesino, NULL);
		}

		if ((WWIIContadorElvine >= 9999) || (WWIIContadorAresden >= 9999) || (WWIIContadorAssesino >= 9999))
			EndWorldWarII();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActualizarWWIIContador");
	}
#endif
}

void CMapServer::DeleteCliente(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char seps[] = "= \t\n";
		char *token, cBuff[256];
		class CStrTok *pStrTok;
		char cNick[21];
		int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		ZeroMemory(cNick, sizeof(cNick));
		memcpy_secure(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token == NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			delete pStrTok;
			return;
		}
		memcpy_secure(cNick, token, 20);

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cNick, strlen(cNick)) == 0)) {
				if (m_pClientList[i]->NoClear == TRUE)
					m_iAFKUsers--;

				m_pClientList[i]->NoClear = FALSE;
				//Antipull
				m_pClientList[i]->NoDelete = FALSE;

				m_pClientList[i]->m_bForceDisconnect = true;
				DeleteClient(i, TRUE, TRUE);
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DeleteCliente");
	}
#endif
}

void CMapServer::CallMercenary(short Map)
{
#ifdef DEF_DEBUG
	try {
#endif
		char MapName[11];
		int pX, pY, iNamingValue, z, i, j, l;
		char cWaypoint[11];
		char cNpcName[21];
		char cName_Master[10], cSA;
		BOOL bMaster;

		ZeroMemory(MapName, sizeof(MapName));
		cSA = 0;
		if (Map == 1) strcpy_secure(MapName, "aresden");
		else if (Map == 2) strcpy_secure(MapName, "elvine");

		for (z = 0; z < DEF_MAXMAPS; z++) {
			if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, MapName) == 0)) {
				for (j = 0; j < 5; j++) {
					if (m_bIsCrusadeMode == TRUE) {
						switch (j) {
							case 0: // shop 
								if (Map == 1) {
									pX = 129;
									pY = 173;
								}
								else if (Map == 2) {
									pX = 230;
									pY = 158;
								}
								break;

							case 1: // WH
								if (Map == 1) {
									pX = 105;
									pY = 189;
								}
								else if (Map == 2) {
									pX = 201;
									pY = 132;
								}
								break;
							case 2: // BS
								if (Map == 1) {
									pX = 157;
									pY = 205;
								}
								else if (Map == 2) {
									pX = 236;
									pY = 111;
								}
								break;
							case 3: // CH
								if (Map == 1) {
									pX = 151;
									pY = 128;
								}
								else if (Map == 2) {
									pX = 150;
									pY = 130;
								}
								break;
							case 4: // GMG
								if (Map == 1) {
									pX = 165;
									pY = 111;
								}
								else if (Map == 2) {
									pX = 170;
									pY = 121;
								}
								break;
						}
					}

					for (i = 0; i < 5; i++) {
						if (m_bIsRushNetMode) {
							if (Map == 2) {
								pX = 180;
								pY = 153 + i;
							}
							//Reliquia Aresden
							else if (Map == 1) {
								pX = 155;
								pY = 134 + i;
							}
							j = 5;
						}

						for (l = 0; l < 5; l++) {
							switch (iDice(1, 6)) {
								case 1:
									if (Map == 1) strcpy_secure(cNpcName, "XB-Aresden");
									else if (Map == 2) strcpy_secure(cNpcName, "XB-Elvine");
									break;
								case 2:
									if (Map == 1) strcpy_secure(cNpcName, "XW-Aresden");
									else if (Map == 2) strcpy_secure(cNpcName, "XW-Elvine");
									break;
								case 3:
									if (Map == 1) strcpy_secure(cNpcName, "XY-Aresden");
									else if (Map == 2) strcpy_secure(cNpcName, "XY-Elvine");
									break;
								case 4:
									if (Map == 1) strcpy_secure(cNpcName, "YB-Aresden");
									else if (Map == 2) strcpy_secure(cNpcName, "YB-Elvine");
									break;
								case 5:
									if (Map == 1) strcpy_secure(cNpcName, "YW-Aresden");
									else if (Map == 2) strcpy_secure(cNpcName, "YW-Elvine");
									break;
								case 6:
									if (Map == 1) strcpy_secure(cNpcName, "YY-Aresden");
									else if (Map == 2) strcpy_secure(cNpcName, "YY-Elvine");
									break;
							}
							if ((m_pMapList[z]->m_iMaximumObject - 500) > m_pMapList[z]->m_iTotalActiveObject) {
								iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
								if (iNamingValue != -1) {
									ZeroMemory(cName_Master, sizeof(cName_Master));
									wsprintf(cName_Master, "XX%d", iNamingValue);
									cName_Master[0] = '_';
									cName_Master[1] = z + 65;

									if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[z]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
										m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
									}
								}
							}
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CallMercenary");
	}
#endif
}

//New Data Reduced - ZeroEoyPnk
void CMapServer::SendPlayerData(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * pBuffer = NULL;
		DWORD * dwp;
		WORD  * wp;
		char  * cp;
		short * sp;
		int   * ip, iRet, iStats;

		if (m_pClientList[iClientH] == NULL) return;

		pBuffer = new char[DEF_MSGBUFFERSIZE + 1];
		ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE + 1);

		dwp = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_PLAYERCHARACTERCONTENTS;
		wp = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
		//6
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_iHP;
		cp += 2;
		//8
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_iMP;
		cp += 2;
		//10
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_iSP;
		cp += 2;
		//12
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
		//16
		*cp = m_pClientList[iClientH]->m_iStr;
		cp++;
		//17
		*cp = m_pClientList[iClientH]->m_iInt;
		cp++;
		//18
		*cp = m_pClientList[iClientH]->m_iVit;
		cp++;
		//19
		*cp = m_pClientList[iClientH]->m_iDex;
		cp++;
		//20
		*cp = m_pClientList[iClientH]->m_iMag;
		cp++;
		//21
		*cp = m_pClientList[iClientH]->m_iCharisma;
		cp++;
		//22
		iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
			m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma);

		/*m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLevel * 3 - (iStats - 70);*/

		int pool = m_pClientList[iClientH]->m_iLevel * 3 - (iStats - 70);
		pool = pool + m_pClientList[iClientH]->getRebirthStats();
		m_pClientList[iClientH]->m_iLU_Pool = pool;

		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iLU_Pool;
		cp += 2;
		//24
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iExp;
		cp += 4;
		//28
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iEnemyKillCount;
		cp += 4;
		//32
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iPKCount;
		cp += 4;
		//36
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iRewardGold;
		cp += 4;
		//40
		memcpy_secure(cp, m_pClientList[iClientH]->m_cLocation, 10);
		cp += 10;
		//50
		memcpy_secure(cp, m_pClientList[iClientH]->m_cGuildName, 20);
		cp += 20;
		//70
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildRank;
		cp += 4;
		//74
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iFightzoneNumber;
		cp += 4;
		//78
		if (m_pClientList[iClientH]->Assasain) *cp = 1;
		else *cp = 0;
		cp++;
		//79

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 79); // old 115
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				if (pBuffer != NULL) delete[]pBuffer;
				return;
		}
		if (pBuffer != NULL) delete[]pBuffer;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendPlayerData");
	}
#endif
}

void CMapServer::LoadPlayerItems(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * pBuffer = NULL;
		short * sp;
		DWORD * dwp;
		WORD  * wp;
		char  * cp;
		int   i, iTotalItemA, iTotalItemB, iRet;
		BOOL bFlag;
		short Temp;

		if (m_pClientList[iClientH] == NULL) return;

		pBuffer = new char[DEF_MSGBUFFERSIZE + 1];
		ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE + 1);

		dwp = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_PLAYERITEMLISTCONTENTS;
		wp = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		iTotalItemA = 0;
		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
				iTotalItemA++;
		}

		bFlag = FALSE;
		while (bFlag == FALSE) {
			bFlag = TRUE;
			for (i = 0; i < DEF_MAXITEMS - 1; i++) {
				if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH]->m_pItemList[i + 1] != NULL)) {
					m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemList[i + 1];
					m_pClientList[iClientH]->m_pItemList[i + 1] = NULL;
					m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_ItemPosList[i + 1].x;
					m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_ItemPosList[i + 1].y;
					bFlag = FALSE;
				}
			}
		}
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
		CalcTotalItemEffect(iClientH, -1, FALSE);

		cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
		*cp = iTotalItemA;
		cp++;

		for (i = 0; i < iTotalItemA; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
				CharacterLogList(G_cTxt);

				DeleteClient(iClientH, FALSE, TRUE);
				if (pBuffer != NULL) delete[]pBuffer;
				return;
			}
			memcpy_secure(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
			cp += 20;
			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
			cp += 4;
			*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
			cp++;
			*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
			cp++;
			*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
			cp++;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
			cp += 2;
			*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
			cp++;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
			cp += 2;
			*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
			cp++;
			//*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
			//cp++;
			//lalomanu
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
			cp += 4;
			*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3; // v1.41 
			cp++;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[i]->GetBagPositionX();
			cp += 2;

			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[i]->GetBagPositionY();
			cp += 2;
		}

		iTotalItemB = 0;
		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL)
				iTotalItemB++;
		}

		sp = (short *)cp;
		*sp = iTotalItemB;
		cp += 2;

		for (i = 0; i < iTotalItemB; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
				wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
				PutLogList(G_cTxt);

				DeleteClient(iClientH, FALSE, TRUE);
				if (pBuffer != NULL) delete[]pBuffer;
				return;
			}

			memcpy_secure(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
			cp += 20;
			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
			cp += 4;
			*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
			cp++;
			*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
			cp++;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
			cp += 2;
			*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
			cp++;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
			cp += 2;
			*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor;
			cp++;
			//*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2;
			//cp++;
			//lalomanu
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2;
			cp += 2;
			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
			cp += 4;
			*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3;
			cp++;
			// ZeroEoyPnk - WH Page
			*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->GetBankPosition();
			cp++;
		}

		Temp = 0;
		for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
			*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
			cp++;
			if (m_pClientList[iClientH]->m_cMagicMastery[i] != NULL) Temp++;
		}

		for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
			*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
			cp++;
		}

		for (i = 0; i < DEF_MAXACHIVEMENTS; i++) {
			CheckCompleteAchivement(iClientH, i, FALSE, FALSE);
		}

		//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA * 49 + iTotalItemB * 46 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		//lalomanu
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA * 50 + iTotalItemB * 47 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				if (pBuffer != NULL) delete[]pBuffer;
				return;
		}
		if (pBuffer != NULL) delete[]pBuffer;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LoadPlayerItems");
	}
#endif
}

void CMapServer::SendRestPlayerData(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char  * pBuffer = NULL;
		short * sp;
		DWORD * dwp;
		WORD  * wp;
		char  * cp;
		int   * ip, iSize, iRet;
		char cPrice = 0;

		if (m_pClientList[iClientH] == NULL) return;

		if (TRUE == m_pClientList[iClientH]->m_bIsOnShop) {
			cPrice = 0;
			if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide)
				cPrice = -10;
		}

		pBuffer = new char[DEF_MSGBUFFERSIZE + 1];
		ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE + 1);

		dwp = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_INITDATA;
		wp = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
		*wp = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

		if (m_pClientList[iClientH]->m_sX == -1 && m_pClientList[iClientH]->m_sY == -1)
			GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);
		else if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
			bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
		else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

		// ObjectID
		sp = (short *)cp;
		*sp = iClientH;
		cp += 2;
		//8
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
		cp += 2;
		//10
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
		cp += 2;
		//12
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sType;
		cp += 2;
		//14
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sAppr1;
		cp += 2;
		//16
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sAppr2;
		cp += 2;
		//18
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sAppr3;
		cp += 2;
		//20
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_sAppr4;
		cp += 2;
		//22
		ip = (int *)cp; // v1.4
		*ip = m_pClientList[iClientH]->m_iApprColor;
		cp += 4;
		//26
		// New Colors -> ZeroEoyPnk
		ip = (int *)cp; // v1.4
		*ip = m_pClientList[iClientH]->m_iApprColor2;
		cp += 4;
		//26 30
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iStatus;
		cp += 4;
		//30 34
		memcpy_secure(cp, m_pClientList[iClientH]->m_cMapName, 10);
		cp += 10;
		//40 44
		memcpy_secure(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
		cp += 10;
		//50 54
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)
			*cp = 1;
		else *cp = m_cDayOrNight;
		cp++;
		//51 55
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)
			*cp = NULL;
		else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
		cp++;
		//52 56
		if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
				DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		}

		*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
		cp++;

		// 53 57
		*cp = cPrice;
		cp += 1;

		// 54 58
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0 && m_pClientList[iClientH]->m_iAdminUserLevel <= 9)
			*cp = (char)m_pClientList[iClientH]->m_iAdminUserLevel;
		else *cp = 0;
		cp++; //59

		iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->res_sX, m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->res_sY, iClientH, cp);

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, iSize + 59); //Original
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				if (pBuffer != NULL) delete[]pBuffer;
				return;
		}
		if (pBuffer != NULL) delete[]pBuffer;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendRestPlayerData");
	}
#endif
}

void CMapServer::SendLasData(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		SendContribution(iClientH);
		SendEnemyKills(iClientH);
		SendCriticals(iClientH);

		if (m_pClientList[iClientH] == NULL) return;

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
		SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ASSASAINSPOINTS, m_pClientList[iClientH]->AssasainPoint, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendLasData");
	}
#endif
}

// Data Reduced -> Final Version 3.0
void CMapServer::SendEnemyKills(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iEnemyKillCount > 0) {
			if (m_pClientList[iClientH]->m_iEnemyKillCount <= 125)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ENEMYKILLS1, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			else if (m_pClientList[iClientH]->m_iEnemyKillCount > 125 && m_pClientList[iClientH]->m_iEnemyKillCount <= 30000)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ENEMYKILLS2, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			else if (m_pClientList[iClientH]->m_iEnemyKillCount > 30000)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ENEMYKILLS3, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
		}
		else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ENEMYKILLS1, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEnemyKills");
	}
#endif
}

void CMapServer::SendContribution(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iContribution > 0) {
			if (m_pClientList[iClientH]->m_iContribution <= 125)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CONTRIBUTION1, m_pClientList[iClientH]->m_iContribution, NULL, NULL, NULL);
			else if (m_pClientList[iClientH]->m_iContribution > 125 && m_pClientList[iClientH]->m_iContribution <= 30000)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CONTRIBUTION2, m_pClientList[iClientH]->m_iContribution, NULL, NULL, NULL);
			else if (m_pClientList[iClientH]->m_iContribution > 30000)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CONTRIBUTION3, m_pClientList[iClientH]->m_iContribution, NULL, NULL, NULL);
		}
		else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CONTRIBUTION1, m_pClientList[iClientH]->m_iContribution, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendContribution");
	}
#endif
}

void CMapServer::SendCriticals(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iSuperAttackLeft > 0) {
			if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 125)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SUPERATTACKLEFT1, m_pClientList[iClientH]->m_iSuperAttackLeft, NULL, NULL, NULL);
			else if (m_pClientList[iClientH]->m_iSuperAttackLeft > 125 && m_pClientList[iClientH]->m_iSuperAttackLeft <= 30000)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SUPERATTACKLEFT2, m_pClientList[iClientH]->m_iSuperAttackLeft, NULL, NULL, NULL);
			else if (m_pClientList[iClientH]->m_iSuperAttackLeft > 30000)
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SUPERATTACKLEFT3, m_pClientList[iClientH]->m_iSuperAttackLeft, NULL, NULL, NULL);
		}
		else SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SUPERATTACKLEFT1, m_pClientList[iClientH]->m_iSuperAttackLeft, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendCriticals");
	}
#endif
}

/*void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
#ifdef DEF_DEBUG
	try {
#endif
		int * ip, iRet, iShortCutIndex = 0;
		char * cp, cData[200];
		DWORD * dwp;
		WORD  * wp;
		short * sp;
		int   * ipStatus, iTemp, iTemp2, iTemp3, iDumm, i;
		BOOL  bFlag;
		char  cKey;
		int iSize;

		ipStatus = (int *)&iDumm;
		cKey = (char)(rand() % 255) + 1;
		iSize = 0;

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = wMsgType;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sOwnerH] == NULL) return;

			switch (wMsgType) {
			case DEF_OBJECTMAGIC:
				wp = (WORD *)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				*cp = (unsigned char)sV1;
				cp++; // 10

				*cp = (unsigned char)sV2;
				cp++; // 11

				iSize = 11;
				break;

			case DEF_OBJECTDAMAGE:
				wp = (WORD *)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short *)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				iSize = 12;
				break;

			case DEF_OBJECTDAMAGEMOVE:
				wp = (WORD *)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short *)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				iSize = 12;
				break;

			case DEF_OBJECTDYING:
				wp = (WORD *)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short *)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sX;
				cp += 2; // 14

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sY;
				cp += 2; // 16

				iSize = 16;
				break;

			case DEF_OBJECTATTACK:
			case DEF_OBJECTATTACKMOVE:
				wp = (WORD *)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				*cp = sV1 - m_pClientList[sOwnerH]->m_sX;
				cp++; // 10

				*cp = sV2 - m_pClientList[sOwnerH]->m_sY;
				cp++; // 11

				sp = (short *)cp;
				*sp = sV3;
				cp += 2; // 13

				iSize = 13;
				break;


			case DEF_MSGTYPE_CONFIRM:
			case DEF_MSGTYPE_REJECT:
			case DEF_OBJECTNULLACTION:
			default:
				wp = (WORD *)cp;
				*wp = sOwnerH;
				cp += 2; // 8

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sX;
				cp += 2;  // 10

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sY;
				cp += 2; // 12

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sType;
				cp += 2; // 14

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 15

				memcpy_secure(cp, m_pClientList[sOwnerH]->m_cCharName, 10);
				cp += 10; // 25

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr1;
				cp += 2; // 27

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr2;
				cp += 2; // 29

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr3;
				cp += 2; // 31

				sp = (short *)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr4;
				cp += 2; // 33

				ip = (int *)cp;
				*ip = m_pClientList[sOwnerH]->m_iApprColor;
				cp += 4; // 37

				// New Colors -> ZeroEoyPnk
				ip = (int *)cp;
				*ip = m_pClientList[sOwnerH]->m_iApprColor2;
				cp += 4; // 37//41

				ip = (int *)cp;
				ipStatus = ip;
				*ip = m_pClientList[sOwnerH]->m_iStatus;
				cp += 4; // 41 45

				iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;

				if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 && m_pClientList[sOwnerH]->m_iAdminUserLevel <= 9)
					*cp = (char)m_pClientList[sOwnerH]->m_iAdminUserLevel;
				else {
					if (m_pClientList[sOwnerH]->OpenSell == TRUE) *cp = 99;
					else *cp = 0;
				}
				cp++; // 42 46

				if (wMsgType == DEF_OBJECTNULLACTION) {
					if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) *cp = 1;
					else *cp = 0;
				}
				else *cp = 0;
				cp++;

				iSize = 47;
				break;

			}

			bFlag = TRUE;
			iShortCutIndex = 0;
			while (bFlag == TRUE) {
				i = m_iClientShortCut[iShortCutIndex];
				iShortCutIndex++;
				if (i == 0) bFlag = FALSE;
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
						(!m_pClientList[i]->NoClear) &&
						(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 16 + 3) &&
						(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 16 + 3) &&
						(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 12 + 2) &&
						(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 12 + 2)) { 
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
							if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0)
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							else if (i != sOwnerH) iTemp = iTemp3;
							else iTemp = m_pClientList[sOwnerH]->m_iStatus;
						}
						else iTemp = m_pClientList[sOwnerH]->m_iStatus;

						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
						iTemp = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						switch (wMsgType) {
						case DEF_OBJECTNULLACTION:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;

						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTMAGIC:
						case DEF_OBJECTDAMAGEMOVE:
						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;

						default:
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;
						}
					}
				}
			}
		}
		else {
			if (m_pNpcList[sOwnerH] == NULL) return;

			switch (wMsgType) {
			case DEF_OBJECTDYING:
				wp = (WORD *)cp;
				*wp = sOwnerH + 40000;
				cp += 2; // 8

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short *)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				sp = (short *)cp;
				*sp = m_pNpcList[sOwnerH]->m_sX;
				cp += 2; // 14

				sp = (short *)cp;
				*sp = m_pNpcList[sOwnerH]->m_sY;
				cp += 2; // 16

				iSize = 16;
				break;

			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDAMAGEMOVE:
				wp = (WORD *)cp;
				*wp = sOwnerH + 40000;
				cp += 2; // 8

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short *)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				iSize = 12;
				break;

			case DEF_OBJECTATTACK:
			case DEF_OBJECTATTACKMOVE:
				wp = (WORD *)cp;
				*wp = sOwnerH + 40000;
				cp += 2; // 8

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 9

				*cp = sV1 - m_pNpcList[sOwnerH]->m_sX;
				cp++; // 10

				*cp = sV2 - m_pNpcList[sOwnerH]->m_sY;
				cp++; // 11

				sp = (short *)cp;
				*sp = sV3;
				cp += 2; // 13

				iSize = 13;
				break;

			case DEF_MSGTYPE_CONFIRM:
			case DEF_MSGTYPE_REJECT:
			case DEF_OBJECTNULLACTION:
			default:
				wp = (WORD *)cp;
				*wp = sOwnerH + 10000;
				cp += 2; // 8

				sp = (short *)cp;
				*sp = m_pNpcList[sOwnerH]->m_sX;
				cp += 2; // 10

				sp = (short *)cp;
				*sp = m_pNpcList[sOwnerH]->m_sY;
				cp += 2; // 12

				sp = (short *)cp;
				*sp = m_pNpcList[sOwnerH]->m_sType;
				cp += 2; // 14

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 15

				memcpy_secure(cp, m_pNpcList[sOwnerH]->m_cName, 5);
				cp += 5; // 20

				sp = (short *)cp;
				*sp = m_pNpcList[sOwnerH]->m_sAppr2;
				cp += 2; // 22

				ip = (int *)cp;
				ipStatus = ip;
				*ip = m_pNpcList[sOwnerH]->m_iStatus;
				cp += 4; // 26

				if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE) *cp = 1;
				else *cp = 0;
				cp++; // 27

				iSize = 27;
				break;
			}

			bFlag = TRUE;
			iShortCutIndex = 0;
			while (bFlag == TRUE) {
				i = m_iClientShortCut[iShortCutIndex];
				iShortCutIndex++;
				if (i == 0) bFlag = FALSE;
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {

					if ((m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
						(m_pClientList[i]->NoClear == FALSE) &&
						(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 16 - 3) &&
						(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 16 + 3) &&
						(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 12 - 2) &&
						(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 12 + 2)) {
						iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(sOwnerH, i);
						iTemp = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
						case DEF_OBJECTDYING:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;

						default:
							if (m_pClientList[i]->m_pXSock != NULL)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;
						}
					}
					
					
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEventToNearClient_TypeA");
	}
#endif
}*/

void CMapServer::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
#ifdef DEF_DEBUG
	try {
#endif
		int* ip, iRet, iShortCutIndex = 0;
		char* cp, cData[200];
		DWORD* dwp;
		WORD* wp;
		short* sp;
		int* ipStatus, iTemp, iTemp2, iTemp3, iDumm, i;
		BOOL  bFlag;
		char  cKey;
		int iSize;

		ipStatus = (int*)&iDumm;
		cKey = (char)(rand() % 255) + 1;
		iSize = 0;

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD*)(cData + DEF_INDEX4_MSGID);
		*dwp = dwMsgID;
		wp = (WORD*)(cData + DEF_INDEX2_MSGTYPE);
		*wp = wMsgType;

		cp = (char*)(cData + DEF_INDEX2_MSGTYPE + 2);

		if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sOwnerH] == NULL) return;

			switch (wMsgType) {
			case DEF_OBJECTMAGIC:
				wp = (WORD*)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				*cp = (unsigned char)sV1;
				cp++; // 10

				*cp = (unsigned char)sV2;
				cp++; // 11

				iSize = 11;
				break;

			case DEF_OBJECTDAMAGE:
				wp = (WORD*)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short*)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				iSize = 12;
				break;

			case DEF_OBJECTDAMAGEMOVE:
				wp = (WORD*)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short*)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				iSize = 12;
				break;

			case DEF_OBJECTDYING:
				wp = (WORD*)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short*)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sX;
				cp += 2; // 14

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sY;
				cp += 2; // 16

				iSize = 16;
				break;

			case DEF_OBJECTATTACK:
			case DEF_OBJECTATTACKMOVE:
				wp = (WORD*)cp;
				*wp = sOwnerH + 30000;
				cp += 2; // 8

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 9

				*cp = sV1 - m_pClientList[sOwnerH]->m_sX;
				cp++; // 10

				*cp = sV2 - m_pClientList[sOwnerH]->m_sY;
				cp++; // 11

				sp = (short*)cp;
				*sp = sV3;
				cp += 2; // 13

				iSize = 13;
				break;


			case DEF_MSGTYPE_CONFIRM:
			case DEF_MSGTYPE_REJECT:
			case DEF_OBJECTNULLACTION:
			default:
				wp = (WORD*)cp;
				*wp = sOwnerH;
				cp += 2; // 8

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sX;
				cp += 2;  // 10

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sY;
				cp += 2; // 12

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sType;
				cp += 2; // 14

				*cp = m_pClientList[sOwnerH]->m_cDir;
				cp++; // 15

				memcpy_secure(cp, m_pClientList[sOwnerH]->m_cCharName, 10);
				cp += 10; // 25

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr1;
				cp += 2; // 27

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr2;
				cp += 2; // 29

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr3;
				cp += 2; // 31

				sp = (short*)cp;
				*sp = m_pClientList[sOwnerH]->m_sAppr4;
				cp += 2; // 33

				ip = (int*)cp;
				*ip = m_pClientList[sOwnerH]->m_iApprColor;
				cp += 4; // 37

				// New Colors -> ZeroEoyPnk
				ip = (int*)cp;
				*ip = m_pClientList[sOwnerH]->m_iApprColor2;
				cp += 4; // 37//41

				ip = (int*)cp;
				ipStatus = ip;
				*ip = m_pClientList[sOwnerH]->m_iStatus;
				cp += 4; // 41 45

				iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F;

				if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0 && m_pClientList[sOwnerH]->m_iAdminUserLevel <= 9)
					*cp = (char)m_pClientList[sOwnerH]->m_iAdminUserLevel;
				else {
					if (m_pClientList[sOwnerH]->OpenSell == TRUE) *cp = 99;
					else *cp = 0;
				}
				cp++; // 42 46

				if (wMsgType == DEF_OBJECTNULLACTION) {
					if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) *cp = 1;
					else *cp = 0;
				}
				else *cp = 0;
				cp++;

				iSize = 47;
				break;

			}

			bFlag = TRUE;
			iShortCutIndex = 0;
			while (bFlag == TRUE) {
				i = m_iClientShortCut[iShortCutIndex];
				iShortCutIndex++;
				if (i == 0) bFlag = FALSE;
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
						(!m_pClientList[i]->NoClear) &&
						(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 16 - 3) &&
						(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 16 + 3) &&
						(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 12 - 2) &&
						(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 12 + 2)) {
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
							if (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0)
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							else if (i != sOwnerH) iTemp = iTemp3;
							else iTemp = m_pClientList[sOwnerH]->m_iStatus;
						}
						else iTemp = m_pClientList[sOwnerH]->m_iStatus;

						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
						iTemp = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						switch (wMsgType) {
						case DEF_OBJECTNULLACTION:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDYING:
							
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;

						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTMAGIC:
						case DEF_OBJECTDAMAGEMOVE:
						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;

						default:
							if (i != sOwnerH)
							{
								/*string response = "asd";
								sendto(m_pClientList[i]->serverSocket, response.c_str(), response.size(), 0,
									(sockaddr*)&m_pClientList[i]->clientAddr, m_pClientList[i]->clientAddrLen);*/
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							}								
							break;
						}
					}
				}
			}
		}
		else {
			if (m_pNpcList[sOwnerH] == NULL) return;

			switch (wMsgType) {
			case DEF_OBJECTDYING:
				wp = (WORD*)cp;
				*wp = sOwnerH + 40000;
				cp += 2; // 8

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short*)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				sp = (short*)cp;
				*sp = m_pNpcList[sOwnerH]->m_sX;
				cp += 2; // 14

				sp = (short*)cp;
				*sp = m_pNpcList[sOwnerH]->m_sY;
				cp += 2; // 16

				iSize = 16;
				break;

			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDAMAGEMOVE:
				wp = (WORD*)cp;
				*wp = sOwnerH + 40000;
				cp += 2; // 8

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 9

				sp = (short*)cp;
				*sp = sV1;
				cp += 2; // 11

				*cp = (unsigned char)sV2;
				cp++; // 12

				iSize = 12;
				break;

			case DEF_OBJECTATTACK:
			case DEF_OBJECTATTACKMOVE:
				wp = (WORD*)cp;
				*wp = sOwnerH + 40000;
				cp += 2; // 8

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 9

				*cp = sV1 - m_pNpcList[sOwnerH]->m_sX;
				cp++; // 10

				*cp = sV2 - m_pNpcList[sOwnerH]->m_sY;
				cp++; // 11

				sp = (short*)cp;
				*sp = sV3;
				cp += 2; // 13

				iSize = 13;
				break;

			case DEF_MSGTYPE_CONFIRM:
			case DEF_MSGTYPE_REJECT:
			case DEF_OBJECTNULLACTION:
			default:
				wp = (WORD*)cp;
				*wp = sOwnerH + 10000;
				cp += 2; // 8

				sp = (short*)cp;
				*sp = m_pNpcList[sOwnerH]->m_sX;
				cp += 2; // 10

				sp = (short*)cp;
				*sp = m_pNpcList[sOwnerH]->m_sY;
				cp += 2; // 12

				sp = (short*)cp;
				*sp = m_pNpcList[sOwnerH]->m_sType;
				cp += 2; // 14

				*cp = m_pNpcList[sOwnerH]->m_cDir;
				cp++; // 15

				memcpy_secure(cp, m_pNpcList[sOwnerH]->m_cName, 5);
				cp += 5; // 20

				sp = (short*)cp;
				*sp = m_pNpcList[sOwnerH]->m_sAppr2;
				cp += 2; // 22

				ip = (int*)cp;
				ipStatus = ip;
				*ip = m_pNpcList[sOwnerH]->m_iStatus;
				cp += 4; // 26

				if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE) *cp = 1;
				else *cp = 0;
				cp++; // 27

				iSize = 27;
				break;
			}

			bFlag = TRUE;
			iShortCutIndex = 0;
			while (bFlag == TRUE) {
				i = m_iClientShortCut[iShortCutIndex];
				iShortCutIndex++;
				if (i == 0) bFlag = FALSE;
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {

					if ((m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
						(m_pClientList[i]->NoClear == FALSE) &&
						(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 16 - 3) &&
						(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 16 + 3) &&
						(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 12 - 2) &&
						(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 12 + 2)) {
						iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(sOwnerH, i);
						iTemp = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
						case DEF_OBJECTDYING:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							break;

						default:
							if (m_pClientList[i]->m_pXSock != NULL)
							{/*
								string response = "asd";
								sendto(m_pClientList[i]->serverSocket, response.c_str(), response.size(), 0,
									(sockaddr*)&m_pClientList[i]->clientAddr, m_pClientList[i]->clientAddrLen);*/
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, iSize, cKey);
							}
								
							break;
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEventToNearClient_TypeA");
	}
#endif
}
void CMapServer::HammerStrip(int sAttackerH, char cAttackerType, int sTargetH, int iHitPoint)
{
#ifdef DEF_DEBUG
	try {
#endif
		// Hammer Stripping
		int iDownValue = 1;
		int iHammerChance = 100;
		short iTemp = 0, iTemp2 = 0;

		if (m_pClientList[sAttackerH] == NULL) return;
		if (m_pClientList[sTargetH] == NULL) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH] != NULL) && (m_pClientList[sAttackerH] != NULL)) {
			//Agregado all vs all -> Efecto de strip en hammer
			if (((AllVsAll == TRUE) && ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0) &&
				(strcmp(m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)))
				|| (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
				switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
					case 14:
						if (30 == ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4) || 31 == ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4)
							|| 32 == ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4)) {

							iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) {
								if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) iDownValue = 25; // BH
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) iDownValue = 30; // BBH
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) iDownValue = 35; // GBH
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4905) iDownValue = 50; // BLACK BH
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4975) iDownValue = 50; // PkssBarbarian
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 846) iDownValue = 45; // DEVAS
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4913) iDownValue = 50; // BLACK DEVAS
								else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4969) iDownValue = 100; // StripHammer
							}
						}
						else iDownValue = 20;
						break;

					case 10: iDownValue = 3; break;
					default: iDownValue = 1; break;
				}
			}
		}

		switch (iHitPoint) {
			case 1:
				iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
				if (iTemp == -1) iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_FULLBODY];
				break;

			case 2:
				switch (iDice(1, 2)) {
					case 1: iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS]; break;
					case 2: iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS]; break;
				}
				break;

			case 3: iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS]; break;
			case 4: iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD]; break;
			default: iTemp = -1; break;
		}

		// Aca empieza la joda :P
		if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
			// El endu mayor a 5k, es de "knight" con algunas meriens [en el +7 ya casi llega a los 10k aprox], o sea esta bien el num de 5k [default son 3.5k]
			// EL endu menor a 15k, es para lo white y dk [ cuando empieza el server no hay strip, asi que si tenes un white bajo, no pasa nada, ya que no te lo van a super estripear.
			// Para stripear mas seguido, hay que bajar bastante el endu.. una vez que un item knight, con merien baja de los 5k, se modifica al igual que un item
			// normal [no knight]
			if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan > 5000 && m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan < 15000) {
				iDownValue += 100; // Esto es el endu que le baja al item.
			}

			if (((m_pClientList[sTargetH]->m_cSide != DEF_NETURAL) || (m_pClientList[sTargetH]->Assasain)) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))
				m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iDownValue;

			if ((m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan >= 65000)) {
				m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
				SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				ReleaseItemHandler(sTargetH, iTemp, TRUE);
			}
			else if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)
				&& (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14)) {

				// Aca se calcula la "probabilidad" para el stripeo del item [ el calulo es el iHammerChance].
				if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan < 2000)
					iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));
				else iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan));

				if (30 == ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4) || 31 == ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4)
					|| 32 == ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4)) {

					iTemp2 = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
					if ((iTemp2 != -1) && (m_pClientList[sAttackerH]->m_pItemList[iTemp2] != NULL)) {

						// Aca se re-calcula la "probabilidad" para el stripeo del item [ el calulo es el iHammerChance ].
						// Se multiplica y se divide, a mayor el divisor, menor el stripeo...
						if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 761) iHammerChance = iHammerChance / 7; // Battle Hammer
						else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 762) iHammerChance = (5 * iHammerChance) / 5; // Giant Battle Hammer
						else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 843) iHammerChance = (5 * iHammerChance) / 6; // Barbarian Hammer
						else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4905) iHammerChance = (5 * iHammerChance) / 4; // BlackHammer
						else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4975) iHammerChance = (5 * iHammerChance) / 4; // PkssBarbarian
						else if (m_pClientList[sAttackerH]->m_pItemList[iTemp2]->m_sIDnum == 4969) iHammerChance = (5 * iHammerChance) / 2; // StripHammer
					}
				}
				else iHammerChance = iHammerChance / 4;

				switch (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_sIDnum) {
					case 621: // MerienPlateMailM
					case 622: // MerienPlateMailW
					case 3243: //MerienChainMailM
					case 3244: //MerienChainMailW
						iHammerChance = 0;
						break;
				}
				// Se verifica el endu actual, y si la chance calculada, es mayor al endu actual, se genera el stripeo.
				if (iHammerChance > m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan) {
					ReleaseItemHandler(sTargetH, iTemp, TRUE);
					SendNotifyMsg(NULL, sTargetH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: HammerStrip");
	}
#endif
}

void CMapServer::SendEventOpenData(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		// Crusade
		if (m_bIsCrusadeMode == TRUE) {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			}
			else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_iWarContribution = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
			}
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
		}
		else {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
			}
			else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);
				m_pClientList[iClientH]->m_iWarContribution = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			}
		}

		if (AbaddonEvent == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ABADDONMAP, NULL, NULL, NULL, NULL);
		else if (m_bIsRushNetMode == TRUE) { //Aviso que el RushNet Esta activado
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_RUSH, 10, NULL, NULL, NULL, NULL);
			UpdateRushNet(0);
		}
		else if (TowerDefense == TRUE) { //Aviso que el TowerDefense Esta activado
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TOWERDEFENCE, 10, NULL, NULL, NULL, NULL);
			UpdateTowerDefence(0);
		}
		else if (Soccer == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ENERGYSPHERECREATED, GolesAresden, GolesElvine, NULL, NULL);
		else if ((AllVsAllPortals == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) {
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_OPENPORTALS, NULL, NULL, NULL, NULL, NULL);
			RequestTeleportHandler(iClientH, "1   ");
		}
		else if (CityVsCity == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_CVCNOW, ContadorElvine, ContadorAresden, ContadorAssesino, NULL);
		//WorldWar - LaloRamos
		else if (WorldWar == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_WWNOW, WWContadorElvine, WWContadorAresden, WWContadorAssesino, NULL);
		//TowerOfHell - LaloRamos
		else if (TowerHell == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_TOHNOW, 10, NULL, NULL, NULL, NULL);	
		//Extreme Fight - LaloRamos
		else if (Masacre == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_EXTRNOW, 10, NULL, NULL, NULL, NULL);
		//Quest x 2 - Lalo Ramos
		else if (Questx2 == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST2, 10, NULL, NULL, NULL, NULL);
		//Quest x 3 - Lalo Ramos
		else if (Questx3 == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_QUEST3, 10, NULL, NULL, NULL, NULL);
		//Hunt Map - Lalo Ramos
		else if (VipMap == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_HUNTON, 10, NULL, NULL, NULL, NULL);
		//WorldWar - LaloRamos
		else if (WorldWarII == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_WWNOWII, WWIIContadorElvine, WWIIContadorAresden, WWIIContadorAssesino, NULL);
		//EventDk
		else if (DKEvent == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DKEVENT, 10, NULL, NULL, NULL, NULL);
		//AllEks
		else if (AllEks == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ALLEKSON, 10, NULL, NULL, NULL, NULL);
		//AllDkEks
		else if (AllDkEks == TRUE) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ALLDKEKSON, 10, NULL, NULL, NULL, NULL);

		/* ZeroEoyPnk - Envio la data de los eventos */
		SendEventData(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEventOpenData");
	}
#endif
}

// Summon Event - ZeroEoyPnk
void CMapServer::LaunchSummonEvent()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent == TRUE || RunSummonEvent == TRUE || RunSummonEvent2 == TRUE || RunSummonEvent3 == TRUE) return;
		DWORD dwTime = timeGetTime();
		int i;

		ActiveEvent = RunSummonEvent = RunSummonEvent2 = RunSummonEvent3 = SummonLaunched = TRUE;
		AresdenRound = ElvineRound = AssasainRound = TotalRounds = MSTotal = 0;

		SummonEventTime = timeGetTime() - 500;
		SelectedRounds = iDice(1, 12);
		SelectedRounds--;

		wsprintf(G_cTxt, "Summon Selected %d", SelectedRounds);
		PutLogList(G_cTxt);

		for (i = SelectedRounds * 25; i < (SelectedRounds * 25) + 25; i++) {
			if (SummonRound[i].Cant != NULL) TotalRounds++;
		}

		CreateMSStructures();
		AssasainSummon = AresdenSummon = ElvineSummon = timeGetTime() - 50;
		NextRound(0, AssasainRound, TotalRounds);
		NextRound(1, AresdenRound, TotalRounds);
		NextRound(2, ElvineRound, TotalRounds);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LaunchSummonEvent");
	}
#endif
}

void CMapServer::EndSummonEvent()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (RunSummonEvent == FALSE && RunSummonEvent2 == FALSE && RunSummonEvent3 == FALSE) return;
		int i, ESAresden, ESElvine, ESAssasain;

		ActiveEvent = RunSummonEvent = RunSummonEvent2 = RunSummonEvent3 = SummonLaunched = FALSE;
		AssasainSummon = AresdenSummon = ElvineSummon = SummonEventTime = -1;
		TotalRounds = MSTotal = 0;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear)
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
		}

		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] != NULL) {
				if (strcmp(m_pMapList[i]->m_cName, "ESAresden") == 0) ESAresden = i;
				else if (strcmp(m_pMapList[i]->m_cName, "ESElvine") == 0) ESElvine = i;
				else if (strcmp(m_pMapList[i]->m_cName, "ESAssasain") == 0) ESAssasain = i;
			}
		}

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				if (m_pNpcList[i]->m_cMapIndex == ESAresden || m_pNpcList[i]->m_cMapIndex == ESElvine || m_pNpcList[i]->m_cMapIndex == ESAssasain)
					NpcBehavior_Dead(i, FALSE);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndSummonEvent");
	}
#endif
}

void CMapServer::NextRound(short Side, short Type, short Total)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear && m_pClientList[i]->m_cSide == Side) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_NEXTROUND, Type, Total, NULL, NULL);
				if (m_pClientList[i] != NULL) {
					m_pClientList[i]->m_bIsSafeAttackMode = TRUE;

					if (m_pClientList[i]->m_cSide == 1) SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SUMMONEVENT, AresdenRound, TotalRounds, NULL, NULL);
					else if (m_pClientList[i]->m_cSide == 2) SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SUMMONEVENT, ElvineRound, TotalRounds, NULL, NULL);
					else if (m_pClientList[i]->Assasain == TRUE) SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SUMMONEVENT, AssasainRound, TotalRounds, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NextRound");
	}
#endif
}

void CMapServer::SummonAresden()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];
		int TempMap = -1, Position;

		AresdenSummon = -1;
		Position = 1;

		if (AresdenRound + 1 <= TotalRounds) {
			for (z = 0; z < DEF_MAXMAPS; z++) {
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "ESAresden") == 0)) {
					TempMap = z;
					for (i = 0; i < SummonRound[(SelectedRounds * 25) + AresdenRound].Cant; i++) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							ZeroMemory(cNpcName, sizeof(cNpcName));
							strcpy_secure(cNpcName, SummonRound[(SelectedRounds * 25) + AresdenRound].cNpcName);

							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

							switch (Position) {
								case 1: tX = 45; tY = 40; break;
								case 2: tX = 48; tY = 33; break;
								case 3: tX = 57; tY = 37; break;
								case 4: tX = 42; tY = 47; break;
								case 5: tX = 31; tY = 41; break;
								default: tX = 45; tY = 40; break;
							}
							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
								i = SummonRound[(SelectedRounds * 25) + AresdenRound].Cant;
							}
						}
						Position++;
						if (Position == 6) Position = 1;
					}
				}
			}
			NextRound(1, 2, SummonRound[(SelectedRounds * 25) + AresdenRound].Cant);

			if (TempMap != -1 && m_pMapList[TempMap]->m_iTotalAliveObject <= MSTotal) {
				AresdenRound++;
				SummonAresden();
			}
		}
		else {
			if (TempMap != -1) {
				RunSummonEvent = FALSE;
				AbrirPortales(2);
			}
		}
		if (TempMap != -1) {
			AresdenRound++;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear
					&& m_pClientList[i]->m_cSide == 1 && AresdenRound <= TotalRounds)
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SUMMONEVENT, AresdenRound, TotalRounds, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SummonAresden");
	}
#endif
}

void CMapServer::SummonElvine()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];
		int TempMap = -1, Position;

		ElvineSummon = -1;
		Position = 1;

		if (ElvineRound + 1 <= TotalRounds) {
			for (z = 0; z < DEF_MAXMAPS; z++) {
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "ESElvine") == 0)) {
					TempMap = z;
					for (i = 0; i < SummonRound[(SelectedRounds * 25) + ElvineRound].Cant; i++) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							ZeroMemory(cNpcName, sizeof(cNpcName));
							strcpy_secure(cNpcName, SummonRound[(SelectedRounds * 25) + ElvineRound].cNpcName);

							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
							switch (Position) {
								case 1: tX = 45; tY = 40; break;
								case 2: tX = 48; tY = 33; break;
								case 3: tX = 57; tY = 37; break;
								case 4: tX = 42; tY = 47; break;
								case 5: tX = 31; tY = 41; break;
								default: tX = 45; tY = 40; break;
							}

							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
								i = SummonRound[(SelectedRounds * 25) + ElvineRound].Cant;
							}
						}
						Position++;
						if (Position == 6) Position = 1;
					}
				}
			}
			NextRound(2, 2, SummonRound[(SelectedRounds * 25) + ElvineRound].Cant);
			if (TempMap != -1 && m_pMapList[TempMap]->m_iTotalAliveObject <= MSTotal) {
				ElvineRound++;
				SummonElvine();
			}
		}
		else {
			if (TempMap != -1) {
				RunSummonEvent2 = FALSE;
				AbrirPortales(3);
			}
		}
		if (TempMap != -1) {
			ElvineRound++;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear
					&& m_pClientList[i]->m_cSide == 2 && ElvineRound <= TotalRounds)
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SUMMONEVENT, ElvineRound, TotalRounds, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SummonElvine");
	}
#endif
}

void CMapServer::SummonAssasain()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];
		int TempMap = -1, Position;

		AssasainSummon = -1;
		Position = 1;

		if (AssasainRound + 1 <= TotalRounds) {
			for (z = 0; z < DEF_MAXMAPS; z++) {
				if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, "ESAssasain") == 0)) {
					TempMap = z;
					for (i = 0; i < SummonRound[(SelectedRounds * 25) + AssasainRound].Cant; i++) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							ZeroMemory(cNpcName, sizeof(cNpcName));
							strcpy_secure(cNpcName, SummonRound[(SelectedRounds * 25) + AssasainRound].cNpcName);

							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
							switch (Position) {
								case 1: tX = 45; tY = 40; break;
								case 2: tX = 48; tY = 33; break;
								case 3: tX = 57; tY = 37; break;
								case 4: tX = 42; tY = 47; break;
								case 5: tX = 31; tY = 41; break;
								default: tX = 45; tY = 40; break;
							}
							if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
								m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
								i = SummonRound[(SelectedRounds * 25) + AssasainRound].Cant;
							}
						}
						Position++;
						if (Position == 6) Position = 1;
					}
				}
			}
			NextRound(0, 2, SummonRound[(SelectedRounds * 25) + AssasainRound].Cant);
			if (TempMap != -1 && m_pMapList[TempMap]->m_iTotalAliveObject <= MSTotal) {
				AssasainRound++;
				SummonAssasain();
			}
		}
		else {
			if (TempMap != -1) {
				RunSummonEvent = FALSE;
				AbrirPortales(4);
			}
		}
		if (TempMap != -1) {
			AssasainRound++;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear
					&& m_pClientList[i]->Assasain == TRUE && AssasainRound <= TotalRounds)
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_SUMMONEVENT, AssasainRound, TotalRounds, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChatMsgHandler");
	}
#endif
}

void CMapServer::CreateMSStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];
		BOOL CreateMS;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
		CreateMS = FALSE;

		for (i = 0; i < MAX_DEFENCESTRUCTURESA; i++) {
			if (m_stSummonStructures[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stSummonStructures[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;

							switch (m_stSummonStructures[i].cType) {
								case 38:
									if (strcmp(m_pMapList[z]->m_cName, "ESAresden") == 0)
										strcpy_secure(cNpcName, "MS-Aresden");
									else if (strcmp(m_pMapList[z]->m_cName, "ESElvine") == 0)
										strcpy_secure(cNpcName, "MS-Elvine");
									else if (strcmp(m_pMapList[z]->m_cName, "ESAssasain") == 0)
										strcpy_secure(cNpcName, "MS-Elvine");
									break;

								default:
									strcpy_secure(cNpcName, m_pNpcConfigList[m_stSummonStructures[i].cType]->m_cNpcName);
									break;
							}

							tX = (int)m_stSummonStructures[i].dX;
							tY = (int)m_stSummonStructures[i].dY;

							if (strcmp(m_pMapList[z]->m_cName, "ESAssasain") == 0)
								CreateMS = bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, 11, FALSE);
							else CreateMS = bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE);

							if (CreateMS == FALSE) m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
							else {
								MSTotal++;
								wsprintf(G_cTxt, "Creating Summon Structure(%s) at %s(%d, %d)", cNpcName, m_stSummonStructures[i].cMapName, tX, tY);
								PutLogList(G_cTxt);
							}
						}
					}
				}
			}
		}
		MSTotal = MSTotal / 3;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateMSStructures");
	}
#endif
}

BOOL CMapServer::bReadSummonStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile != NULL) {
		PutLogList("Reading Summon configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! Summon configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);

								if (m_stSummonStructures[iIndex].cType != NULL) {
									ErrorList("(!!!) CRITICAL ERROR! Summon configuration file error - Duplicate number.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stSummonStructures[iIndex].cMapName, sizeof(m_stSummonStructures[iIndex].cMapName));
								memcpy_secure(m_stSummonStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Summon configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stSummonStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Summon configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stSummonStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! Summon configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stSummonStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default: break;
				}
			}
			else {
				if (memcmp(token, "summon-structure", 16) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! Summon Structure configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CMapServer::bReadRoundSummonConfigFile(char * cFn, short CFG)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile != NULL) {
		PutLogList("Reading Round configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = CFG * 25;

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) ERROR! Summon Round - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
									if (pFile != NULL) fclose(pFile);
								}
								iIndex = (CFG * 25) + atoi(token) - 1;

								if (iIndex >= (CFG * 25) + 25) {
									ErrorList("(!!!) ERROR! Summon Round - sobrepasado Max 25");
									delete cp;
									delete pStrTok;
									return FALSE;
									if (pFile != NULL) fclose(pFile);
								}

								if (SummonRound[iIndex].Cant != NULL) {
									ErrorList("(!!!) ERROR! Summon Round - Duplicate number.");
									wsprintf(G_cTxt, "Summon ID %d", iIndex);
									ErrorList(G_cTxt);
									delete cp;
									delete pStrTok;
									return FALSE;
									if (pFile != NULL) fclose(pFile);
								}
								cReadModeB = 2;
								break;

							case 2:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) ERROR! Summon Round - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
									if (pFile != NULL) fclose(pFile);
								}
								SummonRound[iIndex].Cant = atoi(token);
								cReadModeB = 3;
								break;

							case 3:
								ZeroMemory(SummonRound[iIndex].cNpcName, sizeof(SummonRound[iIndex].cNpcName));
								memcpy_secure(SummonRound[iIndex].cNpcName, token, strlen(token));
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "round-summon", 13) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) ERROR! Summon Round - file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::AdminOrder_Assasain(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cBuff[256];
		class  CStrTok * pStrTok;
		register int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					wsprintf(G_cTxt, "GM Order(%s): PC(%s) Cange to Assassin", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
					PutGMLogData(G_cTxt);
					m_pClientList[i]->AssasainPoint = DEF_ASSASAINPOINTS;
					ChangeToAssasain(i);
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_Assassin");
	}
#endif
}

void CMapServer::ChangeToAssasain(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		strcpy_secure(m_pClientList[iClientH]->m_cLocation, "NONE");
		ShowClientMsg(iClientH, "New job obteined: Assassin");
		m_pClientList[iClientH]->Assasain = TRUE;
		m_pClientList[iClientH]->m_iPKCount = 0;
		m_pClientList[iClientH]->m_iRating = 0;
		m_pClientList[iClientH]->m_cSide = DEF_NETURAL;
		if ((memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) { // Falta dato
			RemoveFromGuild(iClientH);
		}
		bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
		SendPlayerData(iClientH);
		RequestTeleportHandler(iClientH, "1   ");

		if (!m_pClientList[iClientH]->Achivements[24].Complete)
			CheckCompleteAchivement(iClientH, 24, TRUE);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChangeToAssassin");
	}
#endif
}

//New Function - ZeroEoyPnk
void CMapServer::ApplyPkPoint(int iAttackerH, int iClientH, BOOL Discount)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iAttackerH] == NULL) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iLevel < 21) return;

		//funcion antilam
		if ((strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIP2) == 0)
			|| (strcmp(m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cIPaddress) == 0)) {
			char cMsg[150];
			ZeroMemory(cMsg, sizeof(cMsg));
			wsprintf(cMsg, "Your PK(%s) has been blocked. Kill any other player!", m_pClientList[iClientH]->m_cCharName);
			ShowClientMsg(iAttackerH, cMsg);
			_bPKLog(DEF_PKLOG_BYPK, iAttackerH, iClientH, NULL, TRUE);
			return;
		}
		else _bPKLog(DEF_PKLOG_BYPK, iAttackerH, iClientH, NULL);

		strcpy_secure(m_pClientList[iAttackerH]->m_cIP2, m_pClientList[iClientH]->m_cIPaddress);

		if (!Discount) {
			m_pClientList[iAttackerH]->m_iExp += (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;
			if (memcmp(m_pClientList[iAttackerH]->m_cMapName, "masacre", 7) == 0) {
				m_pClientList[iAttackerH]->m_iPKCount += 2;
				m_pClientList[iAttackerH]->AssasainPoint += 2;
			}
			else {
				if (bHappyDay) m_pClientList[iAttackerH]->m_iPKCount += 4;
				else if (bHappyHour) m_pClientList[iAttackerH]->m_iPKCount += 2;
				m_pClientList[iAttackerH]->m_iPKCount++;
				m_pClientList[iAttackerH]->AssasainPoint++;
			}
			//WorldWar - LaloRamos Aumento pk
			if (memcmp(m_pClientList[iAttackerH]->m_cMapName, "FightMap", 8) == 0) {
				m_pClientList[iAttackerH]->m_iPKCount += 1;
				m_pClientList[iAttackerH]->AssasainPoint += 1;
			}

			//WorldWarII - LaloRamos Aumento pk
			if (memcmp(m_pClientList[iAttackerH]->m_cMapName, "WorldMap", 8) == 0) {
				m_pClientList[iAttackerH]->m_iPKCount += 2;
				m_pClientList[iAttackerH]->AssasainPoint += 2;
			}

			if (m_bIsCrusadeMode == TRUE) {
				m_pClientList[iAttackerH]->m_iPKCount += 1;
				m_pClientList[iAttackerH]->AssasainPoint += 1;
			}

			if ((m_pClientList[iClientH]->m_cSide = DEF_ARESDEN) && (memcmp(m_pClientList[iAttackerH]->m_cMapName, "evento13", 8) == 0) 
				|| (m_pClientList[iClientH]->m_cSide = DEF_ELVINE) && (memcmp(m_pClientList[iAttackerH]->m_cMapName, "evento13", 8) == 0)) {
					m_pClientList[iAttackerH]->m_iEnemyKillCount += 10;
			}
			else if ((m_pClientList[iClientH]->m_cSide = DEF_NETURAL) && (memcmp(m_pClientList[iAttackerH]->m_cMapName, "evento13", 8) == 0))
			{
				m_pClientList[iAttackerH]->m_iPKCount += 1;
				m_pClientList[iAttackerH]->AssasainPoint += 1;
			}

			if ((m_pClientList[iClientH]->m_cSide = DEF_ARESDEN) && (memcmp(m_pClientList[iAttackerH]->m_cMapName, "evento14", 8) == 0)
				|| (m_pClientList[iClientH]->m_cSide = DEF_ELVINE) && (memcmp(m_pClientList[iAttackerH]->m_cMapName, "evento14", 8) == 0)) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount += 10;
			}
			else if ((m_pClientList[iClientH]->m_cSide = DEF_NETURAL) && (memcmp(m_pClientList[iAttackerH]->m_cMapName, "evento14", 8) == 0))
			{
				m_pClientList[iAttackerH]->m_iPKCount += 1;
				m_pClientList[iAttackerH]->AssasainPoint += 1;
			}

			m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
			SendNotifyMsg(NULL, iAttackerH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
		}
		else {
			if (m_pClientList[iClientH]->m_iPKCount > 0) {
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
				m_pClientList[iAttackerH]->AssasainPoint--;
				m_pClientList[iClientH]->m_iPKCount--;
			}
			m_pClientList[iAttackerH]->m_iExp += (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;
			m_pClientList[iAttackerH]->AssasainPoint++;
			m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		}

		SendNotifyMsg(NULL, iAttackerH, CLIENT_NOTIFY_PKCAPTURED, m_pClientList[iClientH]->m_iPKCount, m_pClientList[iClientH]->m_iLevel, NULL, m_pClientList[iClientH]->m_cCharName);

		if (CityVsCity == TRUE) {
			if (m_pClientList[iAttackerH]->Assasain)  ContadorAssesino++;
		}

		//WorldWar - LaloRamos
		if ((WorldWar == TRUE) && (memcmp(m_pClientList[iClientH]->m_cMapName, "FightMap", 8) == 0)) {
			if (m_pClientList[iAttackerH]->Assasain) WWContadorAssesino++;
		}

		//WorldWar - LaloRamos
		if ((WorldWarII == TRUE) && (memcmp(m_pClientList[iClientH]->m_cMapName, "WorldMap", 8) == 0)) {
			if (m_pClientList[iAttackerH]->Assasain) WWIIContadorAssesino++;
		}

		if (m_pClientList[iAttackerH]->Assasain == FALSE) {
			if (bCheckLimitedUser(iAttackerH) == FALSE) {
				SendNotifyMsg(NULL, iAttackerH, CLIENT_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ApplyPkPoint");
	}
#endif
}

void CMapServer::GetAssasainHero(int iClientH, int iOpcion)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   i, iNum, iRet, iEraseReq, iPkRequired = 0, iRequiredContri = 0, iItemID;
		char  * cp, cData[256], cItemName[21];
		class CItem * pItem;
		DWORD * dwp;
		short * sp;
		WORD  * wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (!m_pClientList[iClientH]->Assasain) return;

		if (_iGetItemSpaceLeft(iClientH) == 0) {
			SendItemNotifyMsg(iClientH, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}

		iItemID = 0;
		switch (iOpcion) {
			case 1:
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 4101;
				else iItemID = 4102;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 2:
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 4105;
				else iItemID = 4106;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 3:
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 4109;
				else iItemID = 4110;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 4:
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 4111;
				else iItemID = 4112;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 5: iItemID = 4100;  iPkRequired = 2000; iRequiredContri = 0; break;

			case 6:
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 4103;
				else iItemID = 4104;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 7:
				if (m_pClientList[iClientH]->m_cSex == 1) iItemID = 4107;
				else iItemID = 4108;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 8:
				iItemID = 4972;
				iPkRequired = 2000;
				iRequiredContri = 0;
				break;

			case 9:
				iItemID = 4976;
				iPkRequired = 4000;
				iRequiredContri = 0;
				break;

			case 10:
				iItemID = 4977;
				iPkRequired = 6000;
				iRequiredContri = 0;
				break;

			case 11:
				iItemID = 4975;
				iPkRequired = 8000;
				iRequiredContri = 0;
				break;

			case 12:
				iItemID = 4974;
				iPkRequired = 6000;
				iRequiredContri = 0;
				break;

			case 13:
				iItemID = 4973;
				iPkRequired = 8000;
				iRequiredContri = 0;
				break;

			case 14:
				iItemID = 3095;
				iPkRequired = 100;
				iRequiredContri = 0;
				break;

			default: return; break;
		}

		if (iItemID == 0) return;
		if ((m_pClientList[iClientH]->m_iPKCount < iPkRequired) || (m_pClientList[iClientH]->m_iContribution < iRequiredContri)) return;

		iNum = 1;
		for (i = 1; i <= iNum; i++) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				pItem = NULL;
			}
			else {
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

					m_pClientList[iClientH]->m_iPKCount -= iPkRequired;
					m_pClientList[iClientH]->m_iContribution -= iRequiredContri;

					ZeroMemory(cItemName, sizeof(cItemName));
					memcpy_secure(cItemName, pItem->m_cName, 20);
					wsprintf(G_cTxt, "(*) Get Assassin Hero : Char(%s) Item(%s) Player-PK(%d) Contribution(%d)", m_pClientList[iClientH]->m_cCharName, cItemName, m_pClientList[iClientH]->m_iPKCount, m_pClientList[iClientH]->m_iContribution);
					CharacterLogList(G_cTxt);

					pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMOBTAINED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0;
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					//*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					//cp++;
					//cambio lalomanu
					sp = (short *)cp;
					*sp = pItem->m_sItemSpecEffectValue2;
					cp += 2;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;

					*cp = (char)pItem->m_sItemSpecEffectValue3;
					cp++;

					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

					if (iEraseReq == 1) {
						delete pItem;
						pItem = NULL;
					}

					//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 54);
					//cambio lalomanu
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);

					iCalcTotalWeight(iClientH);

					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
					SendContribution(iClientH);
				}
				else {
					delete pItem;
					pItem = NULL;

					iCalcTotalWeight(iClientH);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: GetAssasainHero");
	}
#endif
}

void CMapServer::ResetAssasain(int iClientH, int iV1)
{

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iPKCount < 5000) return;

		DWORD wResult;

		switch (iV1) {
			case 1:
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy_secure(m_pClientList[iClientH]->m_cLocation, "aresden");
				m_pClientList[iClientH]->m_cSide = DEF_ARESDEN;
				wResult = 1;
				break;
			case 2:
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy_secure(m_pClientList[iClientH]->m_cLocation, "elvine");
				m_pClientList[iClientH]->m_cSide = DEF_ELVINE;
				wResult = 2;
				break;
			default:
				wResult = 0;
				break;
		}

		if (wResult != 0) {
			m_pClientList[iClientH]->m_iPKCount = 0;
			m_pClientList[iClientH]->m_iRating = 0;
			m_pClientList[iClientH]->AssasainPoint = 0;
			m_pClientList[iClientH]->Assasain = FALSE;
			bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);
			if (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) { // Falta Dato
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy_secure(m_pClientList[iClientH]->m_cGuildName, "NONE");
				m_pClientList[iClientH]->m_iGuildRank = -1;
				m_pClientList[iClientH]->m_iGuildGUID = -1;

				SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
			}
			SendPlayerData(iClientH);
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ResetAssasain");
	}
#endif
}

void CMapServer::ChangePkToEk(int iClientH, int iV1)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (!m_pClientList[iClientH]->Assasain) return;
		unsigned int Ek, Pk;

		switch (iV1) {
			case 1: Pk = 10; Ek = 100; break;
			case 2: Pk = 50; Ek = 500; break;
			case 3: Pk = 100; Ek = 1000; break;
			case 4: Pk = 500; Ek = 5000; break;
			case 5: Pk = 1000; Ek = 10000; break;
			case 6: Pk = 5000; Ek = 50000; break;
			case 7: Pk = 10000; Ek = 100000; break;
			case 8: Pk = 50000; Ek = 500000; break;
			case 9: Pk = 100000; Ek = 1000000; break;
			default: Ek = 0; Pk = 0; break;
		}

		if (Pk != 0) {
			if (m_pClientList[iClientH]->m_iPKCount >= Pk) {
				m_pClientList[iClientH]->m_iEnemyKillCount += Ek;
				m_pClientList[iClientH]->m_iPKCount -= Pk;
			}
			SendEnemyKills(iClientH);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChangePkToEk");
	}
#endif
}

void CMapServer::ChangeLocation(int iClientH, DWORD wResult)
{

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		char * cp, cData[100];
		DWORD * dwp;
		WORD * wp;
		int  iRet;

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_RESPONSE_CIVILRIGHT;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = (WORD)wResult;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy_secure(cp, m_pClientList[iClientH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return;
		}

		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

		if (m_pClientList[iClientH]->m_iPartyID != NULL) RequestDismissPartyHandler(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChangeLocation");
	}
#endif
}

// Hell Of Death Event
BOOL CMapServer::bReadHellOfDeathConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;
	class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		ErrorList("Cannot open Hell Of Death configuration file.");
		return FALSE;
	}
	else {
		PutLogList("Reading Hell Of Death configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stHellOfDeathStructures[iIndex].cMapName, sizeof(m_stHellOfDeathStructures[iIndex].cMapName));
								memcpy_secure(m_stHellOfDeathStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;


							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stHellOfDeathStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stHellOfDeathStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stHellOfDeathStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;
					case 2:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iIndex = atoi(token);
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(m_stHellOfDeathStructures[iIndex].cMapName, sizeof(m_stHellOfDeathStructures[iIndex].cMapName));
								memcpy_secure(m_stHellOfDeathStructures[iIndex].cMapName, token, strlen(token));
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stHellOfDeathStructures[iIndex].cType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stHellOfDeathStructures[iIndex].dX = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR!  Hell Of Death configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_stHellOfDeathStructures[iIndex].dY = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "structure", 9) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "structurs", 9) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) CRITICAL ERROR! Hell Of Death Structure configuration file contents error!");
			return FALSE;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::CreateHellOfDeathStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, z, tX, tY, iNamingValue;
		char cName[6], cNpcName[21], cNpcWayPoint[11];

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cNpcName, sizeof(cNpcName));
		ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

		for (i = 0; i < MAX_DEFENCESTRUCTURES; i++) {
			if (m_stHellOfDeathStructures[i].cType != NULL) {
				for (z = 0; z < DEF_MAXMAPS; z++) {
					if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stHellOfDeathStructures[i].cMapName) == 0)) {
						iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = z + 65;
							tX = tY = 0;
							if (PriceHODEvent == FALSE) {
								switch (i) {
									case 1:
										if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0)
											strcpy_secure(cNpcName, "gate-a");
										break;
									case 2:
										if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0)
											strcpy_secure(cNpcName, "gate-n");
										break;
									case 3:
										if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0)
											strcpy_secure(cNpcName, "gate-e");
										break;
									case 4:
									case 5:
									case 6:
									case 7:
										if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0)
											strcpy_secure(cNpcName, "Reliquia-e");
										break;
									case 8:
									case 9:
									case 10:
									case 11:
										if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0)
											strcpy_secure(cNpcName, "Reliquia-a");
										break;
									default:
										strcpy_secure(cNpcName, m_pNpcConfigList[m_stHellOfDeathStructures[i].cType]->m_cNpcName);
										break;
								}
								tX = (int)m_stHellOfDeathStructures[i].dX;
								tY = (int)m_stHellOfDeathStructures[i].dY;
							}
							else {
								if (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0) {
									if (m_pMapList[z]->m_iTotalAliveObject <= 9) { // max mobs -1 -> 10 mobs = 9
										strcpy_secure(cNpcName, "HellDeath");
										tX = 128;
										tY = 133;
									}
								}
							}
							if (tX != 0) {
								if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
									m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
								}
							}
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateHellOfDeathStructures");
	}
#endif
}

void CMapServer::InitHellOfDeath()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (HellOfDeath || ActiveEvent) return;
		DWORD dwTime = timeGetTime();

		HellOfDeath = ActiveEvent = TRUE;
		PriceHODEvent = FALSE;

		RandomEventID = iDice(1, 100000);

		dw_HODTime = dwTime - 100;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (m_pClientList[i]->RndEventID != RandomEventID) m_pClientList[i]->RndEventID = RandomEventID;
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HELLOFDEATH, 10, NULL, NULL, NULL, NULL);
				m_pClientList[i]->m_bIsSafeAttackMode = TRUE;
			}
		}

		CreateHellOfDeathStructures();

		ActualizarStructures();
		PutLogList("Hell Of Death Mode ON.");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitHellOfDeath");
	}
#endif
}

void CMapServer::EndHellOfDeathMode(int Loser)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;
		DWORD dwTime = timeGetTime();

		if (HellOfDeath == FALSE) return;
		HellOfDeath = FALSE;
		ActiveEvent = FALSE;

		PutLogList("Hell Of Death Mode OFF.");

		EventTime = ((((dwTime - dw_HODTime) / 60000) * DEF_EVENT_TIME_PRICE) / 100);

		RemoveHODStructures();

		if (Loser != 0) {
			ActiveEvent = TRUE;
			PriceHODEvent = TRUE;
			dw_PriceHODTime = dwTime - 100;
			CreateHellOfDeathStructures();
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (m_pClientList[i]->RndEventID != RandomEventID) m_pClientList[i]->RndEventID = RandomEventID;

				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HELLOFDEATH, Loser, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_EVENTDATA, DEF_HOD, EventCount[DEF_HOD].AresdenWin, EventCount[DEF_HOD].ElvineWin, NULL, EventCount[DEF_HOD].Draw, EventCount[DEF_HOD].LastWin);
				m_pClientList[i]->m_bIsSafeAttackMode = TRUE;

				if ((m_pClientList[i]->m_cSide != Loser) && (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_EVENTMAP_HELLOFDEAT, 8) == 0)) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
				}
			}
		}
		CreateEventResults(Loser, 5);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndHellOfDeathMode");
	}
#endif
}

void CMapServer::RemoveHODStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;

		for (i = 0; i < DEF_MAXNPCS; i++) {
			if (m_pNpcList[i] != NULL) {
				switch (m_pNpcList[i]->m_sType) {
					case 91:
					case 92:
					case 108:
						NpcBehavior_Dead(i, FALSE);
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveHODStructures");
	}
#endif
}

void CMapServer::SearchAssasainPosition(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		int i, Temp;
		Temp = -1;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && m_pClientList[i]->m_iAdminUserLevel == 0
				&& m_pClientList[i]->Assasain == TRUE) {
				if (m_pClientList[i]->FirstPosition == TRUE)
					Temp = i;
			}
		}

		if ((Top[3][0].Points == NULL) || (Top[3][0].Points == 0))
			HandleRequestMemoryTops(0, 3, FALSE);
		else if (Top[3][0].Points <= m_pClientList[iClientH]->m_iPKCount)
			HandleRequestMemoryTops(0, 3, FALSE);

		if (strcmp(Top[3][0].Name, m_pClientList[iClientH]->m_cCharName) == 0) {
			m_pClientList[iClientH]->FirstPosition = TRUE;
			if (Temp != -1) {
				m_pClientList[Temp]->FirstPosition = FALSE;
				CalcTotalItemEffect(Temp, -1, FALSE);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SearchAssasainPosition");
	}
#endif
}

void CMapServer::CloseHODMap()
{
#ifdef DEF_DEBUG
	try {
#endif
		int i;

		if (PriceHODEvent == FALSE) return;

		PriceHODEvent = FALSE;
		ActiveEvent = FALSE;

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear) {
				if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, DEF_EVENTMAP_HELLOFDEAT, 8) == 0) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
				}
				m_pClientList[i]->m_bIsSafeAttackMode = FALSE;
			}
		}
		RemoveHODStructures();
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CloseHODMap");
	}
#endif
}

void CMapServer::ReloadSummonEventConfig()
{
#ifdef DEF_DEBUG
	try {
#endif

		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound.txt", 0);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound2.txt", 1);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound3.txt", 2);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound4.txt", 3);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound5.txt", 4);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound6.txt", 5);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound7.txt", 6);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound8.txt", 7);
		bReadRoundSummonConfigFile("Events\\Summon\\SummonRound9.txt", 8);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReloadSummonEventConfig");
	}
#endif
}

/* New Trade Item System */
/*void CGame::RequestTradeItemHandler(int iClientH, char * pItemName, int iNum, short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		char  * cp, cItemName[21], cData[100];
		short * sp;
		DWORD * dwp, dwItemCount;
		WORD  * wp;
		int   i, iRet, iEraseReq;
		int * ip;
		short Init, Finish;
		char TradeLog[500];

		BOOL Check = FALSE, ID = FALSE;
		short ItemPos;
		int Points;

		ZeroMemory(TradeLog, sizeof(TradeLog));

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iLevel < 200) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && FinalFight) return;

		switch (Type) {
			case 0: Init = 0; Finish = 499; break;
			case 1: Init = 500; Finish = 999; break;
			case 2: Init = 1000; Finish = 1499; break;
			case 3: Init = 1500; Finish = 1999; break;
			default: return;
		}

		for (i = Init; i <= Finish; i++) {
			if (memcmp(pItemName, ItemsTrade[i].m_cName, 21) == 0) {
				Check = TRUE;
				ItemPos = i;
				if (Check) ID = TradeID[Type];
				if (ItemsTrade[i].unique) ID = TRUE;
			}
		}

		if (Check == FALSE) return;

		ZeroMemory(cData, sizeof(cData));
		ZeroMemory(cItemName, sizeof(cItemName));

		if (memcmp(pItemName, DEF_ITEMNAME_10ARROWS, 8) == 0) {
			strcpy_secure(cItemName, DEF_ITEMNAME_ARROW);
			dwItemCount = 10;
		}
		else if (memcmp(pItemName, DEF_ITEMNAME_100ARROWS, 9) == 0) {
			strcpy_secure(cItemName, DEF_ITEMNAME_ARROW);
			dwItemCount = 100;
		}
		else {
			memcpy_secure(cItemName, pItemName, 20);
			dwItemCount = 1;
		}

		for (i = 1; i <= iNum; i++) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) delete pItem;
			else {
				pItem->m_dwCount = dwItemCount;
				if (ID) {
					pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				}
				else {
					pItem->m_sTouchEffectType = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1, 100000);

					// Anti Dup System
					SYSTEMTIME SysTime;
					char cTemp[256];
					GetLocalTime(&SysTime);
					ZeroMemory(cTemp, sizeof(cTemp));
					pItem->m_sTouchEffectValue2 = iDice(1, 100000);
					wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue2 = atoi(cTemp);

					ZeroMemory(cTemp, sizeof(cTemp));
					wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);
				}

				switch (Type) {
					case 0: Points = m_pClientList[iClientH]->m_iEnemyKillCount; break;
					case 1: Points = m_pClientList[iClientH]->m_iContribution; break;
					case 2: Points = m_pClientList[iClientH]->m_iCoins; break;
					case 3: Points = m_pClientList[iClientH]->m_iPKCount; break;
				}

				if (Points < ItemsTrade[ItemPos].m_wPrice) {
					delete pItem;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_NOTENOUGHGOLD2; // Cambiar mensaje
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = Type;
					cp++;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
					return;
				}

				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMPURCHASED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)Type;
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					ip = (int *)cp;
					*ip = ItemsTrade[ItemPos].m_wPrice;
					cp += 4;

					if (iEraseReq == 1) {
						delete pItem;
						pItem = NULL;
					}

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 50);
					iCalcTotalWeight(iClientH);

					switch (Type) {
						case 0:
							m_pClientList[iClientH]->m_iEnemyKillCount -= ItemsTrade[ItemPos].m_wPrice;
							SendEnemyKills(iClientH);
							wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: Enemy Kill - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
							break;
						case 1:
							m_pClientList[iClientH]->m_iContribution -= ItemsTrade[ItemPos].m_wPrice;
							SendContribution(iClientH);
							wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: Contribution - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
							break;
						case 2:
							m_pClientList[iClientH]->m_iCoins -= ItemsTrade[ItemPos].m_wPrice;
							SendNotifyMsg(iClientH, NULL, CLIENT_NOTIFY_COINS, m_pClientList[iClientH]->m_iCoins, NULL, NULL, NULL);
							wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: Coins - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
							break;
						case 3:
							m_pClientList[iClientH]->m_iPKCount -= ItemsTrade[ItemPos].m_wPrice;
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
							wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: PKs - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
							break;
					}
					PutLogTradeFileList(TradeLog);

					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
				else {
					delete pItem;
					iCalcTotalWeight(iClientH);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
						case DEF_XSOCKEVENT_QUENEFULL:
						case DEF_XSOCKEVENT_SOCKETERROR:
						case DEF_XSOCKEVENT_CRITICALERROR:
						case DEF_XSOCKEVENT_SOCKETCLOSED:
							DeleteClient(iClientH, TRUE, TRUE);
							return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestTradeItemHandler");
	}
#endif
}*/
 
//Nueva funcion fix
/* New Trade Item System */
void CMapServer::RequestTradeItemHandler(int iClientH, char * pItemName, int iNum, short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		char  * cp, cItemName[21], cData[100];
		short * sp;
		DWORD * dwp, dwItemCount;
		WORD  * wp;
		int   i, iRet, iEraseReq;
		int * ip;
		short Init, Finish;
		char TradeLog[500];

		BOOL Check = FALSE, ID = FALSE;
		short ItemPos;
		int Points;

		ZeroMemory(TradeLog, sizeof(TradeLog));

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[iClientH]->m_iLevel < 60) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && FinalFight) return;

		switch (Type) {
		case 0: Init = 0; Finish = 499; break;
		case 1: Init = 500; Finish = 999; break;
		case 2: Init = 1000; Finish = 1499; break;
		case 3: Init = 1500; Finish = 1999; break;
		default: return;
		}

		for (i = Init; i <= Finish; i++) {
			if (memcmp(pItemName, ItemsTrade[i].m_cName, 20) == 0) {//21
				Check = TRUE;
				ItemPos = i;
				if (Check) ID = TradeID[Type];
				if (ItemsTrade[i].unique) ID = TRUE;
			}
		}

		if (Check == FALSE) return;

		ZeroMemory(cData, sizeof(cData));
		ZeroMemory(cItemName, sizeof(cItemName));

		if (memcmp(pItemName, DEF_ITEMNAME_10ARROWS, 8) == 0) {
			strcpy_secure(cItemName, DEF_ITEMNAME_ARROW);
			dwItemCount = 10;
		}
		else if (memcmp(pItemName, DEF_ITEMNAME_100ARROWS, 9) == 0) {
			strcpy_secure(cItemName, DEF_ITEMNAME_ARROW);
			dwItemCount = 100;
		}
		else {
			memcpy_secure(cItemName, pItemName, 20);
			dwItemCount = 1;
		}

		for (i = 1; i <= iNum; i++) {
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) delete pItem;
			else {
				pItem->m_dwCount = dwItemCount;
				if (ID) {
					pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				}
				else {
					pItem->m_sTouchEffectType = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1, 100000);

					// Anti Dup System
					SYSTEMTIME SysTime;
					char cTemp[256];
					GetLocalTime(&SysTime);
					ZeroMemory(cTemp, sizeof(cTemp));
					pItem->m_sTouchEffectValue2 = iDice(1, 100000);
					wsprintf(cTemp, "%02d%02d", (short)SysTime.wMonth, (short)SysTime.wDay);
					pItem->m_sTouchEffectValue2 = atoi(cTemp);

					ZeroMemory(cTemp, sizeof(cTemp));
					wsprintf(cTemp, "%02d%02d%02d%d", (short)SysTime.wHour, (short)SysTime.wMinute, (short)SysTime.wSecond, (short)SysTime.wMilliseconds);
					pItem->m_sTouchEffectValue3 = atoi(cTemp);
				}

				switch (Type) {
				case 0: Points = m_pClientList[iClientH]->m_iEnemyKillCount; break;
				case 1: Points = m_pClientList[iClientH]->m_iContribution; break;
				case 2: Points = m_pClientList[iClientH]->m_iCoins; break;
				case 3: Points = m_pClientList[iClientH]->m_iPKCount; break;
				}

				if (Points < ItemsTrade[ItemPos].m_wPrice) {
					delete pItem;

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_NOTENOUGHGOLD2; // Cambiar mensaje
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = Type;
					cp++;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
					return;
				}

				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

					switch (Type) {
					case 0:
						m_pClientList[iClientH]->m_iEnemyKillCount -= ItemsTrade[ItemPos].m_wPrice;
						SendEnemyKills(iClientH);
						wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: Enemy Kill - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);//guardar data dsp de hacer una compra
						break;
					case 1:
						m_pClientList[iClientH]->m_iContribution -= ItemsTrade[ItemPos].m_wPrice;
						SendContribution(iClientH);
						wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: Contribution - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
						break;
					case 2:
						m_pClientList[iClientH]->m_iCoins -= ItemsTrade[ItemPos].m_wPrice;
						SendNotifyMsg(iClientH, NULL, CLIENT_NOTIFY_COINS, m_pClientList[iClientH]->m_iCoins, NULL, NULL, NULL);
						wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: Coins - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
						bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);//guardar data dsp de hacer una compra
						break;
					case 3:
						m_pClientList[iClientH]->m_iPKCount -= ItemsTrade[ItemPos].m_wPrice;
						SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);
						wsprintf(TradeLog, "Character: %s - Item: %s - Trade Type: PKs - Price: %d", m_pClientList[iClientH]->m_cCharName, pItemName, ItemsTrade[ItemPos].m_wPrice);
						break;
					}
					PutLogTradeFileList(TradeLog);
				//	bSendMsgToLS(NUCLEO_REQUEST_SAVEPLAYERDATA, iClientH);//guardar data dsp de hacer una compra

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_ITEMPURCHASED;

					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					*cp = 1;
					cp++;

					memcpy_secure(cp, pItem->m_cName, 20);
					cp += 20;

					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;					

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)Type;
					cp++;

					sp = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;

					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;

					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					ip = (int *)cp;
					*ip = ItemsTrade[ItemPos].m_wPrice;
					cp += 4;

					if (iEraseReq == 1) {
						delete pItem;
						pItem = NULL;
					}

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 50);
					iCalcTotalWeight(iClientH);

					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
				else {
					delete pItem;
					iCalcTotalWeight(iClientH);

					dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = CLIENT_NOTIFY;
					wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp = CLIENT_NOTIFY_CANNOTCARRYMOREITEM;

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestTradeItemHandler");
	}
#endif
}


BOOL CMapServer::ReadTradeItems(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iItemListIndex = 0;
	class CStrTok * pStrTok;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	cReadModeA = 0;
	cReadModeB = 0;

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		return FALSE;
	}
	else {
		PutLogList("Reading Round configuration file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1: // Name
								ZeroMemory(ItemsTrade[iItemListIndex].m_cName, sizeof(ItemsTrade[iItemListIndex].m_cName));
								memcpy_secure(ItemsTrade[iItemListIndex].m_cName, token, strlen(token));
								cReadModeB++;
								break;
							case 15: // m_wPrice
								ItemsTrade[iItemListIndex].m_wPrice = atoi(token);
								cReadModeB++;
								break;

							case 20: // m_wPrice
								ItemsTrade[iItemListIndex].unique = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								iItemListIndex++;
								break;

							default:
								cReadModeB++;
								break;
						}
						break;
					case 2:
						if (memcmp(token, "TRUE", 4) == 0) TradeID[iItemListIndex / 500] = TRUE;
						else if (memcmp(token, "FALSE", 5) == 0) TradeID[iItemListIndex / 500] = FALSE;
						else {
							ErrorList("(!!!) CRITICAL ERROR! XXX configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
							if (pFile != NULL) fclose(pFile);
						}
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					case 3:
						if (memcmp(token, "EnemyKills", 10) == 0) iItemListIndex = 0;
						else if (memcmp(token, "Contributions", 13) == 0) iItemListIndex = 500;
						else if (memcmp(token, "Coins", 5) == 0) iItemListIndex = 1000;
						else if (memcmp(token, "Pks", 3) == 0) iItemListIndex = 1500;
						else {
							ErrorList("(!!!) CRITICAL ERROR! XXX configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
							if (pFile != NULL) fclose(pFile);
						}
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "Item", 4) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				else if (memcmp(token, "ID", 2) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
				else if (memcmp(token, "Trade-Type", 10) == 0) {
					cReadModeA = 3;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete[]cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			ErrorList("(!!!) ERROR! TradeContrib - file contents error!");
			return FALSE;
		}
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

/* New System Exchange */
void CMapServer::RequestRemoveItemExchange(int iClientH, int iItemIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iExH, i, Error, iWeightLeft;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

		if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			if ((m_pClientList[iExH] == NULL) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0)) {}
			else {
				Error = -1;
				if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;

				for (i = iItemIndex; i < 20; i++) {
					if (m_pClientList[iClientH]->m_cExchangeItemIndex[i + 1] != -1) {
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = m_pClientList[iClientH]->m_cExchangeItemIndex[i + 1];
						m_pClientList[iClientH]->m_iExchangeItemAmount[i] = m_pClientList[iClientH]->m_iExchangeItemAmount[i + 1];
						memcpy_secure(m_pClientList[iClientH]->m_cExchangeItemName[i], m_pClientList[iClientH]->m_cExchangeItemName[i + 1], 20);
					}
					else {
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iClientH]->m_iExchangeItemAmount[i] = -1;
						ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
					}
				}

				m_pClientList[iClientH]->iExchangeCount--;
				SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_REMOVEITEMEXCHANGE, iItemIndex, NULL, NULL, NULL, NULL);
				SendNotifyMsg(iClientH, iExH, CLIENT_RESPONSE_REMOVEITEMEXCHANGE, iItemIndex + 20, NULL, NULL, NULL, NULL);

				iWeightLeft = CalcWeightExchange(iClientH, iExH);
				if (iWeightLeft < 100) Error = 1;

				if (Error == -1) {
					iWeightLeft = CalcWeightExchange(iExH, iClientH);
					if (iWeightLeft < 100) Error = 2;
				}

				if (Error == -1) {
					if (CalcTotalBagExchange(iExH, iClientH) == TRUE) Error = 3;
					else if (CalcTotalBagExchange(iExH, iClientH) == TRUE) Error = 4;
				}

				if (Error == -1) {
					SendNotifyMsg(iClientH, iClientH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 0, NULL, NULL, NULL);
					SendNotifyMsg(iClientH, iExH, CLIENT_RESPONSE_WEIGHTEXCHANGE, 0, NULL, NULL, NULL);
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestRemoveItemExchange");
	}
#endif
}

int CMapServer::CalcWeightExchange(int iClientH, int iExH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iWeightLeft, iWeight, i, j;
		BOOL Check;
		iWeight = 0;

		if (m_pClientList[iClientH] == NULL) return 0;
		if (m_pClientList[iExH] == NULL) return 0;

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				Check = TRUE;

				for (j = 0; j <= m_pClientList[iClientH]->iExchangeCount; j++) {
					if (m_pClientList[iClientH]->m_cExchangeItemIndex[j] == i)
						Check = FALSE;
				}

				if (Check && m_pClientList[iClientH]->m_pItemList[i] != NULL)
					iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
			}
		}

		if (m_pClientList[iExH]->iExchangeCount != 0) {
			for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
				if (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] != NULL)
					iWeight += iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]], m_pClientList[iExH]->m_iExchangeItemAmount[i]);
			}
		}

		iWeightLeft = (_iCalcMaxLoad(iClientH) - iWeight) / 100;

		return iWeightLeft;

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalcWeightExchange");
	}
#endif
	return 0;
}

BOOL CMapServer::CalcTotalBagExchange(int iClientH, int iExH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short TotalItems, i, j;
		BOOL Check;

		if (m_pClientList[iClientH] == NULL) return 0;
		if (m_pClientList[iExH] == NULL) return 0;

		TotalItems = 0;
		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				Check = TRUE;

				for (j = 0; j <= m_pClientList[iClientH]->iExchangeCount; j++) {
					if (m_pClientList[iClientH]->m_cExchangeItemIndex[j] == i)
						Check = FALSE;
				}

				if (Check) TotalItems++;
			}
		}

		if (m_pClientList[iExH]->iExchangeCount != 0) {
			for (i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
				if (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] != NULL)
					TotalItems++;
			}
		}

		if (TotalItems >= DEF_MAXITEMS) return TRUE;
		else return FALSE;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChatMsgHandler");
	}
#endif
	return TRUE;
}

void CMapServer::CheckItemStatedEquipment(int iClientH)//seguir aca
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		char cEquipPos;

		if (m_pClientList[iClientH] == NULL) return;

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				if (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) {
					cEquipPos = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
					if ((DKEvent && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_EVENTDK) == 0) ||
						(AllDkEks && strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0))
					{
						bool itemAllowed = false;
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum)
							{
							case 702: //hat w 
							case 703: //Hat M
							case 706: // DarkKnightHauberk
							case 707: // DarkKnightFullHelm 
							case 708: // DarkKnightLeggings  
							case 710: // DarkKnightPlateMail 
							case 711: // DarkMageHauberk 
							case 712: // DarkMageChainMail
							case 713: // DarkMageLeggings  
							case 715: //DarkMageRobe
							case 716: // DarkMageLedderArmor
							case 719: // DarkMageScaleMail
							case 724: // DarkKnightHauberkW
							case 725: // DarkKnightFullHelmW 
							case 726: // DarkKnightLeggingsW 
							case 728: // DarkKnightPlateMailW 
							case 729: // DarkMageHauberkW 
							case 730: // DarkMageChainMailW 
							case 731: // DarkMageLeggingsW 
							case 733: //DarkMageRobeW
							case 709: // DarkKnightFlameberge
							case 718: // DarkKnightGreatSword
							case 727: // DarkKnightFlamebergW
							case 736: // SangAhGiantSword
							case 737: // DarkKnightGiantSword
							case 745: // BlackKnightTemple
							case 2011: // DarkKnightHammer			
							case 2012: // DarkKnightBHammer			
							case 2013: // DarkKnightBBHammer
							case 714: // DarkMageMagicStaff 
							case 732: // DarkMageMagicStaffW 
							case 738: // DarkMageMagicWand
							case 746: // BlackMageTemple
							case 717: // DarkKnightRapier
							itemAllowed = true;
							break;
							default:
							break;
							}
							if (!itemAllowed)
							{
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "En este mapa solo puedes usar Items DK");
							}
					}
					switch (cEquipPos) {
						case DEF_EQUIPPOS_HEAD:
						case DEF_EQUIPPOS_BODY:
						case DEF_EQUIPPOS_ARMS:
						case DEF_EQUIPPOS_PANTS:
							switch (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue4) {
								case 10: // Str ���� 
									if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue5) {
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
										ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
									}
									break;
								case 11: // Dex
									if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue5) {
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
										ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
									}
									break;
								case 12: // Vit
									if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue5) {
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
										ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
									}
									break;
								case 13: // Int
									if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue5) {
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
										ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
									}
									break;
								case 14: // Mag
									if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue5) {
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
										ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
									}
									break;
								case 15: // Chr
									if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectValue5) {
										SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
										ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
									}
									break;
							}
							break;

						case DEF_EQUIPPOS_RHAND:
						case DEF_EQUIPPOS_TWOHAND:
						case DEF_EQUIPPOS_LHAND:
							if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[i]->m_wWeight / 100) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos], TRUE);
							}
							break;
					}
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {

						case 4913: // BlackDevastator
						case 846:  // The_Devastator
						case 850:  // KlonessAxe
						case 4905: // BlackHammer
						case 849:  // Kloness Blade
						case 4975: // PkssBarbarian
						case 4976: // PkssBlade
						case 4977: // PkssAxe
							if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 200 Dex");
							}
							break;
						case 865: // Resur Wand Ms 10
						case 866: // Resur Wand Ms 29
							if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt)) > 99 &&
								((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag)) > 99 && m_pClientList[iClientH]->m_iSpecialAbilityTime < 1) {
								m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATECHANGE_SUCCESS, 1, NULL, NULL, NULL);
							}
							break;
						case 890: // power hero sword
							if (((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < 200) ||
								((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 200 Str and 200 Dex");
							}
							break;
						case 2090: // power hero wand
						case 861: // Berserk Wand MS30
						case 862: // Berserk Wand MS10
						case 4973: // Assasain Wand MS20
						case 4974: // Assasain Wand MS40
						case 3116: //Black ZW
							if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 200) ||
								((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) < 200)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 200 Int and 200 Mag");
							}
							break;
						case 863: //KlonessWand(MS30)
						case 864: //KlonessWand(MS10)
							if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 100) ||
								((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_sRankAddMag + m_pClientList[iClientH]->m_iAngelicMag) < 200)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 100 Int and 200 Mag");
							}
							break;
						case 845: //StormBringer
							if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 65) ||
								((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 65 Int and 200 Dex");
							}
							break;
						case 4957: // Ares Storm Bringer
						case 4958: // Elv Storm Bringer|
							if (((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_sRankAddInt + m_pClientList[iClientH]->m_iAngelicInt) < 65) ||
								((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 65 Int and 200 Dex");
							}
							break;

						case 762: //GiantBattleHammer
						case 616: //DemonSlayer
						case 848: //LightingBlade
							if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 150) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 150 Dex");
							}
							break;
						case 618: //DarkElfBow
						case 847: //DarkExecutor
							if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 100) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 100 Dex");
							}
							break;

						case 4959: //ares bow
						case 4960: //Elv Bow
							if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 100) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 100 Dex");
							}
							break;
						case 4969: // Ice Strip Hammer
							if (((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_sRankAddStr + m_pClientList[iClientH]->m_iAngelicStr) < 200) ||
								((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_sRankAddDex + m_pClientList[iClientH]->m_iAngelicDex) < 200)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "You need 200 Str and 200 Dex");
							}
							break;

						case 3111:
							if ((m_pClientList[iClientH]->m_iLevel > 150) || (m_pClientList[iClientH]->m_iRebirthLevel > 0)) {
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, i, NULL, NULL);
								ReleaseItemHandler(iClientH, i, TRUE);
								ShowClientMsg(iClientH, "Your level is too high to use this item");
							}
							break;
						default:
							break;
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckItemStatedEquipment");
	}
#endif
}

void CMapServer::CheckCompleteAchivement(int iClientH, short AchivementID, BOOL Check, BOOL New)
{
	return;
#ifdef DEF_DEBUG
	try {
#endif
		short Temp = 0, Coins = 0;
		char String[500];

		if (m_pClientList[iClientH] == NULL) return;

		switch (AchivementID) {
			/********** First Line **********/
			case 0: // Matar 1000 Mobs
				if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1000)) {
					m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalMobsKilled;
					if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 1000) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 1000;
					Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 1000;
					if (Temp == 100) Coins = 1;
				}
				else Temp = 100;
				break;
			case 1: // Completar 1 quest
				if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
					m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalQuestCompleted;
					if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 1)m_pClientList[iClientH]->Achivements[AchivementID].Contador = 1;
					if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
					else Temp = 0;
					if (Temp == 100) Coins = 1;
				}
				else Temp = 100;
				break;
			case 2: // Crear / participar de una partyd
				if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
					if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
					else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

					if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
					else Temp = 0;
					if (Temp == 100) Coins = 1;
				}
				else Temp = 100;
				break;
			case 3: // Matar un Mob flechas
				if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
					if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
					else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

					if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
					else Temp = 0;
					if (Temp == 100) Coins = 1;
				}
				else Temp = 100;
				break;
			case 4: // Matar 100 players
				if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 100)) {
					m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalClientKilled;
					if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 100)m_pClientList[iClientH]->Achivements[AchivementID].Contador = 100;
					Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador;
					if (Temp == 100) Coins = 1;
				}
				else Temp = 100;
				break;

				/********** Second Line **********/
			case 5: // Completar 10 Quests
				if (m_pClientList[iClientH]->Achivements[0].Complete && m_pClientList[iClientH]->Achivements[1].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 10)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalQuestCompleted - 1;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 10)m_pClientList[iClientH]->Achivements[AchivementID].Contador = 10;
						Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador * 10;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 6: // participar de una party de 15 players
				if (m_pClientList[iClientH]->Achivements[1].Complete && m_pClientList[iClientH]->Achivements[2].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 7: // participar / crear una guild
				if (m_pClientList[iClientH]->Achivements[2].Complete && m_pClientList[iClientH]->Achivements[3].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 8:// Matar un char con flechas
				if (m_pClientList[iClientH]->Achivements[3].Complete && m_pClientList[iClientH]->Achivements[4].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;

				/********** Thirt Line **********/
			case 9: // Matar 10000 Mobs
				if (m_pClientList[iClientH]->Achivements[0].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 10000)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalMobsKilled - 1000;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 10000) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 10000;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 10000;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 10: // Destruir 10 estructuras durante un evento
				if (m_pClientList[iClientH]->Achivements[5].Complete && m_pClientList[iClientH]->Achivements[6].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 10)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalStructuresKilled;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 10) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 10;
						Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador * 10;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 11: // Matar un boss (ultimo golpe)
				if (m_pClientList[iClientH]->Achivements[6].Complete && m_pClientList[iClientH]->Achivements[7].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 12: // Conseguir 500 coins
				if (m_pClientList[iClientH]->Achivements[7].Complete && m_pClientList[iClientH]->Achivements[8].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 500)) {
						if (m_pClientList[iClientH]->m_iCoins >= 500) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 500;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->m_iCoins;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 500;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 13: // Matar 500 Players
				if (m_pClientList[iClientH]->Achivements[4].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 500)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalClientKilled - 100;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 500) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 500;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 500;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;

				/********** Four Line **********/
			case 14: // Completar 50 Quests
				if (m_pClientList[iClientH]->Achivements[5].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 50)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalQuestCompleted - 11;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 50) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 50;
						Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador * 2;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 15: // Ganar 1 all vs all
				if (m_pClientList[iClientH]->Achivements[10].Complete && m_pClientList[iClientH]->Achivements[11].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 16: // Aprender una magia de manual
				if (m_pClientList[iClientH]->Achivements[11].Complete && m_pClientList[iClientH]->Achivements[12].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 17: // Tener 10 Pks
				/*if (m_pClientList[iClientH]->Achivements[8].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 10)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->m_iPKCount;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 10) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 10;
						Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador * 10;
						if (Temp == 100) Coins = 500;
					}
					else Temp = 100;
				}
				break;*/
				//Hacer 750 eks!
				if (m_pClientList[iClientH]->Achivements[8].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 750)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalClientKilled - 100;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 750) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 750;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 750;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;

				/********** Five Line **********/
			case 18: // Figurar en un top
				if (m_pClientList[iClientH]->Achivements[15].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
				//Cambiar anulado
		/*	case 19: // Recibir 1 resurrection en un all vs all ;)
				if (m_pClientList[iClientH]->Achivements[15].Complete && m_pClientList[iClientH]->Achivements[16].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;
						//cambio archivement para que este aprobado si o si LaloArchiv
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador >= 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 500;
					}
					else Temp = 100;
				}
				break;*/
			case 19: // Extra QUEST
				if (m_pClientList[iClientH]->Achivements[15].Complete && m_pClientList[iClientH]->Achivements[16].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 500)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalQuestCompleted - 61;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 500) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 500;
						Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 20: // Completar todos los circulos de magias
				if (m_pClientList[iClientH]->Achivements[16].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;

				/********** Six Line **********/
			case 21: // Completar 100 Quests
				if (m_pClientList[iClientH]->Achivements[14].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 100)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalQuestCompleted - 61;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 100) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 100;
						Temp = m_pClientList[iClientH]->Achivements[AchivementID].Contador;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;

			case 22: // Figurar en el primer puesto de un top
				if (m_pClientList[iClientH]->Achivements[18].Complete && m_pClientList[iClientH]->Achivements[19].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 23: // Tener mas de 1500 horas de online
				if (m_pClientList[iClientH]->Achivements[19].Complete && m_pClientList[iClientH]->Achivements[20].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1500)) {
						if (m_pClientList[iClientH]->HourPlaying >= 1500) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 1500;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->HourPlaying;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 1500;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
				//Nuevo
			case 24: // Tener mas de 2500 horas de online
				if (m_pClientList[iClientH]->Achivements[17].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 2500)) {
						if (m_pClientList[iClientH]->HourPlaying >= 2500) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 2500;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->HourPlaying;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 2500;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
				//An8ulado
			/*case 24: // Hacerte Asesino
				if (m_pClientList[iClientH]->Achivements[17].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 5000;
					}
					else Temp = 100;
				}
				break;*/

				/********** Seven Line **********/
			case 25: // Matar 100000 Mobs
				if (m_pClientList[iClientH]->Achivements[9].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 100000)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalMobsKilled - 11000;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 100000) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 100000;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 100000;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 26: // Matar un abby (ultimo golpe)
				if (m_pClientList[iClientH]->Achivements[22].Complete && m_pClientList[iClientH]->Achivements[23].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1)) {
						if (Check) m_pClientList[iClientH]->Achivements[AchivementID].Contador++;
						else m_pClientList[iClientH]->Achivements[AchivementID].Contador = 0;

						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 0) Temp = 100;
						else Temp = 0;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;
			case 27: // Matar 1000 Players
				if (m_pClientList[iClientH]->Achivements[13].Complete) {
					if ((!m_pClientList[iClientH]->Achivements[AchivementID].Complete) && (m_pClientList[iClientH]->Achivements[AchivementID].Contador < 1000)) {
						m_pClientList[iClientH]->Achivements[AchivementID].Contador = m_pClientList[iClientH]->TotalClientKilled - 600;
						if (m_pClientList[iClientH]->Achivements[AchivementID].Contador > 1000) m_pClientList[iClientH]->Achivements[AchivementID].Contador = 1000;
						Temp = (m_pClientList[iClientH]->Achivements[AchivementID].Contador * 100) / 1000;
						if (Temp == 100) Coins = 1;
					}
					else Temp = 100;
				}
				break;

			default:
				Temp = 0;
				Coins = 0;
				break;
		}

		if (m_pClientList[iClientH] == NULL) return;
		if (Temp >= 100) m_pClientList[iClientH]->Achivements[AchivementID].Complete = TRUE;

		if (Check && Temp == 100) {
			m_pClientList[iClientH]->m_iCoins += Coins;
			if ((m_pClientList[iClientH]->m_iCoins >= 500) && (!m_pClientList[iClientH]->Achivements[12].Complete))
				CheckCompleteAchivement(iClientH, 12, TRUE);
			SendNotifyMsg(iClientH, NULL, CLIENT_NOTIFY_COINS, m_pClientList[iClientH]->m_iCoins, NULL, NULL, NULL);

			if (Coins > 0) {
				wsprintf(String, "Character: %s - Coins Gained: %d - Total Coins: %d - Achivement Complete: %d", m_pClientList[iClientH]->m_cCharName, Coins, m_pClientList[iClientH]->m_iCoins, AchivementID);
				PutLogCoinsFileList(String);
			}
		}
		if (m_pClientList[iClientH] != NULL) SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ACHIVEMENTS, AchivementID, Temp, New, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckCompleteAchivement");
	}
#endif
}

void CMapServer::CompleteAchivementList(int iClientH)
{
	return;
#ifdef DEF_DEBUG
	try {
#endif
		char String[200];

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->Achivements[29].Contador != 1) {
			m_pClientList[iClientH]->Achivements[29].Contador = 1;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ACHIVEMENTS, 29, 1, NULL, NULL);
			m_pClientList[iClientH]->m_iCoins += 40;
			wsprintf(String, "Character: %s - Coins Gained: %d - Total Coins: 40 - Achivement Complete: %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iCoins, 29);
			PutLogCoinsFileList(String);
			SendNotifyMsg(iClientH, NULL, CLIENT_NOTIFY_COINS, m_pClientList[iClientH]->m_iCoins, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CompleteAchivementList");
	}
#endif
}

void CMapServer::ClientFakeMove(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		BOOL bRet;

		if (m_pClientList[iClientH] == NULL) return;

		bRet = iClientMotion_Move_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, iDice(1, 8), TRUE);
		if (bRet) SendEventToNearClient_TypeA((short)iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
		else m_pClientList[iClientH]->TimerMove = timeGetTime() + (iDice(1, 120) * 60000);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClientFakeMove");
	}
#endif
}

void CMapServer::ClientFakeMoveTimmer()
{
#ifdef DEF_DEBUG
	try {
#endif
		DWORD dwTime = timeGetTime();
		short i;
		short sItemIndex;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if ((m_pClientList[i]->NoClear) && (m_pClientList[i]->TimerMove != -1)) {
					if ((m_pClientList[i]->m_iStatus & 0x00000008) == 0) m_pClientList[i]->Active++;

					if ((m_pClientList[i]->TimerMove - dwTime) < 1000) {
						m_pClientList[i]->Active++;
						if (m_pClientList[i]->Active == 1) {
							m_pClientList[i]->m_iStatus = m_pClientList[i]->m_iStatus & 0xFFFFFFF7;
							SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						}
					}
					if (m_pClientList[i]->Active > 15 && m_pClientList[i]->Active < 20) {
						sItemIndex = iDice(1, 50) - 1;
						if (bEquipItemHandler(i, sItemIndex, FALSE) == FALSE) {
							if (m_pClientList[i]->m_pItemList[sItemIndex] != NULL)
								m_pClientList[i]->m_bIsItemEquipped[sItemIndex] = FALSE;
						}
					}
					if (m_pClientList[i]->Active > 25 && m_pClientList[i]->Active <= 50) {
						m_pClientList[i]->Moves++;
						if (m_pClientList[i]->Moves < 20) {
							ClientFakeMove(i);
							m_pClientList[i]->Moves = iDice(1, 25);
						}
					}
					if (m_pClientList[i]->Active >= 80) {
						m_pClientList[i]->TimerMove = dwTime + (iDice(1, 120) * 60000);
						m_pClientList[i]->m_iStatus = m_pClientList[i]->m_iStatus | 0x00000008;
						m_pClientList[i]->Active = 0;
						m_pClientList[i]->Moves = 0;
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ClientFakeMoveTimmer");
	}
#endif
}

void CMapServer::SearchStatusFriend(int iClientH, short Position, char CharName[10])
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		int i;
		char *cp, cName[11], cBuff[256];
		WORD *wp;

		BOOL Envio = FALSE;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (memcmp(m_pClientList[i]->m_cCharName, CharName, 10) == 0) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_STATUSFRIEND, Position, 1, NULL, NULL);
					Envio = TRUE;
					return;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SearchStatusFriend");
	}
#endif
}

void CMapServer::RequestGuildMembers(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_cGuildName == NULL) return;

		char *cp, cName[11], cBuff[256];
		WORD *wp;

		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 22) == 0)
					SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_GUILDMEMBER, m_pClientList[i]->m_iGuildRank, NULL, NULL, m_pClientList[i]->m_cCharName);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestGuildMembers");
	}
#endif
}

void CMapServer::SendF5DataCharacter(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_F5DATA,
			m_pClientList[iClientH]->m_iCoins,
			m_pClientList[iClientH]->HourPlaying,
			m_pClientList[iClientH]->TotalMobsKilled,
			NULL,
			m_pClientList[iClientH]->TotalDeath,
			m_pClientList[iClientH]->TotalClientKilled,
			m_pClientList[iClientH]->TotalQuestCompleted);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendF5DataCharacter");
	}
#endif
}

void CMapServer::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
#ifdef DEF_DEBUG
	try {
#endif
		int   iOldSSN, iSSNpoint;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

		iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
		m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue * 50;

		iSSNpoint = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1];

		if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
			(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {
			m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;
			switch (sSkillIndex) {
				case 23:
					if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
						m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
						m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
					}
					else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;

				default:
					m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
					break;
			}

			if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
				bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CalculateSSN_SkillIndex");
	}
#endif
}

int CMapServer::Random(int Minimo, int Maximo)
{
	register int iRet;

	if (Maximo <= 0) return 0;
	if (Minimo <= 1) Minimo = 1;

	iRet = Minimo + (rand() % (Maximo + 1 - Minimo));

	return iRet;
}

void CMapServer::CheckProcess(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (iClientH < 0) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_CHECKPROCESS, NULL, NULL, NULL, NULL);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckProcess");
	}
#endif
}

void CMapServer::DataProcessReceived(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (iClientH < 0 || iClientH > 2000) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

		char *cp;
		BOOL Process = FALSE;
		char Buffer[5000], Buff[40], DirLog[100], Temp[50], cCharName[10];
		FILE * pLogFile;
		SYSTEMTIME SysTime;
		GetLocalTime(&SysTime);

		strcpy_secure(cCharName, m_pClientList[iClientH]->m_cCharName);

		_mkdir("..\\ServerLogs\\ProcessLog");

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
		Process = *cp;
		cp++;

		ZeroMemory(Buffer, sizeof(Buffer));
		ZeroMemory(Buff, sizeof(Buff));

		strcpy_secure(Buff, cp);
		cp += 30;

		if (Process) {
			wsprintf(Temp, "Proceso: %s \n", Buff);
			strcat(Buffer, Temp);
		}
		else {
			wsprintf(Temp, "Dlls: %s \n", Buff);
			strcat(Buffer, Temp);
		}

		ZeroMemory(DirLog, sizeof(DirLog));
		wsprintf(DirLog, "..\\ServerLogs\\ProcessLog\\%s [% 02d - % 02d - % 04d].log", cCharName, SysTime.wDay, SysTime.wMonth, SysTime.wYear);

		pLogFile = fopen(DirLog, "at");

		if (pLogFile == NULL) return;

		fwrite(Buffer, 1, strlen(Buffer), pLogFile);
		fclose(pLogFile);
		if (pLogFile != NULL) fclose(pLogFile);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DataProcessReceived");
	}
#endif
}

void CMapServer::CheckProcessClients()
{
#ifdef DEF_DEBUG
	try {
#endif

		for (int i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete != FALSE)) {
				if (m_pClientList[i]->CheckProcess)
					CheckProcess(i);
			}
		}
		m_dwCheckProcess = timeGetTime();

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckProcessClients");
	}
#endif
}

void CMapServer::CheckHability(int iClientH, char *pData, DWORD dwMsgSize)
{

#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cName[11], cBuff[256];
		class  CStrTok * pStrTok;
		register int i;

		char Msg[70];
		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cName, sizeof(cName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (strlen(token) > 10) memcpy_secure(cName, token, 10);
			else memcpy_secure(cName, token, strlen(token));

			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
					m_pClientList[i]->CheckProcess = TRUE;
					CheckProcess(i);
					wsprintf(G_cTxt, "GM Order(%s): PC(%s) Checking Process", m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);
					PutGMLogData(G_cTxt);
					wsprintf(Msg, "Checking process activated to: %s ", m_pClientList[i]->m_cCharName);
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOTICEMSG, NULL, NULL, NULL, Msg);
				}
			}
		}
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckHability");
	}
#endif
}

BOOL CMapServer::ReadProcessAndDllBlockedFile(char * cFn, BOOL Type)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	int i;
	char buf[50];

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		return FALSE;
	}
	else {
		PutLogList("Reading configuration file...");
		for (i = 0; i < 100; i++) {
			if (Type) ZeroMemory(Process[i], sizeof(Process[i]));
			else ZeroMemory(Dlls[i], sizeof(Dlls[i]));
		}

		i = 0;
		while (fgets(buf, 49, pFile)) {
			if (i < 100) {
				if (Type) {
					memcpy_secure(Process[i], buf, strlen(buf) - 1);
					if (strlen(Process[i]) > 0) i++;
				}
				else {
					memcpy_secure(Dlls[i], buf, strlen(buf) - 1);
					if (strlen(Dlls[i]) > 0) i++;
				}
			}
		}
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::SendProcessBlocked(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif

		int i = 0;
		if (m_pClientList[iClientH] == NULL) return;
		for (i = 0; i < 100; i++) {
		//	if (strlen(Process[i]) > 0) SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_PROCESSBLOCKED, 1, i, NULL, Process[i]);
			if (strlen(Process[i]) > 0) SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_PELMASO, 1, i, NULL, Process[i]);
			else i = 100;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendProcessBlocked");
	}
#endif
}

void CMapServer::SendDllsBlocked(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i = 0;
		if (m_pClientList[iClientH] == NULL) return;
		for (i = 0; i < 100; i++) {
			//if (strlen(Dlls[i]) > 0) SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_PROCESSBLOCKED, 0, i, NULL, Dlls[i]);
			if (strlen(Dlls[i]) > 0) SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_PELMASO, 0, i, NULL, Dlls[i]);
			else i = 100;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendDllsBlocked");
	}
#endif
}

void CMapServer::ChangeHeroSide(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short i;
		class CItem * pItem;
		int iEraseReq;
		short ItemID;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_cSide == 0) return;

		// Character WH Items
		for (i = 0; i < DEF_MAXBANKITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
					(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
					(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {

					switch (m_pClientList[iClientH]->m_pItemInBankList[i]->m_sIDnum) {
						case 400://AresdenHeroCape
						case 403://aHeroHelm(M)
						case 404://aHeroHelm(W)
						case 407://aHeroCap(M)
						case 408://aHeroCap(W)
						case 411://aHeroArmor(M)
						case 412://aHeroArmor(W)
						case 415://aHeroRobe(M)
						case 416://aHeroRobe(W)
						case 419://aHeroHauberk(M)
						case 420://aHeroHauberk(W)
						case 423://aHeroLeggings(M)
						case 424://aHeroLeggings(W)
						case 427://AresdenHeroCape+1
							if (m_pClientList[iClientH]->m_cSide != 1) DeleteWhItem(iClientH, i);
							break;
						case 401://ElvineHeroCape
						case 405://eHeroHelm(M)
						case 406://eHeroHelm(W)
						case 409://eHeroCap(M)
						case 410://eHeroCap(W)
						case 413://eHeroArmor(M)	
						case 414://eHeroArmor(W)
						case 417://eHeroRobe(M)
						case 418://eHeroRobe(W)
						case 421://eHeroHauberk(M)
						case 422://eHeroHauberk(W)
						case 425://eHeroLeggings(M)
						case 426://eHeroLeggings(W)
						case 428://ElvineHeroCape+1
							if (m_pClientList[iClientH]->m_cSide != 2) DeleteWhItem(iClientH, i);
							break;
					}
				}
			}
		}

		// Character Bag Items
		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
					ItemID = 0;
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
						case 400://AresdenHeroCape-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 401;
							}
							break;
						case 401://ElvineHeroCape-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 400;
							}
							break;
						case 403://aHeroHelm(M)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 405;
							}
							break;
						case 404://aHeroHelm(W)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 406;
							}
							break;
						case 405://eHeroHelm(M)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 403;
							}
							break;
						case 406://eHeroHelm(W)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 404;
							}
							break;
						case 407://aHeroCap(M)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 409;
							}
							break;
						case 408://aHeroCap(W)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 410;
							}
							break;
						case 409://eHeroCap(M)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 407;
							}
							break;
						case 410://eHeroCap(W)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 408;
							}
							break;
						case 411://aHeroArmor(M)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 413;
							}
							break;
						case 412://aHeroArmor(W)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 414;
							}
							break;
						case 413://eHeroArmor(M)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 411;
							}
							break;
						case 414://eHeroArmor(W)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 412;
							}
							break;
						case 415://aHeroRobe(M)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 417;
							}
							break;
						case 416://aHeroRobe(W)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 418;
							}
							break;
						case 417://eHeroRobe(M)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 415;
							}
							break;
						case 418://eHeroRobe(W)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 416;
							}
							break;
						case 419://aHeroHauberk(M)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 421;
							}
							break;
						case 420://aHeroHauberk(W)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 422;
							}
							break;
						case 421://eHeroHauberk(M)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 419;
							}
							break;
						case 422://eHeroHauberk(W)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 420;
							}
							break;
						case 423://aHeroLeggings(M)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 425;
							}
							break;
						case 424://aHeroLeggings(W)-
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 426;
							}
							break;
						case 425://eHeroLeggings(M)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 423;
							}
							break;
						case 426://eHeroLeggings(W)-
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 424;
							}
							break;
						case 427://AresdenHeroCape+1
							if (m_pClientList[iClientH]->m_cSide != 1) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 428;
							}
							break;
						case 428://ElvineHeroCape+1
							if (m_pClientList[iClientH]->m_cSide != 2) {
								ReleaseItemHandler(iClientH, i, FALSE);
								CalcTotalItemEffect(iClientH, i);
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);

								ItemID = 427;
							}
							break;
					}

					if (ItemID != 0) {

						m_pClientList[iClientH]->m_pItemList[i] = new class CItem;
						_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[i], ItemID);
						m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ChangeHeroSide");
	}
#endif
}

void CMapServer::DeleteWhItem(int iClientH, short sItemIndex)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXBANKITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == NULL) return;

		short BankPosition, ItemID = 0;
		class CItem * pItem;

		BankPosition = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]->GetBankPosition();

		pItem = new class CItem;

		switch (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]->m_sIDnum) {
			case 400: ItemID = 401; break; //AresdenHeroCape
			case 401: ItemID = 400; break; //ElvineHeroCape
			case 403: ItemID = 405; break; //aHeroHelm(M)
			case 404: ItemID = 406; break; //aHeroHelm(W)
			case 405: ItemID = 403; break; //eHeroHelm(M)
			case 406: ItemID = 404; break; //eHeroHelm(W)
			case 407: ItemID = 409; break; //aHeroCap(M)
			case 408: ItemID = 410; break; //aHeroCap(W)
			case 409: ItemID = 407; break; //eHeroCap(M)
			case 410: ItemID = 408; break; //eHeroCap(W)
			case 411: ItemID = 413; break; //aHeroArmor(M)
			case 412: ItemID = 414; break; //aHeroArmor(W)
			case 413: ItemID = 411; break; //eHeroArmor(M)	
			case 414: ItemID = 412; break; //eHeroArmor(W)
			case 415: ItemID = 417; break; //aHeroRobe(M)
			case 416: ItemID = 418; break; //aHeroRobe(W)
			case 417: ItemID = 415; break; //eHeroRobe(M)
			case 418: ItemID = 416; break; //eHeroRobe(W)
			case 419: ItemID = 421; break; //aHeroHauberk(M)
			case 420: ItemID = 422; break; //aHeroHauberk(W)
			case 421: ItemID = 419; break; //eHeroHauberk(M)
			case 422: ItemID = 420; break; //eHeroHauberk(W)
			case 423: ItemID = 425; break; //aHeroLeggings(M)
			case 424: ItemID = 426; break; //aHeroLeggings(W)
			case 425: ItemID = 423; break; //eHeroLeggings(M)
			case 426: ItemID = 424; break; //eHeroLeggings(W)
			case 427: ItemID = 428; break; //AresdenHeroCape+1
			case 428: ItemID = 427; break; //ElvineHeroCape+1
		}
		if (ItemID == NULL) {
			delete pItem;
			return;
		}

		_bInitItemAttr(pItem, ItemID);

		delete m_pClientList[iClientH]->m_pItemInBankList[sItemIndex];
		m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = NULL;

		pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

		pItem->SetBankPosition(BankPosition);

		m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = pItem;

		SendBankItemData(iClientH, pItem, sItemIndex, TRUE);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: DeleteWhItem");
	}
#endif
}

BOOL CMapServer::SendBankItemData(int iClientH, class CItem * pItem, short Position, BOOL Actualizar)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet;
		DWORD * dwp;
		WORD  * wp;
		char  * cp;
		short * sp;
		char cData[100];

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_NOTIFY;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = CLIENT_NOTIFY_ITEMTOBANK;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		*sp = Position;
		cp += 2;

		*cp = Actualizar;
		cp++;

		memcpy_secure(cp, pItem->m_cName, 20);
		cp += 20;

		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0;
		cp++;

		sp = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		//*cp = (char)pItem->m_sItemSpecEffectValue2;
		//cp++;
		//cambio lalomanu
		sp = (short *)cp;
		*sp = pItem->m_sItemSpecEffectValue2;
		cp += 2;

		*cp = (char)pItem->m_sItemSpecEffectValue3;
		cp++;

		*cp = (char)pItem->GetBankPosition();
		cp++;

		//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 58);
		//lalomanu
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 59);

		m_pClientList[iClientH]->m_bIsBankModified = TRUE;

		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);//Agregado Lalo882
				return TRUE;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendBankItemData");
	}
#endif
	return TRUE;
}

void CMapServer::CheckHeroData(int iClientH, short ItemIndex, BOOL WH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!WH) {
			if (m_pClientList[iClientH]->m_pItemList[ItemIndex] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_sIDnum) {
					case 400://AresdenHeroCape-
					case 401://ElvineHeroCape-
					case 427://AresdenHeroCape+1
					case 428://ElvineHeroCape+1
						m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_wMaxLifeSpan = 300;
						if (m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_wCurLifeSpan > 300)
							m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_wCurLifeSpan = 300;
						m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_sItemSpecEffectValue1 = 0;
						m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_dwAttribute = 0;
						break;
					case 403://aHeroHelm(M)-
					case 404://aHeroHelm(W)-
					case 405://eHeroHelm(M)-
					case 406://eHeroHelm(W)-
					case 407://aHeroCap(M)-
					case 408://aHeroCap(W)-
					case 409://eHeroCap(M)-
					case 410://eHeroCap(W)-
					case 411://aHeroArmor(M)-
					case 412://aHeroArmor(W)-
					case 413://eHeroArmor(M)-
					case 414://eHeroArmor(W)-
					case 415://aHeroRobe(M)-
					case 416://aHeroRobe(W)-
					case 417://eHeroRobe(M)-
					case 418://eHeroRobe(W)-
					case 419://aHeroHauberk(M)-
					case 420://aHeroHauberk(W)-
					case 421://eHeroHauberk(M)-
					case 422://eHeroHauberk(W)-
					case 423://aHeroLeggings(M)-
					case 424://aHeroLeggings(W)-
					case 425://eHeroLeggings(M)-
					case 426://eHeroLeggings(W)-
						m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_wMaxLifeSpan = 8000;
						if (m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_wCurLifeSpan > 8000)
							m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_wCurLifeSpan = 8000;
						m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_sItemSpecEffectValue1 = 0;
						m_pClientList[iClientH]->m_pItemList[ItemIndex]->m_dwAttribute = 0;
						break;
				}
			}
		}
		else {
			if (m_pClientList[iClientH]->m_pItemInBankList[ItemIndex] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_sIDnum) {
					case 400://AresdenHeroCape-
					case 401://ElvineHeroCape-
					case 427://AresdenHeroCape+1
					case 428://ElvineHeroCape+1
						m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_wMaxLifeSpan = 300;
						if (m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_wCurLifeSpan > 300)
							m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_wCurLifeSpan = 300;
						m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_sItemSpecEffectValue1 = 0;
						m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_dwAttribute = 0;

						break;
					case 403://aHeroHelm(M)-
					case 404://aHeroHelm(W)-
					case 405://eHeroHelm(M)-
					case 406://eHeroHelm(W)-
					case 407://aHeroCap(M)-
					case 408://aHeroCap(W)-
					case 409://eHeroCap(M)-
					case 410://eHeroCap(W)-
					case 411://aHeroArmor(M)-
					case 412://aHeroArmor(W)-
					case 413://eHeroArmor(M)-
					case 414://eHeroArmor(W)-
					case 415://aHeroRobe(M)-
					case 416://aHeroRobe(W)-
					case 417://eHeroRobe(M)-
					case 418://eHeroRobe(W)-
					case 419://aHeroHauberk(M)-
					case 420://aHeroHauberk(W)-
					case 421://eHeroHauberk(M)-
					case 422://eHeroHauberk(W)-
					case 423://aHeroLeggings(M)-
					case 424://aHeroLeggings(W)-
					case 425://eHeroLeggings(M)-
					case 426://eHeroLeggings(W)-
						m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_wMaxLifeSpan = 8000;
						if (m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_wCurLifeSpan > 8000)
							m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_wCurLifeSpan = 8000;
						m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_sItemSpecEffectValue1 = 0;
						m_pClientList[iClientH]->m_pItemInBankList[ItemIndex]->m_dwAttribute = 0;
						break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckHeroData");
	}
#endif
}

BOOL CMapServer::_bReadItemsEventCFG(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token;
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemIndex = 0;
	class CStrTok * pStrTok;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		ErrorList("Cannot open Tower Defence configuration file.");
		return FALSE;
	}
	else {
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		for (iItemIndex = 0; iItemIndex < 100; iItemIndex++)
			ZeroMemory(ItemsEvent[iItemIndex], sizeof(ItemsEvent[iItemIndex]));

		iItemIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								iItemIndex = atoi(token);

								if (iItemIndex >= 100) {
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								cReadModeB = 2;
								break;

							case 2:
								ZeroMemory(ItemsEvent[iItemIndex], sizeof(ItemsEvent[iItemIndex]));
								memcpy_secure(ItemsEvent[iItemIndex], token, strlen(token));
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "item", 4) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete[]cp;
	}

	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::InitItemsClient(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short iItemIndex, i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) return;

		if (m_pClientList[iClientH]->Heredado == FALSE) {
			m_pClientList[iClientH]->Heredado = TRUE;
			for (i = 0; i < 50; i++) {
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					m_pClientList[iClientH]->m_pEventItemList[i] = new class CItem;
					_bInitItemAttr(m_pClientList[iClientH]->m_pEventItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum);
					m_pClientList[iClientH]->m_pEventItemList[i]->m_dwCount = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectType = m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sItemSpecEffectValue2 = m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_sItemSpecEffectValue3 = m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
					m_pClientList[iClientH]->m_pEventItemList[i]->m_dwAttribute = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
					m_pClientList[iClientH]->m_EventItemPosList[i].x = m_pClientList[iClientH]->m_pItemList[i]->GetBagPositionX();
					m_pClientList[iClientH]->m_EventItemPosList[i].y = m_pClientList[iClientH]->m_pItemList[i]->GetBagPositionY();
					m_pClientList[iClientH]->m_bIsEventItemEquipped[i] = m_pClientList[iClientH]->m_bIsItemEquipped[i];
					m_pClientList[iClientH]->m_pEventItemList[i]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan;

					ReleaseItemHandler(iClientH, i, FALSE);
					CalcTotalItemEffect(iClientH, i);
					delete m_pClientList[iClientH]->m_pItemList[i];
					m_pClientList[iClientH]->m_pItemList[i] = NULL;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ANGELIC_STATS, NULL, NULL, NULL, NULL);
				}
			}
			m_pClientList[iClientH]->Temporal_Rating = m_pClientList[iClientH]->m_iRating;
			m_pClientList[iClientH]->m_iRating = 0;
			SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
		}

		for (i = 1; i < 100; i++) {
			if (i < 3 && ItemsEvent[i] != NULL && strlen(ItemsEvent[i]) > 0) {
				for (iItemIndex = 0; iItemIndex < 10; iItemIndex++) {
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) {
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], ItemsEvent[i]);
						iItemIndex = 50;
					}
					else m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
				}
			}
			else {
				if (i < 30) {
					if (m_pClientList[iClientH]->m_cSex == 2) i = 30;
					else i = 50;
				}

				if (ItemsEvent[i] != NULL && strlen(ItemsEvent[i]) > 0 && i < 70) {
					for (iItemIndex = 0; iItemIndex < 10; iItemIndex++) {
						if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) {
							m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
							_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], ItemsEvent[i]);
							iItemIndex = 50;
						}
						else m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					}
				}
				else {
					if (i < 70) i = 70;
					if (ItemsEvent[i] != NULL && strlen(ItemsEvent[i]) > 0) {
						for (iItemIndex = 0; iItemIndex < 12; iItemIndex++) {
							if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) {
								m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
								_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], ItemsEvent[i]);
								iItemIndex = 50;
							}
							else m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						}
					}
					else i = 100;
				}
			}
		}
		AddCandys(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitItemsClient");
	}
#endif
}

void CMapServer::AddCandys(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short Blue = 0, i;

		if (m_pClientList[iClientH] == NULL) return;

		for (i = 12; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				delete m_pClientList[iClientH]->m_pItemList[i];
				m_pClientList[iClientH]->m_pItemList[i] = NULL;
			}
		}

		for (i = 0; i < DEF_MAXITEMS; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				m_pClientList[iClientH]->m_pItemList[i] = new class CItem;
				if (Blue < 20) {
					_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[i], 781);
					Blue++;
				}
				else _bInitItemAttr(m_pClientList[iClientH]->m_pItemList[i], 780);
			}
		}
		NivelObteined(iClientH);
		LoadPlayerItems(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AddCandys");
	}
#endif
}

void CMapServer::RestoreItems(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) return;

		if (m_pClientList[iClientH]->Heredado == TRUE) {
			m_pClientList[iClientH]->Heredado = FALSE;
			for (i = 0; i < 50; i++) {
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					ReleaseItemHandler(iClientH, i, FALSE);
					m_pClientList[iClientH]->m_pItemList[i] = NULL;
				}
				if (m_pClientList[iClientH]->m_pEventItemList[i] != NULL) {
					m_pClientList[iClientH]->m_pItemList[i] = new class CItem;
					_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pEventItemList[i]->m_sIDnum);
					m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = m_pClientList[iClientH]->m_pEventItemList[i]->m_dwCount;
					m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType = m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectType;
					m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectValue1;
					m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectValue2;
					m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_pEventItemList[i]->m_sTouchEffectValue3;
					m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor = m_pClientList[iClientH]->m_pEventItemList[i]->m_cItemColor;
					m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pEventItemList[i]->m_sItemSpecEffectValue1;
					m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2 = m_pClientList[iClientH]->m_pEventItemList[i]->m_sItemSpecEffectValue2;
					m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3 = m_pClientList[iClientH]->m_pEventItemList[i]->m_sItemSpecEffectValue3;
					m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pEventItemList[i]->m_wCurLifeSpan;
					m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute = m_pClientList[iClientH]->m_pEventItemList[i]->m_dwAttribute;
					m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_EventItemPosList[i].x;
					m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_EventItemPosList[i].y;
					m_pClientList[iClientH]->m_pItemList[i]->SetBagPosition(m_pClientList[iClientH]->m_ItemPosList[i].x, m_pClientList[iClientH]->m_ItemPosList[i].y);
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = m_pClientList[iClientH]->m_bIsItemEquipped[i];
					m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pEventItemList[i]->m_wMaxLifeSpan;
					if (m_pClientList[iClientH]->m_bIsItemEquipped[i]) bEquipItemHandler(iClientH, i);
				}
				delete m_pClientList[iClientH]->m_pEventItemList[i];
				m_pClientList[iClientH]->m_pEventItemList[i] = NULL;
			}
			m_pClientList[iClientH]->m_iRating = m_pClientList[iClientH]->Temporal_Rating;
			m_pClientList[iClientH]->Temporal_Rating = 0;
			SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);
		}
		LoadPlayerItems(iClientH);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RestoreItems");
	}
#endif
}

void CMapServer::InitArenaEvent()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (FinalFight || ActiveEvent) return;
		short i;

		FinalFight = ActiveEvent = TRUE;
		FinalFight_ID++;

		for (i = 0; i < 10; i++) {
			ZeroMemory(PvpContador[i].CharName, sizeof(PvpContador[i].CharName));
			PvpContador[i].Nivel = PvpContador[i].Kills = PvpContador[i].Deaths = -1;
		}
		TotalAnnoucement = 0;

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ARENAPVPEVENT_INIT, NULL, NULL, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: InitArenaEvent");
	}
#endif
}

void CMapServer::CreateFinalFightID()
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cTxt[256], cFn[256], cTemp[1024];
		FILE * pFile;

		ZeroMemory(cFn, sizeof(cFn));
		strcat(cFn, "Events\\FinalFight\\EventID.txt");

		pFile = fopen(cFn, "wt");
		if (pFile == NULL) {
			wsprintf(cTxt, "Cannot create Final Fight ID file");
			ErrorList(cTxt);
		}
		else {
			ZeroMemory(cTemp, sizeof(cTemp));

			wsprintf(cTxt, "%d", FinalFight_ID);
			strcat(cTemp, cTxt);

			cp = (char *)cTemp;
			fwrite(cp, strlen(cp), 1, pFile);
		}
		if (pFile != NULL) fclose(pFile);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateFinalFightID");
	}
#endif
}

BOOL CMapServer::bReadFinalFightConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;
	char * cp, *token;
	class CStrTok * pStrTok;
	char seps[] = "= \t\n";

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		ErrorList("(!) Cannot open Final Fight ID file.");
		return FALSE;
	}
	else {
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		FinalFight_ID = atoi(token);

		delete pStrTok;
		delete[]cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CMapServer::CloseArenaEvent()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!FinalFight || !ActiveEvent) return;
		short i, Pos;

		ArmarEventTop();
		FinalFight = ActiveEvent = FALSE;
		CreateFinalFightID();
		//bug finalfight
		for (i = 1; i < DEF_MAXCLIENTS; i++) {
		//for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete)) {
				//SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ARENAPVPEVENT_INIT, NULL, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_ARENAPVPEVENT_CLOSE, NULL, NULL, NULL, NULL, NULL);
				//for (Pos = 0; Pos < 10; Pos++) {
				for (Pos = 1; Pos < 11; Pos++) {
					wsprintf(G_cTxt, "Char: %s, Position: %d", PvpContador[Pos].CharName, i);
					PutLogList(G_cTxt);

					if (memcmp(PvpContador[Pos].CharName, m_pClientList[i]->m_cCharName, 10) == 0) {
						/*m_pClientList[i]->m_iCoins += (2000 - (Pos * 50));
						SendNotifyMsg(i, NULL, CLIENT_NOTIFY_COINS, m_pClientList[i]->m_iCoins, NULL, NULL, NULL);*/
						if (!m_pClientList[i]->Achivements[12].Complete) CheckCompleteAchivement(i, 12, TRUE);
					}
				}
				if (strcmp(m_pClientList[i]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0) {
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
				}
			}
		}

		for (i = 0; i < 10; i++) {
			ZeroMemory(PvpContador[i].CharName, sizeof(PvpContador[i].CharName));
			PvpContador[i].Nivel = PvpContador[i].Kills = PvpContador[i].Deaths = -1;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CloseArenaEvent");
	}
#endif
}

void CMapServer::ArmarEventTop()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (FinalFight == FALSE) return;

		int TopIndex = 0, ShortCutIndex = 0, i, x, y;
		char TempName[11];
		short TempNivel, TempKill, TempDeath;
		bool bFlag = true;

		for (i = 0; i < 10; i++) {
			ZeroMemory(PvpContador[i].CharName, sizeof(PvpContador[i].CharName));
			PvpContador[i].Nivel = -1;
			PvpContador[i].Kills = -1;
			PvpContador[i].Deaths = -1;
		}

		ShortCutIndex = 0;
		i = m_iClientShortCut[ShortCutIndex];

		// Ahora si armo el top
		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL  && m_pClientList[i]->m_bIsInitComplete == TRUE && m_pClientList[i]->m_iAdminUserLevel == 0
				&& strcmp(m_pClientList[i]->m_cMapName, DEF_EVENTMAP_PVPEVENT) == 0 && m_pClientList[i]->Event_Killed > 0) {
				for (x = 0; x < 10; x++) {
					bFlag = true;
					if (m_pClientList[i]->Event_Killed > PvpContador[x].Kills) {
						for (y = 0; y < 10; y++) {
							if (strcmp(PvpContador[y].CharName, m_pClientList[i]->m_cCharName) == 0)
								bFlag = false; // No deja poner el mismo personaje en el top
						}

						if (bFlag == true) {
							if (PvpContador[x].Kills > 0) { // Hay otro cliente en la lista
								for (y = 8; y >= x; y--) {
									PvpContador[y + 1].Kills = PvpContador[y].Kills;

									ZeroMemory(PvpContador[y + 1].CharName, sizeof(PvpContador[y + 1].CharName));
									strcpy_secure(PvpContador[y + 1].CharName, PvpContador[y].CharName);
									PvpContador[y + 1].Kills = PvpContador[y].Kills;
									PvpContador[y + 1].Nivel = PvpContador[y].Nivel;
									PvpContador[y + 1].Deaths = PvpContador[y].Deaths;
								}

								PvpContador[x].Kills = m_pClientList[i]->Event_Killed;
								strcpy_secure(PvpContador[x].CharName, m_pClientList[i]->m_cCharName);
								PvpContador[x].Deaths = m_pClientList[i]->Event_Death;
								PvpContador[x].Nivel = m_pClientList[i]->EventLevel;
							}
							else {
								PvpContador[x].Kills = m_pClientList[i]->Event_Killed;
								strcpy_secure(PvpContador[x].CharName, m_pClientList[i]->m_cCharName);
								PvpContador[x].Deaths = m_pClientList[i]->Event_Death;
								PvpContador[x].Nivel = m_pClientList[i]->EventLevel;
							}
						}
					}
				}
			}
		}

		for (x = 0; x < 9; x++) {
			for (y = x + 1; y < 10; y++) {
				if (PvpContador[y].Kills > PvpContador[x].Kills) {
					// Guardo los datos en variables temporales
					ZeroMemory(TempName, sizeof(TempName));
					strcpy_secure(TempName, PvpContador[x].CharName);
					TempNivel = PvpContador[x].Nivel;
					TempKill = PvpContador[x].Kills;
					TempDeath = PvpContador[x].Deaths;

					// Reemplazo el valor actual, por el nuevo
					ZeroMemory(PvpContador[x].CharName, sizeof(PvpContador[x].CharName));
					strcpy_secure(PvpContador[x].CharName, PvpContador[y].CharName);
					PvpContador[x].Kills = PvpContador[y].Kills;
					PvpContador[x].Nivel = PvpContador[y].Nivel;
					PvpContador[x].Deaths = PvpContador[y].Deaths;


					// Devuelvo los datos de las variables temporales, a la nueva posicion
					ZeroMemory(PvpContador[y].CharName, sizeof(PvpContador[y].CharName));
					strcpy_secure(PvpContador[y].CharName, TempName);
					PvpContador[y].Nivel = TempNivel;
					PvpContador[y].Kills = TempKill;
					PvpContador[y].Deaths = TempDeath;
				}
			}
		}

		char cData[512];
		short *sp, Size;
		char *cp;
		DWORD *dwp;
		WORD *wp;

		ZeroMemory(cData, sizeof(cData));

		dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = CLIENT_NOTIFY;
		wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp = CLIENT_NOTIFY_TOPARENAEVENT;

		cp = (char *)(cData + 6);
		Size = 6;

		for (i = 0; i < 10; i++) {
			if (strlen(PvpContador[i].CharName) > 0) {
				memcpy_secure(cp, PvpContador[i].CharName, strlen(PvpContador[i].CharName));
				cp += 11;

				sp = (short *)cp;
				*sp = PvpContador[i].Nivel;
				cp += 2;

				sp = (short *)cp;
				*sp = PvpContador[i].Kills;
				cp += 2;

				sp = (short *)cp;
				*sp = PvpContador[i].Deaths;
				cp += 2;
			}
			Size += 17;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_MYDATAEVENT, m_pClientList[i]->EventLevel, m_pClientList[i]->Event_Killed, m_pClientList[i]->Event_Death, NULL);
				//Agregado Lalo882
				//m_pClientList[i]->m_pXSock->iSendMsg(cData, Size);
				int iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, Size);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(i, TRUE, TRUE);
					break;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ArmarEventTop");
	}
#endif
}

void CMapServer::CheckNewNivel(int iClientH, BOOL Init)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (FinalFight == FALSE) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->EventLevel >= 8) return;

		short Kill = 10, KilledNeed = 0;

		KilledNeed = (((Kill + m_pClientList[iClientH]->EventLevel)*m_pClientList[iClientH]->EventLevel) + Kill + m_pClientList[iClientH]->EventLevel);
		if (m_pClientList[iClientH]->Event_Killed >= KilledNeed) {
			m_pClientList[iClientH]->EventLevel++;
			if (!Init) NivelObteined(iClientH);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckNewNivel");
	}
#endif
}

void CMapServer::NivelObteined(int iClientH)
{

#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (m_pClientList[iClientH]->EventLevel == 0) return;

		int dwType, dwValue;
		switch (m_pClientList[iClientH]->EventLevel) {
			case 1:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[3]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[4]);
				break;
			case 2:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[5]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[6]);
				break;
			case 3:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[7]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[8]);
				m_pClientList[iClientH]->m_iRating += 2000;
				if (m_pClientList[iClientH]->m_iRating > 2000) m_pClientList[iClientH]->m_iRating = 2000;
				break;
			case 4:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[9]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[10]);
				m_pClientList[iClientH]->m_iRating += 2000;
				if (m_pClientList[iClientH]->m_iRating > 4000) m_pClientList[iClientH]->m_iRating = 4000;
				break;
			case 5:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[11]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[12]);
				m_pClientList[iClientH]->m_iRating += 2000;
				if (m_pClientList[iClientH]->m_iRating > 6000) m_pClientList[iClientH]->m_iRating = 6000;
				break;
			case 6:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[13]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[14]);
				m_pClientList[iClientH]->m_iRating += 2000;
				if (m_pClientList[iClientH]->m_iRating > 8000) m_pClientList[iClientH]->m_iRating = 8000;
				break;
			case 7:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[15]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[16]);
				break;
			case 8:
				delete m_pClientList[iClientH]->m_pItemList[0];
				m_pClientList[iClientH]->m_pItemList[0] = NULL;
				m_pClientList[iClientH]->m_pItemList[0] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[0], ItemsEvent[17]);

				delete m_pClientList[iClientH]->m_pItemList[1];
				m_pClientList[iClientH]->m_pItemList[1] = NULL;
				m_pClientList[iClientH]->m_pItemList[1] = new class CItem;
				_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[1], ItemsEvent[18]);
				break;
		}

		SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, m_pClientList[iClientH]->m_iRating, NULL, NULL, NULL);

		for (short i = 0; i < 15; i++) {
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				if ((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory == 6) ||
					(m_pClientList[iClientH]->m_pItemList[i]->m_cCategory == 12)) {
					m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute = NULL;

					if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt) dwType = 7 << 12;
					else dwType = 3 << 12;

					if (m_pClientList[iClientH]->EventLevel > 4) dwValue = (m_pClientList[iClientH]->EventLevel + 2) << 8;
					else dwValue = m_pClientList[iClientH]->EventLevel << 8;

					m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute | dwType | dwValue;
				}
			}
		}
		LoadPlayerItems(iClientH);
		if (m_pClientList[iClientH]->m_bIsItemEquipped[0]) bEquipItemHandler(iClientH, 0);
		if (m_pClientList[iClientH]->m_bIsItemEquipped[1]) bEquipItemHandler(iClientH, 1);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: NivelObteined");
	}
#endif
}

void CMapServer::Event_FinalFight()
{
	SYSTEMTIME SysTime;
	int FinalFightDay[1], FinalFightHour[1], FinalFightMinute[1];
	short Max = 1, i;

	FinalFightDay[0] = 0;
	FinalFightHour[0] = 22;
	FinalFightMinute[0] = 0;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((FinalFightDay[i] == SysTime.wDayOfWeek) && (FinalFightHour[i] == SysTime.wHour) && (FinalFightMinute[i] == SysTime.wMinute)) {
			InitArenaEvent();
			return;
		}
	}
}

void CMapServer::Close_FinalFight()
{
	SYSTEMTIME SysTime;
	int FinalFightDay[1], FinalFightHour[1], FinalFightMinute[1];
	short Max = 1, i;

	FinalFightDay[0] = 0;
	FinalFightHour[0] = 22;
	FinalFightMinute[0] = 30;

	GetLocalTime(&SysTime);
	for (i = 0; i < Max; i++) {
		if ((FinalFightDay[i] == SysTime.wDayOfWeek) && (FinalFightHour[i] == SysTime.wHour) && (FinalFightMinute[i] == SysTime.wMinute)) {
			CloseArenaEvent();
			return;
		}
	}
}

BOOL CMapServer::ReadQuestItemsCFG(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token;
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	class CStrTok * pStrTok;
	int  iQuestConfigListIndex = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		ErrorList("Cannot open Quest Items configuration file.");
		return FALSE;
	}
	else {
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
					case 1:
						switch (cReadModeB) {
							case 1:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								if (m_pQuestConfigList[atoi(token)] != NULL) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[atoi(token)] = new class CQuest;
								iQuestConfigListIndex = atoi(token);

								cReadModeB = 2;
								break;

							case 2:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
								cReadModeB = 3;
								break;

							case 3:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
								cReadModeB = 4;
								break;

							case 4:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
								cReadModeB = 5;
								break;

							case 5:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount = atoi(token);
								cReadModeB = 6;
								break;

							case 6:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
								cReadModeB = 7;
								break;

							case 7:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
								cReadModeB = 8;
								break;

							case 8:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
								cReadModeB = 9;
								break;

							case 9:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
								cReadModeB = 10;
								break;

							case 10:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
								cReadModeB = 11;
								break;

							case 11:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
								cReadModeB = 12;
								break;

							case 12:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
								cReadModeB = 13;
								break;

							case 13:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
								cReadModeB = 14;
								break;

							case 14:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
								cReadModeB = 15;
								break;

							case 15:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
								cReadModeB = 16;
								break;

							case 16:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
								cReadModeB = 17;
								break;

							case 17:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
								cReadModeB = 18;
								break;

							case 18:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
								cReadModeB = 19;
								break;

							case 19:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
								cReadModeB = 20;
								break;

							case 20:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
								cReadModeB = 21;
								break;

							case 21:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
								cReadModeB = 22;
								break;

							case 22:
								ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
								strcpy_secure(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
								cReadModeB = 23;
								break;

							case 23:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
								cReadModeB = 24;
								break;

							case 24:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
								cReadModeB = 25;
								break;

							case 25:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
								cReadModeB = 26;
								break;

							case 26:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
								cReadModeB = 27;
								break;

							case 27:
								if (_bGetIsStringIsNumber(token) == FALSE) {
									ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
									delete cp;
									delete pStrTok;
									return FALSE;
								}
								m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
								cReadModeA = 0;
								cReadModeB = 0;
								break;
						}
						break;

					default:
						break;
				}
			}
			else {
				if (memcmp(token, "quest", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete[]cp;
	}
	if (pFile != NULL) fclose(pFile);

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		ErrorList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	wsprintf(G_cTxt, "QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(G_cTxt);
	return TRUE;
}

void CMapServer::UpdateProcessClient()
{
#ifdef DEF_DEBUG
	try {
#endif
		for (int i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->NoClear == FALSE)) {
				SendProcessBlocked(i);
				SendDllsBlocked(i);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: UpdateProcessClient");
	}
#endif
}

void CMapServer::RequestLogOutHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->NoDelete == TRUE) m_pClientList[iClientH]->NoDelete = FALSE;
}

void CMapServer::RequestCancelLogOutHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->NoDelete == FALSE) m_pClientList[iClientH]->NoDelete = TRUE;
}

void CMapServer::CheckUsersIP(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char seps[] = "= \t\n";
		char *token, cBuff[256];
		class CStrTok *pStrTok;
		char cNick[21];
		int i;
		char Msg[50];
		char IP[21];
		short Total;

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		ZeroMemory(cNick, sizeof(cNick));
		ZeroMemory(IP, sizeof(IP));
		ZeroMemory(Msg, sizeof(Msg));

		memcpy_secure(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token == NULL) {
			delete pStrTok;
			return;
		}

		memcpy_secure(cNick, token, 20);

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cNick, strlen(cNick)) == 0)) {
				strcpy_secure(IP, m_pClientList[i]->m_cIPaddress);
				wsprintf(Msg, "Checking clients connecteds in IP: %s", m_pClientList[i]->m_cIPaddress);
				ShowClientMsg(iClientH, Msg);
				i = DEF_MAXCLIENTS;
			}
		}
		if (strlen(IP) == 0) {
			ShowClientMsg(iClientH, "This player is not online!");
			return;
		}

		ZeroMemory(Msg, sizeof(Msg));
		Total = 1;
		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cNick, strlen(cNick)) != 0) && (memcmp(IP, m_pClientList[i]->m_cIPaddress, 21) == 0)) {
				wsprintf(Msg, "Client: %s -> IP: %s", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
				ShowClientMsg(iClientH, Msg);
				Total++;
			}
		}
		ZeroMemory(Msg, sizeof(Msg));
		wsprintf(Msg, "%d -> Client using this IP: %s", Total, IP);
		ShowClientMsg(iClientH, Msg);
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CheckUsersIP");
	}
#endif
}

void CMapServer::AdminOrder_BanIP(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * token, cBuff[256];
		class  CStrTok * pStrTok;
		char * pk;
		char cMsg[100], cNick[20], cIPtoBan[21];
		int i;
		FILE * pFile;

		ZeroMemory(cIPtoBan, sizeof(cIPtoBan));

		if (m_pClientList[iClientH] == NULL) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token == NULL) {
			delete pStrTok;
			return;
		}
		strcpy_secure(cNick, token);
		pk = pStrTok->pGet();

		pFile = fopen("Configs\\BannedList.cfg", "a");
		if (pFile != NULL) {
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cNick, strlen(cNick)) == 0)) {
					strcpy_secure(cIPtoBan, m_pClientList[i]->m_cIPaddress);
					wsprintf(cMsg, "banned ip: %s.", cIPtoBan);
					ShowClientMsg(iClientH, cMsg);
					wsprintf(G_cTxt, "<%s> Client IP Banned: (%s)", m_pClientList[iClientH]->m_cCharName, cIPtoBan);
					PutLogList(G_cTxt);
					fprintf(pFile, "%s\n", cIPtoBan);
				}
			}
		}
		if (pFile != NULL) fclose(pFile);
		delete pStrTok;

		LoadBannedList(0);

		for (i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (strcmp(m_pClientList[i]->m_cIPaddress, cIPtoBan) == 0)
					DeleteClient(i, TRUE, TRUE);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: AdminOrder_BanIP");
	}
#endif
}

void CMapServer::LoadBannedList(int iClientH)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	int i;
	char buf[30], cMsg[50];

	hFile = CreateFile("Configs\\BannedList.cfg", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen("Configs\\BannedList.cfg", "rt");
	if (pFile != NULL) {
		PutLogList("Reading IP Banned List file...");

		for (i = 0; i < 100; i++) ZeroMemory(BannedIP[i], sizeof(BannedIP[i]));

		i = 0;
		while (fgets(buf, 21, pFile)) {
			if (i < 100) {
				memcpy_secure(BannedIP[i], buf, strlen(buf) - 1);
				if (strlen(BannedIP[i]) > 0) i++;
			}
		}
	}
	if (pFile != NULL) fclose(pFile);
}

/*void CGame::ReqPing(int iClientH, int pData)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

		m_pClientList[iClientH]->m_iLastPing = pData;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PINGPLAYERS, NULL, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ReqPing");
	}
#endif
}*/

BOOL CMapServer::bReadEventResults(char * cFn, short Event)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD dwFileSize;
	char * cp, *token, cReadMode;
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		ErrorList("(!) Cannot open Results file.");
		return FALSE;
	}
	else {
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadMode != 0) {
				switch (cReadMode) {
					case 1:
						EventCount[Event].AresdenWin = atoi(token);
						cReadMode = 0;
						break;

					case 2:
						EventCount[Event].ElvineWin = atoi(token);
						cReadMode = 0;
						break;

					case 3:
						EventCount[Event].Draw = atoi(token);
						cReadMode = 0;
						break;

					case 4:
						EventCount[Event].LastWin = atoi(token);
						cReadMode = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "Aresden-Win", 11) == 0) cReadMode = 1;
				if (memcmp(token, "Elvine-Win", 10) == 0) cReadMode = 2;
				if (memcmp(token, "Draw", 4) == 0) cReadMode = 3;
				if (memcmp(token, "Last-Win", 8) == 0) cReadMode = 4;
			}
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete[]cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CMapServer::CreateEventResults(int iWinnerSide, short Event)
{
#ifdef DEF_DEBUG
	try {
#endif

		char * cp, cTxt[256], cFn[256], cTemp[1024];
		FILE * pFile;

		ZeroMemory(cFn, sizeof(cFn));
		switch (Event)
		{
			case 0: strcat(cFn, "Events\\Crusade\\Results.txt"); break;
			case 1: strcat(cFn, "Events\\CaptureTheFlag\\Results.txt"); break;
			case 2: strcat(cFn, "Events\\Rush\\Results.txt"); break;
			case 3: strcat(cFn, "Events\\TowerDefense\\Results.txt"); break;
			case 4: strcat(cFn, "Events\\CityVsCity\\Results.txt"); break;
			case 5: strcat(cFn, "Events\\HellOfDeath\\Results.txt"); break;
			case 6: strcat(cFn, "Events\\WorldWar\\Results.txt"); break;
			case 7: strcat(cFn, "Events\\WorldWarII\\Results.txt"); break;
		}

		EventCount[Event].LastWin = iWinnerSide;

		if (iWinnerSide == 1) EventCount[Event].AresdenWin++;
		else if (iWinnerSide == 2) EventCount[Event].ElvineWin++;
		else EventCount[Event].Draw++;

		pFile = fopen(cFn, "wt");
		if (pFile == NULL) {
			wsprintf(cTxt, "Cannot create Event Result file");
			ErrorList(cTxt);
		}
		else {
			ZeroMemory(cTemp, sizeof(cTemp));

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "Aresden-Win = %d\n", EventCount[Event].AresdenWin);
			strcat(cTemp, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "Elvine-Win = %d\n", EventCount[Event].ElvineWin);
			strcat(cTemp, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "Draw = %d\n", EventCount[Event].Draw);
			strcat(cTemp, cTxt);

			ZeroMemory(cTxt, sizeof(cTxt));
			wsprintf(cTxt, "Last-Win = %d\n", EventCount[Event].LastWin);
			strcat(cTemp, cTxt);

			cp = (char *)cTemp;
			fwrite(cp, strlen(cp), 1, pFile);
		}
		if (pFile != NULL) fclose(pFile);

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: CreateEventResults");
	}
#endif
}

void CMapServer::AdminOrder_SetPoints(int iClientH, char *pData, DWORD dwMsgSize, short Type)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel == 7)
	{

#ifdef DEF_DEBUG
		try {
#endif

			char seps[] = "= \t\n";
			char   * token, *cp, cName[11], cBuffer[256], cTemp[120];
			class CStrTok *pStrTok;
			WORD * wp;
			char *pk, cPK[6], Msg[50];
			//short Points;//Cambio dar puntos eks
			int Points;
			int i;
			bool Search = false;


			if ((dwMsgSize) <= 0) return;

			ZeroMemory(cBuffer, sizeof(cBuffer));
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cPK, sizeof(cPK));
			memcpy_secure(cBuffer, pData, dwMsgSize);
			pStrTok = new class CStrTok(cBuffer, seps);
			token = pStrTok->pGet();
			token = pStrTok->pGet();

			if (token == NULL) {
				delete pStrTok;
				return;
			}
			memcpy_secure(cName, token, 20);
			pk = pStrTok->pGet();
			if (pk == NULL) {
				delete pStrTok;
				return;
			}
			memcpy_secure(cPK, pk, 5);
			Points = atoi(cPK);
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, strlen(cName)) == 0)) {
					switch (Type) {


					case 0: // EKs
						m_pClientList[i]->m_iEnemyKillCount += Points;
						SendEnemyKills(i);
						wsprintf(Msg, "Added %d EKs to %s - Total %d", Points, cName, m_pClientList[i]->m_iEnemyKillCount);
						break;
					case 1: // Rep
						m_pClientList[i]->m_iRating += Points;
						if (m_pClientList[i]->m_iRating >(DEF_LIMIT_REP * 1000))  m_pClientList[i]->m_iRating = (DEF_LIMIT_REP * 1000);
						if (m_pClientList[i]->m_iRating < -(DEF_LIMIT_REP * 1000)) m_pClientList[i]->m_iRating = -(DEF_LIMIT_REP * 1000);
						SendNotifyMsg(NULL, i, CLIENT_REPONSE_PLAYERREP, m_pClientList[i]->m_iRating, NULL, NULL, NULL);
						wsprintf(Msg, "Added %d Rep to %s - Total %d", Points, cName, m_pClientList[i]->m_iRating);
						break;
					case 2: // Pks
						m_pClientList[i]->m_iPKCount += Points;
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_PKPENALTY, m_pClientList[i]->m_iPKCount, NULL, NULL, NULL);
						wsprintf(Msg, "Added %d Pks to %s - Total %d", Points, cName, m_pClientList[i]->m_iPKCount);
						break;
					case 3: // Coins
						m_pClientList[i]->m_iCoins += Points;
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_COINS, m_pClientList[i]->m_iCoins, NULL, NULL, NULL);
						wsprintf(Msg, "Added %d Coins to %s - Total %d", Points, cName, m_pClientList[i]->m_iCoins);
						break;
					case 4: // Majs
						m_pClientList[i]->m_iGizonItemUpgradeLeft += Points;
						SendNotifyMsg(NULL, i, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
						wsprintf(Msg, "Added %d Majestics to %s - Total %d", Points, cName, m_pClientList[i]->m_iGizonItemUpgradeLeft);
						break;
					case 5: // Crits
						m_pClientList[i]->m_iSuperAttackLeft += Points;
						SendCriticals(i);
						wsprintf(Msg, "Added %d Criticals to %s - Total %d", Points, cName, m_pClientList[i]->m_iSuperAttackLeft);
						break;
					}
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_NOTICEMSG, NULL, NULL, NULL, Msg);
					delete pStrTok;
					return;
				}
			}
#ifdef DEF_DEBUG
		}
		catch (...) {
			ErrorList("Crash Evitado en: AdminOrder_SetPoints");
		}
#endif
	}
}

void CMapServer::LocalStarHappyHour(BOOL StatusHappy)
{
#ifdef DEF_DEBUG
	try {
#endif
		bHappyHour = StatusHappy;
		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (bHappyHour) SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HAPPYHOURSTAR, NULL, NULL, NULL, NULL);
				else SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HAPPYHOUREND, NULL, NULL, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalStarHappyHour");
	}
#endif
}

void CMapServer::LocalStarHappyDay(BOOL StatusHappy)
{
#ifdef DEF_DEBUG
	try {
#endif
		bHappyDay = StatusHappy;
		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL) {
				if (bHappyDay) SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HAPPYDAYSTAR, NULL, NULL, NULL, NULL);
				else SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HAPPYDAYEND, NULL, NULL, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: LocalStarHappyDay");
	}
#endif
}

BOOL CMapServer::ReadMapCFGs(char * cFn)
{
	for (short i = 0; i < DEF_MAXMAPS; i++)	ZeroMemory(MapList[i], sizeof(MapList[i]));

	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, *token, cReadMode, cTxt[120];
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;
	short TotalMaps;

	cReadMode = 0;
	TotalMaps = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL)	return FALSE;
	else {
		PutLogList("Reading maplist file...");
		cp = new char[dwFileSize + 2];
		ZeroMemory(cp, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadMode != 0) {
				switch (cReadMode) {
					case 1:
						if (strlen(token) > 10) {
							wsprintf(cTxt, "CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
							ErrorList(cTxt);
							return FALSE;
						}
						strcpy_secure(MapList[TotalMaps], token);
						cReadMode = 0;
						TotalMaps++;
						break;
				}
			}
			else
				if (memcmp(token, "map", 3) == 0) cReadMode = 1;
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete[]cp;
	}
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

void CMapServer::HandleRequestMemoryTops(int iClientH, short TopID, BOOL Send, BOOL Actualizar)
{
#ifdef DEF_DEBUG
	try {
#endif

		if (iClientH < 0) return;
		if (m_pClientList[iClientH] == NULL) return;

		int TopIndex = 0, ShortCutIndex = 0, i, x, y;
		bool bFlag = true;
		char TempName[11];
		int TempPoints, TempSide;

		i = m_iClientShortCut[ShortCutIndex];

		// Primero actualizo los eks de los chars que est�n en el top site
		while (i > 0 && ShortCutIndex < DEF_MAXCLIENTS) {
			i = m_iClientShortCut[ShortCutIndex];
			ShortCutIndex++;

			if (i >= 0 && i < DEF_MAXCLIENTS && m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && m_pClientList[i]->m_iAdminUserLevel == 0) {
				for (int y = 0; y < 15; y++) {
					if (Top[TopID][y].Points > 0 && (strcmp(Top[TopID][y].Name, m_pClientList[i]->m_cCharName) == 0)) {
						switch (TopID) {
							case 0: Top[TopID][y].Points = m_pClientList[i]->m_iEnemyKillCount; break;
							case 1: Top[TopID][y].Points = m_pClientList[i]->m_iEnemyKillTotalCount; break;
							case 2: Top[TopID][y].Points = m_pClientList[i]->m_iCityFriendKilled; break;
							case 3: Top[TopID][y].Points = m_pClientList[i]->m_iPKCount; break;
							case 4: Top[TopID][y].Points = m_pClientList[i]->TotalDeath; break;
							case 5: Top[TopID][y].Points = m_pClientList[i]->TotalClientKilled; break;
							default: break;
						}
					}
				}
			}
		}

		ShortCutIndex = 0;
		i = m_iClientShortCut[ShortCutIndex];

		// Ahora si armo el top
		while (i > 0 && ShortCutIndex < DEF_MAXCLIENTS) {
			i = m_iClientShortCut[ShortCutIndex];
			ShortCutIndex++;

			if (i >= 0 && i < DEF_MAXCLIENTS && m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && m_pClientList[i]->m_iAdminUserLevel == 0) {
				for (int x = 0; x < 15; x++) {
					switch (TopID) {
						case 0: TempPoints = m_pClientList[i]->m_iEnemyKillCount; break;
						case 1: TempPoints = m_pClientList[i]->m_iEnemyKillTotalCount; break;
						case 2: TempPoints = m_pClientList[i]->m_iCityFriendKilled; break;
						case 3:
							if (m_pClientList[i]->Assasain) TempPoints = m_pClientList[i]->m_iPKCount;
							else TempPoints = 0;
							break;
						case 4: TempPoints = m_pClientList[i]->TotalDeath; break;
						case 5: TempPoints = m_pClientList[i]->TotalClientKilled; break;
						default: break;
					}

					if (TempPoints > Top[TopID][x].Points) {
						for (int y = 0; y < 15; y++) {
							if (strcmp(Top[TopID][y].Name, m_pClientList[i]->m_cCharName) == 0)
								bFlag = false; // No deja poner el mismo personaje en el top
						}

						if (bFlag == true) {
							if (Top[TopID][x].Points > 0) { // Hay otro cliente en la lista
								for (int y = 13; y >= x; y--) Top[TopID][y + 1] = Top[TopID][y];

								Top[TopID][x].Points = TempPoints;
								strcpy_secure(Top[TopID][x].Name, m_pClientList[i]->m_cCharName);
								Top[TopID][x].Side = (Citizenship)m_pClientList[i]->m_cSide;
							}
							else {
								Top[TopID][x].Points = TempPoints;
								strcpy_secure(Top[TopID][x].Name, m_pClientList[i]->m_cCharName);
								Top[TopID][x].Side = (Citizenship)m_pClientList[i]->m_cSide;
							}
						}
						bFlag = true;
					}
				}
			}
		}

		for (x = 0; x < 14; x++) {
			for (y = x + 1; y < 15; y++) {
				if (Top[TopID][y].Points > Top[TopID][x].Points) {
					// Guardo los datos en variables temporales
					TempPoints = Top[TopID][x].Points;
					strcpy_secure(TempName, Top[TopID][x].Name);
					TempSide = (Citizenship)Top[TopID][x].Side;

					// Reemplazo el valor actual, por el nuevo
					Top[TopID][x].Points = Top[TopID][y].Points;
					strcpy_secure(Top[TopID][x].Name, Top[TopID][y].Name);
					Top[TopID][x].Side = (Citizenship)Top[TopID][y].Side;

					// Devuelvo los datos de las variables temporales, a la nueva posicion
					Top[TopID][y].Points = TempPoints;
					strcpy_secure(Top[TopID][y].Name, TempName);
					Top[TopID][y].Side = (Citizenship)TempSide;
				}
			}
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete)) {
				for (y = 0; y < 15; y++) {
					if (m_pClientList[i] != NULL) { // le agreo este chequeo.. aunque no se por que crasheo...
						if (strcmp(Top[TopID][y].Name, m_pClientList[i]->m_cCharName) == 0) {
							if (!m_pClientList[i]->Achivements[18].Complete) CheckCompleteAchivement(i, 18, TRUE);
							if (y == 0 && !m_pClientList[i]->Achivements[22].Complete) CheckCompleteAchivement(i, 22, TRUE);
						}
					}
				}
			}
		}

		char cData[512];
		int *ip, Size;
		char *cp;
		DWORD *dwp;
		WORD *wp;

		if (Send) {
			ZeroMemory(cData, sizeof(cData));
			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_RESPONSE_TOPMEMORY_EK;

			cp = (char *)(cData + 6);
			Size = 7;

			*cp = (char)TopID;
			cp++;

			for (i = 0; i < 15; i++) {
				memcpy_secure(cp, Top[TopID][i].Name, strlen(Top[TopID][i].Name));
				cp += 11;

				if (TopID != 3) {
					*cp = (char)Top[TopID][i].Side;
					cp++;
					Size++;
				}

				ip = (int *)cp;
				*ip = Top[TopID][i].Points;
				cp += 4;

				Size += 15;
			}
			m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, Size);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: HandleRequestMemoryTops");
	}
#endif
}

void CMapServer::EkAnnoucer(char cAttackerName[12], char cVictimun[12], BOOL EK)
{
	char cEKMsg[30];

	ZeroMemory(cEKMsg, sizeof(cEKMsg));
	wsprintf(cEKMsg, "%s Killed %s", cAttackerName, cVictimun);

	SendEkAnnoucer(cEKMsg, EK);
}

void CMapServer::SendEkAnnoucer(char cEKMsg[30], BOOL EK)
{
#ifdef DEF_DEBUG
	try {
#endif
		for (short i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL))
				SendNotifyMsg(NULL, i, CLIENT_NOTIFY_NOTICEEKMSG, EK, NULL, NULL, cEKMsg);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendEkAnnoucer");
	}
#endif
}

void CMapServer::SendHpReliquia()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!AttackAresden && !AttackElvine) return;
		int i, z, ReliquiaAresden2, ReliquiaElvine2;

		for (z = 1; z < DEF_MAXNPCS; z++) {
			if (m_pNpcList[z] != NULL) {
				if (memcmp(m_pNpcList[z]->m_cNpcName, "Reliquia-a", 11) == 0)
					ReliquiaAresden2 = m_pNpcList[z]->m_iHP;
				else if (memcmp(m_pNpcList[z]->m_cNpcName, "Reliquia-e", 10) == 0)
					ReliquiaElvine2 = m_pNpcList[z]->m_iHP;
			}
		}

		ReliquiaAresden = (ReliquiaAresden2 * 100) / DEF_MAXHPRELIQUIA;
		ReliquiaElvine = (ReliquiaElvine2 * 100) / DEF_MAXHPRELIQUIA;

		if ((ReliquiaAresden > 0) && (ReliquiaElvine > 0)) {
			SendHPStructures(0);
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendHpReliquia");
	}
#endif
}

void CMapServer::ActualizarStructures()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!HellOfDeath) return;
		int i, HPAres = 0, HPElv = 0, z;
		bool Check = false;

		for (z = 1; z < DEF_MAXMAPS; z++) {
			if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, DEF_EVENTMAP_HELLOFDEAT) == 0)) {
				Check = true;
			}
		}

		if (!Check) return;
		for (z = 1; z < DEF_MAXNPCS; z++) {
			if (m_pNpcList[z] != NULL) {
				if (memcmp(m_pNpcList[z]->m_cNpcName, "Reliquia-a", 10) == 0)
					HPAres += m_pNpcList[z]->m_iHP;
				else if (memcmp(m_pNpcList[z]->m_cNpcName, "Reliquia-e", 10) == 0)
					HPElv += m_pNpcList[z]->m_iHP;
			}
		}

		HPAres = HPAres / 4;
		HPElv = HPElv / 4;

		HPAres = abs((HPAres * 100) / DEF_MAXHPRELIQUIAHOD); //DEF_MAXHPRELIQUIAHOD
		HPElv = abs((HPElv * 100) / DEF_MAXHPRELIQUIAHOD); //DEF_MAXHPRELIQUIAHOD

		if (HPAres == 0) EndHellOfDeathMode(2);
		else if (HPElv == 0) EndHellOfDeathMode(1);
		else {
			for (int i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL && m_pClientList[i]->m_bIsInitComplete && !m_pClientList[i]->NoClear && memcmp(m_pClientList[i]->m_cMapName, DEF_EVENTMAP_HELLOFDEAT, 10) == 0)
					SendNotifyMsg(NULL, i, CLIENT_NOTIFY_HPSTRUCTURE, HPAres, HPElv, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActualizarStructures");
	}
#endif
}

void CMapServer::SendHPStructures(short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		for (int i = 0; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && !m_pClientList[i]->NoClear) {
				if (Type == 0) SendNotifyMsg(NULL, i, CLIENT_SEND_HPRELIQUIA, ReliquiaAresden, ReliquiaElvine, NULL, NULL, NULL, NULL);
				else if (Type == 1)	SendNotifyMsg(NULL, i, CLIENT_NOTIFY_STRUCTURES, m_iTowerAresden, m_iTowerElvine, NULL, NULL, NULL, NULL);
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendHPStructures");
	}
#endif
}

// New System -> Market Place -> HB Arg v4.4
void CMapServer::bSetItemToSellList(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		class CItem * pItem;
		short *sp, x = 0, i, sItemIndex;
		char *cp;
		int *ip, Price = 0;
		bool new_item;

		if (m_pClientList[iClientH] == NULL) return;
		if (memcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_MARKETPLACE, 7) != 0) return;

		if (MarketEnabled) {
			for (i = 0; i < DEF_MAXSELLITEMS; i++) {
				if (m_pClientList[iClientH]->MarketItem[i].sIndex != -1)
					x++;
			}

			if (x == DEF_MAXSELLITEMS) return;

			cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

			sp = (short *)cp;
			sItemIndex = *sp;
			cp += 2;

			ip = (int *)cp;
			Price = *ip;
			cp += 4;

			if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
			if (Price <= 0) return;

			new_item = true;
			for (i = 0; i < DEF_MAXSELLITEMS; i++) {
				if (m_pClientList[iClientH]->MarketItem[i].sIndex != -1) {
					if (m_pClientList[iClientH]->MarketItem[i].sIndex == sItemIndex) {
						m_pClientList[iClientH]->MarketItem[i].m_wPrice = Price;
						new_item = false;
					}
				}
			}

			if (new_item) {
				for (i = 0; i < DEF_MAXSELLITEMS; i++) {
					if (m_pClientList[iClientH]->MarketItem[i].sIndex == -1) {
						m_pClientList[iClientH]->MarketItem[i].sIndex = sItemIndex;
						m_pClientList[iClientH]->MarketItem[i].m_wPrice = Price;

						if (m_pClientList[iClientH]->OpenSell == FALSE) m_pClientList[iClientH]->OpenSell = TRUE;
						m_pClientList[iClientH]->TotalItemSell = i + 1;
						break;
					}
				}
			}
		}
		else ShowClientMsg(iClientH, "Market is disabled");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: bSetItemToSellList");
	}
#endif
}

void CMapServer::RequestItemsList(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp;
		char   m_msgBuff[10];
		short i, x, TotalSell = 0, sX, sY, sOwner;
		char cOwnerType;
		int * ip;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;

		if (MarketEnabled) {
			cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

			ip = (int *)cp;
			sX = *ip;
			cp += 4;

			ip = (int *)cp;
			sY = *ip;
			cp += 4;

			ZeroMemory(m_msgBuff, sizeof(m_msgBuff));
			strcpy_secure(m_msgBuff, cp);
			cp += 10;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, sX, sY);

			if (sOwner != NULL) {
				switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (iClientH == sOwner) return;
						if (m_pClientList[sOwner] == NULL) return;
						if (memcmp(m_pClientList[sOwner]->m_cCharName, m_msgBuff, 10) != 0) return;
						SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_DELETE_SELL_LIST, NULL, NULL, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_SELLTYPE, m_pClientList[sOwner]->SellType, NULL, NULL, NULL);
						m_pClientList[iClientH]->BuyTo = sOwner;
						for (x = 0; x < DEF_MAXSELLITEMS; x++) {
							if (m_pClientList[sOwner]->MarketItem[x].sIndex != -1) {
								TotalSell++;
								SendDataListItems(iClientH, sOwner, x, TotalSell);
							}
						}
						break;
					default: return;
				}
			}
		}
		else ShowClientMsg(iClientH, "Market is disabled");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestItemsList");
	}
#endif
}

void CMapServer::SendDataListItems(int SendTo, int iClientH, short Position, short TotalSell)
{
#ifdef DEF_DEBUG
	try {
#endif
		int iRet;
		DWORD * dwp;
		WORD  * wp;
		char  * cp;
		short * sp, sItemIndex;
		char cData[100];

		if (m_pClientList[SendTo] == NULL) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->MarketItem[Position].sIndex == -1) return;

		if (MarketEnabled) {
			sItemIndex = m_pClientList[iClientH]->MarketItem[Position].sIndex;

			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

			dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = CLIENT_NOTIFY;
			wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp = CLIENT_RESPONSE_ITEMLIST;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			sp = (short *)cp;
			*sp = Position;
			cp += 2;

			sp = (short *)cp;
			*sp = TotalSell;
			cp += 2;

			memcpy_secure(cp, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
			cp += 20;

			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;
			cp += 4;

			*cp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType;
			cp++;

			*cp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
			cp++;

			*cp = (char)0;
			cp++;

			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit;
			cp += 2;

			*cp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wWeight;
			cp += 2;

			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite;
			cp += 2;

			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame;
			cp += 2;

			*cp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor;
			cp++;

			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			cp += 2;

			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute;
			cp += 4;

			//*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
			//cp++;
			//lalomanu
			sp = (short *)cp;
			*sp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
			cp += 2;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			cp++;

			*cp = (char)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed;
			cp++;

			dwp = (DWORD *)cp;
			*dwp = m_pClientList[iClientH]->MarketItem[Position].m_wPrice;
			cp += 4;

			//iRet = m_pClientList[SendTo]->m_pXSock->iSendMsg(cData, 68);
			//lalomanu
			iRet = m_pClientList[SendTo]->m_pXSock->iSendMsg(cData, 69);

			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(SendTo, TRUE, TRUE);//Agregado Lalo882
					return;
			}
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SendDataListItems");
	}
#endif
}

void CMapServer::RequestDefineSellList(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp;
		short * sp, Temp;

		if (m_pClientList[iClientH] == NULL) return;

		if (MarketEnabled) {
			cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

			sp = (short *)cp;
			Temp = *sp;
			cp += 2;

			if (Temp == -1) {
				m_pClientList[iClientH]->SellType = -1;
				m_pClientList[iClientH]->BuyTo = -1;
				m_pClientList[iClientH]->OpenSell = FALSE;
				SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_MARKET, 0, NULL, NULL, NULL);
				for (short i = 0; i < DEF_MAXSELLITEMS; i++) {
					if (m_pClientList[iClientH]->MarketItem[i].sIndex != -1) {
						m_pClientList[iClientH]->MarketItem[i].sIndex = -1;
						m_pClientList[iClientH]->MarketItem[i].m_wPrice = -1;
					}
				}
			}
			else {
				m_pClientList[iClientH]->SellType = Temp;
				m_pClientList[iClientH]->BuyTo = iClientH;
				m_pClientList[iClientH]->OpenSell = TRUE;
				SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_MARKET, 1, NULL, NULL, NULL);
			}
		}
		else ShowClientMsg(iClientH, "Market is disabled");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestDefineSellList");
	}
#endif
}

void CMapServer::RequestBuyItem(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		short sItemIndex, BuyTo, sIndex, TotalSell;
		register int iRet, iEraseReq;
		short * sp;
		char  * cp, cData[100];
		char m_msgBuff[12];
		DWORD * dwp;
		WORD  * wp;
		class CItem * pItem;
		class CItem * pItemA;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->BuyTo == -1) return;

		if (MarketEnabled) {
			cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

			sp = (short *)cp;
			sItemIndex = *sp;
			cp += 2;

			sp = (short *)cp;
			TotalSell = *sp;
			cp += 2;

			ZeroMemory(m_msgBuff, sizeof(m_msgBuff));
			strcpy_secure(m_msgBuff, cp);
			cp += 10;

			BuyTo = m_pClientList[iClientH]->BuyTo;

			if (m_pClientList[BuyTo] == NULL) return;
			if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXSELLITEMS)) return;
			if (m_pClientList[BuyTo]->MarketItem[sItemIndex].sIndex == -1) return;

			sIndex = m_pClientList[BuyTo]->MarketItem[sItemIndex].sIndex;
			if (m_pClientList[BuyTo]->m_pItemList[sIndex] == NULL) return;

			if ((sIndex < 0) || (sIndex >= DEF_MAXITEMS)) return;
			if ((m_pClientList[BuyTo]->m_pItemList[sIndex] == NULL) || (m_pClientList[BuyTo]->TotalItemSell != TotalSell)) {
				SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_DELETE_SELL_LIST, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_SELLTYPE, m_pClientList[BuyTo]->SellType, NULL, NULL, NULL);
				ActualizarSellingList(BuyTo, iClientH);
				return;
			}

			switch (m_pClientList[BuyTo]->SellType) {
				case 1:
					if (m_pClientList[iClientH]->m_iContribution < m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice) return;
					m_pClientList[iClientH]->m_iContribution -= m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice;
					m_pClientList[BuyTo]->m_iContribution += m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice;
					SendContribution(iClientH);
					SendContribution(BuyTo);
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iCoins < m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice) return;
					m_pClientList[iClientH]->m_iCoins -= m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice;
					m_pClientList[BuyTo]->m_iCoins += m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice;
					break;
				default: return; break;
			}

			// Creo una copia del item original.
			pItem = new class CItem;
			_bInitItemAttr(pItem, m_pClientList[BuyTo]->m_pItemList[sIndex]->m_cName);
			bCopyItemContents(pItem, m_pClientList[BuyTo]->m_pItemList[sIndex]);

			m_pClientList[BuyTo]->MarketItem[sItemIndex].sIndex = -1;
				m_pClientList[BuyTo]->MarketItem[sItemIndex].m_wPrice = -1;

			m_pClientList[BuyTo]->m_bIsItemEquipped[sIndex] = FALSE;

			// Borro el item del listado del que vende, mientras mantengo una copia del original
		/*	m_pClientList[BuyTo]->m_pItemList[sIndex] = NULL;
			delete m_pClientList[BuyTo]->m_pItemList[sIndex];*/
			//Agreafado Lalo882
			delete m_pClientList[BuyTo]->m_pItemList[sIndex];
			m_pClientList[BuyTo]->m_pItemList[sIndex] = NULL;
			SendNotifyMsg(NULL, BuyTo, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, sIndex, 1, NULL, m_pClientList[iClientH]->m_cCharName);

			// Pruebo darle el item al cliente que compra ( sisi, ya le facture :P )

			// Le doy el item al que compra 
			bAddItem(iClientH, pItem, NULL);

			// Guardo en el log la venta del item, por medio del market.
			_bItemLog(DEF_ITEMLOG_BUYMARKET, iClientH, BuyTo, pItem);

			for (short x = 0; x < DEF_MAXSELLITEMS - 1; x++) {
				if (m_pClientList[BuyTo]->MarketItem[x].sIndex == -1) {
					if (m_pClientList[BuyTo]->MarketItem[x + 1].sIndex != -1) {
						m_pClientList[BuyTo]->MarketItem[x].sIndex = m_pClientList[BuyTo]->MarketItem[x + 1].sIndex;
						m_pClientList[BuyTo]->MarketItem[x].m_wPrice = m_pClientList[BuyTo]->MarketItem[x + 1].m_wPrice;

						m_pClientList[BuyTo]->MarketItem[x + 1].sIndex = -1;
						m_pClientList[BuyTo]->MarketItem[x + 1].m_wPrice = -1;
					}
				}
			}
			ActualizarSellingList(BuyTo, iClientH);
		}
		else ShowClientMsg(iClientH, "Market is disabled");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestBuyItem");
	}
#endif
}

void CMapServer::ActualizarSellingList(int BuyTo, int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		short TotalSell = 0;
		if (m_pClientList[BuyTo] == NULL) return;
		if (m_pClientList[iClientH] == NULL) return;

		if (MarketEnabled) {
			if (m_pClientList[BuyTo]->MarketItem[0].sIndex == -1) {
				m_pClientList[BuyTo]->SellType = -1;
				m_pClientList[BuyTo]->BuyTo = -1;
				m_pClientList[BuyTo]->OpenSell = FALSE;
				SendNotifyMsg(NULL, BuyTo, CLIENT_RESPONSE_MARKET, 0, NULL, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_SELLTYPE, -1, NULL, NULL, NULL);
			}
			else {
				SendNotifyMsg(NULL, iClientH, CLIENT_RESPONSE_DELETE_SELL_LIST, NULL, NULL, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_SELLTYPE, m_pClientList[BuyTo]->SellType, NULL, NULL, NULL);
				for (short x = 0; x < DEF_MAXSELLITEMS; x++) {
					if (m_pClientList[BuyTo]->MarketItem[x].sIndex != -1) {
						TotalSell++;
						SendDataListItems(iClientH, BuyTo, x, TotalSell);
					}
				}
				m_pClientList[BuyTo]->TotalItemSell = TotalSell;
			}
		}
		else ShowClientMsg(iClientH, "Market is disabled");
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ActualizarSellingList");
	}
#endif
}
/* End Market Code -> ZeroEoyPnk */

void CMapServer::RequestBuyAssasainPoints(int iClientH, char * pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		char * cp;
		short type;
		short * sp;

		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

		sp = (short *)cp;
		type = *sp;
		cp++;

		if (m_pClientList[iClientH]->AssasainPoint >= DEF_ASSASAINPOINTS) return;

		switch (type) {
			case 1:
				if (m_pClientList[iClientH]->m_iEnemyKillCount < DEF_AP_EKNEED) return;
				m_pClientList[iClientH]->m_iEnemyKillCount -= DEF_AP_EKNEED;
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iContribution < DEF_AP_CONTRIBNEED) return;
				m_pClientList[iClientH]->m_iContribution -= DEF_AP_CONTRIBNEED;
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iCoins < DEF_AP_COINSNEED) return;
				m_pClientList[iClientH]->m_iCoins -= DEF_AP_COINSNEED;
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iRankExp < DEF_AP_EXPRANKNEED) return;
				m_pClientList[iClientH]->m_iRankExp -= DEF_AP_EXPRANKNEED;
				break;
			default: return; break;
		}

		m_pClientList[iClientH]->AssasainPoint += DEF_PURCHASE_ASSASAINPOINTS;

		ShowClientMsg(iClientH, "Has comprado Assassin points");

		if (m_pClientList[iClientH]->AssasainPoint >= DEF_ASSASAINPOINTS)
			ChangeToAssasain(iClientH);
		else {
			SendEnemyKills(iClientH);
			SendContribution(iClientH);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_COINS, m_pClientList[iClientH]->m_iCoins, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ASSASAINSPOINTS, m_pClientList[iClientH]->AssasainPoint, NULL, NULL, NULL);
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestBuyAssasainPoints");
	}
#endif
}

void CMapServer::RequestCreatePartyHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		char *cp, cData[120];
		DWORD * dwp;
		WORD * wp;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
		if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) return;
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0) return;
		if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0) return;

		if (m_pClientList[iClientH]->m_iPartyID != NULL) return;
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;

		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

		for (int i = 1; i < DEF_MAXPARTYNUM; i++) {
			if (m_pPartyManager[i] == NULL) {
				m_pPartyManager[i] = new class PartyManager();
				m_pPartyManager[i]->iCreateNewParty(iClientH);
				if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;

				m_pClientList[iClientH]->m_iPartyID = i;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PARTY, 1, 1, NULL, NULL);

				RefreshParty(iClientH, 4);

				// Achivement
				if (!m_pClientList[iClientH]->Achivements[2].Complete) CheckCompleteAchivement(iClientH, 2, TRUE);
				return;
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestCreatePartyHandler");
	}
#endif
}

void CMapServer::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
#ifdef DEF_DEBUG
	try {
#endif
		char *cp, cData[120];
		DWORD * dwp;
		WORD * wp;
		int iH, i, PartyID, NotifyClient;

		if (m_pClientList[iClientH] == NULL) return;

		switch (iResult) {
			case 0:
				iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
				if (m_pClientList[iH] == NULL) return;
				if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
				if ((m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH)) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0) return;
				if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLEK) == 0) return;
				if (strcmp(m_pClientList[iClientH]->m_cMapName, DEF_EVENTMAP_ALLDKEK) == 0) return;

				SendNotifyMsg(NULL, iH, CLIENT_NOTIFY_PARTY, 7, 0, NULL, NULL);

				m_pClientList[iH]->m_iPartyID = NULL;
				m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;

				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				break;

			case 1:
				iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
				if (m_pClientList[iH] == NULL) return;
				if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
				if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH)) return;

				if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL && m_pClientList[iClientH]->m_iPartyID == NULL)
					RequestCreatePartyHandler(iClientH);

				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				PartyID = m_pClientList[iClientH]->m_iPartyID;

				if (m_pPartyManager[PartyID] != NULL) {
					if (m_pPartyManager[PartyID]->bAddMember(iH)) {
						m_pClientList[iH]->m_iPartyID = PartyID;
						m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
						m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
					}
				}

				for (i = 0; i <= m_pPartyManager[PartyID]->iTotalMembers; i++) {
					if (m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH != NULL) {
						NotifyClient = m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH;
						if (m_pClientList[NotifyClient] != NULL) {
							SendNotifyMsg(NULL, NotifyClient, CLIENT_NOTIFY_PARTY, 4, 1, NULL, m_pClientList[iH]->m_cCharName);
							if ((!m_pClientList[NotifyClient]->Achivements[6].Complete) && (m_pPartyManager[PartyID]->iTotalMembers >= 4))
								CheckCompleteAchivement(NotifyClient, 6, TRUE);
						}
					}
				}
				RefreshParty(iH, 4);
				break;

			case 2:
				iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
				if (m_pClientList[iH] == NULL) return;
				if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
				if ((m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH)) return;

				if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
					RequestDismissPartyHandler(iClientH);
				}
				else {
					iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) &&
						(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
						m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
						ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
					}

					m_pClientList[iClientH]->m_iPartyID = NULL;
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestAcceptJoinPartyHandler");
	}
#endif
}

void CMapServer::RefreshParty(int iClientH, short Type)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, j, NotifyClient, PartyID;
		char Name[10], MapName[12];
		int HP = 0, sX = 0, sY = 0, MemberID;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;
		if (m_pClientList[iClientH]->m_iPartyID == NULL) return;
		if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0) && (m_pClientList[iClientH]->m_iPartyID != NULL))
		{
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) && (m_pClientList[iClientH]->m_iPartyID != NULL))
		{
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) && (m_pClientList[iClientH]->m_iPartyID != NULL))
		{
			RequestDismissPartyHandler(iClientH);
			return;
		}

		// Reload Party
		PartyID = m_pClientList[iClientH]->m_iPartyID;

		ZeroMemory(Name, sizeof(Name));
		memcpy_secure(Name, m_pClientList[iClientH]->m_cCharName, 12);

		HP = (m_pClientList[iClientH]->m_iHP * 100) / iGetMaxHP(iClientH);

		ZeroMemory(MapName, sizeof(MapName));
		memcpy_secure(MapName, m_pClientList[iClientH]->m_cMapName, 12);

		sX = m_pClientList[iClientH]->m_sX;
		sY = m_pClientList[iClientH]->m_sY;

		if (PartyID != NULL && m_pPartyManager[PartyID] != NULL) {
			MemberID = m_pPartyManager[PartyID]->iGetMemberID(iClientH);
			if (MemberID == -1) return;

			for (i = 0; i <= m_pPartyManager[PartyID]->iTotalMembers; i++) {
				NotifyClient = m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH;

				if (m_pClientList[NotifyClient] != NULL) {
					switch (Type) {
						case 1:
							for (j = 0; j <= m_pPartyManager[PartyID]->iTotalMembers; j++) {
								MemberID = m_pPartyManager[PartyID]->m_stPartyInfo[j].iClientH;

								ZeroMemory(Name, sizeof(Name));
								memcpy_secure(Name, m_pClientList[MemberID]->m_cCharName, 12);

								SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYNAME, j, NULL, NULL, Name);
							}
							break;

						case 2: SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYHP, MemberID, HP, NULL, NULL); break;
						case 3: SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYCOORDS, MemberID, sX, sY, MapName); break;

						case 4:
							for (j = 0; j <= m_pPartyManager[PartyID]->iTotalMembers; j++) {
								MemberID = m_pPartyManager[PartyID]->m_stPartyInfo[j].iClientH;
								if (m_pClientList[MemberID] != NULL) {

									ZeroMemory(Name, sizeof(Name));
									memcpy_secure(Name, m_pClientList[MemberID]->m_cCharName, 12);

									HP = (m_pClientList[MemberID]->m_iHP * 100) / iGetMaxHP(MemberID);

									ZeroMemory(MapName, sizeof(MapName));
									memcpy_secure(MapName, m_pClientList[MemberID]->m_cMapName, 12);

									sX = m_pClientList[MemberID]->m_sX;
									sY = m_pClientList[MemberID]->m_sY;

									SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYNAME, j, NULL, NULL, Name);
									SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYHP, j, HP, NULL, NULL);
									SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYCOORDS, j, sX, sY, MapName);
								}
							}
							break;

					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RefreshParty");
	}
#endif
}

void CMapServer::RequestDismissPartyHandler(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int PartyID, ClientID;
		char PlayerName[12], MapName[12];
		int i, j, NotifyClient;
		int HP = 0, sX = 0, sY = 0, MemberID;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;
		if (m_pClientList[iClientH]->m_iPartyID == NULL) return;

		ZeroMemory(PlayerName, sizeof(PlayerName));

		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

		PartyID = m_pClientList[iClientH]->m_iPartyID;

		if (m_pPartyManager[PartyID] != NULL) {
			if (m_pPartyManager[PartyID]->iTotalMembers < 2) {
				for (int i = 0; i <= m_pPartyManager[PartyID]->iTotalMembers; i++) {
					if (m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH != NULL) {
						ClientID = m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH;

						m_pClientList[ClientID]->m_iPartyID = NULL;
						m_pClientList[ClientID]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
						SendNotifyMsg(NULL, ClientID, CLIENT_NOTIFY_PARTY, 2, 0, NULL, NULL);
					}
				}
				m_pPartyManager[PartyID]->ClearParty();
			}
			else {
				if (m_pPartyManager[PartyID]->bRemoveMember(iClientH)) {
					m_pClientList[iClientH]->m_iPartyID = NULL;
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PARTY, 2, 0, NULL, NULL);

					for (int i = 0; i <= m_pPartyManager[PartyID]->iTotalMembers; i++) {
						if (m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH != NULL) {
							ClientID = m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH;

							SendNotifyMsg(NULL, ClientID, CLIENT_NOTIFY_PARTY, 6, 1, NULL, m_pClientList[iClientH]->m_cCharName);
						}
					}
				}
				if (m_pPartyManager[PartyID] != NULL) {
					// Reload party last remove member
					for (i = 0; i <= m_pPartyManager[PartyID]->iTotalMembers; i++) {
						NotifyClient = m_pPartyManager[PartyID]->m_stPartyInfo[i].iClientH;
						SendNotifyMsg(NULL, NotifyClient, CLIENT_NOTIFY_PARTY, 8, NULL, NULL, NULL);

						for (j = 0; j <= m_pPartyManager[PartyID]->iTotalMembers; j++) {
							if (m_pPartyManager[PartyID]->m_stPartyInfo[j].iClientH != NULL) {
								MemberID = m_pPartyManager[PartyID]->m_stPartyInfo[j].iClientH;
								if (m_pClientList[MemberID] != NULL) {
									ZeroMemory(PlayerName, sizeof(PlayerName));
									memcpy_secure(PlayerName, m_pClientList[MemberID]->m_cCharName, 12);

									HP = (m_pClientList[MemberID]->m_iHP * 100) / iGetMaxHP(MemberID);

									ZeroMemory(MapName, sizeof(MapName));
									memcpy_secure(MapName, m_pClientList[MemberID]->m_cMapName, 12);

									sX = m_pClientList[MemberID]->m_sX;
									sY = m_pClientList[MemberID]->m_sY;

									SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYNAME, j, NULL, NULL, PlayerName);
									SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYHP, j, HP, NULL, NULL);
									SendNotifyMsg(NULL, NotifyClient, CLIENT_RESPONSE_PARTYCOORDS, j, sX, sY, MapName);
								}
							}
						}
					}
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestDismissPartyHandler");
	}
#endif
}

void CMapServer::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
#ifdef DEF_DEBUG
	try {
#endif
		char * cp, cData[120];
		short sAppr2;
		DWORD * dwp;
		WORD * wp;
		int i;

		if (m_pClientList[iClientH] == NULL) return;
		if ((AllVsAll == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL) == 0)) return;
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_PVPEVENT) == 0) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_EVENTDK) == 0) return;
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLEK) == 0) return;
		if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLDKEK) == 0) return;


		switch (iV1) {
			case 0:
				RequestDismissPartyHandler(iClientH);
				break;

			case 1:
				if ((m_pClientList[iClientH]->m_iPartyID != NULL) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
					SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PARTY, 7, 0, NULL, NULL);
					return;
				}

				for (i = 1; i < DEF_MAXCLIENTS; i++) {
					if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
						sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
						if (sAppr2 != 0)
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PARTY, 7, 0, NULL, NULL);
						else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PARTY, 7, 0, NULL, NULL);
						else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
							SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PARTY, 7, 0, NULL, NULL);

							m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
							m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
						}
						else {
							m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
							SendNotifyMsg(NULL, i, CLIENT_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);

							m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
							m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
						}
						return;
					}
				}
				break;
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: JoinPartyHandler");
	}
#endif
}

void CMapServer::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char   seps[] = "= \t\n";
		char   * cp, *token, cBuff[256], cData[120], cName[12];
		class  CStrTok * pStrTok;
		DWORD * dwp;
		WORD  * wp;
		int i;

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
		if ((m_pClientList[iClientH]->m_iAdminUserLevel > 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 5)) return;
		if ((dwMsgSize) <= 0) return;

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy_secure(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy_secure(cName, token);
		}
		else {
			delete pStrTok;
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++) {
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
				if ((m_pClientList[i]->m_iPartyID == NULL) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
					delete pStrTok;
					return;
				}

				JoinPartyHandler(i, 1, m_pClientList[i]->m_cCharName);
				delete pStrTok;
				return;
			}
		}
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
		delete pStrTok;
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RequestJoinPartyHandler");
	}
#endif
}

void CMapServer::ObteinStarterKit(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		int i, iTotalItem, TempTotal, Removidos, iItemID;
		class CItem * pItem;

		if (m_pClientList[iClientH] == NULL) return;
		if (!DEF_ACTIVE_KITSTARTER) return;

		iTotalItem = Removidos = iItemID = 0;

		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

		if (iTotalItem + DEF_TOTALITEMSTARTERKIT > DEF_MAXITEMS) {
			TempTotal = (iTotalItem + DEF_TOTALITEMSTARTERKIT) - DEF_MAXITEMS;
			wsprintf(G_cTxt, "TempTotal: %d", TempTotal);
			PutLogList(G_cTxt);
			for (i = 0; i < DEF_MAXITEMS; i++) {
				if (Removidos < TempTotal) {
					if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 91: // RedPotion
							case 92: // BigRedPotion
							case 93: // BluePotion
							case 94: // BigBluePotion
							case 95: // GreenPotion
							case 96: // BigGreenPotion
							case 780: // RedCandy
							case 781: // BlueCandy
							case 782: // GreenCandy	
								delete m_pClientList[iClientH]->m_pItemList[i];
								m_pClientList[iClientH]->m_pItemList[i] = NULL;
								Removidos++;
								break;

							default: break;
						}
					}
				}
			}
		}

		for (i = 1; i <= DEF_TOTALITEMSTARTERKIT; i++) {
			switch (i) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
						iItemID = DEF_WAR_ITEM_STARTERKIT1;
					else iItemID = DEF_MAGE_ITEM_STARTERKIT1;
					break;

				case 2:
					if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
						iItemID = DEF_WAR_ITEM_STARTERKIT2;
					else iItemID = DEF_MAGE_ITEM_STARTERKIT2;
					break;

				case 3:
					if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
						iItemID = DEF_WAR_ITEM_STARTERKIT3;
					else iItemID = DEF_MAGE_ITEM_STARTERKIT3;
					break;

				case 4:
					if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
						iItemID = DEF_WAR_ITEM_STARTERKIT4;
					else iItemID = DEF_MAGE_ITEM_STARTERKIT4;
					break;

				case 5:
					if (m_pClientList[iClientH]->m_iStr > m_pClientList[iClientH]->m_iInt)
						iItemID = DEF_WAR_ITEM_STARTERKIT5;
					else iItemID = DEF_MAGE_ITEM_STARTERKIT5;
					break;

				default:
					if (DEF_TOTAL_STARTERKIT_ZEMS) iItemID = 650; // ZemstoneofSacrifice
					break;
			}

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				pItem = NULL;
			}
			else bAddItem(iClientH, pItem, NULL);
		}

		if (DEF_TOTAL_CONTRIB_STARTERKIT != 0) {
			m_pClientList[iClientH]->m_iContribution += DEF_TOTAL_CONTRIB_STARTERKIT;
			SendContribution(iClientH);
		}

		if (DEF_TOTAL_CRITS_STARTERKIT != 0) {
			m_pClientList[iClientH]->m_iSuperAttackLeft += DEF_TOTAL_CRITS_STARTERKIT;
			SendCriticals(iClientH);
		}

		if (DEF_TOTAL_MPS_STARTERKIT != 0) {
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft += DEF_TOTAL_MPS_STARTERKIT;
			SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_GIZONITEMUPGRADELEFT, NULL, NULL, NULL, NULL);
		}
		//Agregar Rep a nuevos personajes.
		if (DEF_TOTAL_REP_STARTERKIT != 0) {
			m_pClientList[iClientH]->m_iRating += DEF_TOTAL_REP_STARTERKIT;
			SendNotifyMsg(NULL, iClientH, CLIENT_REPONSE_PLAYERREP, NULL, NULL, NULL, NULL);
		}

		LoadPlayerItems(iClientH);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: ObteinStarterKit");
	}
#endif
}

void CMapServer::RemoveItemUniqueID(int iClientH, short itempos, short ItemUse)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (itempos <= 0 || itempos > DEF_MAXITEMS) return;
		if (m_pClientList[iClientH]->m_pItemList[itempos] == NULL) return;

		if (ItemUse <= 0 || ItemUse > DEF_MAXITEMS) return;
		if (m_pClientList[iClientH]->m_pItemList[ItemUse] == NULL) return;

		bool Habilitado = false;

		switch (m_pClientList[iClientH]->m_pItemList[itempos]->m_sIDnum) {
			// Normal Hero
			case 400: // AresdenHeroCape
			case 401: // ElvineHeroCape
			case 403: // aHeroHelm(M)
			case 404: // aHeroHelm(W)
			case 405: // eHeroHelm(M)
			case 406: // eHeroHelm(W)
			case 407: // aHeroCap(M)
			case 408: // aHeroCap(W)
			case 409: // eHeroCap(M)
			case 410: // eHeroCap(W)
			case 411: // aHeroArmor(M)
			case 412: // aHeroArmor(W)
			case 413: // eHeroArmor(M)
			case 414: // eHeroArmor(W)
			case 415: // aHeroRobe(M)
			case 416: // aHeroRobe(W)
			case 417: // eHeroRobe(M)
			case 418: // eHeroRobe(W)
			case 419: // aHeroHauberk(M)
			case 420: // aHeroHauberk(W)
			case 421: // eHeroHauberk(M)
			case 422: // eHeroHauberk(W)
			case 423: // aHeroLeggings(M)
			case 424: // aHeroLeggings(W)
			case 425: // eHeroLeggings(M)
			case 426: // eHeroLeggings(W)
			case 427: // AresdenHeroCape+1
			case 428: // ElvineHeroCape+1
				Habilitado = true;
				break;
				// Power Hero
			case 4018: // PowerAresHeroCape
			case 4019: // PowerElvHeroCape
			case 4020: // PowerAresHeroCape+1
			case 4021: // PowerElvHeroCape+1
			case 4932: // PoweraHeroHelm(M)
			case 4933: // PoweraHeroHelm(W)
			case 4934: // PowereHeroHelm(M)
			case 4935: // PowereHeroHelm(W)
			case 4936: // PoweraHeroCap(M)
			case 4937: // PoweraHeroCap(W)
			case 4938: // PowereHeroCap(M)
			case 4939: // PowereHeroCap(W)
			case 4940: // PoweraHeroArmor(M)
			case 4941: // PoweraHeroArmor(W)
			case 4942: // PowereHeroArmor(M)
			case 4943: // PowereHeroArmor(W)
			case 4944: // PoweraHeroRobe(M)
			case 4945: // PoweraHeroRobe(W)
			case 4946: // PowereHeroRobe(M)
			case 4947: // PowereHeroRobe(W)
			case 4948: // PoweraHeroHauberk(M)
			case 4949: // PoweraHeroHauberk(W)
			case 4950: // PowereHeroHauberk(M)
			case 4951: // PowereHeroHauberk(W)
			case 4952: // PoweraHeroLeggs(M)
			case 4953: // PoweraHeroLeggs(W)
			case 4954: // PowereHeroLeggs(M)
			case 4955: // PowereHeroLeggs(W)
			case 613: // SwordofMedusa
			case 641: // KnecklaceOfMedusa
				Habilitado = true;
				break;
			// Others
			default: break;
		}

		if (Habilitado) {
			ItemDepleteHandler(iClientH, ItemUse, FALSE, FALSE);

			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			ShowClientMsg(iClientH, "El Item ahora te pertenece!");
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveItemUniqueID");
	}
#endif
}


//Nuevo Change Master ID
void CMapServer::RemoveItemMasterID(int iClientH, short itempos, short ItemUse)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (itempos <= 0 || itempos > DEF_MAXITEMS) return;
		if (m_pClientList[iClientH]->m_pItemList[itempos] == NULL) return;

		if (ItemUse <= 0 || ItemUse > DEF_MAXITEMS) return;
		if (m_pClientList[iClientH]->m_pItemList[ItemUse] == NULL) return;

		bool Habilitado = false;

		switch (m_pClientList[iClientH]->m_pItemList[itempos]->m_sIDnum) {
		//Master Ares Hero																											
		case 3200: //	MAresHeroCape
		case 3201: //	MAresHeroHelm(M)
		case 3202: //	MAresHeroHelm(W)
		case 3203: //	MAresHeroCap(M)
		case 3204: //	MAresHeroCap(W)
		case 3205: //	MAresHeroArmor(M)
		case 3206: //	MAresHeroArmor(W)
		case 3207: //	MAresHeroRobe(M)
		case 3208: //	MAresHeroRobe(W)
		case 3209: //	MAresHeroHauberk(M)
		case 3210: //	MAresHeroHauberk(W)
		case 3211: //	MAresHeroLeggs(M)
		case 3212: //	MAresHeroLeggs(W)
		case 3213: //	MAresHeroCape + 1
				   //Master Elvin Hero																											
		case 3214: //	MElvHeroCape
		case 3215: //	MElvHeroHelm(M)
		case 3216: //	MElvHeroHelm(W)
		case 3217: //	MElvHeroCap(M)
		case 3218: //	MElvHeroCap(W)
		case 3219: //	MElvHeroArmor(M)
		case 3220: //	MElvHeroArmor(W)
		case 3221: //	MElvHeroRobe(M)
		case 3222: //	MElvHeroRobe(W)
		case 3223: //	MElvHeroHauberk(M)
		case 3224: //	MElvHeroHauberk(W)
		case 3225: //	MElvHeroLeggs(M)
		case 3226: //	MElvHeroLeggs(W)
		case 3227: //	MElvHeroCape + 1
			Habilitado = true;
			break;
			// Others
		default: break;
		}

		if (Habilitado) {
			ItemDepleteHandler(iClientH, ItemUse, FALSE, FALSE);

			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			ShowClientMsg(iClientH, "El Item ahora te pertenece!");
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveItemMasterID");
	}
#endif
}

void CMapServer::RemoveTotalID(int iClientH, short itempos, short ItemUse)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (m_pClientList[iClientH] == NULL) return;

		if (itempos <= 0 || itempos > DEF_MAXITEMS) return;
		if (m_pClientList[iClientH]->m_pItemList[itempos] == NULL) return;

		if (ItemUse <= 0 || ItemUse > DEF_MAXITEMS) return;
		if (m_pClientList[iClientH]->m_pItemList[ItemUse] == NULL) return;

		bool Habilitado = false;

		switch (m_pClientList[iClientH]->m_pItemList[itempos]->m_sIDnum) {
			// Normal Hero
		case 400: // AresdenHeroCape
		case 401: // ElvineHeroCape
		case 403: // aHeroHelm(M)
		case 404: // aHeroHelm(W)
		case 405: // eHeroHelm(M)
		case 406: // eHeroHelm(W)
		case 407: // aHeroCap(M)
		case 408: // aHeroCap(W)
		case 409: // eHeroCap(M)
		case 410: // eHeroCap(W)
		case 411: // aHeroArmor(M)
		case 412: // aHeroArmor(W)
		case 413: // eHeroArmor(M)
		case 414: // eHeroArmor(W)
		case 415: // aHeroRobe(M)
		case 416: // aHeroRobe(W)
		case 417: // eHeroRobe(M)
		case 418: // eHeroRobe(W)
		case 419: // aHeroHauberk(M)
		case 420: // aHeroHauberk(W)
		case 421: // eHeroHauberk(M)
		case 422: // eHeroHauberk(W)
		case 423: // aHeroLeggings(M)
		case 424: // aHeroLeggings(W)
		case 425: // eHeroLeggings(M)
		case 426: // eHeroLeggings(W)
		case 427: // AresdenHeroCape+1
		case 428: // ElvineHeroCape+1
			Habilitado = true;
			break;
			// Power Hero
		case 4018: // PowerAresHeroCape
		case 4019: // PowerElvHeroCape
		case 4020: // PowerAresHeroCape+1
		case 4021: // PowerElvHeroCape+1
		case 4932: // PoweraHeroHelm(M)
		case 4933: // PoweraHeroHelm(W)
		case 4934: // PowereHeroHelm(M)
		case 4935: // PowereHeroHelm(W)
		case 4936: // PoweraHeroCap(M)
		case 4937: // PoweraHeroCap(W)
		case 4938: // PowereHeroCap(M)
		case 4939: // PowereHeroCap(W)
		case 4940: // PoweraHeroArmor(M)
		case 4941: // PoweraHeroArmor(W)
		case 4942: // PowereHeroArmor(M)
		case 4943: // PowereHeroArmor(W)
		case 4944: // PoweraHeroRobe(M)
		case 4945: // PoweraHeroRobe(W)
		case 4946: // PowereHeroRobe(M)
		case 4947: // PowereHeroRobe(W)
		case 4948: // PoweraHeroHauberk(M)
		case 4949: // PoweraHeroHauberk(W)
		case 4950: // PowereHeroHauberk(M)
		case 4951: // PowereHeroHauberk(W)
		case 4952: // PoweraHeroLeggs(M)
		case 4953: // PoweraHeroLeggs(W)
		case 4954: // PowereHeroLeggs(M)
		case 4955: // PowereHeroLeggs(W)
		case 613: // SwordofMedusa
		case 641: // KnecklaceOfMedusa
			Habilitado = true;
			break;
			//Master Ares Hero																											
		case 3200: //	MAresHeroCape
		case 3201: //	MAresHeroHelm(M)
		case 3202: //	MAresHeroHelm(W)
		case 3203: //	MAresHeroCap(M)
		case 3204: //	MAresHeroCap(W)
		case 3205: //	MAresHeroArmor(M)
		case 3206: //	MAresHeroArmor(W)
		case 3207: //	MAresHeroRobe(M)
		case 3208: //	MAresHeroRobe(W)
		case 3209: //	MAresHeroHauberk(M)
		case 3210: //	MAresHeroHauberk(W)
		case 3211: //	MAresHeroLeggs(M)
		case 3212: //	MAresHeroLeggs(W)
		case 3213: //	MAresHeroCape + 1
			//Master Elvin Hero																											
		case 3214: //	MElvHeroCape
		case 3215: //	MElvHeroHelm(M)
		case 3216: //	MElvHeroHelm(W)
		case 3217: //	MElvHeroCap(M)
		case 3218: //	MElvHeroCap(W)
		case 3219: //	MElvHeroArmor(M)
		case 3220: //	MElvHeroArmor(W)
		case 3221: //	MElvHeroRobe(M)
		case 3222: //	MElvHeroRobe(W)
		case 3223: //	MElvHeroHauberk(M)
		case 3224: //	MElvHeroHauberk(W)
		case 3225: //	MElvHeroLeggs(M)
		case 3226: //	MElvHeroLeggs(W)
		case 3227: //	MElvHeroCape + 1
			Habilitado = true;
			break;
			// Others
		default: break;
		}

		if (Habilitado) {
			ItemDepleteHandler(iClientH, ItemUse, FALSE, FALSE);

			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue1 = 1;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue2 = 1;
			m_pClientList[iClientH]->m_pItemList[itempos]->m_sTouchEffectValue3 = 1;
			ShowClientMsg(iClientH, "El Item ahora no posee ID, puedes tradearlo!");
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: RemoveTotalID");
	}
#endif
}



// send floor item data
void CMapServer::r_flooritem(int iClientH, char * dat)
{
	if (!m_pClientList[iClientH]) return;
	short x, y;

	Pop(dat, x);
	Pop(dat, y);

	auto m = m_pMapList[m_pClientList[iClientH]->m_cMapIndex];
	if (!m)	return;

	if ((x < 0 || x >= m->m_sSizeX || y < 0 || y >= m->m_sSizeY)) return;

	auto pTile = (class CTile *)(m->m_pTile + x + y*m->m_sSizeY);
	if (!pTile)	return;

	auto it = pTile->m_pItem[0];
	if (!it)
		return;

	char data[112];
	auto * cp = dat;

	Push(cp, (u32)NOT_ITEMDATA);
	Push(cp, (u16)0);

	memcpy(cp, it->m_cName, 20);
	cp += 20;

	auto dwp = (DWORD *)cp;
	*dwp = it->m_dwCount;
	cp += 4;

	*cp = it->m_cItemType;
	cp++;

	*cp = it->m_cEquipPos;
	cp++;

	auto sp = (short *)cp;
	*sp = it->m_sLevelLimit;
	cp += 2;

	*cp = it->m_cGenderLimit;
	cp++;

	auto wp = (WORD *)cp;
	*wp = it->m_wCurLifeSpan;
	cp += 2;

	wp = (WORD *)cp;
	*wp = it->m_wWeight;
	cp += 2;

	sp = (short *)cp;
	*sp = it->m_sSprite;
	cp += 2;

	sp = (short *)cp;
	*sp = it->m_sSpriteFrame;
	cp += 2;

	*cp = it->m_cItemColor; // v1.4
	cp++;

	sp = (short *)cp;
	*sp = it->m_sItemSpecEffectValue2;
	cp += 2;

	dwp = (DWORD *)cp;
	*dwp = it->m_dwAttribute;
	cp += 4;

	*cp = (char)it->m_sItemSpecEffectValue3;
	cp++;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(dat, cp - dat);
}


void CMapServer::ApplyResolution(int iClientH)
{
	auto p = m_pClientList[iClientH];
	if (!p) return;

	if (m_pClientList[iClientH]->sResolution == C1024x768)
	{
		m_pClientList[iClientH]->res_sX = 16;
		m_pClientList[iClientH]->res_sY = 11;
		m_pClientList[iClientH]->res_tilX = 33;
		m_pClientList[iClientH]->res_tilY = 25;

	}
	else if (m_pClientList[iClientH]->sResolution == C800x600)
	{
		m_pClientList[iClientH]->res_sX = 12;
		m_pClientList[iClientH]->res_sY = 9;
		m_pClientList[iClientH]->res_tilX = 26;
		m_pClientList[iClientH]->res_tilY = 21;
	}
	else if (m_pClientList[iClientH]->sResolution == C640x480)
	{
		m_pClientList[iClientH]->res_sX = 10;
		m_pClientList[iClientH]->res_sY = 7;
		m_pClientList[iClientH]->res_tilX = 21;
		m_pClientList[iClientH]->res_tilY = 16;
	}
}

void CMapServer::send_objects_data()
{
	vObjects.clear();

	for (int i = 1; i < DEF_MAXCLIENTS; i++)
	{
		auto pi = m_pClientList[i];
		if (!pi) continue;
		if (!pi->m_bIsInitComplete) continue;

		short tmpside = 0;
		if (string(pi->m_cLocation) == "aresden") tmpside = 1;
		else if (string(pi->m_cLocation) == "elvine") tmpside = 2;

		st_objects u;

		u.client = pi->client;
		u.m_sSide = tmpside;
		u.iLevel = pi->m_iLevel;
		u.iRebirthLevel = pi->m_iRebirthLevel;
	
		vObjects.push_back(u);
	}

	if (vObjects.size() > 0)
	{
		for (int i = 1; i < DEF_MAXCLIENTS; i++)
		{
			auto pi = m_pClientList[i];
			if (!pi) continue;

			SendObjectsData(i);
		}
	}
}

void CMapServer::SendObjectsData(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	if (vObjects.size() < 1) return;

	char* cData = new char[5000];
	auto cp = cData;

	Push(cp, (u32)NOT_OBJECTS_DATA);
	Push(cp, (u16)0);
	Push(cp, (int)vObjects.size());

	for (int i = 0; i < vObjects.size(); i++)
	{
		Push(cp, vObjects[i].client);
		Push(cp, vObjects[i].m_sSide);
		Push(cp, vObjects[i].iLevel);
		Push(cp, vObjects[i].iRebirthLevel);
	}

	m_pClientList[client]->m_pXSock->iSendMsg(cData, cp - cData);

	delete(cData);
}


void  CMapServer::NotifyRankData(int client)
{

	auto p = m_pClientList[client];
	if (!p) return;

	char data[500];
	char* cp = data;

	Push(cp, (u32)NOT_RANKSTATS);
	Push(cp, (u16)0);

	Push(cp, p->m_sRankAddStr);
	Push(cp, p->m_sRankAddDex);
	Push(cp, p->m_sRankAddInt);
	Push(cp, p->m_sRankAddMag);
	Push(cp, p->m_sRankLevel);
	Push(cp, p->m_iRankPoints);
	Push(cp, p->m_iRankExp);
	
	m_pClientList[client]->m_pXSock->iSendMsg(data, sizeof(data));
}


// send floor item data
void CMapServer::setrankstats(int iClientH, char * dat)
{
	auto p = m_pClientList[iClientH];
	if (!p) return;

	short m_sTmpRankAddStr;
	short m_sTmpRankAddDex;
	short m_sTmpRankAddInt;
	short m_sTmpRankAddMag;

	Pop(dat, m_sTmpRankAddStr);
	Pop(dat, m_sTmpRankAddDex);
	Pop(dat, m_sTmpRankAddInt);
	Pop(dat, m_sTmpRankAddMag);

	if (m_pClientList[iClientH]->m_iRankPoints <= 0) return;

	int tmpstats = m_sTmpRankAddStr + m_sTmpRankAddDex + m_sTmpRankAddInt + m_sTmpRankAddMag;
	int curstats = p->m_sRankAddStr + p->m_sRankAddDex + p->m_sRankAddInt + p->m_sRankAddMag;

	auto resul = tmpstats - curstats;
	
	if (resul == 0) return;

	if (resul > p->m_iRankPoints) return;

	int max = p->m_sRankLevel +1;
	
	if (tmpstats > max || tmpstats <= 0) return;

	if (m_sTmpRankAddStr < 0 || m_sTmpRankAddStr > max || 
		m_sTmpRankAddDex < 0 || m_sTmpRankAddDex > max ||
		m_sTmpRankAddInt < 0 || m_sTmpRankAddInt > max ||
		m_sTmpRankAddMag < 0 || m_sTmpRankAddMag > max) return;

	p->m_iRankPoints -= resul;

	p->m_sRankAddStr = m_sTmpRankAddStr;
	p->m_sRankAddDex = m_sTmpRankAddDex;
	p->m_sRankAddInt = m_sTmpRankAddInt;
	p->m_sRankAddMag = m_sTmpRankAddMag;

	NotifyRankData(iClientH);
	AutoSkill(iClientH);

	ShowClientMsg(iClientH, "Rank stats has been changed.");
}

void CMapServer::CharacterRankingReset(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;
	if (p->m_sRankLevel == 0) return;

	int cost = 50000;

	if (p->m_iContribution < cost)
	{
		ShowClientMsg(client, "Insufficient contribution!");
		return;
	}

	p->m_iContribution -= cost;
	SendContribution(client);

	UnEquipItems(client);

	p->m_sRankAddStr = 0;
	p->m_sRankAddDex = 0;
	p->m_sRankAddInt = 0;
	p->m_sRankAddMag = 0;

	p->m_iRankPoints = p->m_sRankLevel;
	NotifyRankData(client);

	AutoSkill(client);

	bCheckMagicInt(client);

	if (p->m_iHP > iGetMaxHP(client)) {
		int iRestHP = p->m_iHP - iGetMaxHP(client);
		p->m_iHP -= iRestHP;
		SendNotifyMsg(NULL, client, CLIENT_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}

	SendNotifyMsg(NULL, client, CLIENT_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);

	ShowClientMsg(client, "The rank was reset successfully!");
}

void CMapServer::UnEquipItems(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;
	
	for (int i = 0; i < DEF_MAXITEMS; i++) {
		auto it = p->m_pItemList[i];
		if (!it) continue;
		if (!p->m_bIsItemEquipped[i]) continue;
		SendNotifyMsg(NULL, client, CLIENT_NOTIFY_ITEMRELEASED, it->m_cEquipPos, i, NULL, NULL);
		ReleaseItemHandler(client, i, TRUE);
	}
}

void CMapServer::get_object(int client, char * data)
{
	auto p = m_pClientList[client];
	if (!p) return;

	WORD object;
	Pop(data, object);

	ReqMobHP(client, object);
}

void CMapServer::ReqMobHP(int client, int npc)
{
	auto p = m_pClientList[client];
	if (!p) return;
	auto mob = npc - 10000;
	auto moblist = m_pNpcList[mob];
	if (!moblist) return;

	if (mob <= 0 || mob >= DEF_MAXNPCS) return;

	if (moblist->m_iHP > moblist->m_iMaxHP) moblist->m_iMaxHP = moblist->m_iHP;

	notifyNpcHealth(client, mob);	
}

void CMapServer::notifyNpcHealth(int client, int npc)
{
	auto p = m_pClientList[client];
	if (!p) return;

	auto mob = m_pNpcList[npc];
	if (!mob) return;

	char data[500];
	char* cp = data;

	Push(cp, (u32)NOT_NPC_HEALTH);
	Push(cp, (u16)0);

	Push(cp, mob->m_iHP);
	Push(cp, mob->m_iMaxHP);

	m_pClientList[client]->m_pXSock->iSendMsg(data, sizeof(data));
}

void CMapServer::shinning_clear(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	if (m_bShinning)
	{

		char data[20];
		char* cp = data;

		Push(cp, (u32)NOT_SHINNING_CLEAR);
		Push(cp, (u16)0);

		Push(cp, client);

		for (int i = 0; i < DEF_MAXCLIENTS; i++)
		{
			auto pi = m_pClientList[i];
			if (!pi) continue;
			if (pi == p) continue;
			if (pi->m_cMapIndex == -1 || pi->m_cMapIndex != p->m_cMapIndex)	continue;

			pi->m_pXSock->iSendMsg(data, sizeof(data));
		}		
	}
}

void CMapServer::shinning_update(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	if (m_bShinning)
	{
		char data[20];
		char* cp = data;

		Push(cp, (u32)NOT_SHINNING_UPDATE);
		Push(cp, (u16)0);

		Push(cp, client);
		Push(cp, p->m_sX);
		Push(cp, p->m_sY);

		for (int i = 0; i < DEF_MAXCLIENTS; i++)
		{
			auto pi = m_pClientList[i];
			if (!pi) continue;
			if (pi == p) continue;
			if (pi->m_cMapIndex == -1 || pi->m_cMapIndex != p->m_cMapIndex)	continue;

			pi->m_pXSock->iSendMsg(data, sizeof(data));
		}		
	}
}

void CMapServer::showShinningStatus()
{

	char cstatus[100];
	short s_status = 0;

	if (m_bShinning)
	{
		strcpy(cstatus, "Evento shinning activado");
		s_status = 1;
	}
	else
	{
		strcpy(cstatus, "Evento shinning desactivado");
	}

	char data[108];
	char* cp = data;

	Push(cp, (u32)NOT_SHINNINGSTATUS);
	Push(cp, (u16)0);

	Push(cp, cstatus, 100);
	Push(cp, s_status);

	for (int i = 0; i < DEF_MAXCLIENTS; i++)
	{
		auto pi = m_pClientList[i];
		if (!pi) continue;
		if (!pi->m_bIsInitComplete) continue;

		pi->m_pXSock->iSendMsg(data, sizeof(data));
	}
}

void CMapServer::notifyShinningStatus(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	short s_status = 0;
	if (m_bShinning) s_status = 1;

	char data[8];
	char* cp = data;

	Push(cp, (u32)NOT_SHINNINGSTATUS_ONLYCLIENT);
	Push(cp, (u16)0);

	Push(cp, s_status);

	p->m_pXSock->iSendMsg(data, sizeof(data));
}

void CMapServer::DkMapUnEquipItems(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	for (int i = 0; i < DEF_MAXITEMS; i++) {
		auto it = p->m_pItemList[i];

		if (!it) continue;
		if (!p->m_bIsItemEquipped[i]) continue;

		switch (p->m_pItemList[i]->m_sIDnum)
			{
				case 702: //hat w 
				case 703: //Hat M
				case 706: // DarkKnightHauberk
				case 707: // DarkKnightFullHelm 
				case 708: // DarkKnightLeggings  
				case 710: // DarkKnightPlateMail 
				case 711: // DarkMageHauberk 
				case 712: // DarkMageChainMail
				case 713: // DarkMageLeggings  
				case 715: //DarkMageRobe
				case 716: // DarkMageLedderArmor
				case 719: // DarkMageScaleMail
				case 724: // DarkKnightHauberkW
				case 725: // DarkKnightFullHelmW 
				case 726: // DarkKnightLeggingsW 
				case 728: // DarkKnightPlateMailW 
				case 729: // DarkMageHauberkW 
				case 730: // DarkMageChainMailW 
				case 731: // DarkMageLeggingsW 
				case 733: //DarkMageRobeW
				case 709: // DarkKnightFlameberge
				case 718: // DarkKnightGreatSword
				case 727: // DarkKnightFlamebergW
				case 736: // SangAhGiantSword
				case 737: // DarkKnightGiantSword
				case 745: // BlackKnightTemple
				case 2011: // DarkKnightHammer			
				case 2012: // DarkKnightBHammer			
				case 2013: // DarkKnightBBHammer
				case 714: // DarkMageMagicStaff 
				case 732: // DarkMageMagicStaffW 
				case 738: // DarkMageMagicWand
				case 746: // BlackMageTemple
				case 717: // DarkKnightRapier
				continue;
			}
		SendNotifyMsg(NULL, client, CLIENT_NOTIFY_ITEMRELEASED, it->m_cEquipPos, i, NULL, NULL);
		ReleaseItemHandler(client, i, TRUE);
	}
}

//Dk Event LaloRamos
void CMapServer::StartDkEvent(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent || DKEvent) return;

		DKEvent = ActiveEvent = true;
	//	DKEvent = true;
		
		auto player = m_pClientList[iClientH];
		if (!player) return;

		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DKEVENT, 10, NULL, NULL, NULL, NULL);

		if ((memcmp(m_pMapList[player->m_cMapIndex]->m_cName, "EventDk", 7) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0))
		{
			DkMapUnEquipItems(iClientH);
		}

		PutLogList("Dk Event OPEN!");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartDKEvent");
	}
#endif
}

//WorldWar LaloRamos
void CMapServer::EndDkEvent(int iClientH)
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!DKEvent) return;

		DKEvent = ActiveEvent = false;

		if (m_pClientList[iClientH] == NULL) return;
		SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_DKEVENTOFF, 10, NULL, NULL, NULL, NULL);

		PutLogList("DKEvent Closed");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndDkEvent");
	}
#endif
}


//All EK LaloRamos
void CMapServer::StartAllEks()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent || AllEks) return;

		AllEks = ActiveEvent = true;
		DWORD dwTime = timeGetTime();
		AllEksTime = dwTime - 500;

		for (short iClientH = 1; iClientH < DEF_MAXCLIENTS; iClientH++) {
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsInitComplete == TRUE)) {
				if (m_pClientList[iClientH] == NULL) return;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ALLEKSON, 10, NULL, NULL, NULL, NULL);
			}
		}

		PutLogList("All Eks OPEN!");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartAllEks");
	}
#endif
}

//All Eks LaloRamos
void CMapServer::EndAllEks()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!AllEks) return;

		AllEks = ActiveEvent = false;

		for (short iClientH = 1; iClientH < DEF_MAXCLIENTS; iClientH++) {
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsInitComplete == TRUE)) {
				if (m_pClientList[iClientH] == NULL) return;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ALLEKSOFF, 10, NULL, NULL, NULL, NULL);
				SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 1, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 2, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 4, NULL, NULL);
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
			}
		}

		PutLogList("All Eks Closed");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndAllEks");
	}
#endif
}


//All EK LaloRamos
void CMapServer::StartAllDkEks()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (ActiveEvent || AllDkEks) return;

		AllDkEks = ActiveEvent = true;
		DWORD dwTime = timeGetTime();
		AllDkEksTime = dwTime - 500;

		for (short iClientH = 1; iClientH < DEF_MAXCLIENTS; iClientH++) {
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsInitComplete == TRUE)) {
				if (m_pClientList[iClientH] == NULL) return;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ALLDKEKSON, 10, NULL, NULL, NULL, NULL);
			}
		}

		PutLogList("All Dk Eks OPEN!");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: StartAllDkEks");
	}
#endif
}

//All Eks LaloRamos
void CMapServer::EndAllDkEks()
{
#ifdef DEF_DEBUG
	try {
#endif
		if (!AllDkEks) return;

		AllDkEks = ActiveEvent = false;

		for (short iClientH = 1; iClientH < DEF_MAXCLIENTS; iClientH++) {
			if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsInitComplete == TRUE)) {
				if (m_pClientList[iClientH] == NULL) return;
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_ALLDKEKSOFF, 10, NULL, NULL, NULL, NULL);
				SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 1, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 2, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 3, NULL, NULL);
				SendNotifyMsg(NULL, iClientH, CLIENT_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE, 4, NULL, NULL);
				m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_CONFUSE] = NULL;
			}
		}

		PutLogList("All Dk Eks Closed");

#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: EndAllDkEks");
	}
#endif
}

//HeatoN 2024
void CMapServer::handleEnchantingExtract(int client, char* data)
{
	int count = 0;
	auto p = m_pClientList[client];
	if (!p) return;

	Pop(data, count);
	if (count == 0) return;

	// Variables acumulativas para shards y fragments
	std::map<short, int> shardTotals;
	std::map<short, int> fragmentTotals;
	bool enter = false;
	for (int i = 0; i < count; i++)
	{
		bool rem = false;
		int itemIndex = -1;
		Pop(data, itemIndex);

		auto sourceItem = p->m_pItemList[itemIndex];
		if (!sourceItem) continue;

		// Extraer estadísticas del item
		short type1 = (sourceItem->m_dwAttribute & 0x00F00000) >> 20;
		short val1 = (sourceItem->m_dwAttribute & 0x000F0000) >> 16;
		short type2 = (sourceItem->m_dwAttribute & 0x0000F000) >> 12;
		short val2 = (sourceItem->m_dwAttribute & 0x00000F00) >> 8;

		// Validar tipos permitidos
		if (!PermitedType1(type1) && !PermitedType2(type2))
		{
			continue;
		}

		if (val1 == 0 && val2 == 0)
		{
			continue;
		}
		
		if (!enter)
		{
			enter = true;
			SendCommand(client, "/closeenchantingpanel");
		}
		
		// Acumular shards y fragments
		if (val1 != 0 && PermitedType1(type1)) {
			shardTotals[type1] += val1 * 10;
			rem = true;
		}

		if (val2 != 0 && PermitedType2(type2)) {
			fragmentTotals[type2] += val2 * 10;
			rem = true;
		}

		if (rem) ItemDepleteHandler(client, itemIndex, FALSE);
	}
		
	SendCommand(client, "/closeenchantingpanel");	

	// Enviar mensajes acumulados para shards
	for (const auto& shard : shardTotals) {
		AddShard(client, shard.first, shard.second);
	}

	// Enviar mensajes acumulados para fragments
	for (const auto& fragment : fragmentTotals) {
		AddFragment(client, fragment.first, fragment.second);
	}
}


void CMapServer::AddShard(int client, short type, int points)
{
	auto p = m_pClientList[client];
	if (!p) return;

	switch (type)
	{
	case 6:
		p->shard_light += points;
		SendCommand(client, "/shards", p->shard_light, p->shard_strong);
		wsprintf(G_cTxt, "You get %d light shards", points);
		ShowClientMsg(client, G_cTxt);
		break; //Light

	case 8:
		p->shard_strong += points;
		SendCommand(client, "/shards", p->shard_light, p->shard_strong);
		wsprintf(G_cTxt, "You get %d strong shards", points);
		ShowClientMsg(client, G_cTxt);
		break; //Strong

	default: SendAlertMsg(client, "Not permited stat."); break;
	}

}

void CMapServer::AddFragment(int client, short type, int points)
{
	auto p = m_pClientList[client];
	if (!p) return;

	switch (type)
	{
	case 2:
		p->fragment_hp += points;
		SendCommand(client, "/fragment_hp", p->fragment_hp);
		wsprintf(G_cTxt, "You get %d hit prob fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //hitting probability

	case 3:
		p->fragment_dr += points;
		SendCommand(client, "/fragment_dr", p->fragment_dr);
		wsprintf(G_cTxt, "You get %d dr fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //defense ratio

	case 4:
		p->fragment_hprec += points;
		SendCommand(client, "/fragment_hprec", p->fragment_hprec);
		wsprintf(G_cTxt, "You get %d hp rec fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //HP Recovery

	case 5:
		p->fragment_sprec += points;
		SendCommand(client, "/fragment_sprec", p->fragment_sprec);
		wsprintf(G_cTxt, "You get %d sp rec fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //SP Recovery

	case 6:
		p->fragment_mprec += points;
		SendCommand(client, "/fragment_mprec", p->fragment_mprec);
		wsprintf(G_cTxt, "You get %d mp rec fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //MP Recovery

	case 7:
		p->fragment_mr += points;
		SendCommand(client, "/fragment_mr", p->fragment_mr);
		wsprintf(G_cTxt, "You get %d mr fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //Magic Resistance

	case 8:
		p->fragment_pa += points;
		SendCommand(client, "/fragment_pa", p->fragment_pa);
		wsprintf(G_cTxt, "You get %d pa fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //Physical Absorption

	case 9:
		p->fragment_ma += points;
		SendCommand(client, "/fragment_ma", p->fragment_ma);
		wsprintf(G_cTxt, "You get %d ma fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //Magic Absorption


	case 11:
		p->fragment_exp += points;
		SendCommand(client, "/fragment_exp", p->fragment_exp);
		wsprintf(G_cTxt, "You get %d exp fragments", points);
		ShowClientMsg(client, G_cTxt);
		break; //EXP

	default: SendAlertMsg(client, "Not permited type."); break;
	}
}

bool CMapServer::PermitedType1(short type)
{
	switch (type)
	{
	case 6: //Light
	case 8: //Strong
		return true;
		break;

	default: return false; break;
	}

	return false;
}

bool CMapServer::PermitedType2(short type)
{
	switch (type)
	{
	case 2:	//hitting probability
	case 3:	//defense ratio
	case 4: //HP Recovery
	case 5: //SP Recovery
	case 6: //MP Recovery
	case 7: //Magic Resistance
	case 8: //Physical Absorption
	case 9: //Magic Absorption
	case 11: //Exp
		return true;
		break;
	default: return false; break;
	}

	return false;
}

void CMapServer::handleEnchantingUpgrade(int client, char* data)
{
	auto p = m_pClientList[client];
	if (!p) return;

	short m_sDestItem, m_sSelType, m_sType;

	Pop(data, m_sDestItem);
	Pop(data, m_sSelType);
	Pop(data, m_sType);

	auto& destItem = p->m_pItemList[m_sDestItem];
	if (!destItem) return;

	// Extraer valores actuales
	short type1 = (destItem->m_dwAttribute & 0x00F00000) >> 20;
	short val1 = (destItem->m_dwAttribute & 0x000F0000) >> 16;
	short type2 = (destItem->m_dwAttribute & 0x0000F000) >> 12;
	short val2 = (destItem->m_dwAttribute & 0x00000F00) >> 8;

	short upgradeLevel = (destItem->m_dwAttribute & 0xF0000000) >> 28;

	if (upgradeLevel != 0 && m_sType == 8 && m_sSelType == 1)
	{
		ShowClientMsg(client, "No puedes realizar esta operacion.");
		return;
	}

	if (m_sSelType == 1 && val1 >= DEF_LIMIT_ENCHANTING_UPGRADE) return; //max val type 1 (strong etc)
	if (m_sSelType == 2 && val2 >= DEF_LIMIT_ENCHANTING_UPGRADE) return; //mas val type 2 (pa ma hp etc)

	int costPoints = 0;
	switch (m_sSelType)
	{
	case 1:
		if (type1 == m_sType || type1 == 0)
		{
			costPoints = (val1 + 1) * 150;
			if (costPoints != 0)
			{
				switch (m_sType)
				{
				case 6:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->shard_light >= costPoints) {
						p->shard_light -= costPoints;
						SendCommand(client, "/shards", p->shard_light, p->shard_strong);
					}
					else {
						SendAlertMsg(client, "Not enough Light Shards to perform this action.");
						return;
					}
					break;

				case 8:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->shard_strong >= costPoints) {
						p->shard_strong -= costPoints;
						SendCommand(client, "/shards", p->shard_light, p->shard_strong);
					}
					else {
						SendAlertMsg(client, "Not enough Strong Shards to perform this action.");
						return;
					}
					break;

				default: return; break;
				}

				val1++;
				type1 = m_sType; 

				destItem->m_dwAttribute &= ~0x00F00000; 
				destItem->m_dwAttribute |= (type1 << 20); 
				destItem->m_dwAttribute &= ~0x000F0000; 
				destItem->m_dwAttribute |= (val1 << 16); 

				if (m_sType == 6 && m_sSelType == 1 || m_sType == 8 && m_sSelType == 1)
				{
					revertitemWeight(m_pClientList[client]->m_pItemList[m_sDestItem], m_pClientList[client]->m_pItemList[m_sDestItem]->m_cName);
					_AdjustRareItemValue(m_pClientList[client]->m_pItemList[m_sDestItem]);
				}
				else if (m_sType == 0 && m_sSelType == 1)
				{
					_AdjustRareItemValue(m_pClientList[client]->m_pItemList[m_sDestItem]);
				}

				SendNotifyMsg(NULL, client, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, m_sDestItem, destItem->m_dwAttribute, NULL, NULL);
				NotifyNewWeight(client, m_sDestItem, destItem->m_wWeight);
				destItem->m_wCurLifeSpan = destItem->m_wMaxLifeSpan;
				NotifyNewEndurance(client, m_sDestItem, destItem->m_wCurLifeSpan, destItem->m_wMaxLifeSpan);
				/*if (m_sType == 6 && m_sSelType == 1 || m_sType == 0 && m_sSelType == 1) 
					
				else if (m_sType == 8 && m_sSelType == 1 || m_sType == 0 && m_sSelType == 1)
				{
				
				}*/
			}
		}
		break;
	case 2:
		if (type2 == m_sType || type2 == 0)
		{
			costPoints = (val2 + 1) * 150;
			if (costPoints != 0)
			{
				switch (m_sType)
				{
				case 2:
					if (!destItem->IsWeapon()) return;
					if (p->fragment_hp >= costPoints) {
						p->fragment_hp -= costPoints;
						SendCommand(client, "/fragment_hp", p->fragment_hp);
					}
					else {
						SendAlertMsg(client, "Not enough HP Fragments to perform this action.");
						return;
					}
					break;

				case 3:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_dr >= costPoints) {
						p->fragment_dr -= costPoints;
						SendCommand(client, "/fragment_dr", p->fragment_dr);
					}
					else {
						SendAlertMsg(client, "Not enough DR Fragments to perform this action.");
						return;
					}
					break;
				case 4:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_hprec >= costPoints) {
						p->fragment_hprec -= costPoints;
						SendCommand(client, "/fragment_hprec", p->fragment_hprec);
					}
					else {
						SendAlertMsg(client, "Not enough HP Rec Fragments to perform this action.");
						return;
					}
					break;
				case 5:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_sprec >= costPoints) {
						p->fragment_sprec -= costPoints;
						SendCommand(client, "/fragment_sprec", p->fragment_sprec);
					}
					else {
						SendAlertMsg(client, "Not enough SP Rec Fragments to perform this action.");
						return;
					}
					break;
				case 6:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_mprec >= costPoints) {
						p->fragment_mprec -= costPoints;
						SendCommand(client, "/fragment_mprec", p->fragment_mprec);
					}
					else {
						SendAlertMsg(client, "Not enough MP Rec Fragments to perform this action.");
						return;
					}
					break;
				case 7:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_mr >= costPoints) {
						p->fragment_mr -= costPoints;
						SendCommand(client, "/fragment_mr", p->fragment_mr);
					}
					else {
						SendAlertMsg(client, "Not enough MR Fragments to perform this action.");
						return;
					}
					break;
				case 8:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_pa >= costPoints) {
						p->fragment_pa -= costPoints;
						SendCommand(client, "/fragment_pa", p->fragment_pa);
					}
					else {
						SendAlertMsg(client, "Not enough PA Fragments to perform this action.");
						return;
					}
					break;
				case 9:
					if (!destItem->IsArmor() && !destItem->IsShield()) return;
					if (p->fragment_ma >= costPoints) {
						p->fragment_ma -= costPoints;
						SendCommand(client, "/fragment_ma", p->fragment_ma);
					}
					else {
						SendAlertMsg(client, "Not enough MA Fragments to perform this action.");
						return;
					}
					break;

				case 11:
					if (!destItem->PermitedInExp()) return;
					if (p->fragment_exp >= costPoints) {
						p->fragment_exp -= costPoints;
						SendCommand(client, "/fragment_exp", p->fragment_exp);
					}
					else {
						SendAlertMsg(client, "Not enough Exp Fragments to perform this action.");
						return;
					}
					break;
				default: return; break;
				}

				val2++;
				type2 = m_sType;

				destItem->m_dwAttribute &= ~0x0000F000;
				destItem->m_dwAttribute |= (type2 << 12);
				destItem->m_dwAttribute &= ~0x00000F00;
				destItem->m_dwAttribute |= (val2 << 8);				
							
				SendNotifyMsg(NULL, client, CLIENT_NOTIFY_ITEMATTRIBUTECHANGE, m_sDestItem, destItem->m_dwAttribute, NULL, NULL);
			}
		}

		break;
	default: break;
	}
}

void CMapServer::NotifyNewWeight(int client, short destitem, WORD weight)
{
	if (!m_pClientList[client]) return;
	
	char data[512];
	auto* cp = data;

	Push(cp, (u32)NOT_NEWWEIGHT);
	Push(cp, (u16)0);

	Push(cp, destitem);
	Push(cp, weight);

	m_pClientList[client]->m_pXSock->iSendMsg(data, cp - data);
}

void CMapServer::NotifyNewEndurance(int client, short destitem, int endu, int maxendu)
{
	auto p = m_pClientList[client];
	if (!p) return;
	auto item = p->m_pItemList[destitem];
	if (!item) return;


	char data[512];
	auto* cp = data;

	Push(cp, (u32)NOT_NEWENDURANCE);
	Push(cp, (u16)0);

	Push(cp, destitem);
	Push(cp, endu);
	Push(cp, maxendu);

	m_pClientList[client]->m_pXSock->iSendMsg(data, cp - data);
}

void CMapServer::SendAlertMsg(int client, char * pMsg)
{
	auto p = m_pClientList[client];
	if (!p) return;
	auto cl = client;
	char message[200];
	ZeroMemory(message, sizeof(message));
	strcpy(message, pMsg);
	SendNotifyMsg(NULL, client, NOTIFYMSG, NULL, NULL, NULL, message);
}

void CMapServer::SendCommand(int client, const char * command, int val1, int val2)
{
	char cCommand[30];
	ZeroMemory(cCommand, sizeof(cCommand));
	strcpy(cCommand, command);

	char data[256];
	auto * cp = data;

	Push(cp, (u32)NOT_COMMAND);
	Push(cp, (u16)0);

	Push(cp, cCommand, 30);
	Push(cp, val1);
	Push(cp, val2);

	m_pClientList[client]->m_pXSock->iSendMsg(data, cp - data);
}


//HeatoN rebirth
void CMapServer::requestRebirth(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	if (!player->IsInMap("cityhall_2") && !player->IsInMap("cityhall_1")) return;
	int cost = player->m_iRebirthLevel * 2500;
	
	if (player->m_sRebirthEnabled == 1) return;
	
	if (player->m_iLevel != DEF_PLAYERMAXLEVEL)
	{
		ShowClientMsg(client, "You need to be level %d to be reborn!");
		return;
	}

	auto nextlevel = player->m_iRebirthLevel + 1;

	if (nextlevel > 20)
	{
		ShowClientMsg(client, "Error. The maximum rebirth level has been reached.");
		return;
	}

	if (cost != 0)
	{
		if (player->m_iContribution < cost)
		{
			char notice[100];
			wsprintf(notice, "Error! You need %d contribution points", cost);
			ShowClientMsg(client, notice);
			return;
		}


		player->m_iContribution -= cost;
		SendCommand(client, "/contrib", m_pClientList[client]->m_iContribution);
	}
	

	unequipItems(client);

	copyStats(client);
	copyLevel(client);
	copyExp(client);
	copyStatsPoints(client);

	player->m_iExp = 0;
	player->m_iLevel = 1;
	m_pClientList[client]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[client]->m_iLevel + 1];

	auto war = player->m_iStr > player->m_iMag;
	
	if (war)
	{
		player->m_iStr = 14;
		player->m_iVit = 12;
		player->m_iInt = 10;
		player->m_iMag = 10;
		player->m_iDex = 14;
		player->m_iCharisma = 10;
	}
	else
	{
		player->m_iStr = 10;
		player->m_iVit = 12;
		player->m_iInt = 14;
		player->m_iMag = 14;
		player->m_iDex = 10;
		player->m_iCharisma = 10;
	}

	SendCommand(client, "/playerlevel", player->m_iLevel);
	SendCommand(client, "/playerexp", player->m_iExp);
	SendCommand(client, "/str", player->m_iStr);
	SendCommand(client, "/dex", player->m_iDex);
	SendCommand(client, "/int", player->m_iInt);
	SendCommand(client, "/vit", player->m_iVit);
	SendCommand(client, "/mag", player->m_iMag);
	SendCommand(client, "/chr", player->m_iCharisma);

	calculatePoints(client);

	notify_hp_mp_sp(client);

	copyRebirthLevel(client);

	player->m_iRebirthLevel = nextlevel;
	enableRebirthStatus(client);
	enableRebirth(client);

	SendCommand(client, "/rebirthlevel", m_pClientList[client]->m_iRebirthLevel);
	SendCommand(client, "/rebirthstatus", m_pClientList[client]->m_sRebirthStatus);
	SendCommand(client, "/rebirthenabled", m_pClientList[client]->m_sRebirthEnabled);

	int iStats = (m_pClientList[client]->m_iStr + m_pClientList[client]->m_iDex + m_pClientList[client]->m_iVit +
		m_pClientList[client]->m_iInt + m_pClientList[client]->m_iMag + m_pClientList[client]->m_iCharisma);

	/*m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLevel * 3 - (iStats - 70);*/

	int pool = m_pClientList[client]->m_iLevel * 3 - (iStats - 70);
	pool = pool + m_pClientList[client]->getRebirthStats();
	m_pClientList[client]->m_iLU_Pool = pool;

	SendCommand(client, "/statspoints", m_pClientList[client]->m_iLU_Pool);

	notifyLevelChange(client);
	AutoSkill(client);

	SendNotifyMsg(NULL, client, CLIENT_NOTIFY_SETTING_STATS, NULL, NULL, NULL, NULL);
	LocalSavePlayerData(client);	
}

void CMapServer::switchRebirth(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	if (!player->IsInMap("cityhall_2") && !player->IsInMap("cityhall_1")) return;

	if (player->m_sRebirthEnabled == 0) return;

	int goldcost = 10000;

	if (player->m_iLevel >= 1 && player->m_iLevel <= m_iPlayerMaxLevel - 1 && player->m_sRebirthStatus == 1 && player->m_sRebirthEnabled == 1)
	{
		int goldcost = 10000;

		if (dwGetItemCount(client, "Gold") < goldcost)
		{
			char notice[100];
			wsprintf(notice, "Error! You need %d gold", goldcost);
			ShowClientMsg(client, notice);
			return;
		}

		SetItemCount(client, "Gold", dwGetItemCount(client, "Gold") - goldcost);

		restoreLevel(client);
		restoreRebirthLevel(client);
		restoreStats(client);
		restoreStatsPoints(client);
		restoreExp(client);
		disableRebirthStatus(client);
		calculatePoints(client);
		notify_hp_mp_sp(client);

		notifyLevelChange(client);

		calcStatsPoints(client);

		m_pClientList[client]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[client]->m_iLevel + 1];

		unequipItems(client);
		AutoSkill(client);
		LocalSavePlayerData(client);
	}
	else if (player->m_iLevel == m_iPlayerMaxLevel && player->m_sRebirthStatus == 0 && player->m_sRebirthEnabled == 1)
	{

		if (dwGetItemCount(client, "Gold") < goldcost)
		{
			char notice[100];
			wsprintf(notice, "Error! You need %d gold", goldcost);
			ShowClientMsg(client, notice);
			return;
		}

		SetItemCount(client, "Gold", dwGetItemCount(client, "Gold") - goldcost);

		restoreLevel(client);
		restoreRebirthLevel(client);
		restoreStats(client);
		restoreStatsPoints(client);
		restoreExp(client);
		enableRebirthStatus(client);
		calculatePoints(client);
		notify_hp_mp_sp(client);

		notifyLevelChange(client);

		calcStatsPoints(client);

		m_pClientList[client]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[client]->m_iLevel + 1];

		unequipItems(client);
		AutoSkill(client);
		LocalSavePlayerData(client);
	}
	else return;
}

void CMapServer::calcStatsPoints(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	int iStats = (m_pClientList[client]->m_iStr + m_pClientList[client]->m_iDex + m_pClientList[client]->m_iVit +
		m_pClientList[client]->m_iInt + m_pClientList[client]->m_iMag + m_pClientList[client]->m_iCharisma);

	int pool = m_pClientList[client]->m_iLevel * 3 - (iStats - 70);
	pool = pool + m_pClientList[client]->getRebirthStats();
	m_pClientList[client]->m_iLU_Pool = pool;

	m_pClientList[client]->m_iLU_Pool = m_pClientList[client]->m_iLU_Pool - 3;

	SendCommand(client, "/statspoints", m_pClientList[client]->m_iLU_Pool);
}

void CMapServer::unequipItems(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	for (int i = 0; i < DEF_MAXITEMS; i++)
	{
		if (player->m_pItemList[i] != NULL)
		{
			if (player->m_bIsItemEquipped[i] == TRUE)
			{
				SendNotifyMsg(NULL, client, CLIENT_NOTIFY_ITEMRELEASED, player->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(client, i, TRUE);
			}
		}
	}
}

void CMapServer::copyStats(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iBackStr = player->m_iStr;
	player->m_iBackDex = player->m_iDex;
	player->m_iBackInt = player->m_iInt;
	player->m_iBackVit = player->m_iVit;
	player->m_iBackMag = player->m_iMag;
	player->m_iBackChr = player->m_iCharisma;
}

void CMapServer::restoreStats(int client)
{
	int tmpStr, tmpMag, tmpVit, tmpDex, tmpInt, tmpChr;

	auto player = m_pClientList[client];
	if (!player) return;

	tmpStr = player->m_iStr;
	tmpDex = player->m_iDex;
	tmpInt = player->m_iInt;
	tmpVit = player->m_iVit;
	tmpMag = player->m_iMag;
	tmpChr = player->m_iCharisma;

	player->m_iStr = player->m_iBackStr;
	player->m_iDex = player->m_iBackDex;
	player->m_iInt = player->m_iBackInt;
	player->m_iVit = player->m_iBackVit;
	player->m_iMag = player->m_iBackMag;
	player->m_iCharisma = player->m_iBackChr;

	player->m_iBackStr = tmpStr;
	player->m_iBackDex = tmpDex;
	player->m_iBackInt = tmpInt;
	player->m_iBackVit = tmpVit;
	player->m_iBackMag = tmpMag;
	player->m_iBackChr = tmpChr;

	SendCommand(client, "/str", player->m_iStr);
	SendCommand(client, "/dex", player->m_iDex);
	SendCommand(client, "/int", player->m_iInt);
	SendCommand(client, "/vit", player->m_iVit);
	SendCommand(client, "/mag", player->m_iMag);
	SendCommand(client, "/chr", player->m_iCharisma);
}

void CMapServer::copyLevel(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iBackLevel = player->m_iLevel;
}

void CMapServer::copyExp(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iBackExp = player->m_iExp;
}

void CMapServer::copyStatsPoints(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iBackStatsPoint = player->m_iLU_Pool;
}

void CMapServer::restoreLevel(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	int tmpBackLevel;
	tmpBackLevel = player->m_iLevel;
	player->m_iLevel = player->m_iBackLevel;
	player->m_iBackLevel = tmpBackLevel;

	SendCommand(client, "/playerlevel", m_pClientList[client]->m_iLevel);
}

void CMapServer::restoreStatsPoints(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	int tmpBackStats;
	tmpBackStats = player->m_iLU_Pool;
	player->m_iLU_Pool = player->m_iBackStatsPoint;
	player->m_iBackStatsPoint = tmpBackStats;

	SendCommand(client, "/statspoints", m_pClientList[client]->m_iLU_Pool);
}

void CMapServer::restoreExp(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	int tmpBackExp;
	tmpBackExp = player->m_iExp;
	player->m_iExp = player->m_iBackExp;
	player->m_iBackExp = tmpBackExp;

	SendCommand(client, "/playerexp", m_pClientList[client]->m_iExp);
}

void CMapServer::copyRebirthLevel(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iBackRebirthLevel = player->m_iRebirthLevel;
}

void CMapServer::restoreRebirthLevel(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	int tmpBackRebirthLevel;
	tmpBackRebirthLevel = player->m_iRebirthLevel;
	player->m_iRebirthLevel = player->m_iBackRebirthLevel;
	player->m_iBackRebirthLevel = tmpBackRebirthLevel;
	SendCommand(client, "/rebirthlevel", m_pClientList[client]->m_iRebirthLevel);
}

void CMapServer::disableRebirthStatus(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_sRebirthStatus = 0;
	SendCommand(client, "/rebirthstatus", m_pClientList[client]->m_sRebirthStatus);
}

void CMapServer::enableRebirthStatus(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_sRebirthStatus = 1;
	SendCommand(client, "/rebirthstatus", m_pClientList[client]->m_sRebirthStatus);
}

void CMapServer::enableRebirth(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_sRebirthEnabled = 1;
	SendCommand(client, "/rebirthenabled", m_pClientList[client]->m_sRebirthEnabled);
}

void CMapServer::disableRebirth(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_sRebirthEnabled = 0;
	SendCommand(client, "/rebirthenabled", m_pClientList[client]->m_sRebirthEnabled);
}

void CMapServer::notify_hp_mp_sp(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	SendCommand(client, "/hp", m_pClientList[client]->m_iHP);
	SendCommand(client, "/mp", m_pClientList[client]->m_iMP);
	SendCommand(client, "/sp", m_pClientList[client]->m_iSP);
}

void CMapServer::calculatePoints(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iHP = iGetMaxHP(client);
	player->m_iMP = player->GetMaxMP();
	player->m_iSP = player->GetMaxSP();
}

void CMapServer::notifyLevelChange(int client)
{
	auto player = m_pClientList[client];
	if (!player) return;

	char data[50];
	auto* cp = data;
	Push(cp, (u32)NOTIFY_LEVELCHANGE);
	Push(cp, (u16)0);

	player->m_pXSock->iSendMsg(data, cp - data);
}

//heaton add more variables to read list
BOOL CMapServer::_bDecodePlayerDatafileContents2(int iClientH, char* pData, DWORD dwSize)
{
#ifdef DEF_DEBUG
	try {
#endif
		char* pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
		char   seps[] = "= \t\n";
		char   cReadModeA, cReadModeB;
		int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
		class  CStrTok* pStrTok;
		short  sTmpType = 1, sTmpAppr1;
		short itemBagPossX;
		short itemBagPossY;
		short ItemBankPosition;
		short TotalBankPosition = 0;
		short TempPosition = 0;
		BOOL   bRet;
		int    iTemp;
		SYSTEMTIME SysTime;
		__int64 iDateSum1, iDateSum2;
		BOOL   bIsNotUsedItemFound = FALSE, TempItem = FALSE;

		if (m_pClientList[iClientH] == NULL) return FALSE;

		iTotalGold = 0;
		iItemIndex = 0;
		iItemInBankIndex = 0;
		iNotUsedItemPrice = 0;

		cReadModeA = 0;
		cReadModeB = 0;

		pContents = new char[dwSize + 2];
		ZeroMemory(pContents, dwSize + 2);
		memcpy_secure(pContents, pData, dwSize);

		pOriginContents = pContents;

		pStrTok = new class CStrTok(pContents, seps);
		token = pStrTok->pGet();

		while (token != NULL) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iRebirthLevel = atoi(token);
					cReadModeA = 0;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_sRebirthStatus = atoi(token);
					cReadModeA = 0;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_sRebirthEnabled = atoi(token);
					cReadModeA = 0;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackRebirthLevel = atoi(token);
					cReadModeA = 0;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackExp = atoi(token);
					cReadModeA = 0;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackStatsPoint = atoi(token);
					cReadModeA = 0;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackStr = atoi(token);
					cReadModeA = 0;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackVit = atoi(token);
					cReadModeA = 0;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackInt = atoi(token);
					cReadModeA = 0;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackDex = atoi(token);
					cReadModeA = 0;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackChr = atoi(token);
					cReadModeA = 0;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackMag = atoi(token);
					cReadModeA = 0;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->m_iBackLevel = atoi(token);
					cReadModeA = 0;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->shard_light = atoi(token);
					cReadModeA = 0;
					break;

				case 15:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->shard_strong = atoi(token);
					cReadModeA = 0;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_hp = atoi(token);
					cReadModeA = 0;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_dr = atoi(token);
					cReadModeA = 0;
					break;

				case 18:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_hprec = atoi(token);
					cReadModeA = 0;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_sprec = atoi(token);
					cReadModeA = 0;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_mprec = atoi(token);
					cReadModeA = 0;
					break;

				case 21:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_mr = atoi(token);
					cReadModeA = 0;
					break;

				case 22:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_pa = atoi(token);
					cReadModeA = 0;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_ma = atoi(token);
					cReadModeA = 0;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pClientList[iClientH]->fragment_exp = atoi(token);
					cReadModeA = 0;
					break;
				}
			}
			else {
				//heaton rebirth
				if (memcmp(token, "character-rebirth-level", 23) == 0)        cReadModeA = 1;
				else if (memcmp(token, "character-rebirth-status", 24) == 0)       cReadModeA = 2;
				else if (memcmp(token, "character-rebirth-enabled", 25) == 0)      cReadModeA = 3;
				else if (memcmp(token, "character-back-rebirth-level", 28) == 0)   cReadModeA = 4;
				else if (memcmp(token, "character-back-exp", 18) == 0)             cReadModeA = 5;
				else if (memcmp(token, "character-back-stats-point", 26) == 0)     cReadModeA = 6;
				else if (memcmp(token, "character-back-str", 18) == 0)             cReadModeA = 7;
				else if (memcmp(token, "character-back-vit", 18) == 0)             cReadModeA = 8;
				else if (memcmp(token, "character-back-int", 18) == 0)             cReadModeA = 9;
				else if (memcmp(token, "character-back-dex", 18) == 0)             cReadModeA = 10;
				else if (memcmp(token, "character-back-chr", 18) == 0)             cReadModeA = 11;
				else if (memcmp(token, "character-back-mag", 18) == 0)             cReadModeA = 12;
				else if (memcmp(token, "character-back-level", 20) == 0)           cReadModeA = 13;
				//heaton enchanting
				else if (memcmp(token, "character-shard-light", 21) == 0)    cReadModeA = 14;
				else if (memcmp(token, "character-shard-strong", 22) == 0)   cReadModeA = 15;
				else if (memcmp(token, "character-fragment-hp", 22) == 0)    cReadModeA = 16;
				else if (memcmp(token, "character-fragment-dr", 21) == 0)    cReadModeA = 17;
				else if (memcmp(token, "character-fragment-hprec", 25) == 0) cReadModeA = 18;
				else if (memcmp(token, "character-fragment-sprec", 25) == 0) cReadModeA = 19;
				else if (memcmp(token, "character-fragment-mprec", 25) == 0) cReadModeA = 20;
				else if (memcmp(token, "character-fragment-mr", 22) == 0)    cReadModeA = 21;
				else if (memcmp(token, "character-fragment-pa", 22) == 0)    cReadModeA = 22;
				else if (memcmp(token, "character-fragment-ma", 22) == 0)    cReadModeA = 23;
				else if (memcmp(token, "character-fragment-exp", 23) == 0)    cReadModeA = 24;
				else if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
			}
			token = pStrTok->pGet();
		}

	DPDC_STOP_DECODING:;

		delete pStrTok;
		delete[]pContents;
		if ((cReadModeA != 0)) {
			wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
			PutLogList(cTxt);

			HANDLE hFile2;
			DWORD  nWrite2;
			hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
			WriteFile(hFile2, (char*)pOriginContents, dwSize + 2, &nWrite2, NULL);
			CloseHandle(hFile2);
			return FALSE;
		}

#ifdef DEF_DEBUG
	}
	catch (...) {
		mtx.lock();
		bCheckClient[iClientH] = FALSE;
		m_iTotalClients--;
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = NULL;
		RemoveClientShortCut(iClientH);

		mtx.unlock();
		//DeleteClient(iClientH, FALSE, FALSE);
		ErrorList("Crash Evitado en: _bDecodePlayerDatafileContents");
		return FALSE;
	}
#endif
	return TRUE;
}



bool CMapServer::BlockedTeleport(int client)
{
	auto player = m_pClientList[client];
	if (!player) return true;
	
	if (strcmp(player->m_cMapName, "elvine") == 0 && strcmp(player->m_cLocation, "aresden") == 0) {
		//shop
		if (((player->m_sX == 225) && (player->m_sY == 151)) ||
			((player->m_sX == 225) && (player->m_sY == 152)) ||
			((player->m_sX == 226) && (player->m_sY == 152)) ||
			((player->m_sX == 229) && (player->m_sY == 152)) ||
			((player->m_sX == 230) && (player->m_sY == 151)) ||
			//cityhall
			((player->m_sX == 135) && (player->m_sY == 133)) ||
			((player->m_sX == 136) && (player->m_sY == 133)) ||
			((player->m_sX == 137) && (player->m_sY == 133)) ||
			((player->m_sX == 137) && (player->m_sY == 132)) ||
			((player->m_sX == 144) && (player->m_sY == 127)) ||
			((player->m_sX == 145) && (player->m_sY == 127)) ||
			((player->m_sX == 145) && (player->m_sY == 126)) ||
			((player->m_sX == 146) && (player->m_sY == 126)) ||
			//cath1
			((player->m_sX == 131) && (player->m_sY == 77)) ||
			((player->m_sX == 132) && (player->m_sY == 77)) ||
			((player->m_sX == 132) && (player->m_sY == 76)) ||
			((player->m_sX == 133) && (player->m_sY == 76)) ||
			//bsmith
			((player->m_sX == 239) && (player->m_sY == 107)) ||
			((player->m_sX == 240) && (player->m_sY == 107)) ||
			((player->m_sX == 241) && (player->m_sY == 107)) ||
			((player->m_sX == 241) && (player->m_sY == 106)) ||
			((player->m_sX == 229) && (player->m_sY == 112)) ||
			((player->m_sX == 229) && (player->m_sY == 113)) ||
			((player->m_sX == 230) && (player->m_sY == 113)) ||
			//wrhus2
			((player->m_sX == 197) && (player->m_sY == 127)) ||
			((player->m_sX == 198) && (player->m_sY == 128)) ||
			((player->m_sX == 199) && (player->m_sY == 129)) ||
			((player->m_sX == 203) && (player->m_sY == 129)) ||
			//elvwrhus
			((player->m_sX == 87) && (player->m_sY == 174)) ||
			((player->m_sX == 88) && (player->m_sY == 175)) ||
			((player->m_sX == 89) && (player->m_sY == 176)) ||
			((player->m_sX == 93) && (player->m_sY == 176)) ||
			//gldhall
			((player->m_sX == 76) && (player->m_sY == 141)) ||
			((player->m_sX == 77) && (player->m_sY == 140)) ||
			((player->m_sX == 77) && (player->m_sY == 141)) ||
			((player->m_sX == 78) && (player->m_sY == 141)) ||
			//wztwr
			((player->m_sX == 180) && (player->m_sY == 77)) ||
			((player->m_sX == 181) && (player->m_sY == 77)) ||
			((player->m_sX == 181) && (player->m_sY == 76)) ||
			//cmdhall
			((player->m_sX == 213) && (player->m_sY == 89)) ||
			((player->m_sX == 214) && (player->m_sY == 89)) ||
			((player->m_sX == 214) && (player->m_sY == 88)) ||
			((player->m_sX == 220) && (player->m_sY == 87)) ||
			((player->m_sX == 221) && (player->m_sY == 87)) ||
			((player->m_sX == 222) && (player->m_sY == 87))) {
			return true;
			}
		}
	

	if (strcmp(player->m_cMapName, "aresden") == 0 && strcmp(player->m_cLocation, "elvine") == 0) {
		if (((player->m_sX == 126) && (player->m_sY == 166)) || //shop
			((player->m_sX == 126) && (player->m_sY == 167)) ||
			((player->m_sX == 127) && (player->m_sY == 167)) ||
			((player->m_sX == 130) && (player->m_sY == 167)) ||
			((player->m_sX == 131) && (player->m_sY == 166)) ||
			//cityhall
			((player->m_sX == 135) && (player->m_sY == 129)) ||
			((player->m_sX == 136) && (player->m_sY == 129)) ||
			((player->m_sX == 137) && (player->m_sY == 129)) ||
			((player->m_sX == 137) && (player->m_sY == 128)) ||
			((player->m_sX == 145) && (player->m_sY == 122)) ||
			((player->m_sX == 144) && (player->m_sY == 123)) ||
			((player->m_sX == 145) && (player->m_sY == 123)) ||
			((player->m_sX == 146) && (player->m_sY == 123)) ||
			((player->m_sX == 146) && (player->m_sY == 122)) ||
			//cath1
			((player->m_sX == 185) && (player->m_sY == 93)) ||
			((player->m_sX == 186) && (player->m_sY == 93)) ||
			((player->m_sX == 186) && (player->m_sY == 92)) ||
			((player->m_sX == 187) && (player->m_sY == 92)) ||
			//bsmith
			((player->m_sX == 167) && (player->m_sY == 195)) ||
			((player->m_sX == 168) && (player->m_sY == 195)) ||
			((player->m_sX == 169) && (player->m_sY == 195)) ||
			((player->m_sX == 169) && (player->m_sY == 194)) ||
			((player->m_sX == 157) && (player->m_sY == 200)) ||
			((player->m_sX == 157) && (player->m_sY == 201)) ||
			((player->m_sX == 158) && (player->m_sY == 201)) ||
			//wrhus1
			((player->m_sX == 101) && (player->m_sY == 183)) ||
			((player->m_sX == 102) && (player->m_sY == 184)) ||
			((player->m_sX == 103) && (player->m_sY == 185)) ||
			((player->m_sX == 107) && (player->m_sY == 185)) ||
			//arewrhus
			((player->m_sX == 217) && (player->m_sY == 132)) ||
			((player->m_sX == 218) && (player->m_sY == 133)) ||
			((player->m_sX == 219) && (player->m_sY == 134)) ||
			((player->m_sX == 223) && (player->m_sY == 134)) ||
			//gldhall
			((player->m_sX == 112) && (player->m_sY == 97)) ||
			((player->m_sX == 113) && (player->m_sY == 96)) ||
			((player->m_sX == 113) && (player->m_sY == 97)) ||
			((player->m_sX == 114) && (player->m_sY == 97)) ||
			//wztwr
			((player->m_sX == 55) && (player->m_sY == 118)) ||
			((player->m_sX == 56) && (player->m_sY == 118)) ||
			((player->m_sX == 57) && (player->m_sY == 117)) ||
			//cmdhall
			((player->m_sX == 94) && (player->m_sY == 161)) ||
			((player->m_sX == 95) && (player->m_sY == 161)) ||
			((player->m_sX == 95) && (player->m_sY == 160)) ||
			((player->m_sX == 101) && (player->m_sY == 159)) ||
			((player->m_sX == 102) && (player->m_sY == 159)) ||
			((player->m_sX == 103) && (player->m_sY == 159))) {
			return true;
		}
	}

	if (m_bIsCrusadeMode == TRUE)
	{
		if (strcmp(player->m_cMapName, "aresden") == 0)
		{
			// Dungeon aresden in sade no tp
			if (((player->m_sX == 78) && (player->m_sY == 210)) ||
				((player->m_sX == 78) && (player->m_sY == 211)) ||
				((player->m_sX == 79) && (player->m_sY == 209)) ||
				((player->m_sX == 79) && (player->m_sY == 210)) ||
				((player->m_sX == 80) && (player->m_sY == 209)))
			{
				return true;
			}
		}
		else if (strcmp(player->m_cMapName, "elvine") == 0)
		{
			// Dungeon elvine in sade no tp
			if (((player->m_sX == 258) && (player->m_sY == 82)) ||
				((player->m_sX == 258) && (player->m_sY == 83)) ||
				((player->m_sX == 259) && (player->m_sY == 82)) ||
				((player->m_sX == 259) && (player->m_sY == 81)) ||
				((player->m_sX == 260) && (player->m_sY == 81)))
			{
				return true;
			}
		}
	}
	return false;
}

// command for manage dinamic events
void CMapServer::AdminCommand_Event(int client, char *pData, DWORD dwMsgSize)
{
	char seps[] = "= \t\n";
	char *token, cBuff[256];
	class  CStrTok * pStrTok;
	auto cl = client;
	auto p = m_pClientList[cl];
	if (!p) return;
	if ((dwMsgSize) <= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy_secure(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (!token)
		return;

	EventID id = EventID::Max;
	for (int i = 0; i < (int)EventID::Max; i++)
	{
		if (_eventNameShort[i] == string(token))
		{
			id = (EventID)i;
			break;
		}
	}

	if (id == EventID::Max)
		return;

	token = pStrTok->pGet();
	if (!token)
		return;
	if (strlen(token) > 1)
		return;

	bool flag = atoi(token) > 0;

	if (flag)
	{
		g_ev.Activate(id);
	}
	else
	{
		g_ev.Deactivate(id);
	}
}

//heaton prevent lammers quest and exp
void CMapServer::handleCheckTimer(int client) {
	auto player = m_pClientList[client];
	if (!player) return;

	player->m_iCheckCount++;
}



//heaton unlimbo
void CMapServer::AdminOrder_UnLimbo(int client, char* pData, DWORD dwMsgSize)
{
	return;
	char   seps[] = "= \t\n";
	char* token, cName[11], cBuff[256];
	class  CStrTok* pStrTok;

	if (m_pClientList[client] == NULL) return;
	if ((dwMsgSize) <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy_secure(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (strlen(token) > 10)
			memcpy_secure(cName, token, 10);
		else memcpy_secure(cName, token, strlen(token));
	}

	for (int i = 0; i < DEF_MAXCLIENTS; i++)
	{
		if (!m_pClientList[i])
			continue;

		if (string(m_pClientList[i]->m_cCharName) == cName)
		{
			LocalSavePlayerData(i);
			m_pClientList[i]->m_bForceDisconnect = true;
			DeleteClient(i, TRUE, TRUE, FALSE, FALSE);

			return;
		}
	}
	delete pStrTok;
}

//HeatoN limbo player
void CMapServer::EnableBot(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;
	char msg[100];
	SetLimboAfkFlag(client, 1);
	LocalSavePlayerData(client);
	p->m_pXSock->m_limbo = true;
	p->m_bLimbo = true;
}
//HeatoN limbo player
void CMapServer::DisableBot(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;
	char msg[100];
	//LocalSavePlayerData(client);
	p->m_pXSock->m_limbo = false;
	p->m_bLimbo = false;
}

void CMapServer::SetLimboAfkFlag(int iClientH, int iStatus)
{
#ifdef DEF_DEBUG
	try {
#endif
		char* cp;
		int* ip;
		DWORD dwTime;
		dwTime = timeGetTime();

		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
		if (m_pClientList[iClientH]->OpenSell) return;
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, DEF_EVENTMAP_ALLVSALL, 9) == 0) return;

		if (iStatus == 1) {
			m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus | 0x00000008;
			if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) ||
				(strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0)) {
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 0x00000006) != 0)
					m_pClientList[iClientH]->KilledClientAFK = dwTime;
			}
		}
		else {
			m_pClientList[iClientH]->m_iStatus = m_pClientList[iClientH]->m_iStatus & 0xFFFFFFF7;
			m_pClientList[iClientH]->KilledClientAFK = -1;
		}
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, CLIENT_COMMON_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: SetAfkFlag");
	}
#endif
}

//HeatoN market
// response market names
void CMapServer::RequestMarketNames(int client)
{
	if (!m_pClientList[client])
		return;

	if (!m_pClientList[client]->IsInMap("Whouse") && !m_pClientList[client]->IsInMap("cityhall_1") && !m_pClientList[client]->IsInMap("cityhall_2")) return;

	vector<string> names;

	for (int i = 0; i < DEF_MAXCLIENTS; i++)
	{
		if (!m_pClientList[i])
			continue;

		int cnt = 0;
		for (int x = 0; x < DEF_MAXMARKETITEMS; x++)
		{
			if (m_pClientList[i]->m_pMarketItem[x])
			{
				cnt++;
				break;
			}
		}

		if (cnt > 0)
		{
			names.push_back(m_pClientList[i]->m_cCharName);
		}
	}

	char cData[1024];
	char* cp = cData;
	Push(cp, (u32)REQUEST_MARKETNAMES);
	Push(cp, (u16)0);

	Push(cp, (u16)names.size());

	for (auto s : names)
	{
		char name[12] = {};
		strcpy(name, s.c_str());
		Push(cp, name, 10);
	}

	m_pClientList[client]->m_pXSock->iSendMsg(cData, cp - cData);
}

// response market items
void CMapServer::RequestMarketItems(int client, char* pData)
{
	if (!m_pClientList[client])
		return;

	if (!m_pClientList[client]->IsInMap("Whouse") && !m_pClientList[client]->IsInMap("cityhall_1") && !m_pClientList[client]->IsInMap("cityhall_2")) return;

	pData += 6;
	char name[12] = {};
	Pop(pData, name, 10);

	for (int i = 0; i < DEF_MAXCLIENTS; i++)
	{
		if (!m_pClientList[i])
			continue;

		if (std::string(m_pClientList[i]->m_cCharName) == name)
		{
			char data[10000] = {};
			char* cp = data;
			Push(cp, (u32)REQUEST_MARKETITEMS);
			Push(cp, (u16)0);
			Push(cp, m_pClientList[i]->m_cCharName, 10);

			struct MarketItem
			{
				CItem* item;
				int index;
			};
			vector<MarketItem> item;

			for (int x = 0; x < DEF_MAXMARKETITEMS; x++)
			{
				if (!m_pClientList[i]->m_pMarketItem[x])
					continue;

				item.push_back({ m_pClientList[i]->m_pMarketItem[x], x });
			}

			Push(cp, (u16)item.size());
			for (auto& ite : item)
			{
				Push(cp, ite.index);
				auto it = ite.item;

				Push(cp, it->m_cName, 20); // char 20
				//PutLogList(it->m_cName);

				Push(cp, it->m_dwCount); // DWORD
				//PutLogList((char*)to_string(it->m_dwCount).c_str());

				Push(cp, it->m_cItemType); // char
				//PutLogList((char*)to_string(it->m_cItemType).c_str());

				Push(cp, it->m_cEquipPos); // char
				//PutLogList((char*)to_string(it->m_cEquipPos).c_str());

				Push(cp, it->m_sLevelLimit); // short
				//PutLogList((char*)to_string(it->m_sLevelLimit).c_str());

				Push(cp, it->m_cGenderLimit); // char
				//PutLogList((char*)to_string(it->m_cGenderLimit).c_str());

				Push(cp, it->m_wCurLifeSpan); // int
				//PutLogList((char*)to_string(it->m_wCurLifeSpan).c_str());

				Push(cp, it->m_wWeight); // WORD
				//PutLogList((char*)to_string(it->m_wWeight).c_str());

				Push(cp, it->m_sSprite); // short
				//PutLogList((char*)to_string(it->m_sSprite).c_str());

				Push(cp, it->m_sSpriteFrame); // short
				//PutLogList((char*)to_string(it->m_sSpriteFrame).c_str());

				Push(cp, it->m_cItemColor); // char
				//PutLogList((char*)to_string(it->m_cItemColor).c_str());

				Push(cp, it->m_sItemSpecEffectValue2); // int
				//PutLogList((char*)to_string(it->m_sItemSpecEffectValue2).c_str());

				Push(cp, it->m_dwAttribute); // DWORD
				//PutLogList((char*)to_string(it->m_dwAttribute).c_str());

				Push(cp, it->m_sItemSpecEffectValue3); // int
				//PutLogList((char*)to_string(it->m_sItemSpecEffectValue3).c_str());

				Push(cp, it->m_iCoinVal); // int
				//PutLogList((char*)to_string(it->m_iCoinVal).c_str());
			}
			m_pClientList[client]->m_pXSock->iSendMsg(data, cp - data);
			return;
		}
	}
}



//Market Logs - ChatGPT con ayuda de gabi (?
void CMapServer::handleMarketLog(char* seller, char* buyer, char* itemname, int coinval, DWORD attr)
{
	// Crear el directorio y archivo de log si no existen GABI
	char logDir[] = "..\\ServerLogs\\Market";
	_mkdir(logDir);

	// Obtener la fecha actual
	time_t now = time(0);
	tm* ltm = localtime(&now);
	char logFilename[64];
	sprintf(logFilename, "%s\\Transfers_%02d_%02d_%04d.txt", logDir, ltm->tm_mday, ltm->tm_mon + 1, ltm->tm_year + 1900);

	// Abrir o crear el archivo de log GABI
	std::ofstream logFile;
	logFile.open(logFilename, std::ios::app);

	if (logFile.is_open())
	{
		// Registrar toda la transferencia en una sola línea con la hora GABI
		logFile << "Hora: " << ltm->tm_hour << ":" << ltm->tm_min << ":" << ltm->tm_sec
			<< ", Cliente: " << buyer
			<< ", Vendedor: " << seller
			<< ", Item: " << itemname
			<< ", Atributo: " << attr
			<< ", Monedas: " << coinval
			<< "\n";
		logFile.close();
	}
}

// get and response market items
void CMapServer::RequestGetMarketItem(int client, char* pData)
{
	int saveseller = -1;
	int savebuyer = -1;

	if (!m_pClientList[client])
		return;

//	if (m_pClientList[client]->m_iAdminUserLevel != 0)
	if (m_pClientList[client]->m_iAdminUserLevel > 0 && m_pClientList[client]->m_iAdminUserLevel < 6)
	{
		return;
	}

	/*if (m_pClientList[client]->m_iAdminUserLevel > 0 && m_pClientList[client]->m_iAdminUserLevel < 4)
	{
		PutLogList("4");
		return;
	}*/

	if (!m_pClientList[client]->IsInMap("Whouse") && !m_pClientList[client]->IsInMap("cityhall_1") && !m_pClientList[client]->IsInMap("cityhall_2")) return;


	pData += 6;
	char name[12] = {};
	Pop(pData, name, 10);

	int index;
	Pop(pData, index);

	if (index < 0 || index >= DEF_MAXMARKETITEMS)
		return;

	DWORD coins;
	Pop(pData, coins);

	char itemname[24] = {};
	Pop(pData, itemname, 20);

	DWORD attr;
	Pop(pData, attr);

	for (int i = 0; i < DEF_MAXCLIENTS; i++)
	{
		if (!m_pClientList[i])
			continue;

		if (string(m_pClientList[i]->m_cCharName) != name)
			continue;

		if (!m_pClientList[i]->m_pMarketItem[index])
		{
			ShowClientMsg(client, "This item has expired or has been removed");
			return;
		}

		if (coins != m_pClientList[i]->m_pMarketItem[index]->m_iCoinVal ||
			m_pClientList[i]->m_pMarketItem[index]->m_dwAttribute != attr ||
			string(m_pClientList[i]->m_pMarketItem[index]->m_cName) != itemname)
		{
			ShowClientMsg(client, "This item has expired or has been removed");
			return;
		}

		if (_iGetItemSpaceLeft(client) == 0) {

			SendItemNotifyMsg(client, CLIENT_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
			return;
		}

		if (m_pClientList[i] != m_pClientList[client])
		{
			if (m_pClientList[client]->m_iCoins < m_pClientList[i]->m_pMarketItem[index]->m_iCoinVal)
			{
				ShowClientMsg(client, "Not enough coins");
				return;
			}

			handleMarketLog(m_pClientList[i]->m_cCharName, m_pClientList[client]->m_cCharName, m_pClientList[i]->m_pMarketItem[index]->m_cName, m_pClientList[i]->m_pMarketItem[index]->m_iCoinVal, m_pClientList[i]->m_pMarketItem[index]->m_dwAttribute);

			m_pClientList[client]->m_iCoins -= m_pClientList[i]->m_pMarketItem[index]->m_iCoinVal;
			m_pClientList[i]->m_iCoins += m_pClientList[i]->m_pMarketItem[index]->m_iCoinVal;

			/*SendNotifyMsg(client, NULL, CLIENT_NOTIFY_COINS, m_pClientList[client]->m_iCoins, NULL, NULL, NULL);
			SendNotifyMsg(i, NULL, CLIENT_NOTIFY_COINS, m_pClientList[i]->m_iCoins, NULL, NULL, NULL);*/

			SendF5DataCharacter(client);
			SendF5DataCharacter(i);

			char cTxt[112] = {};
			wsprintf(cTxt, "You have traded %s from market! +%d coins!", m_pClientList[i]->m_pMarketItem[index]->m_cName, m_pClientList[i]->m_pMarketItem[index]->m_iCoinVal);
			ShowClientMsg(i, cTxt);

			saveseller = i;
			savebuyer = client;
		}

		for (int x = 0; x < DEF_MAXITEMS; x++) {
			if (!m_pClientList[client]->m_pItemList[x]) {
				m_pClientList[client]->m_pItemList[x] = m_pClientList[i]->m_pMarketItem[index];
				m_pClientList[i]->m_pMarketItem[index] = nullptr;

				m_pClientList[client]->m_ItemPosList[x].x = 40;
				m_pClientList[client]->m_ItemPosList[x].y = 30;

				m_pClientList[client]->m_bIsItemEquipped[x] = false;

				SendItemNotifyMsg(m_pClientList[client]->client, CLIENT_NOTIFY_ITEMOBTAINED, m_pClientList[client]->m_pItemList[x], NULL);

				iCalcTotalWeight(m_pClientList[client]->client);
				if (m_pClientList[i] != m_pClientList[client])
				{
					ShowClientMsg(client, "Item successfully traded from market!");

					for (int i = 0; i < DEF_MAXITEMS; i++)
					{
						ReqRepairItemCofirmHandler2(client, i, NULL);
					}

				}
				else
				{
					ShowClientMsg(client, "Withdrew item from market");

					for (int i = 0; i < DEF_MAXITEMS; i++)
					{
						ReqRepairItemCofirmHandler2(client, i, NULL);
					}
				}

				break;
			}
		}
	}

	if (saveseller != -1) LocalSavePlayerData(saveseller);
	LocalSavePlayerData(client);
	//if (savebuyer != -1) LocalSavePlayerData(savebuyer);
}


void CMapServer::ReqRepairItemCofirmHandler2(int client, char cItemID, char* pString)
{
	char* cp, cItemCategory, cData[120];
	double   d1, d2, d3;
	DWORD* dwp;
	WORD* wp;

	if (m_pClientList[client] == NULL) return;
	if (m_pClientList[client]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	CItem* item = m_pClientList[client]->m_pItemList[cItemID];

	if (!item) return;

	cItemCategory = item->m_cCategory;

	if (((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) ||
		((cItemCategory >= 11) && (cItemCategory <= 13))) {

		item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
		SendNotifyMsg(NULL, client, CLIENT_NOTIFY_ITEMREPAIRED2, cItemID, item->m_wCurLifeSpan, NULL, NULL); //WTF
		iCalcTotalWeight(client);
	}
}

// set market item
void CMapServer::RequestSetMarketItem(int client, char* pData)
{
	auto p = m_pClientList[client];

	if (!p) return;

	pData += 6;
	int index;
	DWORD coins;
	Pop(pData, index);
	Pop(pData, coins);	

	if (coins <= 0 || coins > DEF_MAXMARKETCOINS)
	{
		return;
	}

	if (index < 0 || index > DEF_MAXITEMS)
	{
		return;
	}

	if (p->m_pItemList[index]->m_cItemType == DEF_ITEMTYPE_CONSUME ||
		p->m_pItemList[index]->m_cItemType == DEF_ITEMTYPE_ARROW)
	{
		return;
	}

	if (!p->IsInMap("Whouse") && !p->IsInMap("cityhall_1") && !p->IsInMap("cityhall_2"))
	{
		p->EnableItem(index);
		return;
	}

	//if (p->m_iAdminUserLevel != 0)
	if (p->m_iAdminUserLevel > 0 && p->m_iAdminUserLevel < 6)
	{
		p->EnableItem(index);
		return;
	}	

	if ((p->m_pItemList[index]->m_sTouchEffectValue1 == p->m_sCharIDnum1) &&
		(p->m_pItemList[index]->m_sTouchEffectValue2 == p->m_sCharIDnum2) &&
		(p->m_pItemList[index]->m_sTouchEffectValue3 == p->m_sCharIDnum3))
	{
		char cInfoString[112] = {};
		wsprintf(cInfoString, "Prohibited transaction item with ID");
		SendAlertMsg(client, cInfoString);
		p->EnableItem(index);
		return;
	}

	for (int i = 0; i < DEF_MAXMARKETITEMS; i++)
	{
		if (p->m_pMarketItem[i])
			continue;

		p->m_pMarketItem[i] = p->m_pItemList[index];
		p->m_pMarketItem[i]->m_iCoinVal = coins;
		p->m_pItemList[index] = nullptr;
		SendNotifyMsg(NULL, client, CLIENT_NOTIFY_GIVEITEMFIN_ERASEITEM, index, 1, NULL, "Howard");
		ShowClientMsg(client, "Item registered in the market!");
		LocalSavePlayerData(client);
		return;
	}

	ShowClientMsg(client, "You don't have any more space in the market!");
	p->EnableItem(index);
}

void CMapServer::SaveCharacterMarket(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	char AscIIDir[10000], charfilename[10000];
	string savefile = "..\\Nucleo\\Market\\";
	wsprintf(charfilename, "\\%s.txt", m_pClientList[client]->m_cCharName);
	wsprintf(AscIIDir, "AscII%d", (unsigned char)m_pClientList[client]->m_cCharName[0], m_pClientList[client]->m_cCharName);
	savefile.append(AscIIDir);
	savefile.append(charfilename);

	string createdir = "..\\Nucleo\\Market\\";
	createdir.append(AscIIDir);

	_mkdir("..\\Nucleo\\Market");
	_mkdir((char*)createdir.c_str());

	/*wsprintf(G_cTxt, "Guardando market de: %s", m_pClientList[client]->m_cCharName);
	PutLogList(G_cTxt);*/

	string item_query;

	if (FILE* f1 = fopen((char*)savefile.c_str(), "wt"))
	{
		for (int i = 0; i < DEF_MAXMARKETITEMS; i++)
		{
			auto item = p->m_pMarketItem[i];
			if (!item) continue;

			char ItemQuery[10000];
			ZeroMemory(ItemQuery, sizeof(ItemQuery));
			sprintf(ItemQuery, "market-item = %s %s %s %s %s %s %s %s %s %s %s %s %s %s\n", item->m_cName, (char*)to_string(item->m_dwCount).c_str(),
				(char*)to_string(item->m_sTouchEffectType).c_str(), (char*)to_string(item->m_sTouchEffectValue1).c_str(),
				(char*)to_string(item->m_sTouchEffectValue2).c_str(), (char*)to_string(item->m_sTouchEffectValue3).c_str(),
				(char*)to_string(item->m_cItemColor).c_str(), (char*)to_string(item->m_sItemSpecEffectValue1).c_str(),
				(char*)to_string(item->m_sItemSpecEffectValue2).c_str(), (char*)to_string(item->m_sItemSpecEffectValue3).c_str(),
				(char*)to_string(item->m_wCurLifeSpan).c_str(), (char*)to_string(item->m_dwAttribute).c_str(), (char*)to_string(item->m_wPrice).c_str(),
				(char*)to_string(item->m_iCoinVal).c_str());

			item_query.append(ItemQuery);
		}

		fwrite((char*)item_query.c_str(), item_query.size(), 1, f1);
		fclose(f1);

	}
}

void CMapServer::bDecodePlayerMarketItemContents(int client, char* pData, DWORD dwSize)
{
	char* pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemMarketIndex, iTotalGold, iNotUsedItemPrice;
	class  CStrTok* pStrTok;
	short  sTmpType, sTmpAppr1;

	BOOL   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL   bIsNotUsedItemFound = FALSE;

	auto p = m_pClientList[client];

	if (!p) return;

	if (client < 0 || client > DEF_MAXCLIENTS)
	{
		return;
	}

	iTotalGold = 0;
	iItemMarketIndex = 0;
	iNotUsedItemPrice = 0;
	int marketindex = 0;
	cReadModeA = 0;
	cReadModeB = 0;
	char cData[1024 * 100];
	DWORD lpNumberOfBytesRead;
	HANDLE hFile = CreateFile(pData, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, 0);
	DWORD dwFileSize = GetFileSize(hFile, NULL);
	if (dwFileSize == -1) {
		wsprintf(G_cTxt, "(X) CRITICAL ERROR! Cannot open configuration file(%s)!", pData);
		PutLogList(pData);
		return;
	}

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, cData, dwFileSize, &lpNumberOfBytesRead, NULL);
	CloseHandle(hFile);

	pContents = new char[dwFileSize + 1];
	memcpy_secure(pContents, cData, dwFileSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while (token != NULL) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {

			case 1:
				switch (cReadModeB) {
				case 1:
					if (iItemMarketIndex >= DEF_MAXMARKETITEMS) {
						delete pContents;
						delete pStrTok;
						return;
					}
					if (_bInitItemAttr(m_pClientList[client]->m_pMarketItem[iItemMarketIndex], token) == FALSE) {
						wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[client]->m_cCharName, token);
						PutLogList(cTxt);
						HANDLE hFile;
						DWORD  nWrite;
						hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
						WriteFile(hFile, (char*)pOriginContents, dwSize + 2, &nWrite, NULL);
						CloseHandle(hFile);

						delete pContents;
						delete pStrTok;
						return;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					iTemp = atoi(token);
					if (iTemp < 0) iTemp = 1;
					if (iGetItemWeight(m_pClientList[client]->m_pMarketItem[iItemMarketIndex], iTemp) > _iCalcMaxLoad(client)) {
						iTemp = 1;
						wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¾ÆÀÌÅÛ(%s) °³¼ö ¿À¹öÇÃ·Î¿ì", m_pClientList[client]->m_cCharName, m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_cName);
						//PutLogFileList(G_cTxt);
						PutLogList(G_cTxt);
					}

					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_dwCount = (DWORD)iTemp;
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_cItemColor = atoi(token);
					cReadModeB = 8;
					break;



				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sItemSpecEffectValue1 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sItemSpecEffectValue2 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_sItemSpecEffectValue3 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_wCurLifeSpan = atoi(token);

					cReadModeB = 12;
					break;

				case 12:
				{
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}

					unsigned __int64 m_dwAttribute64;
					_stscanf((LPCTSTR)token, _T("%I64u"), &m_dwAttribute64);
					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_dwAttribute = m_dwAttribute64;

					cReadModeB = 13;
					break;
				}

				case 13:
				{
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}

					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_wPrice = atoi(token);
					cReadModeB = 14;
					break;
				}


				case 14:
				{
					if (_bGetIsStringIsNumber(token) == FALSE) {
						wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[client]->m_cCharName);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return;
					}

					m_pClientList[client]->m_pMarketItem[iItemMarketIndex]->m_iCoinVal = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					iItemMarketIndex++;
					break;
				}
				}
				break;
			}
		}
		else {
			if (memcmp(token, "market-item", 11) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pClientList[client]->m_pMarketItem[iItemMarketIndex] = new class CItem;
			}
		}

		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete[]pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[client]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char*)pOriginContents, dwSize + 2, &nWrite2, NULL);
		CloseHandle(hFile2);

		return;
	}
	return;
}

void CMapServer::ReadMarket(int client)
{
	char cFileName3[500] = {};
	char cDir3[500] = {};
	strcat(cFileName3, "..\\Nucleo\\");
	strcat(cFileName3, "\\");
	strcat(cFileName3, "\\");
	strcat(cFileName3, "Market");
	strcat(cFileName3, "\\");
	strcat(cFileName3, "\\");
	wsprintf(cDir3, "AscII%d", m_pClientList[client]->m_cCharName[0]);
	strcat(cFileName3, cDir3);
	strcat(cFileName3, "\\");
	strcat(cFileName3, "\\");
	strcat(cFileName3, m_pClientList[client]->m_cCharName);
	strcat(cFileName3, ".txt");

	bDecodePlayerMarketItemContents(client, cFileName3, 0);
}


BOOL CMapServer::revertitemWeight(class CItem* pItem, char* pItemName)
{
#ifdef DEF_DEBUG
	try {
#endif
		register int i;
		char cTmpName[22];

		ZeroMemory(cTmpName, sizeof(cTmpName));
		memcpy_secure(cTmpName, pItemName, 20);

		for (i = 0; i < DEF_MAXITEMTYPES; i++) {
			if (m_pItemConfigList[i] != NULL) {
				if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {					
					pItem->m_wWeight = m_pItemConfigList[i]->m_wWeight;
					pItem->m_wCurLifeSpan = m_pItemConfigList[i]->m_wMaxLifeSpan;
					pItem->m_wMaxLifeSpan = pItem->m_wCurLifeSpan;
					return TRUE;
				}
			}
		}
#ifdef DEF_DEBUG
	}
	catch (...) {
		ErrorList("Crash Evitado en: _bInitItemAttr");
	}
#endif
	return FALSE;
}

bool CMapServer::getitemname(int client, int cx, int cy)
{
	auto p = m_pClientList[client];
	if (!p) return false;
	auto m = m_pMapList[m_pClientList[client]->m_cMapIndex];
	if (!m)	return false;
	if ((cx < 0 || cx >= m->m_sSizeX || cy < 0 || cy >= m->m_sSizeY)) return false;

	auto pTile = (class CTile *)(m->m_pTile + cx + cy*m->m_sSizeY);
	if (!pTile)	return false;

	auto it = pTile->m_pItem[0];
	if (!it) return false;
	if (string(it->m_cName) == "Gold" || string(it->m_cName) == "CoinBall" ||
		string(it->m_cName) == "RepBall" || string(it->m_cName) == "ContribBall" || 
		string(it->m_cName) == "MajBall") return true;

	return false;
}
/*

void CMapServer::getCriticals(int client)
{
	int maxcrits = 5000;
	int cost_per_crit = 5;

	auto p = m_pClientList[client];
	if (!p) return; 

	int current_crits = p->m_iSuperAttackLeft; 
	if (current_crits >= maxcrits) return; 

	int player_contrib = p->m_iContribution;
	if (player_contrib <= 0) return;

	int crits_needed = maxcrits - current_crits; 
	int crits_to_buy = (crits_needed < player_contrib) ? crits_needed : player_contrib;

	if (crits_to_buy > 0)
	{
		
		p->m_iContribution -= ;
		p->m_iSuperAttackLeft += crits_to_buy;
		SendCriticals(client);
	}
}
*/

void CMapServer::getCriticals(int client)
{
	int maxcrits = 5000;
	int cost_per_crit = 3;

	if (m_pClientList[client]->m_iSuperAttackLeft >= maxcrits) return;

	auto p = m_pClientList[client];
	if (!p) return;

	int current_crits = p->m_iSuperAttackLeft;
	if (current_crits >= maxcrits) return;

	int player_gold = dwGetItemCount(client, "Gold");
	if (player_gold < cost_per_crit)
	{
		ShowClientMsg(client, "Not enough Gold. Cost: 1 Critical x 3 Gold.");
		return;
	}

	int crits_needed = maxcrits - current_crits;
	int max_crits_affordable = player_gold / cost_per_crit; // Críticos que el jugador puede permitirse
	int crits_to_buy = (crits_needed < max_crits_affordable) ? crits_needed : max_crits_affordable;

	if (crits_to_buy > 0)
	{
		int total_cost = crits_to_buy * cost_per_crit;
		SetItemCount(client, "Gold", player_gold - total_cost);
		p->m_iSuperAttackLeft += crits_to_buy;
		SendCriticals(client);

		// Mensaje al cliente indicando la cantidad comprada y el oro gastado
		char msg[256];
		sprintf(msg, "You bought %d criticals for %d Gold.", crits_to_buy, total_cost);
		ShowClientMsg(client, msg);
	}
	else
	{
		ShowClientMsg(client, "Not enough Gold. Cost: 1 Critical x 3 Gold.");
	}
}


void CMapServer::SendMessageToClientUDP(int client)
{
	auto p = m_pClientList[client];
	if (!p) return;

	string response = "Message";
	sendto(p->serverSocket, response.c_str(), response.size(), 0, (sockaddr*)&p->clientAddr, p->clientAddrLen);
}

void CMapServer::sendMessageToClient(int client, int msgid) {
	auto p = m_pClientList[client];
	if (!p) return;

	if (!p->m_bUdpSocket) return;

	char data[500];
	char* cp = data;
	
	bool bsend = false;

	Push(cp, msgid);

	switch (msgid)
	{
		case SOCKMSG_WELCOME:
		{
			char test3[5];
			wsprintf(test3, "hola");
			Push(cp, test3, 5);
			bsend = true;
			break;
		}
		case SOCKMSG_PING:
		{
			bsend = true;
			break;
		}
	}

	if (!bsend) return;
	
	// Calcular el tamaño total del mensaje
	int totalSize = cp - data;

	// Enviar el mensaje
	int bytesSent = sendto(p->serverSocket, data, totalSize, 0, (sockaddr*)&p->clientAddr, p->clientAddrLen);
	if (bytesSent == SOCKET_ERROR) {
		//std::cerr << "Error sending custom message to client." << std::endl;
	}
	else {
		//std::cout << "Custom message sent to client: Size = " << totalSize << std::endl;
	}
}

void CMapServer::SendUDPCommand(int client, const char * command, int val1, int val2)
{
	auto p = m_pClientList[client];
	if (!p) return;
	if (p->m_bLimbo) return;
	char cCommand[30];
	ZeroMemory(cCommand, sizeof(cCommand));
	strcpy(cCommand, command);

	char data[256];
	auto * cp = data;

	Push(cp, (int)SOCKMSG_COMMAND);

	Push(cp, cCommand, 30);
	Push(cp, val1);
	Push(cp, val2);

	// Calcular el tamaño total del mensaje
	int totalSize = cp - data;

	// Enviar el mensaje
	int bytesSent = sendto(p->serverSocket, data, totalSize, 0, (sockaddr*)&p->clientAddr, p->clientAddrLen);
	if (bytesSent == SOCKET_ERROR) {
		//std::cerr << "Error sending custom message to client." << std::endl;
	}
	else {
		//std::cout << "Custom message sent to client: Size = " << totalSize << std::endl;
	}
}

/*

enum ObjectAction
{
	ACTION_OBJECTSTOP,
	ACTION_OBJECTMOVE,
	ACTION_OBJECTRUN,
	ACTION_OBJECTATTACK,
	ACTION_OBJECTMAGIC,
	ACTION_OBJECTGETITEM,
	ACTION_OBJECTDAMAGE,
	ACTION_OBJECTDAMAGEMOVE,
	ACTION_OBJECTATTACKMOVE,
	ACTION_OBJECTDYING,
	ACTION_OBJECTNULLACTION,
	ACTION_OBJECTDEAD
};*/

/*

void CMapServer::updateEntitySync(int owner, short owner_type, short command)
{
	char data[512];
	auto * cp = data;

	Push(cp, (int)SOCKMSG_OBJECTCOMMAND);
	Push(cp, (short)owner_type);
	Push(cp, (short)command);
	bool bsend = false;
	switch (owner_type)
	{
	case DEF_OWNERTYPE_PLAYER:
	{
		auto owner_player = m_pClientList[owner];
		if (!owner_player) return;

		switch (command)
		{
		case ACTION_OBJECTSTOP: { break; }
		case ACTION_OBJECTMOVE: { break; }
		case ACTION_OBJECTRUN: { break; }
		case ACTION_OBJECTATTACK: { break; }
		case ACTION_OBJECTMAGIC: { break; }
		case ACTION_OBJECTGETITEM: { break; }
		case ACTION_OBJECTDAMAGE: { break; }
		case ACTION_OBJECTDAMAGEMOVE: { break; }
		case ACTION_OBJECTATTACKMOVE: { break; }
		case ACTION_OBJECTDYING: { break; }
		case ACTION_OBJECTNULLACTION: { break; }
		case ACTION_OBJECTDEAD: { break; }
		default: return;  break;
		}

		break;
	}
	case DEF_OWNERTYPE_NPC:
	{
		auto owner_mob = m_pNpcList[owner];
		if (!owner_mob) return;

		switch (command)
		{
		case ACTION_OBJECTSTOP: { break; }

		case ACTION_OBJECTMOVE:
		{
			Push(cp, (int)owner + 1000);
			Push(cp, (short)owner_mob->m_sX);
			Push(cp, (short)owner_mob->m_sY);
			Push(cp, (short)owner_mob->m_sType);
			Push(cp, owner_mob->m_cDir);
			Push(cp, owner_mob->m_cName, 5);
			Push(cp, (short)owner_mob->m_sAppr2);
			Push(cp, (int)owner_mob->m_iStatus);
			char killed; 
			if (owner_mob->m_bIsKilled == TRUE) killed = 1;
			else killed = 0;
			Push(cp, killed);

			bsend = true;

			break; 
		}

		case ACTION_OBJECTRUN: { break; }
		case ACTION_OBJECTATTACK: { break; }
		case ACTION_OBJECTMAGIC: { break; }
		case ACTION_OBJECTGETITEM: { break; }
		case ACTION_OBJECTDAMAGE: { break; }
		case ACTION_OBJECTDAMAGEMOVE: { break; }
		case ACTION_OBJECTATTACKMOVE: { break; }
		case ACTION_OBJECTDYING: { break; }
		case ACTION_OBJECTNULLACTION: { break; }
		case ACTION_OBJECTDEAD: { break; }
		default: return;  break;
		}
		break;
	}
	default:
		break;
	}

	if (!bsend) return;

	for (int i = 1; i < DEF_MAXCLIENTS; i++) 
	{
		auto player = m_pClientList[i];
		if (!player) continue;
		if (!player->m_bIsInitComplete) continue;
		if (player->m_bLimbo) continue;
		if (!player->m_bUdpSocket) continue;

		if (owner_type == DEF_OWNERTYPE_NPC)
		{
			if (string(m_pNpcList[owner]->m_cMapName) != player->m_cMapName) continue;
			//m_pNpcList[owner]->m_sX;
			//m_pNpcList[owner]->m_sY;
		}

		if (owner_type == DEF_OWNERTYPE_PLAYER)
		{
			if (string(m_pClientList[owner]->m_cMapName) != player->m_cMapName) continue;

		}

		int totalSize = cp - data;

		// Enviar el mensaje
		int bytesSent = sendto(player->serverSocket, data, totalSize, 0, (sockaddr*)&player->clientAddr, player->clientAddrLen);
		if (bytesSent == SOCKET_ERROR) {
			//std::cerr << "Error sending custom message to client." << std::endl;
		}
		else {
			//std::cout << "Custom message sent to client: Size = " << totalSize << std::endl;
		}
	}

	
}*/

void CMapServer::updateEntitySync(int owner, short owner_type, short command)
{
	char data[512];
	auto* cp = data;

	Push(cp, (int)SOCKMSG_OBJECTCOMMAND);
	Push(cp, (short)owner_type);
	Push(cp, (short)command);
	bool bsend = false;

	switch (owner_type)
	{
	case DEF_OWNERTYPE_PLAYER:
	{
		auto owner_player = m_pClientList[owner];
		if (!owner_player) return;

		// Filtra comandos para jugadores si es necesario (opcional)
		switch (command)
		{
		case ACTION_OBJECTSTOP: break;
		case ACTION_OBJECTMOVE: break;
		case ACTION_OBJECTRUN: break;
		case ACTION_OBJECTATTACK: break;
		case ACTION_OBJECTMAGIC: break;
		case ACTION_OBJECTGETITEM: break;
		case ACTION_OBJECTDAMAGE: break;
		case ACTION_OBJECTDAMAGEMOVE: break;
		case ACTION_OBJECTATTACKMOVE: break;
		case ACTION_OBJECTDYING: break;
		case ACTION_OBJECTNULLACTION: break;
		case ACTION_OBJECTDEAD: break;
		default: return;
		}

		break;
	}
	case DEF_OWNERTYPE_NPC:
	{
		auto owner_mob = m_pNpcList[owner];
		if (!owner_mob) return;

		switch (command)
		{
		case ACTION_OBJECTSTOP: break;
		case ACTION_OBJECTMOVE:
		{
			Push(cp, (int)owner + 1000);
			Push(cp, (short)owner_mob->m_sX);
			Push(cp, (short)owner_mob->m_sY);
			Push(cp, (short)owner_mob->m_sType);
			Push(cp, owner_mob->m_cDir);
			Push(cp, owner_mob->m_cName, 5);
			Push(cp, (short)owner_mob->m_sAppr2);
			Push(cp, (int)owner_mob->m_iStatus);

			char killed = owner_mob->m_bIsKilled ? 1 : 0;
			Push(cp, killed);

			bsend = true;

			break;
		}
		default: return;
		}
		break;
	}
	default:
		break;
	}

	if (!bsend) return;

	// Rango visual en tiles (800x600 píxeles equivale a 25x18 tiles)
	const int rangeX = 25;
	const int rangeY = 18;

	for (int i = 1; i < DEF_MAXCLIENTS; i++)
	{
		auto player = m_pClientList[i];
		if (!player) continue;
		if (!player->m_bIsInitComplete) continue;
		if (player->m_bLimbo) continue;
		if (!player->m_bUdpSocket) continue;

		// Filtrar por rango visual para NPC
		if (owner_type == DEF_OWNERTYPE_NPC)
		{
			if (string(m_pNpcList[owner]->m_cMapName) != player->m_cMapName) continue;

			int deltaX = abs(player->m_sX - m_pNpcList[owner]->m_sX);
			int deltaY = abs(player->m_sY - m_pNpcList[owner]->m_sY);

			if (deltaX > rangeX || deltaY > rangeY) continue;
		}

		// Filtrar por rango visual para jugadores si es necesario
		if (owner_type == DEF_OWNERTYPE_PLAYER)
		{
			if (string(m_pClientList[owner]->m_cMapName) != player->m_cMapName) continue;
		}

		int totalSize = cp - data;

		// Enviar el mensaje
		int bytesSent = sendto(player->serverSocket, data, totalSize, 0, (sockaddr*)&player->clientAddr, player->clientAddrLen);
		if (bytesSent == SOCKET_ERROR)
		{
			//std::cerr << "Error sending custom message to client." << std::endl;
		}
		else
		{
			//std::cout << "Custom message sent to client: Size = " << totalSize << std::endl;
		}
	}
}

void CMapServer::response_ping(int client)
{
	char cData[10];
	char* cp = cData;
	Push(cp, (u32)NOTIFY_PING);
	Push(cp, (u16)0);

	m_pClientList[client]->m_pXSock->iSendMsg(cData, cp - cData);
}

void CMapServer::SaveAllCharacters()
{
	if (m_bShutDownServer) return;
//	PutLogList("Save all characters");
	for (short i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {

			if (!m_pClientList[i]->m_bIsInitComplete) continue;

			if ((memcmp(m_pClientList[i]->m_cMapName, DEF_EVENTMAP_PVPEVENT, 7) != 0) && !FinalFight)
				LocalSavePlayerData(i);
		}
	}
}

